import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { CameraKeyframes, DeckLayerKeyframes } from '../keyframes';
import Animation from './animation';

function noop() {}

export default class DeckAnimation extends Animation {
  constructor(_ref) {
    let {
      id = 'deck',
      cameraKeyframe = undefined,
      getLayers = _ => [],
      layerKeyframes = [],
      onLayersUpdate = noop,
      onCameraUpdate = noop
    } = _ref;
    super({
      id
    });

    _defineProperty(this, "cameraKeyframe", void 0);

    _defineProperty(this, "layerKeyframes", {});

    this.layerKeyframes = {};
    this.onLayersUpdate = onLayersUpdate;
    this.onCameraUpdate = onCameraUpdate;
    this.getLayers = getLayers;
    this.setKeyframes({
      cameraKeyframe,
      layerKeyframes
    });
    this.draw();
  }

  setOnLayersUpdate(onLayersUpdate) {
    this.onLayersUpdate = onLayersUpdate;
  }

  setOnCameraUpdate(onCameraUpdate) {
    this.onCameraUpdate = onCameraUpdate;
  }

  setGetLayers(getLayers) {
    this.getLayers = getLayers;
    this.draw();
  }

  setKeyframes(_ref2) {
    let {
      layerKeyframes = [],
      cameraKeyframe = undefined,
      timeline = undefined
    } = _ref2;

    if (this.cameraKeyframe && cameraKeyframe) {
      this.cameraKeyframe.set(cameraKeyframe);
    } else if (cameraKeyframe) {
      this.cameraKeyframe = new CameraKeyframes(cameraKeyframe);
      this.unattachedKeyframes.push(this.cameraKeyframe);
    }

    if (layerKeyframes && layerKeyframes.length > 0) {
      this.layerKeyframes = layerKeyframes.reduce((acc, value) => {
        if (acc[value.id]) {
          acc[value.id].set(value);
        } else {
          acc[value.id] = new DeckLayerKeyframes(value);
          this.unattachedKeyframes.push(acc[value.id]);
        }

        return acc;
      }, this.layerKeyframes);
    }

    if (timeline) {
      this.attachKeyframes(timeline);
    }
  }

  getKeyframes() {
    return {
      cameraKeyframe: this.cameraKeyframe,
      layerKeyframes: this.layerKeyframes
    };
  }

  animator(animation) {
    if (animation.cameraKeyframe) {
      animation.onCameraUpdate(animation.cameraKeyframe.getFrame());
    }

    if (Object.values(animation.layerKeyframes).length > 0) {
      animation.onLayersUpdate(this.getLayers(animation));
    }
  }

  applyLayerKeyframes(layers) {
    return layers.map(layer => {
      if (this.layerKeyframes[layer.id]) {
        const frame = this.layerKeyframes[layer.id].getFrame();
        return layer.clone({ ...frame,
          updateTriggers: frame
        });
      }

      return layer;
    });
  }

}
//# sourceMappingURL=deck-animation.js.map