"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));

var _react = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _d3Selection = require("d3-selection");

var _d3Brush = require("d3-brush");

var _utils = require("@kepler.gl/utils");

var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var StyledG = _styledComponents["default"].g(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["\n  .selection {\n    stroke: none;\n    fill: ", ";\n    fill-opacity: ", ";\n  }\n  .handle {\n    fill: ", ";\n    fill-opacity: 0.3;\n  }\n"])), function (props) {
  return props.isRanged ? props.theme.rangeBrushBgd : props.theme.BLUE2;
}, function (props) {
  return props.isRanged ? 0.3 : 1;
}, function (props) {
  return props.theme.BLUE2;
});

function moveRight(startSel, selection) {
  var _startSel = (0, _slicedToArray2["default"])(startSel, 1),
      startSel0 = _startSel[0];

  var _selection = (0, _slicedToArray2["default"])(selection, 1),
      sel0 = _selection[0];

  return Boolean(startSel0 === sel0);
} // style brush resize handle
// https://github.com/crossfilter/crossfilter/blob/gh-pages/index.html#L466


var getHandlePath = function getHandlePath(props) {
  return function brushResizePath(d) {
    var e = Number(d.type === 'e');
    var x = e ? 1 : -1;
    var h = 39;
    var w = 4.5;
    var y = (props.height - h) / 2;
    return "M".concat(0.5 * x, ",").concat(y, "c").concat(2.5 * x, ",0,").concat(w * x, ",2,").concat(w * x, ",").concat(w, "v").concat(h - w * 2, "c0,2.5,").concat(-2 * x, ",").concat(w, ",").concat(-w * x, ",").concat(w, "V").concat(y, "z");
  };
};

function RangeBrushFactory() {
  var RangeBrush = /*#__PURE__*/function (_Component) {
    (0, _inherits2["default"])(RangeBrush, _Component);

    var _super = _createSuper(RangeBrush);

    function RangeBrush() {
      var _this;

      (0, _classCallCheck2["default"])(this, RangeBrush);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "rootContainer", /*#__PURE__*/(0, _react.createRef)());
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "brushing", false);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "moving", false);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "root", _this.rootContainer.current ? (0, _d3Selection.select)(_this.rootContainer.current) : undefined);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "brush", void 0);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_startSel", void 0);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_lastSel", void 0);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handle", void 0);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_brushed", function (evt) {
        var _this2;

        // Ignore brush events which don't have an underlying sourceEvent
        if (!evt.sourceEvent) return;

        var _evt$selection = (0, _slicedToArray2["default"])(evt.selection, 2),
            sel0 = _evt$selection[0],
            sel1 = _evt$selection[1];

        var right = moveRight(_this._startSel, evt.selection);

        var _this$props = _this.props,
            _this$props$range = (0, _slicedToArray2["default"])(_this$props.range, 2),
            min = _this$props$range[0],
            max = _this$props$range[1],
            _this$props$step = _this$props.step,
            step = _this$props$step === void 0 ? 0 : _this$props$step,
            width = _this$props.width,
            marks = _this$props.marks,
            isRanged = _this$props.isRanged;

        var invert = function invert(x) {
          return x * (max - min) / width + min;
        };

        var d0 = invert(sel0);
        var d1 = invert(sel1);
        d0 = (0, _utils.normalizeSliderValue)(d0, min, step, marks);
        d1 = (0, _utils.normalizeSliderValue)(d1, min, step, marks);
        if (isRanged) _this._move(d0, d1);else (_this2 = _this)._move.apply(_this2, (0, _toConsumableArray2["default"])(right ? [d1, d1] : [d0, d0]));
        if (isRanged) _this._onBrush(d0, d1);else _this._onBrush(right ? d1 : d0);
      });
      return _this;
    }

    (0, _createClass2["default"])(RangeBrush, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this3 = this,
            _this$root,
            _this$root2;

        // We want the React app to respond to brush state and vice-versa
        // but d3-brush fires the same events for both user-initiated brushing
        // and programmatic brushing (brush.move). We need these flags to
        // distinguish between the uses.
        //
        // We don't use state because that would trigger another `componentDidUpdate`
        var _this$props2 = this.props,
            theme = _this$props2.theme,
            isRanged = _this$props2.isRanged,
            onMouseoverHandle = _this$props2.onMouseoverHandle,
            onMouseoutHandle = _this$props2.onMouseoutHandle;
        this.root = this.rootContainer.current ? (0, _d3Selection.select)(this.rootContainer.current) : undefined;
        this.brush = (0, _d3Brush.brushX)().handleSize(3).on('start', function (event) {
          if (typeof _this3.props.onBrushStart === 'function') _this3.props.onBrushStart();
          _this3._startSel = event.selection;
        }).on('brush', function (event) {
          if (_this3.moving) {
            return;
          }

          if (event.selection) {
            _this3._lastSel = event.selection;
            _this3.brushing = true;

            _this3._brushed(event);
          }
        }).on('end', function (event) {
          if (!event.selection) {
            if (_this3.brushing) {
              // handle null selection
              _this3._click(_this3._lastSel);
            } else if (_this3._startSel) {
              // handle click
              _this3._click(_this3._startSel);
            }
          }

          if (typeof _this3.props.onBrushEnd === 'function') _this3.props.onBrushEnd();
          _this3.brushing = false;
          _this3.moving = false;
        });
        (_this$root = this.root) === null || _this$root === void 0 ? void 0 : _this$root.call(this.brush);
        var brushResizePath = getHandlePath(this.props);
        this.handle = (_this$root2 = this.root) === null || _this$root2 === void 0 ? void 0 : _this$root2.selectAll('.handle--custom').data([{
          type: 'w'
        }, {
          type: 'e'
        }]).enter().append('path').attr('class', 'handle--custom').attr('display', isRanged ? null : 'none').attr('fill', theme ? theme.sliderHandleColor : '#D3D8E0').attr('cursor', 'ew-resize').attr('d', brushResizePath).on('mouseover', function () {
          if (onMouseoverHandle) onMouseoverHandle();
        }).on('mouseout', function () {
          if (onMouseoutHandle) onMouseoutHandle();
        });

        var _this$props$value = (0, _slicedToArray2["default"])(this.props.value, 2),
            val0 = _this$props$value[0],
            val1 = _this$props$value[1];

        this.moving = true;

        this._move(val0, val1);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this$props3 = this.props,
            _this$props3$value = (0, _slicedToArray2["default"])(_this$props3.value, 2),
            val0 = _this$props3$value[0],
            val1 = _this$props3$value[1],
            width = _this$props3.width;

        var _prevProps$value = (0, _slicedToArray2["default"])(prevProps.value, 2),
            prevVal0 = _prevProps$value[0],
            prevVal1 = _prevProps$value[1];

        if (prevProps.width !== width) {
          var _this$root3;

          // width change should not trigger this._brushed
          this.moving = true;
          if (this.brush) (_this$root3 = this.root) === null || _this$root3 === void 0 ? void 0 : _this$root3.call(this.brush);

          this._move(val0, val1);
        }

        if (!this.brushing && !this.moving) {
          if (prevVal0 !== val0 || prevVal1 !== val1) {
            this.moving = true;

            this._move(val0, val1);
          }
        }

        if (!this.props.isRanged && this.handle) {
          this.handle.attr('display', 'none');
        }
      }
    }, {
      key: "_click",
      value: function _click(selection) {
        // fake brush
        this.brushing = true;

        this._brushed({
          sourceEvent: {},
          selection: selection
        });
      }
    }, {
      key: "_move",
      value: function _move() {
        var val0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var val1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        var _this$props4 = this.props,
            _this$props4$range = (0, _slicedToArray2["default"])(_this$props4.range, 2),
            min = _this$props4$range[0],
            max = _this$props4$range[1],
            width = _this$props4.width,
            isRanged = _this$props4.isRanged;

        if (width && max - min && this.brush && this.handle) {
          var scale = function scale(x) {
            return (x - min) * width / (max - min);
          };

          if (!isRanged) {
            // only draw a 1 pixel line
            if (this.root) this.brush.move(this.root, [scale(val0), scale(val0) + 1]);
          } else {
            if (this.root) this.brush.move(this.root, [scale(val0), scale(val1)]);
            this.handle.attr('display', null).attr('transform', function (d, i) {
              return "translate(".concat([i === 0 ? scale(val0) : scale(val1), 0], ")");
            });
          }
        }
      }
    }, {
      key: "_onBrush",
      value: function _onBrush() {
        var val0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var val1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        var _this$props5 = this.props,
            isRanged = _this$props5.isRanged,
            _this$props5$value = (0, _slicedToArray2["default"])(_this$props5.value, 2),
            currentVal0 = _this$props5$value[0],
            currentVal1 = _this$props5$value[1];

        if (currentVal0 === val0 && currentVal1 === val1) {
          return;
        }

        if (isRanged) {
          this.props.onBrush(val0, val1);
        } else {
          this.props.onBrush(val0, val0);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var isRanged = this.props.isRanged;
        return /*#__PURE__*/_react["default"].createElement(StyledG, {
          className: "kg-range-slider__brush",
          isRanged: isRanged,
          ref: this.rootContainer
        });
      }
    }]);
    return RangeBrush;
  }(_react.Component);

  (0, _defineProperty2["default"])(RangeBrush, "defaultProps", {
    isRanged: true
  });
  return (0, _styledComponents.withTheme)(RangeBrush);
}

var _default = RangeBrushFactory;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21tb24vcmFuZ2UtYnJ1c2gudHN4Il0sIm5hbWVzIjpbIlN0eWxlZEciLCJzdHlsZWQiLCJnIiwicHJvcHMiLCJpc1JhbmdlZCIsInRoZW1lIiwicmFuZ2VCcnVzaEJnZCIsIkJMVUUyIiwibW92ZVJpZ2h0Iiwic3RhcnRTZWwiLCJzZWxlY3Rpb24iLCJzdGFydFNlbDAiLCJzZWwwIiwiQm9vbGVhbiIsImdldEhhbmRsZVBhdGgiLCJicnVzaFJlc2l6ZVBhdGgiLCJkIiwiZSIsIk51bWJlciIsInR5cGUiLCJ4IiwiaCIsInciLCJ5IiwiaGVpZ2h0IiwiUmFuZ2VCcnVzaEZhY3RvcnkiLCJSYW5nZUJydXNoIiwicm9vdENvbnRhaW5lciIsImN1cnJlbnQiLCJ1bmRlZmluZWQiLCJldnQiLCJzb3VyY2VFdmVudCIsInNlbDEiLCJyaWdodCIsIl9zdGFydFNlbCIsInJhbmdlIiwibWluIiwibWF4Iiwic3RlcCIsIndpZHRoIiwibWFya3MiLCJpbnZlcnQiLCJkMCIsImQxIiwiX21vdmUiLCJfb25CcnVzaCIsIm9uTW91c2VvdmVySGFuZGxlIiwib25Nb3VzZW91dEhhbmRsZSIsInJvb3QiLCJicnVzaCIsImhhbmRsZVNpemUiLCJvbiIsImV2ZW50Iiwib25CcnVzaFN0YXJ0IiwibW92aW5nIiwiX2xhc3RTZWwiLCJicnVzaGluZyIsIl9icnVzaGVkIiwiX2NsaWNrIiwib25CcnVzaEVuZCIsImNhbGwiLCJoYW5kbGUiLCJzZWxlY3RBbGwiLCJkYXRhIiwiZW50ZXIiLCJhcHBlbmQiLCJhdHRyIiwic2xpZGVySGFuZGxlQ29sb3IiLCJ2YWx1ZSIsInZhbDAiLCJ2YWwxIiwicHJldlByb3BzIiwicHJldlZhbDAiLCJwcmV2VmFsMSIsInNjYWxlIiwibW92ZSIsImkiLCJjdXJyZW50VmFsMCIsImN1cnJlbnRWYWwxIiwib25CcnVzaCIsIkNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdB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QUFBQTtBQUFBLElBQ3hDcUQsZ0JBRHdDOztBQUFBLG1DQUMzRHRELFVBRDJELGtCQUV6QztBQUNwQnRCLElBQUFBLFFBQVEsRUFBRTtBQURVLEdBRnlDO0FBZ01qRSxTQUFPLGlDQUFVc0IsVUFBVixDQUFQO0FBQ0Q7O2VBRWNELGlCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50LCBjcmVhdGVSZWZ9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzdHlsZWQsIHt3aXRoVGhlbWV9IGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcbmltcG9ydCB7c2VsZWN0LCBTZWxlY3Rpb259IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQge0JydXNoQmVoYXZpb3IsIGJydXNoWH0gZnJvbSAnZDMtYnJ1c2gnO1xuaW1wb3J0IHtub3JtYWxpemVTbGlkZXJWYWx1ZX0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5cbmludGVyZmFjZSBTdHlsZWRHUHJvcHMge1xuICBpc1JhbmdlZD86IGJvb2xlYW47XG59XG5cbmNvbnN0IFN0eWxlZEcgPSBzdHlsZWQuZzxTdHlsZWRHUHJvcHM+YFxuICAuc2VsZWN0aW9uIHtcbiAgICBzdHJva2U6IG5vbmU7XG4gICAgZmlsbDogJHtwcm9wcyA9PiAocHJvcHMuaXNSYW5nZWQgPyBwcm9wcy50aGVtZS5yYW5nZUJydXNoQmdkIDogcHJvcHMudGhlbWUuQkxVRTIpfTtcbiAgICBmaWxsLW9wYWNpdHk6ICR7cHJvcHMgPT4gKHByb3BzLmlzUmFuZ2VkID8gMC4zIDogMSl9O1xuICB9XG4gIC5oYW5kbGUge1xuICAgIGZpbGw6ICR7cHJvcHMgPT4gcHJvcHMudGhlbWUuQkxVRTJ9O1xuICAgIGZpbGwtb3BhY2l0eTogMC4zO1xuICB9XG5gO1xuXG5mdW5jdGlvbiBtb3ZlUmlnaHQoc3RhcnRTZWwsIHNlbGVjdGlvbikge1xuICBjb25zdCBbc3RhcnRTZWwwXSA9IHN0YXJ0U2VsO1xuICBjb25zdCBbc2VsMF0gPSBzZWxlY3Rpb247XG5cbiAgcmV0dXJuIEJvb2xlYW4oc3RhcnRTZWwwID09PSBzZWwwKTtcbn1cbi8vIHN0eWxlIGJydXNoIHJlc2l6ZSBoYW5kbGVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zc2ZpbHRlci9jcm9zc2ZpbHRlci9ibG9iL2doLXBhZ2VzL2luZGV4Lmh0bWwjTDQ2NlxuY29uc3QgZ2V0SGFuZGxlUGF0aCA9IChwcm9wczogUmFuZ2VCcnVzaFByb3BzKSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiBicnVzaFJlc2l6ZVBhdGgoZCkge1xuICAgIGNvbnN0IGUgPSBOdW1iZXIoZC50eXBlID09PSAnZScpO1xuICAgIGNvbnN0IHggPSBlID8gMSA6IC0xO1xuICAgIGNvbnN0IGggPSAzOTtcbiAgICBjb25zdCB3ID0gNC41O1xuICAgIGNvbnN0IHkgPSAocHJvcHMuaGVpZ2h0IC0gaCkgLyAyO1xuICAgIHJldHVybiBgTSR7MC41ICogeH0sJHt5fWMkezIuNSAqIHh9LDAsJHt3ICogeH0sMiwke3cgKiB4fSwke3d9diR7aCAtIHcgKiAyfWMwLDIuNSwkey0yICpcbiAgICAgIHh9LCR7d30sJHstdyAqIHh9LCR7d31WJHt5fXpgO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgT25CcnVzaCA9ICh2YWwwOiBudW1iZXIsIHZhbDE6IG51bWJlcikgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBSYW5nZUJydXNoUHJvcHMge1xuICBpc1JhbmdlZD86IGJvb2xlYW47XG4gIHRoZW1lPzogYW55O1xuICByYW5nZTogbnVtYmVyW107XG4gIHZhbHVlOiBudW1iZXJbXTtcbiAgb25CcnVzaFN0YXJ0OiAoKSA9PiB2b2lkO1xuICBvbkJydXNoRW5kOiAoKSA9PiB2b2lkO1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgb25CcnVzaDogT25CcnVzaDtcbiAgc3RlcD86IG51bWJlcjtcbiAgbWFya3M/OiBudW1iZXJbXTtcbiAgb25Nb3VzZW92ZXJIYW5kbGU6ICgpID0+IHZvaWQ7XG4gIG9uTW91c2VvdXRIYW5kbGU6ICgpID0+IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIFJhbmdlQnJ1c2hGYWN0b3J5KCk6IFJlYWN0LkNvbXBvbmVudFR5cGU8UmFuZ2VCcnVzaFByb3BzPiB7XG4gIGNsYXNzIFJhbmdlQnJ1c2ggZXh0ZW5kcyBDb21wb25lbnQ8UmFuZ2VCcnVzaFByb3BzPiB7XG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgIGlzUmFuZ2VkOiB0cnVlXG4gICAgfTtcblxuICAgIHJvb3RDb250YWluZXIgPSBjcmVhdGVSZWY8U1ZHR0VsZW1lbnQ+KCk7XG5cbiAgICBicnVzaGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIG1vdmluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcm9vdCA9IHRoaXMucm9vdENvbnRhaW5lci5jdXJyZW50ID8gc2VsZWN0KHRoaXMucm9vdENvbnRhaW5lci5jdXJyZW50KSA6IHVuZGVmaW5lZDtcbiAgICBicnVzaDogQnJ1c2hCZWhhdmlvcjxhbnk+IHwgdW5kZWZpbmVkO1xuICAgIF9zdGFydFNlbDogbnVtYmVyW10gfCB1bmRlZmluZWQ7XG4gICAgX2xhc3RTZWw6IG51bWJlcltdIHwgdW5kZWZpbmVkO1xuXG4gICAgaGFuZGxlOiBTZWxlY3Rpb248U1ZHUGF0aEVsZW1lbnQsIHt0eXBlOiBzdHJpbmd9LCBTVkdHRWxlbWVudCB8IG51bGwsIHVua25vd24+IHwgdW5kZWZpbmVkO1xuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAvLyBXZSB3YW50IHRoZSBSZWFjdCBhcHAgdG8gcmVzcG9uZCB0byBicnVzaCBzdGF0ZSBhbmQgdmljZS12ZXJzYVxuICAgICAgLy8gYnV0IGQzLWJydXNoIGZpcmVzIHRoZSBzYW1lIGV2ZW50cyBmb3IgYm90aCB1c2VyLWluaXRpYXRlZCBicnVzaGluZ1xuICAgICAgLy8gYW5kIHByb2dyYW1tYXRpYyBicnVzaGluZyAoYnJ1c2gubW92ZSkuIFdlIG5lZWQgdGhlc2UgZmxhZ3MgdG9cbiAgICAgIC8vIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIHVzZXMuXG4gICAgICAvL1xuICAgICAgLy8gV2UgZG9uJ3QgdXNlIHN0YXRlIGJlY2F1c2UgdGhhdCB3b3VsZCB0cmlnZ2VyIGFub3RoZXIgYGNvbXBvbmVudERpZFVwZGF0ZWBcbiAgICAgIGNvbnN0IHt0aGVtZSwgaXNSYW5nZWQsIG9uTW91c2VvdmVySGFuZGxlLCBvbk1vdXNlb3V0SGFuZGxlfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdENvbnRhaW5lci5jdXJyZW50ID8gc2VsZWN0KHRoaXMucm9vdENvbnRhaW5lci5jdXJyZW50KSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuYnJ1c2ggPSBicnVzaFgoKVxuICAgICAgICAuaGFuZGxlU2l6ZSgzKVxuICAgICAgICAub24oJ3N0YXJ0JywgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbkJydXNoU3RhcnQgPT09ICdmdW5jdGlvbicpIHRoaXMucHJvcHMub25CcnVzaFN0YXJ0KCk7XG4gICAgICAgICAgdGhpcy5fc3RhcnRTZWwgPSBldmVudC5zZWxlY3Rpb247XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignYnJ1c2gnLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMubW92aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RTZWwgPSBldmVudC5zZWxlY3Rpb247XG4gICAgICAgICAgICB0aGlzLmJydXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2JydXNoZWQoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlbmQnLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKCFldmVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJydXNoaW5nKSB7XG4gICAgICAgICAgICAgIC8vIGhhbmRsZSBudWxsIHNlbGVjdGlvblxuICAgICAgICAgICAgICB0aGlzLl9jbGljayh0aGlzLl9sYXN0U2VsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhcnRTZWwpIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlIGNsaWNrXG4gICAgICAgICAgICAgIHRoaXMuX2NsaWNrKHRoaXMuX3N0YXJ0U2VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25CcnVzaEVuZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5wcm9wcy5vbkJydXNoRW5kKCk7XG5cbiAgICAgICAgICB0aGlzLmJydXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5tb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMucm9vdD8uY2FsbCh0aGlzLmJydXNoKTtcbiAgICAgIGNvbnN0IGJydXNoUmVzaXplUGF0aCA9IGdldEhhbmRsZVBhdGgodGhpcy5wcm9wcyk7XG4gICAgICB0aGlzLmhhbmRsZSA9IHRoaXMucm9vdFxuICAgICAgICA/LnNlbGVjdEFsbCgnLmhhbmRsZS0tY3VzdG9tJylcbiAgICAgICAgLmRhdGEoW3t0eXBlOiAndyd9LCB7dHlwZTogJ2UnfV0pXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnaGFuZGxlLS1jdXN0b20nKVxuICAgICAgICAuYXR0cignZGlzcGxheScsIGlzUmFuZ2VkID8gbnVsbCA6ICdub25lJylcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCB0aGVtZSA/IHRoZW1lLnNsaWRlckhhbmRsZUNvbG9yIDogJyNEM0Q4RTAnKVxuICAgICAgICAuYXR0cignY3Vyc29yJywgJ2V3LXJlc2l6ZScpXG4gICAgICAgIC5hdHRyKCdkJywgYnJ1c2hSZXNpemVQYXRoKVxuICAgICAgICAub24oJ21vdXNlb3ZlcicsICgpID0+IHtcbiAgICAgICAgICBpZiAob25Nb3VzZW92ZXJIYW5kbGUpIG9uTW91c2VvdmVySGFuZGxlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKG9uTW91c2VvdXRIYW5kbGUpIG9uTW91c2VvdXRIYW5kbGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdmFsdWU6IFt2YWwwLCB2YWwxXVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICB0aGlzLm1vdmluZyA9IHRydWU7XG4gICAgICB0aGlzLl9tb3ZlKHZhbDAsIHZhbDEpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdmFsdWU6IFt2YWwwLCB2YWwxXSxcbiAgICAgICAgd2lkdGhcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgW3ByZXZWYWwwLCBwcmV2VmFsMV0gPSBwcmV2UHJvcHMudmFsdWU7XG5cbiAgICAgIGlmIChwcmV2UHJvcHMud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgIC8vIHdpZHRoIGNoYW5nZSBzaG91bGQgbm90IHRyaWdnZXIgdGhpcy5fYnJ1c2hlZFxuICAgICAgICB0aGlzLm1vdmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmJydXNoKSB0aGlzLnJvb3Q/LmNhbGwodGhpcy5icnVzaCk7XG4gICAgICAgIHRoaXMuX21vdmUodmFsMCwgdmFsMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5icnVzaGluZyAmJiAhdGhpcy5tb3ZpbmcpIHtcbiAgICAgICAgaWYgKHByZXZWYWwwICE9PSB2YWwwIHx8IHByZXZWYWwxICE9PSB2YWwxKSB7XG4gICAgICAgICAgdGhpcy5tb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX21vdmUodmFsMCwgdmFsMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnByb3BzLmlzUmFuZ2VkICYmIHRoaXMuaGFuZGxlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlLmF0dHIoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9jbGljayhzZWxlY3Rpb24pIHtcbiAgICAgIC8vIGZha2UgYnJ1c2hcbiAgICAgIHRoaXMuYnJ1c2hpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fYnJ1c2hlZCh7c291cmNlRXZlbnQ6IHt9LCBzZWxlY3Rpb259KTtcbiAgICB9XG5cbiAgICBfbW92ZSh2YWwwOiBudW1iZXIgPSAwLCB2YWwxOiBudW1iZXIgPSAwKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJhbmdlOiBbbWluLCBtYXhdLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaXNSYW5nZWRcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICBpZiAod2lkdGggJiYgbWF4IC0gbWluICYmIHRoaXMuYnJ1c2ggJiYgdGhpcy5oYW5kbGUpIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAoeDogbnVtYmVyKSA9PiAoKHggLSBtaW4pICogd2lkdGgpIC8gKG1heCAtIG1pbik7XG4gICAgICAgIGlmICghaXNSYW5nZWQpIHtcbiAgICAgICAgICAvLyBvbmx5IGRyYXcgYSAxIHBpeGVsIGxpbmVcbiAgICAgICAgICBpZiAodGhpcy5yb290KSB0aGlzLmJydXNoLm1vdmUodGhpcy5yb290LCBbc2NhbGUodmFsMCksIHNjYWxlKHZhbDApICsgMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnJvb3QpIHRoaXMuYnJ1c2gubW92ZSh0aGlzLnJvb3QsIFtzY2FsZSh2YWwwKSwgc2NhbGUodmFsMSldKTtcblxuICAgICAgICAgIHRoaXMuaGFuZGxlXG4gICAgICAgICAgICAuYXR0cignZGlzcGxheScsIG51bGwpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQsIGkpID0+IGB0cmFuc2xhdGUoJHtbaSA9PT0gMCA/IHNjYWxlKHZhbDApIDogc2NhbGUodmFsMSksIDBdfSlgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9icnVzaGVkID0gKGV2dDoge3NvdXJjZUV2ZW50OiBhbnk7IHNlbGVjdGlvbjogbnVtYmVyW119KSA9PiB7XG4gICAgICAvLyBJZ25vcmUgYnJ1c2ggZXZlbnRzIHdoaWNoIGRvbid0IGhhdmUgYW4gdW5kZXJseWluZyBzb3VyY2VFdmVudFxuICAgICAgaWYgKCFldnQuc291cmNlRXZlbnQpIHJldHVybjtcbiAgICAgIGNvbnN0IFtzZWwwLCBzZWwxXSA9IGV2dC5zZWxlY3Rpb247XG4gICAgICBjb25zdCByaWdodCA9IG1vdmVSaWdodCh0aGlzLl9zdGFydFNlbCwgZXZ0LnNlbGVjdGlvbik7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmFuZ2U6IFttaW4sIG1heF0sXG4gICAgICAgIHN0ZXAgPSAwLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgbWFya3MsXG4gICAgICAgIGlzUmFuZ2VkXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGludmVydCA9ICh4OiBudW1iZXIpID0+ICh4ICogKG1heCAtIG1pbikpIC8gd2lkdGggKyBtaW47XG4gICAgICBsZXQgZDAgPSBpbnZlcnQoc2VsMCk7XG4gICAgICBsZXQgZDEgPSBpbnZlcnQoc2VsMSk7XG5cbiAgICAgIGQwID0gbm9ybWFsaXplU2xpZGVyVmFsdWUoZDAsIG1pbiwgc3RlcCwgbWFya3MpO1xuICAgICAgZDEgPSBub3JtYWxpemVTbGlkZXJWYWx1ZShkMSwgbWluLCBzdGVwLCBtYXJrcyk7XG5cbiAgICAgIGlmIChpc1JhbmdlZCkgdGhpcy5fbW92ZShkMCwgZDEpO1xuICAgICAgZWxzZSB0aGlzLl9tb3ZlKC4uLihyaWdodCA/IFtkMSwgZDFdIDogW2QwLCBkMF0pKTtcblxuICAgICAgaWYgKGlzUmFuZ2VkKSB0aGlzLl9vbkJydXNoKGQwLCBkMSk7XG4gICAgICBlbHNlIHRoaXMuX29uQnJ1c2gocmlnaHQgPyBkMSA6IGQwKTtcbiAgICB9O1xuXG4gICAgX29uQnJ1c2godmFsMDogbnVtYmVyID0gMCwgdmFsMTogbnVtYmVyID0gMCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc1JhbmdlZCxcbiAgICAgICAgdmFsdWU6IFtjdXJyZW50VmFsMCwgY3VycmVudFZhbDFdXG4gICAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgaWYgKGN1cnJlbnRWYWwwID09PSB2YWwwICYmIGN1cnJlbnRWYWwxID09PSB2YWwxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUmFuZ2VkKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25CcnVzaCh2YWwwLCB2YWwxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJvcHMub25CcnVzaCh2YWwwLCB2YWwwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7aXNSYW5nZWR9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxTdHlsZWRHIGNsYXNzTmFtZT1cImtnLXJhbmdlLXNsaWRlcl9fYnJ1c2hcIiBpc1JhbmdlZD17aXNSYW5nZWR9IHJlZj17dGhpcy5yb290Q29udGFpbmVyfSAvPlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdpdGhUaGVtZShSYW5nZUJydXNoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmFuZ2VCcnVzaEZhY3Rvcnk7XG4iXX0=