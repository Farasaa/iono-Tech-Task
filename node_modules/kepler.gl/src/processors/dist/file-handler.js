"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrowTable = isArrowTable;
exports.isArrowData = isArrowData;
exports.isGeoJson = isGeoJson;
exports.isFeature = isFeature;
exports.isFeatureCollection = isFeatureCollection;
exports.isRowObject = isRowObject;
exports.isKeplerGlMap = isKeplerGlMap;
exports.makeProgressIterator = makeProgressIterator;
exports.readBatch = readBatch;
exports.readFileInBatches = readFileInBatches;
exports.processFileData = processFileData;
exports.filesToDataPayload = filesToDataPayload;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var arrow = _interopRequireWildcard(require("apache-arrow"));

var _core = require("@loaders.gl/core");

var _json = require("@loaders.gl/json");

var _csv = require("@loaders.gl/csv");

var _arrow = require("@loaders.gl/arrow");

var _dataProcessor = require("./data-processor");

var _utils = require("@kepler.gl/utils");

var _constants = require("@kepler.gl/constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var BATCH_TYPE = {
  METADATA: 'metadata',
  PARTIAL_RESULT: 'partial-result',
  FINAL_RESULT: 'final-result'
};
var CSV_LOADER_OPTIONS = {
  shape: 'object-row-table',
  dynamicTyping: false // not working for now

};
var ARROW_LOADER_OPTIONS = {
  shape: 'arrow-table',
  batchDebounceMs: 10 // time to delay between batches, for incremental loading

};
var JSON_LOADER_OPTIONS = {
  shape: 'object-row-table',
  // instruct loaders.gl on what json paths to stream
  jsonpaths: ['$', // JSON Row array
  '$.features', // GeoJSON
  '$.datasets' // KeplerGL JSON
  ]
};

/**
 * check if table is an ArrowTable object
 * @param table - object to check
 * @returns {boolean} - true if table is an ArrowTable object type guarded
 */
function isArrowTable(table) {
  return Boolean(table instanceof arrow.Table);
}
/**
 * check if data is an ArrowData object, which is an array of RecordBatch
 * @param data - object to check
 * @returns {boolean} - true if data is an ArrowData object type guarded
 */


function isArrowData(data) {
  return Array.isArray(data) && Boolean(data[0].data && data[0].schema);
}

function isGeoJson(json) {
  // json can be feature collection
  // or single feature
  return (0, _utils.isPlainObject)(json) && (isFeature(json) || isFeatureCollection(json));
}

function isFeature(json) {
  return (0, _utils.isPlainObject)(json) && json.type === 'Feature' && Boolean(json.geometry);
}

function isFeatureCollection(json) {
  return (0, _utils.isPlainObject)(json) && json.type === 'FeatureCollection' && Boolean(json.features);
}

function isRowObject(json) {
  return Array.isArray(json) && (0, _utils.isPlainObject)(json[0]);
}

function isKeplerGlMap(json) {
  return Boolean((0, _utils.isPlainObject)(json) && json.datasets && json.config && json.info && (0, _utils.isPlainObject)(json.info) && json.info.app === 'kepler.gl');
}

function makeProgressIterator(_x, _x2) {
  return _makeProgressIterator.apply(this, arguments);
} // eslint-disable-next-line complexity


function _makeProgressIterator() {
  _makeProgressIterator = (0, _wrapAsyncGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(asyncIterator, info) {
    var rowCount, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, rowCountInBatch, percent, progress;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            rowCount = 0;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 3;
            _iterator = (0, _asyncIterator2["default"])(asyncIterator);

          case 5:
            _context.next = 7;
            return (0, _awaitAsyncGenerator2["default"])(_iterator.next());

          case 7:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 11;
            return (0, _awaitAsyncGenerator2["default"])(_step.value);

          case 11:
            _value = _context.sent;

            if (_iteratorNormalCompletion) {
              _context.next = 23;
              break;
            }

            batch = _value;
            // the length could be stored in `batch.length` for arrow batch
            rowCountInBatch = batch.data && (batch.data.length || batch.length) || 0;
            rowCount += rowCountInBatch;
            percent = Number.isFinite(batch.bytesUsed) ? batch.bytesUsed / info.size : null; // Update progress object

            progress = _objectSpread({
              rowCount: rowCount,
              rowCountInBatch: rowCountInBatch
            }, Number.isFinite(percent) ? {
              percent: percent
            } : {});
            _context.next = 20;
            return _objectSpread(_objectSpread({}, batch), {}, {
              progress: progress
            });

          case 20:
            _iteratorNormalCompletion = true;
            _context.next = 5;
            break;

          case 23:
            _context.next = 29;
            break;

          case 25:
            _context.prev = 25;
            _context.t0 = _context["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 29:
            _context.prev = 29;
            _context.prev = 30;

            if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
              _context.next = 34;
              break;
            }

            _context.next = 34;
            return (0, _awaitAsyncGenerator2["default"])(_iterator["return"]());

          case 34:
            _context.prev = 34;

            if (!_didIteratorError) {
              _context.next = 37;
              break;
            }

            throw _iteratorError;

          case 37:
            return _context.finish(34);

          case 38:
            return _context.finish(29);

          case 39:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 25, 29, 39], [30,, 34, 38]]);
  }));
  return _makeProgressIterator.apply(this, arguments);
}

function readBatch(_x3, _x4) {
  return _readBatch.apply(this, arguments);
}

function _readBatch() {
  _readBatch = (0, _wrapAsyncGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(asyncIterator, fileName) {
    var result, batches, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, batch, streamingPath, batchData, i;

    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            result = null;
            batches = [];
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _context2.prev = 4;
            _iterator2 = (0, _asyncIterator2["default"])(asyncIterator);

          case 6:
            _context2.next = 8;
            return (0, _awaitAsyncGenerator2["default"])(_iterator2.next());

          case 8:
            _step2 = _context2.sent;
            _iteratorNormalCompletion2 = _step2.done;
            _context2.next = 12;
            return (0, _awaitAsyncGenerator2["default"])(_step2.value);

          case 12:
            _value2 = _context2.sent;

            if (_iteratorNormalCompletion2) {
              _context2.next = 21;
              break;
            }

            batch = _value2;

            // Last batch will have this special type and will provide all the root
            // properties of the parsed document.
            // Only json parse will have `FINAL_RESULT`
            if (batch.batchType === BATCH_TYPE.FINAL_RESULT) {
              if (batch.container) {
                result = _objectSpread({}, batch.container);
              } // Set the streamed data correctly is Batch json path is set
              // and the path streamed is not the top level object (jsonpath = '$')


              if (batch.jsonpath && batch.jsonpath.length > 1) {
                streamingPath = new _json._JSONPath(batch.jsonpath);
                streamingPath.setFieldAtPath(result, batches);
              } else if (batch.jsonpath && batch.jsonpath.length === 1) {
                // The streamed object is a ROW JSON-batch (jsonpath = '$')
                // row objects
                result = batches;
              }
            } else {
              batchData = isArrowTable(batch.data) ? batch.data.batches : batch.data;

              for (i = 0; i < (batchData === null || batchData === void 0 ? void 0 : batchData.length); i++) {
                batches.push(batchData[i]);
              }
            }

            _context2.next = 18;
            return _objectSpread(_objectSpread(_objectSpread({}, batch), batch.schema ? {
              headers: Object.keys(batch.schema)
            } : {}), {}, {
              fileName: fileName,
              // if dataset is CSV, data is set to the raw batches
              data: result ? result : batches
            });

          case 18:
            _iteratorNormalCompletion2 = true;
            _context2.next = 6;
            break;

          case 21:
            _context2.next = 27;
            break;

          case 23:
            _context2.prev = 23;
            _context2.t0 = _context2["catch"](4);
            _didIteratorError2 = true;
            _iteratorError2 = _context2.t0;

          case 27:
            _context2.prev = 27;
            _context2.prev = 28;

            if (!(!_iteratorNormalCompletion2 && _iterator2["return"] != null)) {
              _context2.next = 32;
              break;
            }

            _context2.next = 32;
            return (0, _awaitAsyncGenerator2["default"])(_iterator2["return"]());

          case 32:
            _context2.prev = 32;

            if (!_didIteratorError2) {
              _context2.next = 35;
              break;
            }

            throw _iteratorError2;

          case 35:
            return _context2.finish(32);

          case 36:
            return _context2.finish(27);

          case 37:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[4, 23, 27, 37], [28,, 32, 36]]);
  }));
  return _readBatch.apply(this, arguments);
}

function readFileInBatches(_x5) {
  return _readFileInBatches.apply(this, arguments);
}

function _readFileInBatches() {
  _readFileInBatches = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(_ref) {
    var file, _ref$loaders, loaders, _ref$loadOptions, loadOptions, batchIterator, progressIterator;

    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            file = _ref.file, _ref$loaders = _ref.loaders, loaders = _ref$loaders === void 0 ? [] : _ref$loaders, _ref$loadOptions = _ref.loadOptions, loadOptions = _ref$loadOptions === void 0 ? {} : _ref$loadOptions;
            loaders = [_json.JSONLoader, _csv.CSVLoader, _arrow.ArrowLoader].concat((0, _toConsumableArray2["default"])(loaders));
            loadOptions = _objectSpread({
              csv: CSV_LOADER_OPTIONS,
              arrow: ARROW_LOADER_OPTIONS,
              json: JSON_LOADER_OPTIONS,
              metadata: true
            }, loadOptions);
            _context3.next = 5;
            return (0, _core.parseInBatches)(file, loaders, loadOptions);

          case 5:
            batchIterator = _context3.sent;
            progressIterator = makeProgressIterator(batchIterator, {
              size: file.size
            });
            return _context3.abrupt("return", readBatch(progressIterator, file.name));

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _readFileInBatches.apply(this, arguments);
}

function processFileData(_ref2) {
  var content = _ref2.content,
      fileCache = _ref2.fileCache;
  return new Promise(function (resolve, reject) {
    var fileName = content.fileName,
        data = content.data;
    var format;
    var processor; // generate unique id with length of 4 using fileName string

    var id = (0, _utils.generateHashIdFromString)(fileName);

    if (isArrowData(data)) {
      format = _constants.DATASET_FORMATS.arrow;
      processor = _dataProcessor.processArrowBatches;
    } else if (isKeplerGlMap(data)) {
      format = _constants.DATASET_FORMATS.keplergl;
      processor = _dataProcessor.processKeplerglJSON;
    } else if (isRowObject(data)) {
      format = _constants.DATASET_FORMATS.row;
      processor = _dataProcessor.processRowObject;
    } else if (isGeoJson(data)) {
      format = _constants.DATASET_FORMATS.geojson;
      processor = _dataProcessor.processGeojson;
    }

    if (format && processor) {
      var result = processor(data);
      resolve([].concat((0, _toConsumableArray2["default"])(fileCache), [{
        data: result,
        info: {
          id: id,
          label: content.fileName,
          format: format
        }
      }]));
    }

    reject('Unknown File Format');
  });
}

function filesToDataPayload(fileCache) {
  // seperate out files which could be a single datasets. or a keplergl map json
  var collection = fileCache.reduce(function (accu, file) {
    var data = file.data,
        info = file.info;

    if ((info === null || info === void 0 ? void 0 : info.format) === _constants.DATASET_FORMATS.keplergl) {
      // if file contains a single kepler map dataset & config
      accu.keplerMaps.push(_objectSpread(_objectSpread({}, data), {}, {
        options: {
          centerMap: !(data.config && data.config.mapState)
        }
      }));
    } else if (_constants.DATASET_FORMATS[info === null || info === void 0 ? void 0 : info.format]) {
      // if file contains only data
      var newDataset = {
        data: data,
        info: _objectSpread({
          id: (info === null || info === void 0 ? void 0 : info.id) || (0, _utils.generateHashId)(4)
        }, info || {})
      };
      accu.datasets.push(newDataset);
    }

    return accu;
  }, {
    datasets: [],
    keplerMaps: []
  }); // add kepler map first with config
  // add datasets later in one add data call

  return collection.keplerMaps.concat({
    datasets: collection.datasets
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWxlLWhhbmRsZXIudHMiXSwibmFtZXMiOlsiQkFUQ0hfVFlQRSIsIk1FVEFEQVRBIiwiUEFSVElBTF9SRVNVTFQiLCJGSU5BTF9SRVNVTFQiLCJDU1ZfTE9BREVSX09QVElPTlMiLCJzaGFwZSIsImR5bmFtaWNUeXBpbmciLCJBUlJPV19MT0FERVJfT1BUSU9OUyIsImJhdGNoRGVib3VuY2VNcyIsIkpTT05fTE9BREVSX09QVElPTlMiLCJqc29ucGF0aHMiLCJpc0Fycm93VGFibGUiLCJ0YWJsZSIsIkJvb2xlYW4iLCJhcnJvdyIsIlRhYmxlIiwiaXNBcnJvd0RhdGEiLCJkYXRhIiwiQXJyYXkiLCJpc0FycmF5Iiwic2NoZW1hIiwiaXNHZW9Kc29uIiwianNvbiIsImlzRmVhdHVyZSIsImlzRmVhdHVyZUNvbGxlY3Rpb24iLCJ0eXBlIiwiZ2VvbWV0cnkiLCJmZWF0dXJlcyIsImlzUm93T2JqZWN0IiwiaXNLZXBsZXJHbE1hcCIsImRhdGFzZXRzIiwiY29uZmlnIiwiaW5mbyIsImFwcCIsIm1ha2VQcm9ncmVzc0l0ZXJhdG9yIiwiYXN5bmNJdGVyYXRvciIsInJvd0NvdW50IiwiYmF0Y2giLCJyb3dDb3VudEluQmF0Y2giLCJsZW5ndGgiLCJwZXJjZW50IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJieXRlc1VzZWQiLCJzaXplIiwicHJvZ3Jlc3MiLCJyZWFkQmF0Y2giLCJmaWxlTmFtZSIsInJlc3VsdCIsImJhdGNoZXMiLCJiYXRjaFR5cGUiLCJjb250YWluZXIiLCJqc29ucGF0aCIsInN0cmVhbWluZ1BhdGgiLCJfSlNPTlBhdGgiLCJzZXRGaWVsZEF0UGF0aCIsImJhdGNoRGF0YSIsImkiLCJwdXNoIiwiaGVhZGVycyIsIk9iamVjdCIsImtleXMiLCJyZWFkRmlsZUluQmF0Y2hlcyIsImZpbGUiLCJsb2FkZXJzIiwibG9hZE9wdGlvbnMiLCJKU09OTG9hZGVyIiwiQ1NWTG9hZGVyIiwiQXJyb3dMb2FkZXIiLCJjc3YiLCJtZXRhZGF0YSIsImJhdGNoSXRlcmF0b3IiLCJwcm9ncmVzc0l0ZXJhdG9yIiwibmFtZSIsInByb2Nlc3NGaWxlRGF0YSIsImNvbnRlbnQiLCJmaWxlQ2FjaGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZvcm1hdCIsInByb2Nlc3NvciIsImlkIiwiREFUQVNFVF9GT1JNQVRTIiwicHJvY2Vzc0Fycm93QmF0Y2hlcyIsImtlcGxlcmdsIiwicHJvY2Vzc0tlcGxlcmdsSlNPTiIsInJvdyIsInByb2Nlc3NSb3dPYmplY3QiLCJnZW9qc29uIiwicHJvY2Vzc0dlb2pzb24iLCJsYWJlbCIsImZpbGVzVG9EYXRhUGF5bG9hZCIsImNvbGxlY3Rpb24iLCJyZWR1Y2UiLCJhY2N1Iiwia2VwbGVyTWFwcyIsIm9wdGlvbnMiLCJjZW50ZXJNYXAiLCJtYXBTdGF0ZSIsIm5ld0RhdGFzZXQiLCJjb25jYXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQU1BOztBQUNBOzs7Ozs7QUFNQSxJQUFNQSxVQUFVLEdBQUc7QUFDakJDLEVBQUFBLFFBQVEsRUFBRSxVQURPO0FBRWpCQyxFQUFBQSxjQUFjLEVBQUUsZ0JBRkM7QUFHakJDLEVBQUFBLFlBQVksRUFBRTtBQUhHLENBQW5CO0FBTUEsSUFBTUMsa0JBQWtCLEdBQUc7QUFDekJDLEVBQUFBLEtBQUssRUFBRSxrQkFEa0I7QUFFekJDLEVBQUFBLGFBQWEsRUFBRSxLQUZVLENBRUo7O0FBRkksQ0FBM0I7QUFLQSxJQUFNQyxvQkFBb0IsR0FBRztBQUMzQkYsRUFBQUEsS0FBSyxFQUFFLGFBRG9CO0FBRTNCRyxFQUFBQSxlQUFlLEVBQUUsRUFGVSxDQUVQOztBQUZPLENBQTdCO0FBS0EsSUFBTUMsbUJBQW1CLEdBQUc7QUFDMUJKLEVBQUFBLEtBQUssRUFBRSxrQkFEbUI7QUFFMUI7QUFDQUssRUFBQUEsU0FBUyxFQUFFLENBQ1QsR0FEUyxFQUNKO0FBQ0wsY0FG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O0FBQTNCLEdBM0JpQixDQUFuQixDQUZvRixDQWdDcEY7QUFDQTs7QUFDQSxTQUFPSCxVQUFVLENBQUNHLFVBQVgsQ0FBc0JLLE1BQXRCLENBQTZCO0FBQUN2RSxJQUFBQSxRQUFRLEVBQUUrRCxVQUFVLENBQUMvRDtBQUF0QixHQUE3QixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuaW1wb3J0IHtwYXJzZUluQmF0Y2hlc30gZnJvbSAnQGxvYWRlcnMuZ2wvY29yZSc7XG5pbXBvcnQge0pTT05Mb2FkZXIsIF9KU09OUGF0aH0gZnJvbSAnQGxvYWRlcnMuZ2wvanNvbic7XG5pbXBvcnQge0NTVkxvYWRlcn0gZnJvbSAnQGxvYWRlcnMuZ2wvY3N2JztcbmltcG9ydCB7QXJyb3dMb2FkZXJ9IGZyb20gJ0Bsb2FkZXJzLmdsL2Fycm93JztcbmltcG9ydCB7XG4gIHByb2Nlc3NBcnJvd0JhdGNoZXMsXG4gIHByb2Nlc3NHZW9qc29uLFxuICBwcm9jZXNzS2VwbGVyZ2xKU09OLFxuICBwcm9jZXNzUm93T2JqZWN0XG59IGZyb20gJy4vZGF0YS1wcm9jZXNzb3InO1xuaW1wb3J0IHtnZW5lcmF0ZUhhc2hJZCwgaXNQbGFpbk9iamVjdCwgZ2VuZXJhdGVIYXNoSWRGcm9tU3RyaW5nfSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7REFUQVNFVF9GT1JNQVRTfSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge0xvYWRlcn0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcbmltcG9ydCB7RmlsZUNhY2hlSXRlbSwgVmFsaWRLZXBsZXJHbE1hcH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge0ZlYXR1cmUsIEFkZERhdGFUb01hcFBheWxvYWR9IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuaW1wb3J0IHtGZWF0dXJlQ29sbGVjdGlvbn0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5cbmNvbnN0IEJBVENIX1RZUEUgPSB7XG4gIE1FVEFEQVRBOiAnbWV0YWRhdGEnLFxuICBQQVJUSUFMX1JFU1VMVDogJ3BhcnRpYWwtcmVzdWx0JyxcbiAgRklOQUxfUkVTVUxUOiAnZmluYWwtcmVzdWx0J1xufTtcblxuY29uc3QgQ1NWX0xPQURFUl9PUFRJT05TID0ge1xuICBzaGFwZTogJ29iamVjdC1yb3ctdGFibGUnLFxuICBkeW5hbWljVHlwaW5nOiBmYWxzZSAvLyBub3Qgd29ya2luZyBmb3Igbm93XG59O1xuXG5jb25zdCBBUlJPV19MT0FERVJfT1BUSU9OUyA9IHtcbiAgc2hhcGU6ICdhcnJvdy10YWJsZScsXG4gIGJhdGNoRGVib3VuY2VNczogMTAgLy8gdGltZSB0byBkZWxheSBiZXR3ZWVuIGJhdGNoZXMsIGZvciBpbmNyZW1lbnRhbCBsb2FkaW5nXG59O1xuXG5jb25zdCBKU09OX0xPQURFUl9PUFRJT05TID0ge1xuICBzaGFwZTogJ29iamVjdC1yb3ctdGFibGUnLFxuICAvLyBpbnN0cnVjdCBsb2FkZXJzLmdsIG9uIHdoYXQganNvbiBwYXRocyB0byBzdHJlYW1cbiAganNvbnBhdGhzOiBbXG4gICAgJyQnLCAvLyBKU09OIFJvdyBhcnJheVxuICAgICckLmZlYXR1cmVzJywgLy8gR2VvSlNPTlxuICAgICckLmRhdGFzZXRzJyAvLyBLZXBsZXJHTCBKU09OXG4gIF1cbn07XG5cbmV4cG9ydCB0eXBlIFByb2Nlc3NGaWxlRGF0YUNvbnRlbnQgPSB7XG4gIGRhdGE6IHVua25vd247XG4gIGZpbGVOYW1lOiBzdHJpbmc7XG4gIGxlbmd0aD86IG51bWJlcjtcbiAgcHJvZ3Jlc3M/OiB7cm93Q291bnQ/OiBudW1iZXI7IHJvd0NvdW50SW5CYXRjaD86IG51bWJlcjsgcGVyY2VudD86IG51bWJlcn07XG4gIC8qKiAgbWV0YWRhdGEgZS5nLiBmb3IgYXJyb3cgZGF0YSwgbWV0YWRhdGEgY291bGQgYmUgdGhlIHNjaGVtYS5maWVsZHMgKi9cbiAgbWV0YWRhdGE/OiBNYXA8c3RyaW5nLCBzdHJpbmc+O1xufTtcblxuLyoqXG4gKiBjaGVjayBpZiB0YWJsZSBpcyBhbiBBcnJvd1RhYmxlIG9iamVjdFxuICogQHBhcmFtIHRhYmxlIC0gb2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRhYmxlIGlzIGFuIEFycm93VGFibGUgb2JqZWN0IHR5cGUgZ3VhcmRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJvd1RhYmxlKHRhYmxlOiBhbnkpOiB0YWJsZSBpcyBhcnJvdy5UYWJsZSB7XG4gIHJldHVybiBCb29sZWFuKHRhYmxlIGluc3RhbmNlb2YgYXJyb3cuVGFibGUpO1xufVxuXG4vKipcbiAqIGNoZWNrIGlmIGRhdGEgaXMgYW4gQXJyb3dEYXRhIG9iamVjdCwgd2hpY2ggaXMgYW4gYXJyYXkgb2YgUmVjb3JkQmF0Y2hcbiAqIEBwYXJhbSBkYXRhIC0gb2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIGRhdGEgaXMgYW4gQXJyb3dEYXRhIG9iamVjdCB0eXBlIGd1YXJkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyb3dEYXRhKGRhdGE6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkYXRhKSAmJiBCb29sZWFuKGRhdGFbMF0uZGF0YSAmJiBkYXRhWzBdLnNjaGVtYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0dlb0pzb24oanNvbjogdW5rbm93bik6IGpzb24gaXMgRmVhdHVyZSB8IEZlYXR1cmVDb2xsZWN0aW9uIHtcbiAgLy8ganNvbiBjYW4gYmUgZmVhdHVyZSBjb2xsZWN0aW9uXG4gIC8vIG9yIHNpbmdsZSBmZWF0dXJlXG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGpzb24pICYmIChpc0ZlYXR1cmUoanNvbikgfHwgaXNGZWF0dXJlQ29sbGVjdGlvbihqc29uKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZlYXR1cmUoanNvbjogdW5rbm93bik6IGpzb24gaXMgRmVhdHVyZSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGpzb24pICYmIGpzb24udHlwZSA9PT0gJ0ZlYXR1cmUnICYmIEJvb2xlYW4oanNvbi5nZW9tZXRyeSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZlYXR1cmVDb2xsZWN0aW9uKGpzb246IHVua25vd24pOiBqc29uIGlzIEZlYXR1cmVDb2xsZWN0aW9uIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoanNvbikgJiYganNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nICYmIEJvb2xlYW4oanNvbi5mZWF0dXJlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jvd09iamVjdChqc29uOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoanNvbikgJiYgaXNQbGFpbk9iamVjdChqc29uWzBdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzS2VwbGVyR2xNYXAoanNvbjogdW5rbm93bik6IGpzb24gaXMgVmFsaWRLZXBsZXJHbE1hcCB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIGlzUGxhaW5PYmplY3QoanNvbikgJiZcbiAgICAgIGpzb24uZGF0YXNldHMgJiZcbiAgICAgIGpzb24uY29uZmlnICYmXG4gICAgICBqc29uLmluZm8gJiZcbiAgICAgIGlzUGxhaW5PYmplY3QoanNvbi5pbmZvKSAmJlxuICAgICAganNvbi5pbmZvLmFwcCA9PT0gJ2tlcGxlci5nbCdcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBtYWtlUHJvZ3Jlc3NJdGVyYXRvcihcbiAgYXN5bmNJdGVyYXRvcjogQXN5bmNJdGVyYWJsZTxhbnk+LFxuICBpbmZvOiB7c2l6ZTogbnVtYmVyfVxuKTogQXN5bmNHZW5lcmF0b3Ige1xuICBsZXQgcm93Q291bnQgPSAwO1xuXG4gIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgYXN5bmNJdGVyYXRvcikge1xuICAgIC8vIHRoZSBsZW5ndGggY291bGQgYmUgc3RvcmVkIGluIGBiYXRjaC5sZW5ndGhgIGZvciBhcnJvdyBiYXRjaFxuICAgIGNvbnN0IHJvd0NvdW50SW5CYXRjaCA9IChiYXRjaC5kYXRhICYmIChiYXRjaC5kYXRhLmxlbmd0aCB8fCBiYXRjaC5sZW5ndGgpKSB8fCAwO1xuICAgIHJvd0NvdW50ICs9IHJvd0NvdW50SW5CYXRjaDtcbiAgICBjb25zdCBwZXJjZW50ID0gTnVtYmVyLmlzRmluaXRlKGJhdGNoLmJ5dGVzVXNlZCkgPyBiYXRjaC5ieXRlc1VzZWQgLyBpbmZvLnNpemUgOiBudWxsO1xuXG4gICAgLy8gVXBkYXRlIHByb2dyZXNzIG9iamVjdFxuICAgIGNvbnN0IHByb2dyZXNzID0ge1xuICAgICAgcm93Q291bnQsXG4gICAgICByb3dDb3VudEluQmF0Y2gsXG4gICAgICAuLi4oTnVtYmVyLmlzRmluaXRlKHBlcmNlbnQpID8ge3BlcmNlbnR9IDoge30pXG4gICAgfTtcblxuICAgIHlpZWxkIHsuLi5iYXRjaCwgcHJvZ3Jlc3N9O1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIHJlYWRCYXRjaChcbiAgYXN5bmNJdGVyYXRvcjogQXN5bmNJdGVyYWJsZTxhbnk+LFxuICBmaWxlTmFtZTogc3RyaW5nXG4pOiBBc3luY0dlbmVyYXRvciB7XG4gIGxldCByZXN1bHQgPSBudWxsO1xuICBjb25zdCBiYXRjaGVzID0gPGFueT5bXTtcbiAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiBhc3luY0l0ZXJhdG9yKSB7XG4gICAgLy8gTGFzdCBiYXRjaCB3aWxsIGhhdmUgdGhpcyBzcGVjaWFsIHR5cGUgYW5kIHdpbGwgcHJvdmlkZSBhbGwgdGhlIHJvb3RcbiAgICAvLyBwcm9wZXJ0aWVzIG9mIHRoZSBwYXJzZWQgZG9jdW1lbnQuXG4gICAgLy8gT25seSBqc29uIHBhcnNlIHdpbGwgaGF2ZSBgRklOQUxfUkVTVUxUYFxuICAgIGlmIChiYXRjaC5iYXRjaFR5cGUgPT09IEJBVENIX1RZUEUuRklOQUxfUkVTVUxUKSB7XG4gICAgICBpZiAoYmF0Y2guY29udGFpbmVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHsuLi5iYXRjaC5jb250YWluZXJ9O1xuICAgICAgfVxuICAgICAgLy8gU2V0IHRoZSBzdHJlYW1lZCBkYXRhIGNvcnJlY3RseSBpcyBCYXRjaCBqc29uIHBhdGggaXMgc2V0XG4gICAgICAvLyBhbmQgdGhlIHBhdGggc3RyZWFtZWQgaXMgbm90IHRoZSB0b3AgbGV2ZWwgb2JqZWN0IChqc29ucGF0aCA9ICckJylcbiAgICAgIGlmIChiYXRjaC5qc29ucGF0aCAmJiBiYXRjaC5qc29ucGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbWluZ1BhdGggPSBuZXcgX0pTT05QYXRoKGJhdGNoLmpzb25wYXRoKTtcbiAgICAgICAgc3RyZWFtaW5nUGF0aC5zZXRGaWVsZEF0UGF0aChyZXN1bHQsIGJhdGNoZXMpO1xuICAgICAgfSBlbHNlIGlmIChiYXRjaC5qc29ucGF0aCAmJiBiYXRjaC5qc29ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gVGhlIHN0cmVhbWVkIG9iamVjdCBpcyBhIFJPVyBKU09OLWJhdGNoIChqc29ucGF0aCA9ICckJylcbiAgICAgICAgLy8gcm93IG9iamVjdHNcbiAgICAgICAgcmVzdWx0ID0gYmF0Y2hlcztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmF0Y2hEYXRhID0gaXNBcnJvd1RhYmxlKGJhdGNoLmRhdGEpID8gYmF0Y2guZGF0YS5iYXRjaGVzIDogYmF0Y2guZGF0YTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hEYXRhPy5sZW5ndGg7IGkrKykge1xuICAgICAgICBiYXRjaGVzLnB1c2goYmF0Y2hEYXRhW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB5aWVsZCB7XG4gICAgICAuLi5iYXRjaCxcbiAgICAgIC4uLihiYXRjaC5zY2hlbWEgPyB7aGVhZGVyczogT2JqZWN0LmtleXMoYmF0Y2guc2NoZW1hKX0gOiB7fSksXG4gICAgICBmaWxlTmFtZSxcbiAgICAgIC8vIGlmIGRhdGFzZXQgaXMgQ1NWLCBkYXRhIGlzIHNldCB0byB0aGUgcmF3IGJhdGNoZXNcbiAgICAgIGRhdGE6IHJlc3VsdCA/IHJlc3VsdCA6IGJhdGNoZXNcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkRmlsZUluQmF0Y2hlcyh7XG4gIGZpbGUsXG4gIGxvYWRlcnMgPSBbXSxcbiAgbG9hZE9wdGlvbnMgPSB7fVxufToge1xuICBmaWxlOiBGaWxlO1xuICBmaWxlQ2FjaGU6IEZpbGVDYWNoZUl0ZW1bXTtcbiAgbG9hZGVyczogTG9hZGVyW107XG4gIGxvYWRPcHRpb25zOiBhbnk7XG59KTogUHJvbWlzZTxBc3luY0dlbmVyYXRvcj4ge1xuICBsb2FkZXJzID0gW0pTT05Mb2FkZXIsIENTVkxvYWRlciwgQXJyb3dMb2FkZXIsIC4uLmxvYWRlcnNdO1xuICBsb2FkT3B0aW9ucyA9IHtcbiAgICBjc3Y6IENTVl9MT0FERVJfT1BUSU9OUyxcbiAgICBhcnJvdzogQVJST1dfTE9BREVSX09QVElPTlMsXG4gICAganNvbjogSlNPTl9MT0FERVJfT1BUSU9OUyxcbiAgICBtZXRhZGF0YTogdHJ1ZSxcbiAgICAuLi5sb2FkT3B0aW9uc1xuICB9O1xuXG4gIGNvbnN0IGJhdGNoSXRlcmF0b3IgPSBhd2FpdCBwYXJzZUluQmF0Y2hlcyhmaWxlLCBsb2FkZXJzLCBsb2FkT3B0aW9ucyk7XG4gIGNvbnN0IHByb2dyZXNzSXRlcmF0b3IgPSBtYWtlUHJvZ3Jlc3NJdGVyYXRvcihiYXRjaEl0ZXJhdG9yLCB7c2l6ZTogZmlsZS5zaXplfSk7XG5cbiAgcmV0dXJuIHJlYWRCYXRjaChwcm9ncmVzc0l0ZXJhdG9yLCBmaWxlLm5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVEYXRhKHtcbiAgY29udGVudCxcbiAgZmlsZUNhY2hlXG59OiB7XG4gIGNvbnRlbnQ6IFByb2Nlc3NGaWxlRGF0YUNvbnRlbnQ7XG4gIGZpbGVDYWNoZTogRmlsZUNhY2hlSXRlbVtdO1xufSk6IFByb21pc2U8RmlsZUNhY2hlSXRlbVtdPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IHtmaWxlTmFtZSwgZGF0YX0gPSBjb250ZW50O1xuICAgIGxldCBmb3JtYXQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBsZXQgcHJvY2Vzc29yOiBGdW5jdGlvbiB8IHVuZGVmaW5lZDtcblxuICAgIC8vIGdlbmVyYXRlIHVuaXF1ZSBpZCB3aXRoIGxlbmd0aCBvZiA0IHVzaW5nIGZpbGVOYW1lIHN0cmluZ1xuICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVIYXNoSWRGcm9tU3RyaW5nKGZpbGVOYW1lKTtcblxuICAgIGlmIChpc0Fycm93RGF0YShkYXRhKSkge1xuICAgICAgZm9ybWF0ID0gREFUQVNFVF9GT1JNQVRTLmFycm93O1xuICAgICAgcHJvY2Vzc29yID0gcHJvY2Vzc0Fycm93QmF0Y2hlcztcbiAgICB9IGVsc2UgaWYgKGlzS2VwbGVyR2xNYXAoZGF0YSkpIHtcbiAgICAgIGZvcm1hdCA9IERBVEFTRVRfRk9STUFUUy5rZXBsZXJnbDtcbiAgICAgIHByb2Nlc3NvciA9IHByb2Nlc3NLZXBsZXJnbEpTT047XG4gICAgfSBlbHNlIGlmIChpc1Jvd09iamVjdChkYXRhKSkge1xuICAgICAgZm9ybWF0ID0gREFUQVNFVF9GT1JNQVRTLnJvdztcbiAgICAgIHByb2Nlc3NvciA9IHByb2Nlc3NSb3dPYmplY3Q7XG4gICAgfSBlbHNlIGlmIChpc0dlb0pzb24oZGF0YSkpIHtcbiAgICAgIGZvcm1hdCA9IERBVEFTRVRfRk9STUFUUy5nZW9qc29uO1xuICAgICAgcHJvY2Vzc29yID0gcHJvY2Vzc0dlb2pzb247XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdCAmJiBwcm9jZXNzb3IpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NvcihkYXRhKTtcblxuICAgICAgcmVzb2x2ZShbXG4gICAgICAgIC4uLmZpbGVDYWNoZSxcbiAgICAgICAge1xuICAgICAgICAgIGRhdGE6IHJlc3VsdCxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGxhYmVsOiBjb250ZW50LmZpbGVOYW1lLFxuICAgICAgICAgICAgZm9ybWF0XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdKTtcbiAgICB9XG5cbiAgICByZWplY3QoJ1Vua25vd24gRmlsZSBGb3JtYXQnKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxlc1RvRGF0YVBheWxvYWQoZmlsZUNhY2hlOiBGaWxlQ2FjaGVJdGVtW10pOiBBZGREYXRhVG9NYXBQYXlsb2FkW10ge1xuICAvLyBzZXBlcmF0ZSBvdXQgZmlsZXMgd2hpY2ggY291bGQgYmUgYSBzaW5nbGUgZGF0YXNldHMuIG9yIGEga2VwbGVyZ2wgbWFwIGpzb25cbiAgY29uc3QgY29sbGVjdGlvbiA9IGZpbGVDYWNoZS5yZWR1Y2U8e1xuICAgIGRhdGFzZXRzOiBGaWxlQ2FjaGVJdGVtW107XG4gICAga2VwbGVyTWFwczogQWRkRGF0YVRvTWFwUGF5bG9hZFtdO1xuICB9PihcbiAgICAoYWNjdSwgZmlsZSkgPT4ge1xuICAgICAgY29uc3Qge2RhdGEsIGluZm99ID0gZmlsZTtcbiAgICAgIGlmIChpbmZvPy5mb3JtYXQgPT09IERBVEFTRVRfRk9STUFUUy5rZXBsZXJnbCkge1xuICAgICAgICAvLyBpZiBmaWxlIGNvbnRhaW5zIGEgc2luZ2xlIGtlcGxlciBtYXAgZGF0YXNldCAmIGNvbmZpZ1xuICAgICAgICBhY2N1LmtlcGxlck1hcHMucHVzaCh7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBjZW50ZXJNYXA6ICEoZGF0YS5jb25maWcgJiYgZGF0YS5jb25maWcubWFwU3RhdGUpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoREFUQVNFVF9GT1JNQVRTW2luZm8/LmZvcm1hdF0pIHtcbiAgICAgICAgLy8gaWYgZmlsZSBjb250YWlucyBvbmx5IGRhdGFcbiAgICAgICAgY29uc3QgbmV3RGF0YXNldCA9IHtcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgIGlkOiBpbmZvPy5pZCB8fCBnZW5lcmF0ZUhhc2hJZCg0KSxcbiAgICAgICAgICAgIC4uLihpbmZvIHx8IHt9KVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYWNjdS5kYXRhc2V0cy5wdXNoKG5ld0RhdGFzZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3U7XG4gICAgfSxcbiAgICB7ZGF0YXNldHM6IFtdLCBrZXBsZXJNYXBzOiBbXX1cbiAgKTtcblxuICAvLyBhZGQga2VwbGVyIG1hcCBmaXJzdCB3aXRoIGNvbmZpZ1xuICAvLyBhZGQgZGF0YXNldHMgbGF0ZXIgaW4gb25lIGFkZCBkYXRhIGNhbGxcbiAgcmV0dXJuIGNvbGxlY3Rpb24ua2VwbGVyTWFwcy5jb25jYXQoe2RhdGFzZXRzOiBjb2xsZWN0aW9uLmRhdGFzZXRzfSk7XG59XG4iXX0=