{"version":3,"sources":["../../../../src/components/export-video/utils.js"],"names":["parseSetCameraType","strCameraType","viewState","modifiedViewState","match","turfPoint","longitude","latitude","bearing","parseInt","setChecker","Set","has","translatedPoly","geometry","coordinates","zoom","msConversion","durationMs","milliseconds","seconds","minutes","estimateFileSize","frameRate","resolution","mediaType"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {point} from '@turf/helpers';\nimport transformTranslate from '@turf/transform-translate';\n\n/**\n * Parses camera type and creates keyframe for Hubble to use\n * @param {string} strCameraType of user-selected camera option ex: \"Orbit (90ยบ)\"\n * @param {Object} viewState keyframe JSON that contains long, lat, zoom, bearing, pitch\n * @returns {Object} below:\n *      {\n *        longitude: modifiedViewState.longitude,\n *        latitude: modifiedViewState.latitude,\n *        zoom: modifiedViewState.zoom,\n *        bearing: modifiedViewState.bearing,\n *        pitch: modifiedViewState.pitch\n *      }\n *\n */\nexport function parseSetCameraType(strCameraType, viewState) {\n  const modifiedViewState = {...viewState}; // Creating a shallow copy otherwise keyframes bugs out\n  // Returns arr of important keywords. Should work for 2+ words in future ex: [\"Orbit\", \"90\"] | [\"North\", \"South\"] | [\"Zoom\", \"In\"]\n  const match = strCameraType.match(/\\b(?!to)\\b\\S+\\w/g);\n  // Converts mapState object to turf friendly Point obj (GEOJSON)\n  const turfPoint = point([modifiedViewState.longitude, modifiedViewState.latitude]);\n  if (match[0] === 'Orbit') {\n    modifiedViewState.bearing = parseInt(match[1], 10);\n  }\n\n  // TODO future option that'll allow user to set X distance (km OR miles) directionally. Options inside turf\n  // https://turfjs.org/docs/#transformTranslate\n  const setChecker = new Set(['East', 'South', 'West', 'North']);\n  if (setChecker.has(match[0])) {\n    if (match[0] === 'East') {\n      // TODO Temporary solution to catch this branch to master. Doesn't work for \"East to North\" for example if option allows in future\n      const translatedPoly = transformTranslate(turfPoint, 10, 270);\n      modifiedViewState.longitude = translatedPoly.geometry.coordinates[0];\n    } else if (match[0] === 'South') {\n      const translatedPoly = transformTranslate(turfPoint, 10, 0);\n      modifiedViewState.latitude = translatedPoly.geometry.coordinates[1];\n    } else if (match[0] === 'West') {\n      const translatedPoly = transformTranslate(turfPoint, 10, 90);\n      modifiedViewState.longitude = translatedPoly.geometry.coordinates[0];\n    } else if (match[0] === 'North') {\n      const translatedPoly = transformTranslate(turfPoint, 10, 180);\n      modifiedViewState.latitude = translatedPoly.geometry.coordinates[1];\n    }\n  }\n\n  if (match[0] === 'Zoom') {\n    if (match[1] === 'In') {\n      modifiedViewState.zoom = modifiedViewState.zoom + 3;\n    } else if (match[1] === 'Out') {\n      modifiedViewState.zoom = modifiedViewState.zoom - 3;\n    }\n  }\n  return modifiedViewState;\n}\n\n/**\n * Used to convert durationMs (inherited from ExportVideoPanelContainer) to hh:mm:ss\n * @param {number} durationMs duration of animation in milliseconds\n * @returns {string} time in format hh:mm:ss\n */\nexport function msConversion(durationMs) {\n  const milliseconds = parseInt(durationMs % 1000, 10);\n  let seconds = parseInt((durationMs / 1000) % 60, 10);\n  let minutes = parseInt((durationMs / (1000 * 60)) % 60, 10);\n  // let hours = parseInt((durationMs / (1000 * 60 * 60)) % 24, 10); // Hours can be used if needed in future\n\n  // hours = hours < 10 ? `0${hours}` : hours;\n  minutes = minutes < 10 ? `0${minutes}` : minutes;\n  seconds = seconds < 10 ? `0${seconds}` : seconds;\n\n  return `${minutes}:${seconds}.${milliseconds}`;\n}\n\n/**\n * Estimates file size of resulting animation\n * @param {number} frameRate frame rate of animation (set by developer)\n * @param {array} resolution [width, height] of animation\n * @param {number} durationMs duration of animation (set by developer)\n * @param {string} mediaType 'GIF', 'WEBM', etc.\n * @returns {string} size in MB\n */\nexport function estimateFileSize(frameRate, resolution, durationMs, mediaType) {\n  // Based off of https://www.youtube.com/watch?v=DDcYvesZsnw for uncompressed video\n  // Formula: ((horizontal * vertical * bit depth) / (8 * 1024 * 1024 [convert to megabyte MB])) * (frame rate * time in seconds) * compression ratio\n  // Additional resource https://stackoverflow.com/questions/27559103/video-size-calculation\n  // NOTE: Bit depth is a guess because I couldn't find it. Same w/ compression ratio\n  // TODO Read resource from Imgur dev https://stackoverflow.com/questions/23920098/how-to-estimate-gif-file-size\n  if (mediaType === 'gif') {\n    // ParseInt to turn it from float to int\n    const seconds = parseInt(durationMs / 1000, 10);\n    return `${parseInt(\n      ((resolution[0] * resolution[1] * 6) / (8 * 1024 * 1024)) * (frameRate * seconds) * 0.8,\n      10\n    )} MB`;\n  }\n  return 'Size estimation unavailable';\n}\n"],"file":"utils.js"}