import { interpolate, linear } from 'popmotion';
export function sanitizeInterpolators(keyframes, interpolators) {
  let _interpolators = interpolators;

  if (typeof interpolators === 'string') {
    _interpolators = [];

    for (let idx = 0; idx < keyframes.length - 1; idx++) {
      _interpolators.push(interpolators);
    }
  }

  if (keyframes.length - 1 !== _interpolators.length) {
    throw new Error('There must be one fewer interpolator than keyframes');
  }

  return _interpolators;
}
export function sanitizeEasings(keyframes, easings) {
  let _easings = easings;

  if (typeof easings === 'function') {
    _easings = [];

    for (let idx = 0; idx < keyframes.length - 1; idx++) {
      _easings.push(easings);
    }
  }

  if (keyframes.length - 1 !== _easings.length) {
    throw new Error('There must be one fewer easing than keyframes');
  }

  return _easings;
}
export function sanitizeTimings(keyframes, timings) {
  let _timings = timings;

  if (typeof timings === 'number') {
    _timings = [];
    let time = 0;

    for (let idx = 0; idx < keyframes.length; idx++) {
      _timings.push(time);

      time += timings;
    }
  }

  if (keyframes.length !== _timings.length) {
    throw new Error('There must be same number of timings as keyframes');
  }

  return _timings;
}
export function merge(timings, keyframes, easings, interpolators) {
  const _keyframes = keyframes.map((keyframe, idx) => {
    if (idx === 0) {
      return [timings[idx], { ...keyframe,
        ease: undefined,
        interpolate: undefined
      }];
    }

    return [timings[idx], { ...keyframe,
      ease: easings[idx - 1],
      interpolate: interpolators[idx - 1]
    }];
  });

  return _keyframes;
}
export function factorInterpolator(start, end) {
  let ease = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : linear;
  return interpolate([0, 1], [start, end], {
    ease
  });
}
//# sourceMappingURL=utils.js.map