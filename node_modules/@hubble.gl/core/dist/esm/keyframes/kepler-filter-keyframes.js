import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { factorInterpolator } from './utils';
import Keyframes from './keyframes';
import { hold, linear } from './easings';

function getKeyFramesFree(filter) {
  const delta = filter.value[1] - filter.value[0];
  return {
    keyframes: [{
      value: [filter.domain[0], filter.domain[0] + delta]
    }, {
      value: [filter.domain[1] - delta, filter.domain[1]]
    }],
    easings: linear
  };
}

export function timeRangeKeyframes(_ref) {
  let {
    filter,
    timings
  } = _ref;

  if (filter.type !== 'timeRange') {
    throw new Error("filter type must be 'timeRange'.'");
  }

  const duration = timings[1] - timings[0];

  switch (filter.animationWindow) {
    default:
    case 'free':
      {
        return getKeyFramesFree(filter);
      }

    case 'incremental':
      {
        return {
          keyframes: [{
            value: [filter.value[0], filter.value[0] + 1]
          }, {
            value: [filter.value[0], filter.domain[1]]
          }],
          easings: linear
        };
      }

    case 'point':
      {
        return {
          keyframes: [{
            value: filter.domain[0]
          }, {
            value: filter.domain[1]
          }],
          easings: linear
        };
      }

    case 'interval':
      {
        const {
          bins,
          plotType
        } = filter;
        const {
          interval
        } = plotType;

        if (!interval || !bins || Object.keys(bins).length === 0 || !Object.values(bins)[0][interval]) {
          return getKeyFramesFree(filter);
        }

        const intervalBins = Object.values(bins)[0][interval];
        const delta = Math.round(duration / intervalBins.length);
        return {
          timings: intervalBins.map((_, idx) => timings[0] + delta * idx),
          keyframes: intervalBins.map(bin => {
            return {
              value: [bin.x0, bin.x1]
            };
          }),
          easings: hold
        };
      }
  }
}

class KeplerFilterKeyframes extends Keyframes {
  constructor(_ref2) {
    let {
      filter,
      filterIdx,
      timings,
      keyframes,
      easings,
      interpolators,
      getTimeRangeFilterKeyframes = undefined
    } = _ref2;

    if (filter.type === 'input') {
      throw new Error("filter type 'input' is not supported.");
    }

    super(KeplerFilterKeyframes._processParams({
      filter,
      timings,
      keyframes,
      easings,
      interpolators,
      getTimeRangeFilterKeyframes
    }));

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "filterIdx", void 0);

    _defineProperty(this, "getTimeRangeFilterKeyframes", void 0);

    this.id = filter.id;
    this.type = filter.type;
    this.animationWindow = filter.animationWindow;
    this.filterIdx = filterIdx;
    this.getTimeRangeFilterKeyframes = getTimeRangeFilterKeyframes;
  }

  set(_ref3) {
    let {
      filter = undefined,
      filterIdx = undefined,
      timings,
      keyframes,
      easings,
      interpolators
    } = _ref3;

    if (filter && filterIdx) {
      this.id = filter.id;
      this.type = filter.type;
      this.animationWindow = filter.animationWindow;
      this.filterIdx = filterIdx;
    }

    super.set(KeplerFilterKeyframes._processParams({
      filter,
      timings,
      keyframes,
      easings,
      interpolators,
      getTimeRangeFilterKeyframes: this.getTimeRangeFilterKeyframes
    }));
  }

  getFrame() {
    const factor = this.factor;
    const start = this.getStartData();
    const end = this.getEndData();

    if (['select', 'multiSelect', 'polygon'].includes(this.type)) {
      return start.value;
    }

    if (this.type === 'range') {
      return [factorInterpolator(start.value[0], end.value[0], end.ease)(factor), factorInterpolator(start.value[1], end.value[1], end.ease)(factor)];
    }

    if (this.type === 'timeRange') {
      switch (this.animationWindow) {
        case 'free':
        case 'incremental':
          {
            return [factorInterpolator(start.value[0], end.value[0], end.ease)(factor), factorInterpolator(start.value[1], end.value[1], end.ease)(factor)];
          }

        case 'point':
          {
            return factorInterpolator(start.value, end.value, end.ease)(factor);
          }

        case 'interval':
        default:
          {
            return start.value;
          }
      }
    }

    return super.getFrame();
  }

  static _processParams(_ref4) {
    let {
      filter = undefined,
      timings,
      keyframes,
      easings,
      interpolators,
      getTimeRangeFilterKeyframes = undefined
    } = _ref4;
    let params = {
      features: ['value'],
      timings,
      keyframes,
      easings,
      interpolators
    };

    if (filter && filter.type === 'timeRange' && keyframes === undefined) {
      if (timings.length !== 2) throw new Error('[start, end] timings required.');
      params = { ...params,
        ...(getTimeRangeFilterKeyframes ? getTimeRangeFilterKeyframes({
          filter,
          timings
        }) : timeRangeKeyframes({
          filter,
          timings
        }))
      };
    }

    return params;
  }

}

export default KeplerFilterKeyframes;
//# sourceMappingURL=kepler-filter-keyframes.js.map