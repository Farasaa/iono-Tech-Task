"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _encoders = require("../encoders");

var _scene = require("../scene");

var _videoCapture = require("../capture/video-capture");

var DeckAdapter = function () {
  function DeckAdapter(sceneBuilder) {
    var glContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    (0, _classCallCheck2["default"])(this, DeckAdapter);
    (0, _defineProperty2["default"])(this, "scene", void 0);
    (0, _defineProperty2["default"])(this, "sceneBuilder", void 0);
    (0, _defineProperty2["default"])(this, "shouldAnimate", void 0);
    (0, _defineProperty2["default"])(this, "enabled", void 0);
    (0, _defineProperty2["default"])(this, "glContext", void 0);
    this.sceneBuilder = sceneBuilder;
    this.glContext = glContext;
    this.videoCapture = new _videoCapture.VideoCapture();
    this.shouldAnimate = true;
    this.enabled = false;
    this.getProps = this.getProps.bind(this);
    this.render = this.render.bind(this);
    this.stop = this.stop.bind(this);
    this._deckOnLoad = this._deckOnLoad.bind(this);
    this._getViewState = this._getViewState.bind(this);
    this._getLayers = this._getLayers.bind(this);
    this._applyScene = this._applyScene.bind(this);
  }

  (0, _createClass2["default"])(DeckAdapter, [{
    key: "getProps",
    value: function getProps(deckRef, setReady) {
      var _this = this;

      var onNextFrame = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var props = {
        onLoad: function onLoad() {
          return _this._deckOnLoad(deckRef.current.deck).then(function () {
            setReady(true);
          });
        },
        _animate: this.shouldAnimate
      };

      if (onNextFrame) {
        props.onAfterRender = function () {
          return _this.onAfterRender(onNextFrame);
        };
      }

      if (this.scene && this.scene.keyframes.camera && this.enabled) {
        props.controller = false;
        props.viewState = this._getViewState();
      }

      if (this.scene && this.scene.hasLayers()) {
        props.layers = this._getLayers();
      }

      if (this.scene) {
        props.width = this.scene.width;
        props.height = this.scene.height;
      }

      if (this.glContext) {
        props.gl = this.glContext;
      }

      return props;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var Encoder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _encoders.PreviewEncoder;
      var encoderSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var onStop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var updateCamera = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;

      if (updateCamera) {
        this.scene.animationLoop.timeline.detachAnimation(this.scene.currentCamera);
        this.scene.keyframes.camera = updateCamera(this.scene.keyframes.camera);
        this.scene.currentCamera = this.scene.animationLoop.timeline.attachAnimation(this.scene.keyframes.camera);
      }

      var innerOnStop = function innerOnStop() {
        _this2.enabled = false;

        if (onStop) {
          onStop();
        }
      };

      this.shouldAnimate = true;
      this.videoCapture.render(Encoder, encoderSettings, this.scene.lengthMs, innerOnStop);
      this.scene.animationLoop.timeline.setTime(this.videoCapture.encoderSettings.startOffsetMs);
      this.enabled = true;
    }
  }, {
    key: "stop",
    value: function stop(callback) {
      this.enabled = false;
      this.shouldAnimate = false;
      this.videoCapture.stop(callback);
    }
  }, {
    key: "_deckOnLoad",
    value: function () {
      var _deckOnLoad2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(deck) {
        var _this3 = this;

        var animationLoop;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.deck = deck;
                animationLoop = deck.animationLoop;
                animationLoop.timeline.pause();
                animationLoop.timeline.setTime(0);
                _context.next = 6;
                return Promise.resolve(this.sceneBuilder(animationLoop)).then(function (scene) {
                  _this3._applyScene(scene);
                });

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _deckOnLoad(_x) {
        return _deckOnLoad2.apply(this, arguments);
      }

      return _deckOnLoad;
    }()
  }, {
    key: "_applyScene",
    value: function _applyScene(scene) {
      this.scene = scene;
    }
  }, {
    key: "_getViewState",
    value: function _getViewState() {
      if (!this.scene) {
        return null;
      }

      var frame = this.scene.keyframes.camera.getFrame();
      return frame;
    }
  }, {
    key: "_getLayers",
    value: function _getLayers() {
      if (!this.scene) {
        return [];
      }

      return this.scene.renderLayers();
    }
  }, {
    key: "onAfterRender",
    value: function onAfterRender(proceedToNextFrame) {
      var _this4 = this;

      this.videoCapture.capture(this.deck.canvas, function (nextTimeMs) {
        _this4.scene.animationLoop.timeline.setTime(nextTimeMs);

        proceedToNextFrame(nextTimeMs);
      });
    }
  }]);
  return DeckAdapter;
}();

exports["default"] = DeckAdapter;
//# sourceMappingURL=deck-adapter.js.map