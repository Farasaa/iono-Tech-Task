import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { PreviewEncoder } from '../encoders';
import { DeckScene } from '../scene';
import { VideoCapture } from '../capture/video-capture';

var DeckAdapter = function () {
  function DeckAdapter(sceneBuilder) {
    var glContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

    _classCallCheck(this, DeckAdapter);

    _defineProperty(this, "scene", void 0);

    _defineProperty(this, "sceneBuilder", void 0);

    _defineProperty(this, "shouldAnimate", void 0);

    _defineProperty(this, "enabled", void 0);

    _defineProperty(this, "glContext", void 0);

    this.sceneBuilder = sceneBuilder;
    this.glContext = glContext;
    this.videoCapture = new VideoCapture();
    this.shouldAnimate = true;
    this.enabled = false;
    this.getProps = this.getProps.bind(this);
    this.render = this.render.bind(this);
    this.stop = this.stop.bind(this);
    this._deckOnLoad = this._deckOnLoad.bind(this);
    this._getViewState = this._getViewState.bind(this);
    this._getLayers = this._getLayers.bind(this);
    this._applyScene = this._applyScene.bind(this);
  }

  _createClass(DeckAdapter, [{
    key: "getProps",
    value: function getProps(deckRef, setReady) {
      var _this = this;

      var onNextFrame = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var props = {
        onLoad: function onLoad() {
          return _this._deckOnLoad(deckRef.current.deck).then(function () {
            setReady(true);
          });
        },
        _animate: this.shouldAnimate
      };

      if (onNextFrame) {
        props.onAfterRender = function () {
          return _this.onAfterRender(onNextFrame);
        };
      }

      if (this.scene && this.scene.keyframes.camera && this.enabled) {
        props.controller = false;
        props.viewState = this._getViewState();
      }

      if (this.scene && this.scene.hasLayers()) {
        props.layers = this._getLayers();
      }

      if (this.scene) {
        props.width = this.scene.width;
        props.height = this.scene.height;
      }

      if (this.glContext) {
        props.gl = this.glContext;
      }

      return props;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var Encoder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PreviewEncoder;
      var encoderSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var onStop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var updateCamera = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;

      if (updateCamera) {
        this.scene.animationLoop.timeline.detachAnimation(this.scene.currentCamera);
        this.scene.keyframes.camera = updateCamera(this.scene.keyframes.camera);
        this.scene.currentCamera = this.scene.animationLoop.timeline.attachAnimation(this.scene.keyframes.camera);
      }

      var innerOnStop = function innerOnStop() {
        _this2.enabled = false;

        if (onStop) {
          onStop();
        }
      };

      this.shouldAnimate = true;
      this.videoCapture.render(Encoder, encoderSettings, this.scene.lengthMs, innerOnStop);
      this.scene.animationLoop.timeline.setTime(this.videoCapture.encoderSettings.startOffsetMs);
      this.enabled = true;
    }
  }, {
    key: "stop",
    value: function stop(callback) {
      this.enabled = false;
      this.shouldAnimate = false;
      this.videoCapture.stop(callback);
    }
  }, {
    key: "_deckOnLoad",
    value: function () {
      var _deckOnLoad2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(deck) {
        var _this3 = this;

        var animationLoop;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.deck = deck;
                animationLoop = deck.animationLoop;
                animationLoop.timeline.pause();
                animationLoop.timeline.setTime(0);
                _context.next = 6;
                return Promise.resolve(this.sceneBuilder(animationLoop)).then(function (scene) {
                  _this3._applyScene(scene);
                });

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _deckOnLoad(_x) {
        return _deckOnLoad2.apply(this, arguments);
      }

      return _deckOnLoad;
    }()
  }, {
    key: "_applyScene",
    value: function _applyScene(scene) {
      this.scene = scene;
    }
  }, {
    key: "_getViewState",
    value: function _getViewState() {
      if (!this.scene) {
        return null;
      }

      var frame = this.scene.keyframes.camera.getFrame();
      return frame;
    }
  }, {
    key: "_getLayers",
    value: function _getLayers() {
      if (!this.scene) {
        return [];
      }

      return this.scene.renderLayers();
    }
  }, {
    key: "onAfterRender",
    value: function onAfterRender(proceedToNextFrame) {
      var _this4 = this;

      this.videoCapture.capture(this.deck.canvas, function (nextTimeMs) {
        _this4.scene.animationLoop.timeline.setTime(nextTimeMs);

        proceedToNextFrame(nextTimeMs);
      });
    }
  }]);

  return DeckAdapter;
}();

export { DeckAdapter as default };
//# sourceMappingURL=deck-adapter.js.map