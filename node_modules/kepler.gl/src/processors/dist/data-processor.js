"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processCsvData = processCsvData;
exports.parseRowsByFields = parseRowsByFields;
exports.parseCsvRowsByFieldType = parseCsvRowsByFieldType;
exports.processRowObject = processRowObject;
exports.processGeojson = processGeojson;
exports.processKeplerglJSON = processKeplerglJSON;
exports.processKeplerglDataset = processKeplerglDataset;
exports.processArrowTable = processArrowTable;
exports.processArrowBatches = processArrowBatches;
exports.Processors = exports.DATASET_HANDLERS = exports.PARSE_FIELD_VALUE_FROM_STRING = exports.CSV_NULLS = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var arrow = _interopRequireWildcard(require("apache-arrow"));

var _d3Dsv = require("d3-dsv");

var _typeAnalyzer = require("type-analyzer");

var _geojsonNormalize = _interopRequireDefault(require("@mapbox/geojson-normalize"));

var _constants = require("@kepler.gl/constants");

var _utils = require("@kepler.gl/utils");

var _schemas = require("@kepler.gl/schemas");

var _PARSE_FIELD_VALUE_FR, _DATASET_HANDLERS;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// if any of these value occurs in csv, parse it to null;
// const CSV_NULLS = ['', 'null', 'NULL', 'Null', 'NaN', '/N'];
// matches empty string
var CSV_NULLS = /^(null|NULL|Null|NaN|\/N||)$/;
exports.CSV_NULLS = CSV_NULLS;

function tryParseJsonString(str) {
  try {
    return JSON.parse(str);
  } catch (e) {
    return null;
  }
}

var PARSE_FIELD_VALUE_FROM_STRING = (_PARSE_FIELD_VALUE_FR = {}, (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _constants.ALL_FIELD_TYPES["boolean"], {
  valid: function valid(d) {
    return typeof d === 'boolean';
  },
  parse: function parse(d) {
    return d === 'true' || d === 'True' || d === 'TRUE' || d === '1';
  }
}), (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _constants.ALL_FIELD_TYPES.integer, {
  // @ts-ignore
  valid: function valid(d) {
    return parseInt(d, 10) === d;
  },
  // @ts-ignore
  parse: function parse(d) {
    return parseInt(d, 10);
  }
}), (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _constants.ALL_FIELD_TYPES.timestamp, {
  valid: function valid(d, field) {
    return ['x', 'X'].includes(field.format) ? typeof d === 'number' : typeof d === 'string';
  },
  parse: function parse(d, field) {
    return ['x', 'X'].includes(field.format) ? Number(d) : d;
  }
}), (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _constants.ALL_FIELD_TYPES.real, {
  // @ts-ignore
  valid: function valid(d) {
    return parseFloat(d) === d;
  },
  // Note this will result in NaN for some string
  parse: parseFloat
}), (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _constants.ALL_FIELD_TYPES.object, {
  valid: _utils.isPlainObject,
  parse: tryParseJsonString
}), (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _constants.ALL_FIELD_TYPES.array, {
  valid: Array.isArray,
  parse: tryParseJsonString
}), _PARSE_FIELD_VALUE_FR);
/**
 * Process csv data, output a data object with `{fields: [], rows: []}`.
 * The data object can be wrapped in a `dataset` and pass to [`addDataToMap`](../actions/actions.md#adddatatomap)
 * @param rawData raw csv string
 * @returns data object `{fields: [], rows: []}` can be passed to addDataToMaps
 * @public
 * @example
 * import {processCsvData} from 'kepler.gl/processors';
 *
 * const testData = `gps_data.utc_timestamp,gps_data.lat,gps_data.lng,gps_data.types,epoch,has_result,id,time,begintrip_ts_utc,begintrip_ts_local,date
 * 2016-09-17 00:09:55,29.9900937,31.2590542,driver_analytics,1472688000000,False,1,2016-09-23T00:00:00.000Z,2016-10-01 09:41:39+00:00,2016-10-01 09:41:39+00:00,2016-09-23
 * 2016-09-17 00:10:56,29.9927699,31.2461142,driver_analytics,1472688000000,False,2,2016-09-23T00:00:00.000Z,2016-10-01 09:46:37+00:00,2016-10-01 16:46:37+00:00,2016-09-23
 * 2016-09-17 00:11:56,29.9907261,31.2312742,driver_analytics,1472688000000,False,3,2016-09-23T00:00:00.000Z,,,2016-09-23
 * 2016-09-17 00:12:58,29.9870074,31.2175827,driver_analytics,1472688000000,False,4,2016-09-23T00:00:00.000Z,,,2016-09-23`
 *
 * const dataset = {
 *  info: {id: 'test_data', label: 'My Csv'},
 *  data: processCsvData(testData)
 * };
 *
 * dispatch(addDataToMap({
 *  datasets: [dataset],
 *  options: {centerMap: true, readOnly: true}
 * }));
 */

exports.PARSE_FIELD_VALUE_FROM_STRING = PARSE_FIELD_VALUE_FROM_STRING;

function processCsvData(rawData, header) {
  var rows;
  var headerRow;

  if (typeof rawData === 'string') {
    var _parsedRows = (0, _d3Dsv.csvParseRows)(rawData);

    if (!Array.isArray(_parsedRows) || _parsedRows.length < 2) {
      // looks like an empty file, throw error to be catch
      throw new Error('process Csv Data Failed: CSV is empty');
    }

    headerRow = _parsedRows[0];
    rows = _parsedRows.slice(1);
  } else if (Array.isArray(rawData) && rawData.length) {
    rows = rawData;
    headerRow = header;

    if (!Array.isArray(headerRow)) {
      // if data is passed in as array of rows and missing header
      // assume first row is header
      // @ts-ignore
      headerRow = rawData[0];
      rows = rawData.slice(1);
    }
  }

  if (!rows || !headerRow) {
    throw new Error('invalid input passed to processCsvData');
  } // here we assume the csv file that people uploaded will have first row
  // as name of the column


  cleanUpFalsyCsvValue(rows); // No need to run type detection on every data point
  // here we get a list of none null values to run analyze on

  var sample = (0, _utils.getSampleForTypeAnalyze)({
    fields: headerRow,
    rows: rows
  });
  var fields = (0, _utils.getFieldsFromData)(sample, headerRow);
  var parsedRows = parseRowsByFields(rows, fields);
  return {
    fields: fields,
    rows: parsedRows
  };
}
/**
 * Parse rows of csv by analyzed field types. So that `'1'` -> `1`, `'True'` -> `true`
 * @param rows
 * @param fields
 */


function parseRowsByFields(rows, fields) {
  // Edit rows in place
  var geojsonFieldIdx = fields.findIndex(function (f) {
    return f.name === '_geojson';
  });
  fields.forEach(parseCsvRowsByFieldType.bind(null, rows, geojsonFieldIdx));
  return rows;
}
/**
 * Convert falsy value in csv including `'', 'null', 'NULL', 'Null', 'NaN'` to `null`,
 * so that type-analyzer won't detect it as string
 *
 * @param rows
 */


function cleanUpFalsyCsvValue(rows) {
  var re = new RegExp(CSV_NULLS, 'g');

  for (var i = 0; i < rows.length; i++) {
    for (var j = 0; j < rows[i].length; j++) {
      // analyzer will set any fields to 'string' if there are empty values
      // which will be parsed as '' by d3.csv
      // here we parse empty data as null
      // TODO: create warning when deltect `CSV_NULLS` in the data
      if (typeof rows[i][j] === 'string' && rows[i][j].match(re)) {
        rows[i][j] = null;
      }
    }
  }
}
/**
 * Process uploaded csv file to parse value by field type
 *
 * @param rows
 * @param geoFieldIdx field index
 * @param field
 * @param i
 */


function parseCsvRowsByFieldType(rows, geoFieldIdx, field, i) {
  var parser = PARSE_FIELD_VALUE_FROM_STRING[field.type];

  if (parser) {
    // check first not null value of it's already parsed
    var first = rows.find(function (r) {
      return (0, _utils.notNullorUndefined)(r[i]);
    });

    if (!first || parser.valid(first[i], field)) {
      return;
    }

    rows.forEach(function (row) {
      // parse string value based on field type
      if (row[i] !== null) {
        row[i] = parser.parse(row[i], field);

        if (geoFieldIdx > -1 && (0, _utils.isPlainObject)(row[geoFieldIdx]) && // @ts-ignore
        (0, _utils.hasOwnProperty)(row[geoFieldIdx], 'properties')) {
          // @ts-ignore
          row[geoFieldIdx].properties[field.name] = row[i];
        }
      }
    });
  }
}
/* eslint-enable complexity */

/**
 * Process data where each row is an object, output can be passed to [`addDataToMap`](../actions/actions.md#adddatatomap)
 * NOTE: This function may mutate input.
 * @param rawData an array of row object, each object should have the same number of keys
 * @returns dataset containing `fields` and `rows`
 * @public
 * @example
 * import {addDataToMap} from 'kepler.gl/actions';
 * import {processRowObject} from 'kepler.gl/processors';
 *
 * const data = [
 *  {lat: 31.27, lng: 127.56, value: 3},
 *  {lat: 31.22, lng: 126.26, value: 1}
 * ];
 *
 * dispatch(addDataToMap({
 *  datasets: {
 *    info: {label: 'My Data', id: 'my_data'},
 *    data: processRowObject(data)
 *  }
 * }));
 */


function processRowObject(rawData) {
  if (!Array.isArray(rawData)) {
    return null;
  } else if (!rawData.length) {
    // data is empty
    return {
      fields: [],
      rows: []
    };
  }

  var keys = Object.keys(rawData[0]); // [lat, lng, value]

  var rows = rawData.map(function (d) {
    return keys.map(function (key) {
      return d[key];
    });
  }); // [[31.27, 127.56, 3]]
  // row object an still contain values like `Null` or `N/A`

  cleanUpFalsyCsvValue(rows);
  return processCsvData(rows, keys);
}
/**
 * Process GeoJSON [`FeatureCollection`](http://wiki.geojson.org/GeoJSON_draft_version_6#FeatureCollection),
 * output a data object with `{fields: [], rows: []}`.
 * The data object can be wrapped in a `dataset` and passed to [`addDataToMap`](../actions/actions.md#adddatatomap)
 * NOTE: This function may mutate input.
 *
 * @param rawData raw geojson feature collection
 * @returns dataset containing `fields` and `rows`
 * @public
 * @example
 * import {addDataToMap} from 'kepler.gl/actions';
 * import {processGeojson} from 'kepler.gl/processors';
 *
 * const geojson = {
 * 	"type" : "FeatureCollection",
 * 	"features" : [{
 * 		"type" : "Feature",
 * 		"properties" : {
 * 			"capacity" : "10",
 * 			"type" : "U-Rack"
 * 		},
 * 		"geometry" : {
 * 			"type" : "Point",
 * 			"coordinates" : [ -71.073283, 42.417500 ]
 * 		}
 * 	}]
 * };
 *
 * dispatch(addDataToMap({
 *  datasets: {
 *    info: {
 *      label: 'Sample Taxi Trips in New York City',
 *      id: 'test_trip_data'
 *    },
 *    data: processGeojson(geojson)
 *  }
 * }));
 */


function processGeojson(rawData) {
  var normalizedGeojson = (0, _geojsonNormalize["default"])(rawData);

  if (!normalizedGeojson || !Array.isArray(normalizedGeojson.features)) {
    var error = new Error("Read File Failed: File is not a valid GeoJSON. Read more about [supported file format](".concat(_constants.GUIDES_FILE_FORMAT_DOC, ")"));
    throw error; // fail to normalize geojson
  } // getting all feature fields


  var allDataRows = [];

  for (var i = 0; i < normalizedGeojson.features.length; i++) {
    var f = normalizedGeojson.features[i];

    if (f.geometry) {
      allDataRows.push(_objectSpread({
        // add feature to _geojson field
        _geojson: f
      }, f.properties || {}));
    }
  } // get all the field


  var fields = allDataRows.reduce(function (accu, curr) {
    Object.keys(curr).forEach(function (key) {
      if (!accu.includes(key)) {
        accu.push(key);
      }
    });
    return accu;
  }, []); // make sure each feature has exact same fields

  allDataRows.forEach(function (d) {
    fields.forEach(function (f) {
      if (!(f in d)) {
        d[f] = null;

        if (d._geojson.properties) {
          d._geojson.properties[f] = null;
        }
      }
    });
  });
  return processRowObject(allDataRows);
}
/**
 * Process saved kepler.gl json to be pass to [`addDataToMap`](../actions/actions.md#adddatatomap).
 * The json object should contain `datasets` and `config`.
 * @param rawData
 * @param schema
 * @returns datasets and config `{datasets: {}, config: {}}`
 * @public
 * @example
 * import {addDataToMap} from 'kepler.gl/actions';
 * import {processKeplerglJSON} from 'kepler.gl/processors';
 *
 * dispatch(addDataToMap(processKeplerglJSON(keplerGlJson)));
 */


function processKeplerglJSON(rawData) {
  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _schemas.KeplerGlSchema;
  return rawData ? schema.load(rawData.datasets, rawData.config) : null;
}
/**
 * Parse a single or an array of datasets saved using kepler.gl schema
 * @param rawData
 * @param schema
 */


function processKeplerglDataset(rawData) {
  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _schemas.KeplerGlSchema;

  if (!rawData) {
    return null;
  }

  var results = schema.parseSavedData((0, _utils.toArray)(rawData));

  if (!results) {
    return null;
  }

  return Array.isArray(rawData) ? results : results[0];
}
/**
 * Parse arrow table and return a dataset
 *
 * @param arrowTable ArrowTable to parse, see loaders.gl/schema
 * @returns dataset containing `fields` and `rows` or null
 */


function processArrowTable(arrowTable) {
  return processArrowBatches(arrowTable.data.batches);
}
/**
 * Parse arrow batches returned from parseInBatches()
 *
 * @param arrowTable the arrow table to parse
 * @returns dataset containing `fields` and `rows` or null
 */


function processArrowBatches(arrowBatches) {
  if (arrowBatches.length === 0) {
    return null;
  }

  var arrowTable = new arrow.Table(arrowBatches);
  var fields = []; // parse fields

  arrowTable.schema.fields.forEach(function (field, index) {
    var _field$metadata$get;

    var isGeometryColumn = (_field$metadata$get = field.metadata.get('ARROW:extension:name')) === null || _field$metadata$get === void 0 ? void 0 : _field$metadata$get.startsWith('geoarrow');
    fields.push({
      name: field.name,
      id: field.name,
      displayName: field.name,
      format: '',
      fieldIdx: index,
      type: isGeometryColumn ? _constants.ALL_FIELD_TYPES.geoarrow : (0, _utils.arrowDataTypeToFieldType)(field.type),
      analyzerType: isGeometryColumn ? _typeAnalyzer.DATA_TYPES.GEOMETRY : (0, _utils.arrowDataTypeToAnalyzerDataType)(field.type),
      valueAccessor: function valueAccessor(dc) {
        return function (d) {
          return dc.valueAt(d.index, index);
        };
      },
      metadata: field.metadata
    });
  });
  var cols = (0, _toConsumableArray2["default"])(Array(arrowTable.numCols).keys()).map(function (i) {
    return arrowTable.getChildAt(i);
  }); // return empty rows and use raw arrow table to construct column-wise data container

  return {
    fields: fields,
    rows: [],
    cols: cols,
    metadata: arrowTable.schema.metadata
  };
}

var DATASET_HANDLERS = (_DATASET_HANDLERS = {}, (0, _defineProperty2["default"])(_DATASET_HANDLERS, _constants.DATASET_FORMATS.row, processRowObject), (0, _defineProperty2["default"])(_DATASET_HANDLERS, _constants.DATASET_FORMATS.geojson, processGeojson), (0, _defineProperty2["default"])(_DATASET_HANDLERS, _constants.DATASET_FORMATS.csv, processCsvData), (0, _defineProperty2["default"])(_DATASET_HANDLERS, _constants.DATASET_FORMATS.arrow, processArrowTable), (0, _defineProperty2["default"])(_DATASET_HANDLERS, _constants.DATASET_FORMATS.keplergl, processKeplerglDataset), _DATASET_HANDLERS);
exports.DATASET_HANDLERS = DATASET_HANDLERS;
var Processors = {
  processGeojson: processGeojson,
  processCsvData: processCsvData,
  processArrowTable: processArrowTable,
  processArrowBatches: processArrowBatches,
  processRowObject: processRowObject,
  processKeplerglJSON: processKeplerglJSON,
  processKeplerglDataset: processKeplerglDataset,
  analyzerTypeToFieldType: _utils.analyzerTypeToFieldType,
  getFieldsFromData: _utils.getFieldsFromData,
  parseCsvRowsByFieldType: parseCsvRowsByFieldType
};
exports.Processors = Processors;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kYXRhLXByb2Nlc3Nvci50cyJdLCJuYW1lcyI6WyJDU1ZfTlVMTFMiLCJ0cnlQYXJzZUpzb25TdHJpbmciLCJzdHIiLCJKU09OIiwicGFyc2UiLCJlIiwiUEFSU0VfRklFTERfVkFMVUVfRlJPTV9TVFJJTkciLCJBTExfRklFTERfVFlQRVMiLCJ2YWxpZCIsImQiLCJpbnRlZ2VyIiwicGFyc2VJbnQiLCJ0aW1lc3RhbXAiLCJmaWVsZCIsImluY2x1ZGVzIiwiZm9ybWF0IiwiTnVtYmVyIiwicmVhbCIsInBhcnNlRmxvYXQiLCJvYmplY3QiLCJpc1BsYWluT2JqZWN0IiwiYXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJwcm9jZXNzQ3N2RGF0YSIsInJhd0RhdGEiLCJoZWFkZXIiLCJyb3dzIiwiaGVhZGVyUm93IiwicGFyc2VkUm93cyIsImxlbmd0aCIsIkVycm9yIiwic2xpY2UiLCJjbGVhblVwRmFsc3lDc3ZWYWx1ZSIsInNhbXBsZSIsImZpZWxkcyIsInBhcnNlUm93c0J5RmllbGRzIiwiZ2VvanNvbkZpZWxkSWR4IiwiZmluZEluZGV4IiwiZiIsIm5hbWUiLCJmb3JFYWNoIiwicGFyc2VDc3ZSb3dzQnlGaWVsZFR5cGUiLCJiaW5kIiwicmUiLCJSZWdFeHAiLCJpIiwiaiIsIm1hdGNoIiwiZ2VvRmllbGRJZHgiLCJwYXJzZXIiLCJ0eXBlIiwiZmlyc3QiLCJmaW5kIiwiciIsInJvdyIsInByb3BlcnRpZXMiLCJwcm9jZXNzUm93T2JqZWN0Iiwia2V5cyIsIk9iamVjdCIsIm1hcCIsImtleSIsInByb2Nlc3NHZW9qc29uIiwibm9ybWFsaXplZEdlb2pzb24iLCJmZWF0dXJlcyIsImVycm9yIiwiR1VJREVTX0ZJTEVfRk9STUFUX0RPQyIsImFsbERhdGFSb3dzIiwiZ2VvbWV0cnkiLCJwdXNoIiwiX2dlb2pzb24iLCJyZWR1Y2UiLCJhY2N1IiwiY3VyciIsInByb2Nlc3NLZXBsZXJnbEpTT04iLCJzY2hlbWEiLCJLZXBsZXJHbFNjaGVtYSIsImxvYWQiLCJkYXRhc2V0cyIsImNvbmZpZyIsInByb2Nlc3NLZXBsZXJnbERhdGFzZXQiLCJyZXN1bHRzIiwicGFyc2VTYXZlZERhdGEiLCJwcm9jZXNzQXJyb3dUYWJsZSIsImFycm93VGFibGUiLCJwcm9jZXNzQXJyb3dCYXRjaGVzIiwiZGF0YSIsImJhdGNoZXMiLCJhcnJvd0JhdGNoZXMiLCJhcnJvdyIsIlRhYmxlIiwiaW5kZXgiLCJpc0dlb21ldHJ5Q29sdW1uIiwibWV0YWRhdGEiLCJnZXQiLCJzdGFydHNXaXRoIiwiaWQiLCJkaXNwbGF5TmFtZSIsImZpZWxkSWR4IiwiZ2VvYXJyb3ciLCJhbmFseXplclR5cGUiLCJBbmFseXplckRBVEFfVFlQRVMiLCJHRU9NRVRSWSIsInZhbHVlQWNjZXNzb3IiLCJkYyIsInZhbHVlQXQiLCJjb2xzIiwibnVtQ29scyIsImdldENoaWxkQXQiLCJEQVRBU0VUX0hBTkRMRVJTIiwiREFUQVNFVF9GT1JNQVRTIiwiZ2VvanNvbiIsImNzdiIsImtlcGxlcmdsIiwiUHJvY2Vzc29ycyIsImFuYWx5emVyVHlwZVRvRmllbGRUeXBlIiwiZ2V0RmllbGRzRnJvbURhdGEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUVBOztBQVdBOzs7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUNPLElBQU1BLFNBQVMsR0FBRyw4QkFBbEI7OztBQUVQLFNBQVNDLGtCQUFULENBQTRCQyxHQUE1QixFQUFpQztBQUMvQixNQUFJO0FBQ0YsV0FBT0MsSUFBSSxDQUFDQyxLQUFMLENBQVdGLEdBQVgsQ0FBUDtBQUNELEdBRkQsQ0FFRSxPQUFPRyxDQUFQLEVBQVU7QUFDVixXQUFPLElBQVA7QUFDRDtBQUNGOztBQUVNLElBQU1DLDZCQUE2Qix3RkFDdkNDLHFDQUR1QyxFQUNiO0FBQ3pCQyxFQUFBQSxLQUFLLEVBQUUsZUFBQ0MsQ0FBRDtBQUFBLFdBQXlCLE9BQU9BLENBQVAsS0FBYSxTQUF0QztBQUFBLEdB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QUFuQkEsbUJBTkU7QUFPRk0sRUFBQUEsc0JBQXNCLEVBQXRCQSxzQkFQRTtBQVFGbUMsRUFBQUEsdUJBQXVCLEVBQXZCQSw4QkFSRTtBQVNGQyxFQUFBQSxpQkFBaUIsRUFBakJBLHdCQVRFO0FBVUYxRSxFQUFBQSx1QkFBdUIsRUFBdkJBO0FBVkUsQ0FYRyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XG5pbXBvcnQge2NzdlBhcnNlUm93c30gZnJvbSAnZDMtZHN2JztcbmltcG9ydCB7REFUQV9UWVBFUyBhcyBBbmFseXplckRBVEFfVFlQRVN9IGZyb20gJ3R5cGUtYW5hbHl6ZXInO1xuaW1wb3J0IG5vcm1hbGl6ZSBmcm9tICdAbWFwYm94L2dlb2pzb24tbm9ybWFsaXplJztcbmltcG9ydCB7QXJyb3dUYWJsZX0gZnJvbSAnQGxvYWRlcnMuZ2wvc2NoZW1hJztcbmltcG9ydCB7QUxMX0ZJRUxEX1RZUEVTLCBEQVRBU0VUX0ZPUk1BVFMsIEdVSURFU19GSUxFX0ZPUk1BVF9ET0N9IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7UHJvY2Vzc29yUmVzdWx0LCBGaWVsZH0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge1xuICBhcnJvd0RhdGFUeXBlVG9BbmFseXplckRhdGFUeXBlLFxuICBhcnJvd0RhdGFUeXBlVG9GaWVsZFR5cGUsXG4gIG5vdE51bGxvclVuZGVmaW5lZCxcbiAgaGFzT3duUHJvcGVydHksXG4gIGlzUGxhaW5PYmplY3QsXG4gIGFuYWx5emVyVHlwZVRvRmllbGRUeXBlLFxuICBnZXRTYW1wbGVGb3JUeXBlQW5hbHl6ZSxcbiAgZ2V0RmllbGRzRnJvbURhdGEsXG4gIHRvQXJyYXlcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQge0tlcGxlckdsU2NoZW1hLCBQYXJzZWREYXRhc2V0LCBTYXZlZE1hcCwgTG9hZGVkTWFwfSBmcm9tICdAa2VwbGVyLmdsL3NjaGVtYXMnO1xuaW1wb3J0IHtGZWF0dXJlfSBmcm9tICdAbmVidWxhLmdsL2VkaXQtbW9kZXMnO1xuXG4vLyBpZiBhbnkgb2YgdGhlc2UgdmFsdWUgb2NjdXJzIGluIGNzdiwgcGFyc2UgaXQgdG8gbnVsbDtcbi8vIGNvbnN0IENTVl9OVUxMUyA9IFsnJywgJ251bGwnLCAnTlVMTCcsICdOdWxsJywgJ05hTicsICcvTiddO1xuLy8gbWF0Y2hlcyBlbXB0eSBzdHJpbmdcbmV4cG9ydCBjb25zdCBDU1ZfTlVMTFMgPSAvXihudWxsfE5VTEx8TnVsbHxOYU58XFwvTnx8KSQvO1xuXG5mdW5jdGlvbiB0cnlQYXJzZUpzb25TdHJpbmcoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBQQVJTRV9GSUVMRF9WQUxVRV9GUk9NX1NUUklORyA9IHtcbiAgW0FMTF9GSUVMRF9UWVBFUy5ib29sZWFuXToge1xuICAgIHZhbGlkOiAoZDogdW5rbm93bik6IGJvb2xlYW4gPT4gdHlwZW9mIGQgPT09ICdib29sZWFuJyxcbiAgICBwYXJzZTogKGQ6IHVua25vd24pOiBib29sZWFuID0+IGQgPT09ICd0cnVlJyB8fCBkID09PSAnVHJ1ZScgfHwgZCA9PT0gJ1RSVUUnIHx8IGQgPT09ICcxJ1xuICB9LFxuICBbQUxMX0ZJRUxEX1RZUEVTLmludGVnZXJdOiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhbGlkOiAoZDogdW5rbm93bik6IGJvb2xlYW4gPT4gcGFyc2VJbnQoZCwgMTApID09PSBkLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwYXJzZTogKGQ6IHVua25vd24pOiBudW1iZXIgPT4gcGFyc2VJbnQoZCwgMTApXG4gIH0sXG4gIFtBTExfRklFTERfVFlQRVMudGltZXN0YW1wXToge1xuICAgIHZhbGlkOiAoZDogdW5rbm93biwgZmllbGQ6IEZpZWxkKTogYm9vbGVhbiA9PlxuICAgICAgWyd4JywgJ1gnXS5pbmNsdWRlcyhmaWVsZC5mb3JtYXQpID8gdHlwZW9mIGQgPT09ICdudW1iZXInIDogdHlwZW9mIGQgPT09ICdzdHJpbmcnLFxuICAgIHBhcnNlOiAoZDogYW55LCBmaWVsZDogRmllbGQpID0+IChbJ3gnLCAnWCddLmluY2x1ZGVzKGZpZWxkLmZvcm1hdCkgPyBOdW1iZXIoZCkgOiBkKVxuICB9LFxuICBbQUxMX0ZJRUxEX1RZUEVTLnJlYWxdOiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhbGlkOiAoZDogdW5rbm93bik6IGJvb2xlYW4gPT4gcGFyc2VGbG9hdChkKSA9PT0gZCxcbiAgICAvLyBOb3RlIHRoaXMgd2lsbCByZXN1bHQgaW4gTmFOIGZvciBzb21lIHN0cmluZ1xuICAgIHBhcnNlOiBwYXJzZUZsb2F0XG4gIH0sXG4gIFtBTExfRklFTERfVFlQRVMub2JqZWN0XToge1xuICAgIHZhbGlkOiBpc1BsYWluT2JqZWN0LFxuICAgIHBhcnNlOiB0cnlQYXJzZUpzb25TdHJpbmdcbiAgfSxcblxuICBbQUxMX0ZJRUxEX1RZUEVTLmFycmF5XToge1xuICAgIHZhbGlkOiBBcnJheS5pc0FycmF5LFxuICAgIHBhcnNlOiB0cnlQYXJzZUpzb25TdHJpbmdcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9jZXNzIGNzdiBkYXRhLCBvdXRwdXQgYSBkYXRhIG9iamVjdCB3aXRoIGB7ZmllbGRzOiBbXSwgcm93czogW119YC5cbiAqIFRoZSBkYXRhIG9iamVjdCBjYW4gYmUgd3JhcHBlZCBpbiBhIGBkYXRhc2V0YCBhbmQgcGFzcyB0byBbYGFkZERhdGFUb01hcGBdKC4uL2FjdGlvbnMvYWN0aW9ucy5tZCNhZGRkYXRhdG9tYXApXG4gKiBAcGFyYW0gcmF3RGF0YSByYXcgY3N2IHN0cmluZ1xuICogQHJldHVybnMgZGF0YSBvYmplY3QgYHtmaWVsZHM6IFtdLCByb3dzOiBbXX1gIGNhbiBiZSBwYXNzZWQgdG8gYWRkRGF0YVRvTWFwc1xuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7cHJvY2Vzc0NzdkRhdGF9IGZyb20gJ2tlcGxlci5nbC9wcm9jZXNzb3JzJztcbiAqXG4gKiBjb25zdCB0ZXN0RGF0YSA9IGBncHNfZGF0YS51dGNfdGltZXN0YW1wLGdwc19kYXRhLmxhdCxncHNfZGF0YS5sbmcsZ3BzX2RhdGEudHlwZXMsZXBvY2gsaGFzX3Jlc3VsdCxpZCx0aW1lLGJlZ2ludHJpcF90c191dGMsYmVnaW50cmlwX3RzX2xvY2FsLGRhdGVcbiAqIDIwMTYtMDktMTcgMDA6MDk6NTUsMjkuOTkwMDkzNywzMS4yNTkwNTQyLGRyaXZlcl9hbmFseXRpY3MsMTQ3MjY4ODAwMDAwMCxGYWxzZSwxLDIwMTYtMDktMjNUMDA6MDA6MDAuMDAwWiwyMDE2LTEwLTAxIDA5OjQxOjM5KzAwOjAwLDIwMTYtMTAtMDEgMDk6NDE6MzkrMDA6MDAsMjAxNi0wOS0yM1xuICogMjAxNi0wOS0xNyAwMDoxMDo1NiwyOS45OTI3Njk5LDMxLjI0NjExNDIsZHJpdmVyX2FuYWx5dGljcywxNDcyNjg4MDAwMDAwLEZhbHNlLDIsMjAxNi0wOS0yM1QwMDowMDowMC4wMDBaLDIwMTYtMTAtMDEgMDk6NDY6MzcrMDA6MDAsMjAxNi0xMC0wMSAxNjo0NjozNyswMDowMCwyMDE2LTA5LTIzXG4gKiAyMDE2LTA5LTE3IDAwOjExOjU2LDI5Ljk5MDcyNjEsMzEuMjMxMjc0Mixkcml2ZXJfYW5hbHl0aWNzLDE0NzI2ODgwMDAwMDAsRmFsc2UsMywyMDE2LTA5LTIzVDAwOjAwOjAwLjAwMFosLCwyMDE2LTA5LTIzXG4gKiAyMDE2LTA5LTE3IDAwOjEyOjU4LDI5Ljk4NzAwNzQsMzEuMjE3NTgyNyxkcml2ZXJfYW5hbHl0aWNzLDE0NzI2ODgwMDAwMDAsRmFsc2UsNCwyMDE2LTA5LTIzVDAwOjAwOjAwLjAwMFosLCwyMDE2LTA5LTIzYFxuICpcbiAqIGNvbnN0IGRhdGFzZXQgPSB7XG4gKiAgaW5mbzoge2lkOiAndGVzdF9kYXRhJywgbGFiZWw6ICdNeSBDc3YnfSxcbiAqICBkYXRhOiBwcm9jZXNzQ3N2RGF0YSh0ZXN0RGF0YSlcbiAqIH07XG4gKlxuICogZGlzcGF0Y2goYWRkRGF0YVRvTWFwKHtcbiAqICBkYXRhc2V0czogW2RhdGFzZXRdLFxuICogIG9wdGlvbnM6IHtjZW50ZXJNYXA6IHRydWUsIHJlYWRPbmx5OiB0cnVlfVxuICogfSkpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0NzdkRhdGEocmF3RGF0YTogdW5rbm93bltdW10gfCBzdHJpbmcsIGhlYWRlcj86IHN0cmluZ1tdKTogUHJvY2Vzc29yUmVzdWx0IHtcbiAgbGV0IHJvd3M6IHVua25vd25bXVtdIHwgdW5kZWZpbmVkO1xuICBsZXQgaGVhZGVyUm93OiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcblxuICBpZiAodHlwZW9mIHJhd0RhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgcGFyc2VkUm93czogc3RyaW5nW11bXSA9IGNzdlBhcnNlUm93cyhyYXdEYXRhKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJzZWRSb3dzKSB8fCBwYXJzZWRSb3dzLmxlbmd0aCA8IDIpIHtcbiAgICAgIC8vIGxvb2tzIGxpa2UgYW4gZW1wdHkgZmlsZSwgdGhyb3cgZXJyb3IgdG8gYmUgY2F0Y2hcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJvY2VzcyBDc3YgRGF0YSBGYWlsZWQ6IENTViBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBoZWFkZXJSb3cgPSBwYXJzZWRSb3dzWzBdO1xuICAgIHJvd3MgPSBwYXJzZWRSb3dzLnNsaWNlKDEpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmF3RGF0YSkgJiYgcmF3RGF0YS5sZW5ndGgpIHtcbiAgICByb3dzID0gcmF3RGF0YTtcbiAgICBoZWFkZXJSb3cgPSBoZWFkZXI7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGVhZGVyUm93KSkge1xuICAgICAgLy8gaWYgZGF0YSBpcyBwYXNzZWQgaW4gYXMgYXJyYXkgb2Ygcm93cyBhbmQgbWlzc2luZyBoZWFkZXJcbiAgICAgIC8vIGFzc3VtZSBmaXJzdCByb3cgaXMgaGVhZGVyXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBoZWFkZXJSb3cgPSByYXdEYXRhWzBdO1xuICAgICAgcm93cyA9IHJhd0RhdGEuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFyb3dzIHx8ICFoZWFkZXJSb3cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgcGFzc2VkIHRvIHByb2Nlc3NDc3ZEYXRhJyk7XG4gIH1cblxuICAvLyBoZXJlIHdlIGFzc3VtZSB0aGUgY3N2IGZpbGUgdGhhdCBwZW9wbGUgdXBsb2FkZWQgd2lsbCBoYXZlIGZpcnN0IHJvd1xuICAvLyBhcyBuYW1lIG9mIHRoZSBjb2x1bW5cblxuICBjbGVhblVwRmFsc3lDc3ZWYWx1ZShyb3dzKTtcbiAgLy8gTm8gbmVlZCB0byBydW4gdHlwZSBkZXRlY3Rpb24gb24gZXZlcnkgZGF0YSBwb2ludFxuICAvLyBoZXJlIHdlIGdldCBhIGxpc3Qgb2Ygbm9uZSBudWxsIHZhbHVlcyB0byBydW4gYW5hbHl6ZSBvblxuICBjb25zdCBzYW1wbGUgPSBnZXRTYW1wbGVGb3JUeXBlQW5hbHl6ZSh7ZmllbGRzOiBoZWFkZXJSb3csIHJvd3N9KTtcbiAgY29uc3QgZmllbGRzID0gZ2V0RmllbGRzRnJvbURhdGEoc2FtcGxlLCBoZWFkZXJSb3cpO1xuICBjb25zdCBwYXJzZWRSb3dzID0gcGFyc2VSb3dzQnlGaWVsZHMocm93cywgZmllbGRzKTtcblxuICByZXR1cm4ge2ZpZWxkcywgcm93czogcGFyc2VkUm93c307XG59XG5cbi8qKlxuICogUGFyc2Ugcm93cyBvZiBjc3YgYnkgYW5hbHl6ZWQgZmllbGQgdHlwZXMuIFNvIHRoYXQgYCcxJ2AgLT4gYDFgLCBgJ1RydWUnYCAtPiBgdHJ1ZWBcbiAqIEBwYXJhbSByb3dzXG4gKiBAcGFyYW0gZmllbGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJvd3NCeUZpZWxkcyhyb3dzOiBhbnlbXVtdLCBmaWVsZHM6IEZpZWxkW10pIHtcbiAgLy8gRWRpdCByb3dzIGluIHBsYWNlXG4gIGNvbnN0IGdlb2pzb25GaWVsZElkeCA9IGZpZWxkcy5maW5kSW5kZXgoZiA9PiBmLm5hbWUgPT09ICdfZ2VvanNvbicpO1xuICBmaWVsZHMuZm9yRWFjaChwYXJzZUNzdlJvd3NCeUZpZWxkVHlwZS5iaW5kKG51bGwsIHJvd3MsIGdlb2pzb25GaWVsZElkeCkpO1xuXG4gIHJldHVybiByb3dzO1xufVxuXG4vKipcbiAqIENvbnZlcnQgZmFsc3kgdmFsdWUgaW4gY3N2IGluY2x1ZGluZyBgJycsICdudWxsJywgJ05VTEwnLCAnTnVsbCcsICdOYU4nYCB0byBgbnVsbGAsXG4gKiBzbyB0aGF0IHR5cGUtYW5hbHl6ZXIgd29uJ3QgZGV0ZWN0IGl0IGFzIHN0cmluZ1xuICpcbiAqIEBwYXJhbSByb3dzXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXBGYWxzeUNzdlZhbHVlKHJvd3M6IHVua25vd25bXVtdKTogdm9pZCB7XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChDU1ZfTlVMTFMsICdnJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgLy8gYW5hbHl6ZXIgd2lsbCBzZXQgYW55IGZpZWxkcyB0byAnc3RyaW5nJyBpZiB0aGVyZSBhcmUgZW1wdHkgdmFsdWVzXG4gICAgICAvLyB3aGljaCB3aWxsIGJlIHBhcnNlZCBhcyAnJyBieSBkMy5jc3ZcbiAgICAgIC8vIGhlcmUgd2UgcGFyc2UgZW1wdHkgZGF0YSBhcyBudWxsXG4gICAgICAvLyBUT0RPOiBjcmVhdGUgd2FybmluZyB3aGVuIGRlbHRlY3QgYENTVl9OVUxMU2AgaW4gdGhlIGRhdGFcbiAgICAgIGlmICh0eXBlb2Ygcm93c1tpXVtqXSA9PT0gJ3N0cmluZycgJiYgKHJvd3NbaV1bal0gYXMgc3RyaW5nKS5tYXRjaChyZSkpIHtcbiAgICAgICAgcm93c1tpXVtqXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHJvY2VzcyB1cGxvYWRlZCBjc3YgZmlsZSB0byBwYXJzZSB2YWx1ZSBieSBmaWVsZCB0eXBlXG4gKlxuICogQHBhcmFtIHJvd3NcbiAqIEBwYXJhbSBnZW9GaWVsZElkeCBmaWVsZCBpbmRleFxuICogQHBhcmFtIGZpZWxkXG4gKiBAcGFyYW0gaVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDc3ZSb3dzQnlGaWVsZFR5cGUoXG4gIHJvd3M6IHVua25vd25bXVtdLFxuICBnZW9GaWVsZElkeDogbnVtYmVyLFxuICBmaWVsZDogRmllbGQsXG4gIGk6IG51bWJlclxuKTogdm9pZCB7XG4gIGNvbnN0IHBhcnNlciA9IFBBUlNFX0ZJRUxEX1ZBTFVFX0ZST01fU1RSSU5HW2ZpZWxkLnR5cGVdO1xuICBpZiAocGFyc2VyKSB7XG4gICAgLy8gY2hlY2sgZmlyc3Qgbm90IG51bGwgdmFsdWUgb2YgaXQncyBhbHJlYWR5IHBhcnNlZFxuICAgIGNvbnN0IGZpcnN0ID0gcm93cy5maW5kKHIgPT4gbm90TnVsbG9yVW5kZWZpbmVkKHJbaV0pKTtcbiAgICBpZiAoIWZpcnN0IHx8IHBhcnNlci52YWxpZChmaXJzdFtpXSwgZmllbGQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgLy8gcGFyc2Ugc3RyaW5nIHZhbHVlIGJhc2VkIG9uIGZpZWxkIHR5cGVcbiAgICAgIGlmIChyb3dbaV0gIT09IG51bGwpIHtcbiAgICAgICAgcm93W2ldID0gcGFyc2VyLnBhcnNlKHJvd1tpXSwgZmllbGQpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZ2VvRmllbGRJZHggPiAtMSAmJlxuICAgICAgICAgIGlzUGxhaW5PYmplY3Qocm93W2dlb0ZpZWxkSWR4XSkgJiZcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgaGFzT3duUHJvcGVydHkocm93W2dlb0ZpZWxkSWR4XSwgJ3Byb3BlcnRpZXMnKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcm93W2dlb0ZpZWxkSWR4XS5wcm9wZXJ0aWVzW2ZpZWxkLm5hbWVdID0gcm93W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbi8qKlxuICogUHJvY2VzcyBkYXRhIHdoZXJlIGVhY2ggcm93IGlzIGFuIG9iamVjdCwgb3V0cHV0IGNhbiBiZSBwYXNzZWQgdG8gW2BhZGREYXRhVG9NYXBgXSguLi9hY3Rpb25zL2FjdGlvbnMubWQjYWRkZGF0YXRvbWFwKVxuICogTk9URTogVGhpcyBmdW5jdGlvbiBtYXkgbXV0YXRlIGlucHV0LlxuICogQHBhcmFtIHJhd0RhdGEgYW4gYXJyYXkgb2Ygcm93IG9iamVjdCwgZWFjaCBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGtleXNcbiAqIEByZXR1cm5zIGRhdGFzZXQgY29udGFpbmluZyBgZmllbGRzYCBhbmQgYHJvd3NgXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHthZGREYXRhVG9NYXB9IGZyb20gJ2tlcGxlci5nbC9hY3Rpb25zJztcbiAqIGltcG9ydCB7cHJvY2Vzc1Jvd09iamVjdH0gZnJvbSAna2VwbGVyLmdsL3Byb2Nlc3NvcnMnO1xuICpcbiAqIGNvbnN0IGRhdGEgPSBbXG4gKiAge2xhdDogMzEuMjcsIGxuZzogMTI3LjU2LCB2YWx1ZTogM30sXG4gKiAge2xhdDogMzEuMjIsIGxuZzogMTI2LjI2LCB2YWx1ZTogMX1cbiAqIF07XG4gKlxuICogZGlzcGF0Y2goYWRkRGF0YVRvTWFwKHtcbiAqICBkYXRhc2V0czoge1xuICogICAgaW5mbzoge2xhYmVsOiAnTXkgRGF0YScsIGlkOiAnbXlfZGF0YSd9LFxuICogICAgZGF0YTogcHJvY2Vzc1Jvd09iamVjdChkYXRhKVxuICogIH1cbiAqIH0pKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NSb3dPYmplY3QocmF3RGF0YTogdW5rbm93bltdKTogUHJvY2Vzc29yUmVzdWx0IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJhd0RhdGEpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIXJhd0RhdGEubGVuZ3RoKSB7XG4gICAgLy8gZGF0YSBpcyBlbXB0eVxuICAgIHJldHVybiB7XG4gICAgICBmaWVsZHM6IFtdLFxuICAgICAgcm93czogW11cbiAgICB9O1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJhd0RhdGFbMF0pOyAvLyBbbGF0LCBsbmcsIHZhbHVlXVxuICBjb25zdCByb3dzID0gcmF3RGF0YS5tYXAoZCA9PiBrZXlzLm1hcChrZXkgPT4gZFtrZXldKSk7IC8vIFtbMzEuMjcsIDEyNy41NiwgM11dXG5cbiAgLy8gcm93IG9iamVjdCBhbiBzdGlsbCBjb250YWluIHZhbHVlcyBsaWtlIGBOdWxsYCBvciBgTi9BYFxuICBjbGVhblVwRmFsc3lDc3ZWYWx1ZShyb3dzKTtcblxuICByZXR1cm4gcHJvY2Vzc0NzdkRhdGEocm93cywga2V5cyk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBHZW9KU09OIFtgRmVhdHVyZUNvbGxlY3Rpb25gXShodHRwOi8vd2lraS5nZW9qc29uLm9yZy9HZW9KU09OX2RyYWZ0X3ZlcnNpb25fNiNGZWF0dXJlQ29sbGVjdGlvbiksXG4gKiBvdXRwdXQgYSBkYXRhIG9iamVjdCB3aXRoIGB7ZmllbGRzOiBbXSwgcm93czogW119YC5cbiAqIFRoZSBkYXRhIG9iamVjdCBjYW4gYmUgd3JhcHBlZCBpbiBhIGBkYXRhc2V0YCBhbmQgcGFzc2VkIHRvIFtgYWRkRGF0YVRvTWFwYF0oLi4vYWN0aW9ucy9hY3Rpb25zLm1kI2FkZGRhdGF0b21hcClcbiAqIE5PVEU6IFRoaXMgZnVuY3Rpb24gbWF5IG11dGF0ZSBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gcmF3RGF0YSByYXcgZ2VvanNvbiBmZWF0dXJlIGNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIGRhdGFzZXQgY29udGFpbmluZyBgZmllbGRzYCBhbmQgYHJvd3NgXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHthZGREYXRhVG9NYXB9IGZyb20gJ2tlcGxlci5nbC9hY3Rpb25zJztcbiAqIGltcG9ydCB7cHJvY2Vzc0dlb2pzb259IGZyb20gJ2tlcGxlci5nbC9wcm9jZXNzb3JzJztcbiAqXG4gKiBjb25zdCBnZW9qc29uID0ge1xuICogXHRcInR5cGVcIiA6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqIFx0XCJmZWF0dXJlc1wiIDogW3tcbiAqIFx0XHRcInR5cGVcIiA6IFwiRmVhdHVyZVwiLFxuICogXHRcdFwicHJvcGVydGllc1wiIDoge1xuICogXHRcdFx0XCJjYXBhY2l0eVwiIDogXCIxMFwiLFxuICogXHRcdFx0XCJ0eXBlXCIgOiBcIlUtUmFja1wiXG4gKiBcdFx0fSxcbiAqIFx0XHRcImdlb21ldHJ5XCIgOiB7XG4gKiBcdFx0XHRcInR5cGVcIiA6IFwiUG9pbnRcIixcbiAqIFx0XHRcdFwiY29vcmRpbmF0ZXNcIiA6IFsgLTcxLjA3MzI4MywgNDIuNDE3NTAwIF1cbiAqIFx0XHR9XG4gKiBcdH1dXG4gKiB9O1xuICpcbiAqIGRpc3BhdGNoKGFkZERhdGFUb01hcCh7XG4gKiAgZGF0YXNldHM6IHtcbiAqICAgIGluZm86IHtcbiAqICAgICAgbGFiZWw6ICdTYW1wbGUgVGF4aSBUcmlwcyBpbiBOZXcgWW9yayBDaXR5JyxcbiAqICAgICAgaWQ6ICd0ZXN0X3RyaXBfZGF0YSdcbiAqICAgIH0sXG4gKiAgICBkYXRhOiBwcm9jZXNzR2VvanNvbihnZW9qc29uKVxuICogIH1cbiAqIH0pKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NHZW9qc29uKHJhd0RhdGE6IHVua25vd24pOiBQcm9jZXNzb3JSZXN1bHQge1xuICBjb25zdCBub3JtYWxpemVkR2VvanNvbiA9IG5vcm1hbGl6ZShyYXdEYXRhKTtcblxuICBpZiAoIW5vcm1hbGl6ZWRHZW9qc29uIHx8ICFBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRHZW9qc29uLmZlYXR1cmVzKSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgYFJlYWQgRmlsZSBGYWlsZWQ6IEZpbGUgaXMgbm90IGEgdmFsaWQgR2VvSlNPTi4gUmVhZCBtb3JlIGFib3V0IFtzdXBwb3J0ZWQgZmlsZSBmb3JtYXRdKCR7R1VJREVTX0ZJTEVfRk9STUFUX0RPQ30pYFxuICAgICk7XG4gICAgdGhyb3cgZXJyb3I7XG4gICAgLy8gZmFpbCB0byBub3JtYWxpemUgZ2VvanNvblxuICB9XG5cbiAgLy8gZ2V0dGluZyBhbGwgZmVhdHVyZSBmaWVsZHNcbiAgY29uc3QgYWxsRGF0YVJvd3M6IEFycmF5PHtfZ2VvanNvbjogRmVhdHVyZX0gJiBrZXlvZiBGZWF0dXJlPiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vcm1hbGl6ZWRHZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZiA9IG5vcm1hbGl6ZWRHZW9qc29uLmZlYXR1cmVzW2ldO1xuICAgIGlmIChmLmdlb21ldHJ5KSB7XG4gICAgICBhbGxEYXRhUm93cy5wdXNoKHtcbiAgICAgICAgLy8gYWRkIGZlYXR1cmUgdG8gX2dlb2pzb24gZmllbGRcbiAgICAgICAgX2dlb2pzb246IGYsXG4gICAgICAgIC4uLihmLnByb3BlcnRpZXMgfHwge30pXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy8gZ2V0IGFsbCB0aGUgZmllbGRcbiAgY29uc3QgZmllbGRzID0gYWxsRGF0YVJvd3MucmVkdWNlPHN0cmluZ1tdPigoYWNjdSwgY3VycikgPT4ge1xuICAgIE9iamVjdC5rZXlzKGN1cnIpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICghYWNjdS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGFjY3UucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhY2N1O1xuICB9LCBbXSk7XG5cbiAgLy8gbWFrZSBzdXJlIGVhY2ggZmVhdHVyZSBoYXMgZXhhY3Qgc2FtZSBmaWVsZHNcbiAgYWxsRGF0YVJvd3MuZm9yRWFjaChkID0+IHtcbiAgICBmaWVsZHMuZm9yRWFjaChmID0+IHtcbiAgICAgIGlmICghKGYgaW4gZCkpIHtcbiAgICAgICAgZFtmXSA9IG51bGw7XG4gICAgICAgIGlmIChkLl9nZW9qc29uLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICBkLl9nZW9qc29uLnByb3BlcnRpZXNbZl0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBwcm9jZXNzUm93T2JqZWN0KGFsbERhdGFSb3dzKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHNhdmVkIGtlcGxlci5nbCBqc29uIHRvIGJlIHBhc3MgdG8gW2BhZGREYXRhVG9NYXBgXSguLi9hY3Rpb25zL2FjdGlvbnMubWQjYWRkZGF0YXRvbWFwKS5cbiAqIFRoZSBqc29uIG9iamVjdCBzaG91bGQgY29udGFpbiBgZGF0YXNldHNgIGFuZCBgY29uZmlnYC5cbiAqIEBwYXJhbSByYXdEYXRhXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJucyBkYXRhc2V0cyBhbmQgY29uZmlnIGB7ZGF0YXNldHM6IHt9LCBjb25maWc6IHt9fWBcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQge2FkZERhdGFUb01hcH0gZnJvbSAna2VwbGVyLmdsL2FjdGlvbnMnO1xuICogaW1wb3J0IHtwcm9jZXNzS2VwbGVyZ2xKU09OfSBmcm9tICdrZXBsZXIuZ2wvcHJvY2Vzc29ycyc7XG4gKlxuICogZGlzcGF0Y2goYWRkRGF0YVRvTWFwKHByb2Nlc3NLZXBsZXJnbEpTT04oa2VwbGVyR2xKc29uKSkpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0tlcGxlcmdsSlNPTihyYXdEYXRhOiBTYXZlZE1hcCwgc2NoZW1hID0gS2VwbGVyR2xTY2hlbWEpOiBMb2FkZWRNYXAgfCBudWxsIHtcbiAgcmV0dXJuIHJhd0RhdGEgPyBzY2hlbWEubG9hZChyYXdEYXRhLmRhdGFzZXRzLCByYXdEYXRhLmNvbmZpZykgOiBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIG9yIGFuIGFycmF5IG9mIGRhdGFzZXRzIHNhdmVkIHVzaW5nIGtlcGxlci5nbCBzY2hlbWFcbiAqIEBwYXJhbSByYXdEYXRhXG4gKiBAcGFyYW0gc2NoZW1hXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzS2VwbGVyZ2xEYXRhc2V0KFxuICByYXdEYXRhOiBvYmplY3QgfCBvYmplY3RbXSxcbiAgc2NoZW1hID0gS2VwbGVyR2xTY2hlbWFcbik6IFBhcnNlZERhdGFzZXQgfCBQYXJzZWREYXRhc2V0W10gfCBudWxsIHtcbiAgaWYgKCFyYXdEYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCByZXN1bHRzID0gc2NoZW1hLnBhcnNlU2F2ZWREYXRhKHRvQXJyYXkocmF3RGF0YSkpO1xuICBpZiAoIXJlc3VsdHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gQXJyYXkuaXNBcnJheShyYXdEYXRhKSA/IHJlc3VsdHMgOiByZXN1bHRzWzBdO1xufVxuXG4vKipcbiAqIFBhcnNlIGFycm93IHRhYmxlIGFuZCByZXR1cm4gYSBkYXRhc2V0XG4gKlxuICogQHBhcmFtIGFycm93VGFibGUgQXJyb3dUYWJsZSB0byBwYXJzZSwgc2VlIGxvYWRlcnMuZ2wvc2NoZW1hXG4gKiBAcmV0dXJucyBkYXRhc2V0IGNvbnRhaW5pbmcgYGZpZWxkc2AgYW5kIGByb3dzYCBvciBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzQXJyb3dUYWJsZShhcnJvd1RhYmxlOiBBcnJvd1RhYmxlKTogUHJvY2Vzc29yUmVzdWx0IHwgbnVsbCB7XG4gIHJldHVybiBwcm9jZXNzQXJyb3dCYXRjaGVzKGFycm93VGFibGUuZGF0YS5iYXRjaGVzKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhcnJvdyBiYXRjaGVzIHJldHVybmVkIGZyb20gcGFyc2VJbkJhdGNoZXMoKVxuICpcbiAqIEBwYXJhbSBhcnJvd1RhYmxlIHRoZSBhcnJvdyB0YWJsZSB0byBwYXJzZVxuICogQHJldHVybnMgZGF0YXNldCBjb250YWluaW5nIGBmaWVsZHNgIGFuZCBgcm93c2Agb3IgbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0Fycm93QmF0Y2hlcyhhcnJvd0JhdGNoZXM6IGFycm93LlJlY29yZEJhdGNoW10pOiBQcm9jZXNzb3JSZXN1bHQgfCBudWxsIHtcbiAgaWYgKGFycm93QmF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhcnJvd1RhYmxlID0gbmV3IGFycm93LlRhYmxlKGFycm93QmF0Y2hlcyk7XG4gIGNvbnN0IGZpZWxkczogRmllbGRbXSA9IFtdO1xuXG4gIC8vIHBhcnNlIGZpZWxkc1xuICBhcnJvd1RhYmxlLnNjaGVtYS5maWVsZHMuZm9yRWFjaCgoZmllbGQ6IGFycm93LkZpZWxkLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgaXNHZW9tZXRyeUNvbHVtbiA9IGZpZWxkLm1ldGFkYXRhLmdldCgnQVJST1c6ZXh0ZW5zaW9uOm5hbWUnKT8uc3RhcnRzV2l0aCgnZ2VvYXJyb3cnKTtcbiAgICBmaWVsZHMucHVzaCh7XG4gICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgaWQ6IGZpZWxkLm5hbWUsXG4gICAgICBkaXNwbGF5TmFtZTogZmllbGQubmFtZSxcbiAgICAgIGZvcm1hdDogJycsXG4gICAgICBmaWVsZElkeDogaW5kZXgsXG4gICAgICB0eXBlOiBpc0dlb21ldHJ5Q29sdW1uID8gQUxMX0ZJRUxEX1RZUEVTLmdlb2Fycm93IDogYXJyb3dEYXRhVHlwZVRvRmllbGRUeXBlKGZpZWxkLnR5cGUpLFxuICAgICAgYW5hbHl6ZXJUeXBlOiBpc0dlb21ldHJ5Q29sdW1uXG4gICAgICAgID8gQW5hbHl6ZXJEQVRBX1RZUEVTLkdFT01FVFJZXG4gICAgICAgIDogYXJyb3dEYXRhVHlwZVRvQW5hbHl6ZXJEYXRhVHlwZShmaWVsZC50eXBlKSxcbiAgICAgIHZhbHVlQWNjZXNzb3I6IChkYzogYW55KSA9PiBkID0+IHtcbiAgICAgICAgcmV0dXJuIGRjLnZhbHVlQXQoZC5pbmRleCwgaW5kZXgpO1xuICAgICAgfSxcbiAgICAgIG1ldGFkYXRhOiBmaWVsZC5tZXRhZGF0YVxuICAgIH0pO1xuICB9KTtcblxuICBjb25zdCBjb2xzID0gWy4uLkFycmF5KGFycm93VGFibGUubnVtQ29scykua2V5cygpXS5tYXAoaSA9PiBhcnJvd1RhYmxlLmdldENoaWxkQXQoaSkpO1xuICAvLyByZXR1cm4gZW1wdHkgcm93cyBhbmQgdXNlIHJhdyBhcnJvdyB0YWJsZSB0byBjb25zdHJ1Y3QgY29sdW1uLXdpc2UgZGF0YSBjb250YWluZXJcbiAgcmV0dXJuIHtmaWVsZHMsIHJvd3M6IFtdLCBjb2xzLCBtZXRhZGF0YTogYXJyb3dUYWJsZS5zY2hlbWEubWV0YWRhdGF9O1xufVxuXG5leHBvcnQgY29uc3QgREFUQVNFVF9IQU5ETEVSUyA9IHtcbiAgW0RBVEFTRVRfRk9STUFUUy5yb3ddOiBwcm9jZXNzUm93T2JqZWN0LFxuICBbREFUQVNFVF9GT1JNQVRTLmdlb2pzb25dOiBwcm9jZXNzR2VvanNvbixcbiAgW0RBVEFTRVRfRk9STUFUUy5jc3ZdOiBwcm9jZXNzQ3N2RGF0YSxcbiAgW0RBVEFTRVRfRk9STUFUUy5hcnJvd106IHByb2Nlc3NBcnJvd1RhYmxlLFxuICBbREFUQVNFVF9GT1JNQVRTLmtlcGxlcmdsXTogcHJvY2Vzc0tlcGxlcmdsRGF0YXNldFxufTtcblxuZXhwb3J0IGNvbnN0IFByb2Nlc3NvcnM6IHtcbiAgcHJvY2Vzc0dlb2pzb246IHR5cGVvZiBwcm9jZXNzR2VvanNvbjtcbiAgcHJvY2Vzc0NzdkRhdGE6IHR5cGVvZiBwcm9jZXNzQ3N2RGF0YTtcbiAgcHJvY2Vzc0Fycm93VGFibGU6IHR5cGVvZiBwcm9jZXNzQXJyb3dUYWJsZTtcbiAgcHJvY2Vzc0Fycm93QmF0Y2hlczogdHlwZW9mIHByb2Nlc3NBcnJvd0JhdGNoZXM7XG4gIHByb2Nlc3NSb3dPYmplY3Q6IHR5cGVvZiBwcm9jZXNzUm93T2JqZWN0O1xuICBwcm9jZXNzS2VwbGVyZ2xKU09OOiB0eXBlb2YgcHJvY2Vzc0tlcGxlcmdsSlNPTjtcbiAgcHJvY2Vzc0tlcGxlcmdsRGF0YXNldDogdHlwZW9mIHByb2Nlc3NLZXBsZXJnbERhdGFzZXQ7XG4gIGFuYWx5emVyVHlwZVRvRmllbGRUeXBlOiB0eXBlb2YgYW5hbHl6ZXJUeXBlVG9GaWVsZFR5cGU7XG4gIGdldEZpZWxkc0Zyb21EYXRhOiB0eXBlb2YgZ2V0RmllbGRzRnJvbURhdGE7XG4gIHBhcnNlQ3N2Um93c0J5RmllbGRUeXBlOiB0eXBlb2YgcGFyc2VDc3ZSb3dzQnlGaWVsZFR5cGU7XG59ID0ge1xuICBwcm9jZXNzR2VvanNvbixcbiAgcHJvY2Vzc0NzdkRhdGEsXG4gIHByb2Nlc3NBcnJvd1RhYmxlLFxuICBwcm9jZXNzQXJyb3dCYXRjaGVzLFxuICBwcm9jZXNzUm93T2JqZWN0LFxuICBwcm9jZXNzS2VwbGVyZ2xKU09OLFxuICBwcm9jZXNzS2VwbGVyZ2xEYXRhc2V0LFxuICBhbmFseXplclR5cGVUb0ZpZWxkVHlwZSxcbiAgZ2V0RmllbGRzRnJvbURhdGEsXG4gIHBhcnNlQ3N2Um93c0J5RmllbGRUeXBlXG59O1xuIl19