"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setFilterGpuMode = setFilterGpuMode;
exports.assignGpuChannels = assignGpuChannels;
exports.assignGpuChannel = assignGpuChannel;
exports.resetFilterGpuMode = resetFilterGpuMode;
exports.getGpuFilterProps = getGpuFilterProps;
exports.getDatasetFieldIndexForFilter = getDatasetFieldIndexForFilter;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _moment = _interopRequireDefault(require("moment"));

var _constants = require("@kepler.gl/constants");

var _utils = require("@kepler.gl/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Set gpu mode based on current number of gpu filters exists
 */
function setFilterGpuMode(filter, filters) {
  // filter can be applied to multiple datasets, hence gpu filter mode should also be
  // an array, however, to keep us sane, for now, we only check if there is available channel for every dataId,
  // if all of them has, we set gpu mode to true
  // TODO: refactor filter so we don't keep an array of everything
  filter.dataId.forEach(function (dataId, datasetIdx) {
    var gpuFilters = filters.filter(function (f) {
      return f.dataId.includes(dataId) && f.gpu;
    });

    if (filter.gpu && gpuFilters.length === _constants.MAX_GPU_FILTERS) {
      (0, _utils.set)(['gpu'], false, filter);
    }
  });
  return filter;
}
/**
 * Scan though all filters and assign gpu chanel to gpu filter
 */


function assignGpuChannels(allFilters) {
  return allFilters.reduce(function (accu, f, index) {
    var filters = accu; // if gpu is true assign and validate gpu Channel

    if (f.gpu) {
      f = assignGpuChannel(f, accu);
      filters = (0, _utils.set)([index], f, accu);
    }

    return filters;
  }, allFilters);
}
/**
 * Assign a new gpu filter a channel based on first availability
 */


function assignGpuChannel(filter, filters) {
  // find first available channel
  if (!filter.gpu) {
    return filter;
  }

  var gpuChannel = filter.gpuChannel || [];
  filter.dataId.forEach(function (dataId, datasetIdx) {
    var findGpuChannel = function findGpuChannel(channel) {
      return function (f) {
        var dataIdx = (0, _utils.toArray)(f.dataId).indexOf(dataId);
        return f.id !== filter.id && dataIdx > -1 && f.gpu && (0, _utils.toArray)(f.gpuChannel)[dataIdx] === channel;
      };
    };

    if (Number.isFinite(gpuChannel[datasetIdx]) && !filters.find(findGpuChannel(gpuChannel[datasetIdx]))) {
      // if value is already assigned and valid
      return;
    }

    var i = 0;

    while (i < _constants.MAX_GPU_FILTERS) {
      if (!filters.find(findGpuChannel(i))) {
        gpuChannel[datasetIdx] = i;
        return;
      }

      i++;
    }
  }); // if cannot find channel for all dataid, set gpu back to false
  // TODO: refactor filter to handle same filter different gpu mode

  if (!gpuChannel.length || !gpuChannel.every(Number.isFinite)) {
    return _objectSpread(_objectSpread({}, filter), {}, {
      gpu: false
    });
  }

  return _objectSpread(_objectSpread({}, filter), {}, {
    gpuChannel: gpuChannel
  });
}
/**
 * Edit filter.gpu to ensure that only
 * X number of gpu filers can coexist.
 */


function resetFilterGpuMode(filters) {
  var gpuPerDataset = {};
  return filters.map(function (f, i) {
    if (f.gpu) {
      var gpu = true;
      (0, _utils.toArray)(f.dataId).forEach(function (dataId) {
        var count = gpuPerDataset[dataId];

        if (count === _constants.MAX_GPU_FILTERS) {
          gpu = false;
        } else {
          gpuPerDataset[dataId] = count ? count + 1 : 1;
        }
      });

      if (!gpu) {
        return (0, _utils.set)(['gpu'], false, f);
      }
    }

    return f;
  });
}
/**
 * Initial filter uniform
 */


function getEmptyFilterRange() {
  return new Array(_constants.MAX_GPU_FILTERS).fill(0).map(function (d) {
    return [0, 0];
  });
}
/**
 * Returns index of the data element.
 * @param {any} d Data element with row index info.
 * @returns number
 */


var defaultGetIndex = function defaultGetIndex(d) {
  return d.index;
};
/**
 * Returns value at the specified row from the data container.
 * @param dc Data container.
 * @param d Data element with row index info.
 * @param fieldIndex Column index in the data container.
 * @returns
 */


var defaultGetData = function defaultGetData(dc, d, fieldIndex) {
  return dc.valueAt(d.index, fieldIndex);
};
/**
 * @param channels
 * @param dataId
 * @param fields
 * @return {Function} getFilterValue
 */


var getFilterValueAccessor = function getFilterValueAccessor(channels, dataId, fields) {
  return function (dc) {
    return function () {
      var getIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetIndex;
      var getData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetData;
      return function (d) {
        return (// for empty channel, value is 0 and min max would be [0, 0]
          channels.map(function (filter) {
            var _filter$domain;

            if (!filter) {
              return 0;
            }

            var fieldIndex = getDatasetFieldIndexForFilter(dataId, filter);
            var field = fields[fieldIndex];
            var value = filter.type === _constants.FILTER_TYPES.timeRange ? field.filterProps && Array.isArray(field.filterProps.mappedValue) ? field.filterProps.mappedValue[getIndex(d)] : _moment["default"].utc(getData(dc, d, fieldIndex)).valueOf() : getData(dc, d, fieldIndex);
            return (0, _utils.notNullorUndefined)(value) ? value - ((_filter$domain = filter.domain) === null || _filter$domain === void 0 ? void 0 : _filter$domain[0]) : Number.MIN_SAFE_INTEGER;
          })
        );
      };
    };
  };
};
/**
 * Get filter properties for gpu filtering
 */


function getGpuFilterProps(filters, dataId, fields) {
  var filterRange = getEmptyFilterRange();
  var triggers = {}; // array of filter for each channel, undefined, if no filter is assigned to that channel

  var channels = [];

  var _loop = function _loop(i) {
    var _filter$domain2, _filter$domain3;

    var filter = filters.find(function (f) {
      return f.gpu && f.dataId.includes(dataId) && f.gpuChannel && f.gpuChannel[f.dataId.indexOf(dataId)] === i;
    });
    filterRange[i][0] = filter ? filter.value[0] - ((_filter$domain2 = filter.domain) === null || _filter$domain2 === void 0 ? void 0 : _filter$domain2[0]) : 0;
    filterRange[i][1] = filter ? filter.value[1] - ((_filter$domain3 = filter.domain) === null || _filter$domain3 === void 0 ? void 0 : _filter$domain3[0]) : 0;
    triggers["gpuFilter_".concat(i)] = filter ? filter.name[filter.dataId.indexOf(dataId)] : null;
    channels.push(filter);
  };

  for (var i = 0; i < _constants.MAX_GPU_FILTERS; i++) {
    _loop(i);
  }

  var filterValueAccessor = getFilterValueAccessor(channels, dataId, fields);
  return {
    filterRange: filterRange,
    filterValueUpdateTriggers: triggers,
    filterValueAccessor: filterValueAccessor
  };
}
/**
 * Return dataset field index from filter.fieldIdx
 * The index matches the same dataset index for filter.dataId
 */


function getDatasetFieldIndexForFilter(dataId, filter) {
  var datasetIndex = (0, _utils.toArray)(filter.dataId).indexOf(dataId);

  if (datasetIndex < 0) {
    return -1;
  }

  var fieldIndex = filter.fieldIdx[datasetIndex];
  return (0, _utils.notNullorUndefined)(fieldIndex) ? fieldIndex : -1;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ncHUtZmlsdGVyLXV0aWxzLnRzIl0sIm5hbWVzIjpbInNldEZpbHRlckdwdU1vZGUiLCJmaWx0ZXIiLCJmaWx0ZXJzIiwiZGF0YUlkIiwiZm9yRWFjaCIsImRhdGFzZXRJZHgiLCJncHVGaWx0ZXJzIiwiZiIsImluY2x1ZGVzIiwiZ3B1IiwibGVuZ3RoIiwiTUFYX0dQVV9GSUxURVJTIiwiYXNzaWduR3B1Q2hhbm5lbHMiLCJhbGxGaWx0ZXJzIiwicmVkdWNlIiwiYWNjdSIsImluZGV4IiwiYXNzaWduR3B1Q2hhbm5lbCIsImdwdUNoYW5uZWwiLCJmaW5kR3B1Q2hhbm5lbCIsImNoYW5uZWwiLCJkYXRhSWR4IiwiaW5kZXhPZiIsImlkIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJmaW5kIiwiaSIsImV2ZXJ5IiwicmVzZXRGaWx0ZXJHcHVNb2RlIiwiZ3B1UGVyRGF0YXNldCIsIm1hcCIsImNvdW50IiwiZ2V0RW1wdHlGaWx0ZXJSYW5nZSIsIkFycmF5IiwiZmlsbCIsImQiLCJkZWZhdWx0R2V0SW5kZXgiLCJkZWZhdWx0R2V0RGF0YSIsImRjIiwiZmllbGRJbmRleCIsInZhbHVlQXQiLCJnZXRGaWx0ZXJWYWx1ZUFjY2Vzc29yIiwiY2hhbm5lbHMiLCJmaWVsZHMiLCJnZXRJbmRleCIsImdldERhdGEiLCJnZXREYXRhc2V0RmllbGRJbmRleEZvckZpbHRlciIsImZpZWxkIiwidmFsdWUiLCJ0eXBlIiwiRklMVEVSX1RZUEVTIiwidGltZVJhbmdlIiwiZmlsdGVyUHJvcHMiLCJpc0FycmF5IiwibWFwcGVkVmFsdWUiLCJtb21lbnQiLCJ1dGMiLCJ2YWx1ZU9mIiwiZG9tYWluIiwiTUlOX1NBRkVfSU5URUdFUiIsImdldEdwdUZpbHRlclByb3BzIiwiZmlsdGVyUmFuZ2UiLCJ0cmlnZ2VycyIsIm5hbWUiLCJwdXNoIiwiZmlsdGVyVmFsdWVBY2Nlc3NvciIsImZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnMiLCJkYXRhc2V0SW5kZXgiLCJmaWVsZElk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V0FBVyxFQUFYQSxXQURLO0FBRUxLLElBQUFBLHlCQUF5QixFQUFFSixRQUZ0QjtBQUdMRyxJQUFBQSxtQkFBbUIsRUFBbkJBO0FBSEssR0FBUDtBQUtEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVNuQiw2QkFBVCxDQUF1QzVDLE1BQXZDLEVBQXVERixNQUF2RCxFQUErRTtBQUNwRixNQUFNbUUsWUFBWSxHQUFHLG9CQUFRbkUsTUFBTSxDQUFDRSxNQUFmLEVBQXVCbUIsT0FBdkIsQ0FBK0JuQixNQUEvQixDQUFyQjs7QUFDQSxNQUFJaUUsWUFBWSxHQUFHLENBQW5CLEVBQXNCO0FBQ3BCLFdBQU8sQ0FBQyxDQUFSO0FBQ0Q7O0FBRUQsTUFBTTVCLFVBQVUsR0FBR3ZDLE1BQU0sQ0FBQ29FLFFBQVAsQ0FBZ0JELFlBQWhCLENBQW5CO0FBRUEsU0FBTywrQkFBbUI1QixVQUFuQixJQUFpQ0EsVUFBakMsR0FBOEMsQ0FBQyxDQUF0RDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHtNQVhfR1BVX0ZJTFRFUlMsIEZJTFRFUl9UWVBFU30gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtGaWVsZCwgRmlsdGVyfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcblxuaW1wb3J0IHtzZXQsIHRvQXJyYXksIG5vdE51bGxvclVuZGVmaW5lZCwgRGF0YUNvbnRhaW5lckludGVyZmFjZX0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQge0dwdUZpbHRlcn0gZnJvbSAnLi9rZXBsZXItdGFibGUnO1xuXG4vKipcbiAqIFNldCBncHUgbW9kZSBiYXNlZCBvbiBjdXJyZW50IG51bWJlciBvZiBncHUgZmlsdGVycyBleGlzdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZpbHRlckdwdU1vZGUoZmlsdGVyOiBGaWx0ZXIsIGZpbHRlcnM6IEZpbHRlcltdKSB7XG4gIC8vIGZpbHRlciBjYW4gYmUgYXBwbGllZCB0byBtdWx0aXBsZSBkYXRhc2V0cywgaGVuY2UgZ3B1IGZpbHRlciBtb2RlIHNob3VsZCBhbHNvIGJlXG4gIC8vIGFuIGFycmF5LCBob3dldmVyLCB0byBrZWVwIHVzIHNhbmUsIGZvciBub3csIHdlIG9ubHkgY2hlY2sgaWYgdGhlcmUgaXMgYXZhaWxhYmxlIGNoYW5uZWwgZm9yIGV2ZXJ5IGRhdGFJZCxcbiAgLy8gaWYgYWxsIG9mIHRoZW0gaGFzLCB3ZSBzZXQgZ3B1IG1vZGUgdG8gdHJ1ZVxuICAvLyBUT0RPOiByZWZhY3RvciBmaWx0ZXIgc28gd2UgZG9uJ3Qga2VlcCBhbiBhcnJheSBvZiBldmVyeXRoaW5nXG5cbiAgZmlsdGVyLmRhdGFJZC5mb3JFYWNoKChkYXRhSWQsIGRhdGFzZXRJZHgpID0+IHtcbiAgICBjb25zdCBncHVGaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoZiA9PiBmLmRhdGFJZC5pbmNsdWRlcyhkYXRhSWQpICYmIGYuZ3B1KTtcblxuICAgIGlmIChmaWx0ZXIuZ3B1ICYmIGdwdUZpbHRlcnMubGVuZ3RoID09PSBNQVhfR1BVX0ZJTFRFUlMpIHtcbiAgICAgIHNldChbJ2dwdSddLCBmYWxzZSwgZmlsdGVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmaWx0ZXI7XG59XG5cbi8qKlxuICogU2NhbiB0aG91Z2ggYWxsIGZpbHRlcnMgYW5kIGFzc2lnbiBncHUgY2hhbmVsIHRvIGdwdSBmaWx0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkdwdUNoYW5uZWxzKGFsbEZpbHRlcnM6IEZpbHRlcltdKSB7XG4gIHJldHVybiBhbGxGaWx0ZXJzLnJlZHVjZSgoYWNjdSwgZiwgaW5kZXgpID0+IHtcbiAgICBsZXQgZmlsdGVycyA9IGFjY3U7XG5cbiAgICAvLyBpZiBncHUgaXMgdHJ1ZSBhc3NpZ24gYW5kIHZhbGlkYXRlIGdwdSBDaGFubmVsXG4gICAgaWYgKGYuZ3B1KSB7XG4gICAgICBmID0gYXNzaWduR3B1Q2hhbm5lbChmLCBhY2N1KTtcbiAgICAgIGZpbHRlcnMgPSBzZXQoW2luZGV4XSwgZiwgYWNjdSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlcnM7XG4gIH0sIGFsbEZpbHRlcnMpO1xufVxuLyoqXG4gKiBBc3NpZ24gYSBuZXcgZ3B1IGZpbHRlciBhIGNoYW5uZWwgYmFzZWQgb24gZmlyc3QgYXZhaWxhYmlsaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25HcHVDaGFubmVsKGZpbHRlcjogRmlsdGVyLCBmaWx0ZXJzOiBGaWx0ZXJbXSkge1xuICAvLyBmaW5kIGZpcnN0IGF2YWlsYWJsZSBjaGFubmVsXG4gIGlmICghZmlsdGVyLmdwdSkge1xuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cblxuICBjb25zdCBncHVDaGFubmVsID0gZmlsdGVyLmdwdUNoYW5uZWwgfHwgW107XG5cbiAgZmlsdGVyLmRhdGFJZC5mb3JFYWNoKChkYXRhSWQsIGRhdGFzZXRJZHgpID0+IHtcbiAgICBjb25zdCBmaW5kR3B1Q2hhbm5lbCA9IGNoYW5uZWwgPT4gZiA9PiB7XG4gICAgICBjb25zdCBkYXRhSWR4ID0gdG9BcnJheShmLmRhdGFJZCkuaW5kZXhPZihkYXRhSWQpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZi5pZCAhPT0gZmlsdGVyLmlkICYmIGRhdGFJZHggPiAtMSAmJiBmLmdwdSAmJiB0b0FycmF5KGYuZ3B1Q2hhbm5lbClbZGF0YUlkeF0gPT09IGNoYW5uZWxcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGlmIChcbiAgICAgIE51bWJlci5pc0Zpbml0ZShncHVDaGFubmVsW2RhdGFzZXRJZHhdKSAmJlxuICAgICAgIWZpbHRlcnMuZmluZChmaW5kR3B1Q2hhbm5lbChncHVDaGFubmVsW2RhdGFzZXRJZHhdKSlcbiAgICApIHtcbiAgICAgIC8vIGlmIHZhbHVlIGlzIGFscmVhZHkgYXNzaWduZWQgYW5kIHZhbGlkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBNQVhfR1BVX0ZJTFRFUlMpIHtcbiAgICAgIGlmICghZmlsdGVycy5maW5kKGZpbmRHcHVDaGFubmVsKGkpKSkge1xuICAgICAgICBncHVDaGFubmVsW2RhdGFzZXRJZHhdID0gaTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gaWYgY2Fubm90IGZpbmQgY2hhbm5lbCBmb3IgYWxsIGRhdGFpZCwgc2V0IGdwdSBiYWNrIHRvIGZhbHNlXG4gIC8vIFRPRE86IHJlZmFjdG9yIGZpbHRlciB0byBoYW5kbGUgc2FtZSBmaWx0ZXIgZGlmZmVyZW50IGdwdSBtb2RlXG4gIGlmICghZ3B1Q2hhbm5lbC5sZW5ndGggfHwgIWdwdUNoYW5uZWwuZXZlcnkoTnVtYmVyLmlzRmluaXRlKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5maWx0ZXIsXG4gICAgICBncHU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uZmlsdGVyLFxuICAgIGdwdUNoYW5uZWxcbiAgfTtcbn1cbi8qKlxuICogRWRpdCBmaWx0ZXIuZ3B1IHRvIGVuc3VyZSB0aGF0IG9ubHlcbiAqIFggbnVtYmVyIG9mIGdwdSBmaWxlcnMgY2FuIGNvZXhpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldEZpbHRlckdwdU1vZGUoZmlsdGVyczogRmlsdGVyW10pOiBGaWx0ZXJbXSB7XG4gIGNvbnN0IGdwdVBlckRhdGFzZXQgPSB7fTtcblxuICByZXR1cm4gZmlsdGVycy5tYXAoKGYsIGkpID0+IHtcbiAgICBpZiAoZi5ncHUpIHtcbiAgICAgIGxldCBncHUgPSB0cnVlO1xuICAgICAgdG9BcnJheShmLmRhdGFJZCkuZm9yRWFjaChkYXRhSWQgPT4ge1xuICAgICAgICBjb25zdCBjb3VudCA9IGdwdVBlckRhdGFzZXRbZGF0YUlkXTtcblxuICAgICAgICBpZiAoY291bnQgPT09IE1BWF9HUFVfRklMVEVSUykge1xuICAgICAgICAgIGdwdSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdwdVBlckRhdGFzZXRbZGF0YUlkXSA9IGNvdW50ID8gY291bnQgKyAxIDogMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghZ3B1KSB7XG4gICAgICAgIHJldHVybiBzZXQoWydncHUnXSwgZmFsc2UsIGYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJbml0aWFsIGZpbHRlciB1bmlmb3JtXG4gKi9cbmZ1bmN0aW9uIGdldEVtcHR5RmlsdGVyUmFuZ2UoKSB7XG4gIHJldHVybiBuZXcgQXJyYXkoTUFYX0dQVV9GSUxURVJTKS5maWxsKDApLm1hcChkID0+IFswLCAwXSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBpbmRleCBvZiB0aGUgZGF0YSBlbGVtZW50LlxuICogQHBhcmFtIHthbnl9IGQgRGF0YSBlbGVtZW50IHdpdGggcm93IGluZGV4IGluZm8uXG4gKiBAcmV0dXJucyBudW1iZXJcbiAqL1xuY29uc3QgZGVmYXVsdEdldEluZGV4ID0gZCA9PiBkLmluZGV4O1xuXG4vKipcbiAqIFJldHVybnMgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCByb3cgZnJvbSB0aGUgZGF0YSBjb250YWluZXIuXG4gKiBAcGFyYW0gZGMgRGF0YSBjb250YWluZXIuXG4gKiBAcGFyYW0gZCBEYXRhIGVsZW1lbnQgd2l0aCByb3cgaW5kZXggaW5mby5cbiAqIEBwYXJhbSBmaWVsZEluZGV4IENvbHVtbiBpbmRleCBpbiB0aGUgZGF0YSBjb250YWluZXIuXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBkZWZhdWx0R2V0RGF0YSA9IChkYzogRGF0YUNvbnRhaW5lckludGVyZmFjZSwgZDogYW55LCBmaWVsZEluZGV4OiBudW1iZXIpID0+IHtcbiAgcmV0dXJuIGRjLnZhbHVlQXQoZC5pbmRleCwgZmllbGRJbmRleCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBjaGFubmVsc1xuICogQHBhcmFtIGRhdGFJZFxuICogQHBhcmFtIGZpZWxkc1xuICogQHJldHVybiB7RnVuY3Rpb259IGdldEZpbHRlclZhbHVlXG4gKi9cbmNvbnN0IGdldEZpbHRlclZhbHVlQWNjZXNzb3IgPSAoXG4gIGNoYW5uZWxzOiAoRmlsdGVyIHwgdW5kZWZpbmVkKVtdLFxuICBkYXRhSWQ6IHN0cmluZyxcbiAgZmllbGRzOiBhbnlbXVxuKSA9PiAoZGM6IERhdGFDb250YWluZXJJbnRlcmZhY2UpID0+IChnZXRJbmRleCA9IGRlZmF1bHRHZXRJbmRleCwgZ2V0RGF0YSA9IGRlZmF1bHRHZXREYXRhKSA9PiBkID0+XG4gIC8vIGZvciBlbXB0eSBjaGFubmVsLCB2YWx1ZSBpcyAwIGFuZCBtaW4gbWF4IHdvdWxkIGJlIFswLCAwXVxuICBjaGFubmVscy5tYXAoZmlsdGVyID0+IHtcbiAgICBpZiAoIWZpbHRlcikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkSW5kZXggPSBnZXREYXRhc2V0RmllbGRJbmRleEZvckZpbHRlcihkYXRhSWQsIGZpbHRlcik7XG4gICAgY29uc3QgZmllbGQgPSBmaWVsZHNbZmllbGRJbmRleF07XG5cbiAgICBjb25zdCB2YWx1ZSA9XG4gICAgICBmaWx0ZXIudHlwZSA9PT0gRklMVEVSX1RZUEVTLnRpbWVSYW5nZVxuICAgICAgICA/IGZpZWxkLmZpbHRlclByb3BzICYmIEFycmF5LmlzQXJyYXkoZmllbGQuZmlsdGVyUHJvcHMubWFwcGVkVmFsdWUpXG4gICAgICAgICAgPyBmaWVsZC5maWx0ZXJQcm9wcy5tYXBwZWRWYWx1ZVtnZXRJbmRleChkKV1cbiAgICAgICAgICA6IG1vbWVudC51dGMoZ2V0RGF0YShkYywgZCwgZmllbGRJbmRleCkpLnZhbHVlT2YoKVxuICAgICAgICA6IGdldERhdGEoZGMsIGQsIGZpZWxkSW5kZXgpO1xuXG4gICAgcmV0dXJuIG5vdE51bGxvclVuZGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSAtIGZpbHRlci5kb21haW4/LlswXSA6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICB9KTtcblxuLyoqXG4gKiBHZXQgZmlsdGVyIHByb3BlcnRpZXMgZm9yIGdwdSBmaWx0ZXJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdwdUZpbHRlclByb3BzKGZpbHRlcnM6IEZpbHRlcltdLCBkYXRhSWQ6IHN0cmluZywgZmllbGRzOiBGaWVsZFtdKTogR3B1RmlsdGVyIHtcbiAgY29uc3QgZmlsdGVyUmFuZ2UgPSBnZXRFbXB0eUZpbHRlclJhbmdlKCk7XG4gIGNvbnN0IHRyaWdnZXJzID0ge307XG5cbiAgLy8gYXJyYXkgb2YgZmlsdGVyIGZvciBlYWNoIGNoYW5uZWwsIHVuZGVmaW5lZCwgaWYgbm8gZmlsdGVyIGlzIGFzc2lnbmVkIHRvIHRoYXQgY2hhbm5lbFxuICBjb25zdCBjaGFubmVsczogKEZpbHRlciB8IHVuZGVmaW5lZClbXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0dQVV9GSUxURVJTOyBpKyspIHtcbiAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzLmZpbmQoXG4gICAgICBmID0+XG4gICAgICAgIGYuZ3B1ICYmXG4gICAgICAgIGYuZGF0YUlkLmluY2x1ZGVzKGRhdGFJZCkgJiZcbiAgICAgICAgZi5ncHVDaGFubmVsICYmXG4gICAgICAgIGYuZ3B1Q2hhbm5lbFtmLmRhdGFJZC5pbmRleE9mKGRhdGFJZCldID09PSBpXG4gICAgKTtcblxuICAgIGZpbHRlclJhbmdlW2ldWzBdID0gZmlsdGVyID8gZmlsdGVyLnZhbHVlWzBdIC0gZmlsdGVyLmRvbWFpbj8uWzBdIDogMDtcbiAgICBmaWx0ZXJSYW5nZVtpXVsxXSA9IGZpbHRlciA/IGZpbHRlci52YWx1ZVsxXSAtIGZpbHRlci5kb21haW4/LlswXSA6IDA7XG5cbiAgICB0cmlnZ2Vyc1tgZ3B1RmlsdGVyXyR7aX1gXSA9IGZpbHRlciA/IGZpbHRlci5uYW1lW2ZpbHRlci5kYXRhSWQuaW5kZXhPZihkYXRhSWQpXSA6IG51bGw7XG4gICAgY2hhbm5lbHMucHVzaChmaWx0ZXIpO1xuICB9XG5cbiAgY29uc3QgZmlsdGVyVmFsdWVBY2Nlc3NvciA9IGdldEZpbHRlclZhbHVlQWNjZXNzb3IoY2hhbm5lbHMsIGRhdGFJZCwgZmllbGRzKTtcblxuICByZXR1cm4ge1xuICAgIGZpbHRlclJhbmdlLFxuICAgIGZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnM6IHRyaWdnZXJzLFxuICAgIGZpbHRlclZhbHVlQWNjZXNzb3JcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gZGF0YXNldCBmaWVsZCBpbmRleCBmcm9tIGZpbHRlci5maWVsZElkeFxuICogVGhlIGluZGV4IG1hdGNoZXMgdGhlIHNhbWUgZGF0YXNldCBpbmRleCBmb3IgZmlsdGVyLmRhdGFJZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YXNldEZpZWxkSW5kZXhGb3JGaWx0ZXIoZGF0YUlkOiBzdHJpbmcsIGZpbHRlcjogRmlsdGVyKTogbnVtYmVyIHtcbiAgY29uc3QgZGF0YXNldEluZGV4ID0gdG9BcnJheShmaWx0ZXIuZGF0YUlkKS5pbmRleE9mKGRhdGFJZCk7XG4gIGlmIChkYXRhc2V0SW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgY29uc3QgZmllbGRJbmRleCA9IGZpbHRlci5maWVsZElkeFtkYXRhc2V0SW5kZXhdO1xuXG4gIHJldHVybiBub3ROdWxsb3JVbmRlZmluZWQoZmllbGRJbmRleCkgPyBmaWVsZEluZGV4IDogLTE7XG59XG4iXX0=