"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findDefaultColorField = findDefaultColorField;
exports.validateInputData = validateInputData;
exports.getSampleForTypeAnalyze = getSampleForTypeAnalyze;
exports.isHexWkb = isHexWkb;
exports.getFieldsFromData = getFieldsFromData;
exports.renameDuplicateFields = renameDuplicateFields;
exports.analyzerTypeToFieldType = analyzerTypeToFieldType;
exports.getFieldFormatLabels = getFieldFormatLabels;
exports.getFormatLabels = getFormatLabels;
exports.ACCEPTED_ANALYZER_TYPES = exports.datasetColorMaker = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _window = require("global/window");

var _constants = require("@kepler.gl/constants");

var _typeAnalyzer = require("type-analyzer");

var _assert = _interopRequireDefault(require("assert"));

var _utils = require("./utils");

var _dataUtils = require("./data-utils");

var _format = require("./format");

var _d3Array = require("d3-array");

var _colorUtils = require("./color-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _marked = /*#__PURE__*/_regenerator["default"].mark(generateColor);

// apply a color for each dataset
// to use as label colors
var datasetColors = ['#8F2FBF', '#005CFF', '#C06C84', '#F8B195', '#547A82', '#3EACA8', '#A2D4AB'].map(_colorUtils.hexToRgb);
/**
 * Random color generator
 */

function generateColor() {
  var index;
  return _regenerator["default"].wrap(function generateColor$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          index = 0;

        case 1:
          if (!(index < datasetColors.length + 1)) {
            _context.next = 7;
            break;
          }

          if (index === datasetColors.length) {
            index = 0;
          }

          _context.next = 5;
          return datasetColors[index++];

        case 5:
          _context.next = 1;
          break;

        case 7:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

var datasetColorMaker = generateColor();
/**
 * Field name prefixes and suffixes which should not be considered
 * as metrics. Fields will still be included if a 'metric word'
 * is found on the field name, however.
 */

exports.datasetColorMaker = datasetColorMaker;
var EXCLUDED_DEFAULT_FIELDS = [// Serial numbers and identification numbers
'_id', 'id', 'index', 'uuid', 'guid', 'uid', 'gid', 'serial', // Geographic IDs are unlikely to be interesting to color
'zip', 'code', 'post', 'region', 'fips', 'cbgs', 'h3', 's2', // Geographic coords (but not z/elevation/altitude
// since that might be a metric)
'lat', 'lon', 'lng', 'latitude', 'longitude', '_x', '_y'];
/**
 * Prefixes and suffixes that indicate a field is a metric.
 *
 * Note that these are in order of preference, first being
 * most preferred.
 */

var METRIC_DEFAULT_FIELDS = ['metric', 'value', 'sum', 'count', 'unique', 'mean', 'mode', 'median', 'max', 'min', 'deviation', 'variance', 'p99', 'p95', 'p75', 'p50', 'p25', 'p05', // Abbreviations are less preferred
'cnt', 'val'];
/**
 * Choose a field to use as the default color field of a layer.
 *
 * The heuristic is:
 *
 * First, exclude fields that are on the exclusion list and don't
 * have names that suggest they contain metrics. Also exclude
 * field names that are blank.
 *
 * Next, look for a field that is of real type and contains one
 * of the preferred names (in order of the preferred names).
 *
 * Next, look for a field that is of integer type and contains
 * one of the preferred names (in order of the preferred names).
 *
 * Next, look for the first field that is of real type (in order
 * of field index).
 *
 * Next, look for the first field that is of integer type (in
 * order of field index).
 *
 * It's possible no field will be chosen (i.e. because all fields
 * are strings.)
 *
 * @param dataset
 */

function findDefaultColorField(_ref) {
  var fields = _ref.fields,
      _ref$fieldPairs = _ref.fieldPairs,
      fieldPairs = _ref$fieldPairs === void 0 ? [] : _ref$fieldPairs;
  var fieldsWithoutExcluded = fields.filter(function (field) {
    if (field.type !== _constants.ALL_FIELD_TYPES.real && field.type !== _constants.ALL_FIELD_TYPES.integer) {
      // Only select numeric fields.
      return false;
    }

    if (fieldPairs.find(function (pair) {
      return pair.pair.lat.value === field.name || pair.pair.lng.value === field.name;
    })) {
      // Do not permit lat, lon fields
      return false;
    }

    var normalizedFieldName = field.name.toLowerCase();

    if (normalizedFieldName === '') {
      // Special case excluded name when the name is blank.
      return false;
    }

    var hasExcluded = EXCLUDED_DEFAULT_FIELDS.find(function (f) {
      return normalizedFieldName.startsWith(f) || normalizedFieldName.endsWith(f);
    });
    var hasInclusion = METRIC_DEFAULT_FIELDS.find(function (f) {
      return normalizedFieldName.startsWith(f) || normalizedFieldName.endsWith(f);
    });
    return !hasExcluded || hasInclusion;
  });
  var sortedFields = fieldsWithoutExcluded.sort(function (left, right) {
    var normalizedLeft = left.name.toLowerCase();
    var normalizedRight = right.name.toLowerCase();
    var leftHasInclusion = METRIC_DEFAULT_FIELDS.findIndex(function (f) {
      return normalizedLeft.startsWith(f) || normalizedLeft.endsWith(f);
    });
    var rightHasInclusion = METRIC_DEFAULT_FIELDS.findIndex(function (f) {
      return normalizedRight.startsWith(f) || normalizedRight.endsWith(f);
    });

    if (leftHasInclusion !== rightHasInclusion) {
      if (leftHasInclusion === -1) {
        // Elements that do not have the inclusion list should go after those that do.
        return 1;
      } else if (rightHasInclusion === -1) {
        // Elements that do have the inclusion list should go before those that don't.
        return -1;
      } // Compare based on order in the inclusion list


      return leftHasInclusion - rightHasInclusion;
    } // Compare based on type


    if (left.type !== right.type) {
      if (left.type === _constants.ALL_FIELD_TYPES.real) {
        return -1;
      } // left is an integer and right is not
      // and reals come before integers


      return 1;
    } // Finally, order based on the order in the datasets columns
    // @ts-expect-error


    return left.index - right.index;
  });

  if (sortedFields.length) {
    // There was a best match
    return sortedFields[0];
  } // No matches


  return null;
}

var ACCEPTED_ANALYZER_TYPES = [_typeAnalyzer.DATA_TYPES.DATE, _typeAnalyzer.DATA_TYPES.TIME, _typeAnalyzer.DATA_TYPES.DATETIME, _typeAnalyzer.DATA_TYPES.NUMBER, _typeAnalyzer.DATA_TYPES.INT, _typeAnalyzer.DATA_TYPES.FLOAT, _typeAnalyzer.DATA_TYPES.BOOLEAN, _typeAnalyzer.DATA_TYPES.STRING, _typeAnalyzer.DATA_TYPES.GEOMETRY, _typeAnalyzer.DATA_TYPES.GEOMETRY_FROM_STRING, _typeAnalyzer.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING, _typeAnalyzer.DATA_TYPES.ZIPCODE, _typeAnalyzer.DATA_TYPES.ARRAY, _typeAnalyzer.DATA_TYPES.OBJECT];
exports.ACCEPTED_ANALYZER_TYPES = ACCEPTED_ANALYZER_TYPES;
var IGNORE_DATA_TYPES = Object.keys(_typeAnalyzer.DATA_TYPES).filter(function (type) {
  return !ACCEPTED_ANALYZER_TYPES.includes(type);
});
/**
 * Validate input data, adding missing field types, rename duplicate columns
 */

function validateInputData(data) {
  if (!(0, _utils.isPlainObject)(data)) {
    (0, _assert["default"])('addDataToMap Error: dataset.data cannot be null');
    return null;
  } else if (!Array.isArray(data.fields)) {
    (0, _assert["default"])('addDataToMap Error: expect dataset.data.fields to be an array');
    return null;
  } else if (!Array.isArray(data.rows)) {
    (0, _assert["default"])('addDataToMap Error: expect dataset.data.rows to be an array');
    return null;
  }

  var fields = data.fields,
      rows = data.rows,
      cols = data.cols; // check if all fields has name, format and type

  var allValid = fields.every(function (f, i) {
    if (!(0, _utils.isPlainObject)(f)) {
      (0, _assert["default"])("fields needs to be an array of object, but find ".concat((0, _typeof2["default"])(f)));
      fields[i] = {
        name: "column_".concat(i)
      };
    }

    if (!f.name) {
      (0, _assert["default"])("field.name is required but missing in ".concat(JSON.stringify(f))); // assign a name

      fields[i].name = "column_".concat(i);
    }

    if (!f.type || !_constants.ALL_FIELD_TYPES[f.type]) {
      (0, _assert["default"])("unknown field type ".concat(f.type));
      return false;
    }

    if (!fields.every(function (field) {
      return field.analyzerType;
    })) {
      (0, _assert["default"])('field missing analyzerType');
      return false;
    } // check time format is correct based on first 10 not empty element


    if (f.type === _constants.ALL_FIELD_TYPES.timestamp) {
      var sample = findNonEmptyRowsAtField(rows, i, 10).map(function (r) {
        return {
          ts: r[i]
        };
      });

      var analyzedType = _typeAnalyzer.Analyzer.computeColMeta(sample)[0];

      return analyzedType && analyzedType.category === 'TIME' && analyzedType.format === f.format;
    }

    return true;
  });

  if (allValid) {
    return {
      rows: rows,
      fields: fields,
      cols: cols
    };
  } // if any field has missing type, recalculate it for everyone
  // because we simply lost faith in humanity


  var sampleData = getSampleForTypeAnalyze({
    fields: fields.map(function (f) {
      return f.name;
    }),
    rows: rows
  });
  var fieldOrder = fields.map(function (f) {
    return f.name;
  });
  var meta = getFieldsFromData(sampleData, fieldOrder);
  var updatedFields = fields.map(function (f, i) {
    return _objectSpread(_objectSpread({}, f), {}, {
      type: meta[i].type,
      format: meta[i].format,
      analyzerType: meta[i].analyzerType
    });
  });
  return {
    fields: updatedFields,
    rows: rows
  };
}

function findNonEmptyRowsAtField(rows, fieldIdx, total) {
  var sample = [];
  var i = 0;

  while (sample.length < total && i < rows.length) {
    var _rows$i;

    if ((0, _dataUtils.notNullorUndefined)((_rows$i = rows[i]) === null || _rows$i === void 0 ? void 0 : _rows$i[fieldIdx])) {
      sample.push(rows[i]);
    }

    i++;
  }

  return sample;
}
/**
 * Getting sample data for analyzing field type.
 */


function getSampleForTypeAnalyze(_ref2) {
  var fields = _ref2.fields,
      rows = _ref2.rows,
      _ref2$sampleCount = _ref2.sampleCount,
      sampleCount = _ref2$sampleCount === void 0 ? 50 : _ref2$sampleCount;
  var total = Math.min(sampleCount, rows.length); // const fieldOrder = fields.map(f => f.name);

  var sample = (0, _d3Array.range)(0, total, 1).map(function (d) {
    return {};
  }); // collect sample data for each field

  fields.forEach(function (field, fieldIdx) {
    // data counter
    var i = 0; // sample counter

    var j = 0;

    while (j < total) {
      if (i >= rows.length) {
        // if depleted data pool
        sample[j][field] = null;
        j++;
      } else if ((0, _dataUtils.notNullorUndefined)(rows[i][fieldIdx])) {
        var value = rows[i][fieldIdx];
        sample[j][field] = typeof value === 'string' ? value.trim() : value;
        j++;
        i++;
      } else {
        i++;
      }
    }
  });
  return sample;
}
/**
 * Check if string is a valid Well-known binary (WKB) in HEX format
 * https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry
 *
 * @param str input string
 * @returns true if string is a valid WKB in HEX format
 */


function isHexWkb(str) {
  if (!str) return false; // check if the length of the string is even and is at least 10 characters long

  if (str.length < 10 || str.length % 2 !== 0) {
    return false;
  } // check if first two characters are 00 or 01


  if (!str.startsWith('00') && !str.startsWith('01')) {
    return false;
  } // check if the rest of the string is a valid hex


  return /^[0-9a-fA-F]+$/.test(str.slice(2));
}
/**
 * Analyze field types from data in `string` format, e.g. uploaded csv.
 * Assign `type`, `fieldIdx` and `format` (timestamp only) to each field
 *
 * @param data array of row object
 * @param fieldOrder array of field names as string
 * @returns formatted fields
 * @public
 * @example
 *
 * import {getFieldsFromData} from 'kepler.gl/processors';
 * const data = [{
 *   time: '2016-09-17 00:09:55',
 *   value: '4',
 *   surge: '1.2',
 *   isTrip: 'true',
 *   zeroOnes: '0'
 * }, {
 *   time: '2016-09-17 00:30:08',
 *   value: '3',
 *   surge: null,
 *   isTrip: 'false',
 *   zeroOnes: '1'
 * }, {
 *   time: null,
 *   value: '2',
 *   surge: '1.3',
 *   isTrip: null,
 *   zeroOnes: '1'
 * }];
 *
 * const fieldOrder = ['time', 'value', 'surge', 'isTrip', 'zeroOnes'];
 * const fields = getFieldsFromData(data, fieldOrder);
 * // fields = [
 * // {name: 'time', format: 'YYYY-M-D H:m:s', fieldIdx: 1, type: 'timestamp'},
 * // {name: 'value', format: '', fieldIdx: 4, type: 'integer'},
 * // {name: 'surge', format: '', fieldIdx: 5, type: 'real'},
 * // {name: 'isTrip', format: '', fieldIdx: 6, type: 'boolean'},
 * // {name: 'zeroOnes', format: '', fieldIdx: 7, type: 'integer'}];
 *
 */


function getFieldsFromData(data, fieldOrder) {
  // add a check for epoch timestamp
  var metadata = _typeAnalyzer.Analyzer.computeColMeta(data, [{
    regex: /.*geojson|all_points/g,
    dataType: 'GEOMETRY'
  }, {
    regex: /.*census/g,
    dataType: 'STRING'
  }], {
    ignoredDataTypes: IGNORE_DATA_TYPES
  });

  var _renameDuplicateField = renameDuplicateFields(fieldOrder),
      fieldByIndex = _renameDuplicateField.fieldByIndex;

  var result = fieldOrder.map(function (field, index) {
    var name = fieldByIndex[index];
    var fieldMeta = metadata.find(function (m) {
      return m.key === field;
    }); // fieldMeta could be undefined if the field has no data and Analyzer.computeColMeta
    // will ignore the field. In this case, we will simply assign the field type to STRING
    // since dropping the column in the RowData could be expensive

    var type = (fieldMeta === null || fieldMeta === void 0 ? void 0 : fieldMeta.type) || 'STRING';
    var format = (fieldMeta === null || fieldMeta === void 0 ? void 0 : fieldMeta.format) || ''; // check if string is hex wkb

    if (type === _typeAnalyzer.DATA_TYPES.STRING) {
      type = data.some(function (d) {
        return isHexWkb(d[name]);
      }) ? _typeAnalyzer.DATA_TYPES.GEOMETRY : type;
    }

    return {
      name: name,
      id: name,
      displayName: name,
      format: format,
      fieldIdx: index,
      type: analyzerTypeToFieldType(type),
      analyzerType: type,
      valueAccessor: function valueAccessor(dc) {
        return function (d) {
          return dc.valueAt(d.index, index);
        };
      }
    };
  });
  return result;
}
/**
 * pass in an array of field names, rename duplicated one
 * and return a map from old field index to new name
 *
 * @param fieldOrder
 * @returns new field name by index
 */


function renameDuplicateFields(fieldOrder) {
  return fieldOrder.reduce(function (accu, field, i) {
    var allNames = accu.allNames;
    var fieldName = field; // add a counter to duplicated names

    if (allNames.includes(field)) {
      var counter = 0;

      while (allNames.includes("".concat(field, "-").concat(counter))) {
        counter++;
      }

      fieldName = "".concat(field, "-").concat(counter);
    }

    accu.fieldByIndex[i] = fieldName;
    accu.allNames.push(fieldName);
    return accu;
  }, {
    allNames: [],
    fieldByIndex: []
  });
}
/**
 * Convert type-analyzer output to kepler.gl field types
 *
 * @param aType
 * @returns corresponding type in `ALL_FIELD_TYPES`
 */

/* eslint-disable complexity */


function analyzerTypeToFieldType(aType) {
  var DATE = _typeAnalyzer.DATA_TYPES.DATE,
      TIME = _typeAnalyzer.DATA_TYPES.TIME,
      DATETIME = _typeAnalyzer.DATA_TYPES.DATETIME,
      NUMBER = _typeAnalyzer.DATA_TYPES.NUMBER,
      INT = _typeAnalyzer.DATA_TYPES.INT,
      FLOAT = _typeAnalyzer.DATA_TYPES.FLOAT,
      BOOLEAN = _typeAnalyzer.DATA_TYPES.BOOLEAN,
      STRING = _typeAnalyzer.DATA_TYPES.STRING,
      GEOMETRY = _typeAnalyzer.DATA_TYPES.GEOMETRY,
      GEOMETRY_FROM_STRING = _typeAnalyzer.DATA_TYPES.GEOMETRY_FROM_STRING,
      PAIR_GEOMETRY_FROM_STRING = _typeAnalyzer.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING,
      ZIPCODE = _typeAnalyzer.DATA_TYPES.ZIPCODE,
      ARRAY = _typeAnalyzer.DATA_TYPES.ARRAY,
      OBJECT = _typeAnalyzer.DATA_TYPES.OBJECT; // TODO: un recognized types
  // CURRENCY PERCENT NONE

  switch (aType) {
    case DATE:
      return _constants.ALL_FIELD_TYPES.date;

    case TIME:
    case DATETIME:
      return _constants.ALL_FIELD_TYPES.timestamp;

    case FLOAT:
      return _constants.ALL_FIELD_TYPES.real;

    case INT:
      return _constants.ALL_FIELD_TYPES.integer;

    case BOOLEAN:
      return _constants.ALL_FIELD_TYPES["boolean"];

    case GEOMETRY:
    case GEOMETRY_FROM_STRING:
    case PAIR_GEOMETRY_FROM_STRING:
      return _constants.ALL_FIELD_TYPES.geojson;

    case ARRAY:
      return _constants.ALL_FIELD_TYPES.array;

    case OBJECT:
      return _constants.ALL_FIELD_TYPES.object;

    case NUMBER:
    case STRING:
    case ZIPCODE:
      return _constants.ALL_FIELD_TYPES.string;

    default:
      _window.console.warn("Unsupported analyzer type: ".concat(aType));

      return _constants.ALL_FIELD_TYPES.string;
  }
}

var TIME_DISPLAY = '2020-05-11 14:00';

var addTimeLabel = function addTimeLabel(formats) {
  return formats.map(function (f) {
    return _objectSpread(_objectSpread({}, f), {}, {
      label: f.type === _constants.TOOLTIP_FORMAT_TYPES.DATE_TIME || f.type === _constants.TOOLTIP_FORMAT_TYPES.DATE ? (0, _dataUtils.getFormatter)((0, _format.getFormatValue)(f))(TIME_DISPLAY) : f.label
    });
  });
};

function getFieldFormatLabels(fieldType) {
  var tooltipTypes = fieldType && _constants.FIELD_OPTS[fieldType].format.tooltip || [];
  var formatLabels = Object.values(_constants.TOOLTIP_FORMATS).filter(function (t) {
    return tooltipTypes.includes(t.type);
  });
  return addTimeLabel(formatLabels);
}

function getFormatLabels(fields, fieldName) {
  var _fields$find;

  var fieldType = (_fields$find = fields.find(function (f) {
    return f.name === fieldName;
  })) === null || _fields$find === void 0 ? void 0 : _fields$find.type;
  return getFieldFormatLabels(fieldType);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kYXRhc2V0LXV0aWxzLnRzIl0sIm5hbWVzIjpbImdlbmVyYXRlQ29sb3IiLCJkYXRhc2V0Q29sb3JzIiwibWFwIiwiaGV4VG9SZ2IiLCJpbmRleCIsImxlbmd0aCIsImRhdGFzZXRDb2xvck1ha2VyIiwiRVhDTFVERURfREVGQVVMVF9GSUVMRFMiLCJNRVRSSUNfREVGQVVMVF9GSUVMRFMiLCJmaW5kRGVmYXVsdENvbG9yRmllbGQiLCJmaWVsZHMiLCJmaWVsZFBhaXJzIiwiZmllbGRzV2l0aG91dEV4Y2x1ZGVkIiwiZmlsdGVyIiwiZmllbGQiLCJ0eXBlIiwiQUxMX0ZJRUxEX1RZUEVTIiwicmVhbCIsImludGVnZXIiLCJmaW5kIiwicGFpciIsImxhdCIsInZhbHVlIiwibmFtZSIsImxuZyIsIm5vcm1hbGl6ZWRGaWVsZE5hbWUiLCJ0b0xvd2VyQ2FzZSIsImhhc0V4Y2x1ZGVkIiwiZiIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImhhc0luY2x1c2lvbiIsInNvcnRlZEZpZWxkcyIsInNvcnQiLCJsZWZ0IiwicmlnaHQiLCJub3JtYWxpemVkTGVmdCIsIm5vcm1hbGl6ZWRSaWdodCIsImxlZnRIYXNJbmNsdXNpb24iLCJmaW5kSW5kZXgiLCJyaWdodEhhc0luY2x1c2lvbiIsIkFDQ0VQVEVEX0FOQUxZWkVSX1RZUEVTIiwiQW5hbHl6ZXJEQVRBX1RZUEVTIiwiREFURSIsIlRJTUUiLCJEQVRFVElNRSIsIk5VTUJFUiIsIklOVCIsIkZMT0FUIiwiQk9PTEVBTiIsIlNUUklORyIsIkdFT01FVFJZIiwiR0VPTUVUUllfRlJPTV9TVFJJTkciLCJQQUlSX0dFT01FVFJZX0ZST01fU1RSSU5HIiwiWklQQ09ERSIsIkFSUkFZIiwiT0JKRUNUIiwiSUdOT1JFX0RBVEFfVFlQRVMiLCJPYmplY3QiLCJrZXlzIiwiaW5jbHVkZXMiLCJ2YWxpZGF0ZUlucHV0RGF0YSIsImRhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJyb3dzIiwiY29scyIsImFsbFZhbGlkIiwiZXZlcnkiLCJpIiwiSlNPTiIsInN0cmluZ2lmeSIsImFuYWx5emVyVHlwZSIsInRpbWVzdGFtcCIsInNhbXBsZSIsImZpbmROb25FbXB0eVJvd3NBdEZpZWxkIiwiciIsInRzIiwiYW5hbHl6ZWRUeXBlIiwiQW5hbHl6ZXIiLCJjb21wdXRlQ29sTWV0YSIsImNhdGVnb3J5IiwiZm9ybWF0Iiwic2FtcGxlRGF0YSIsImdldFNhbXBsZUZvclR5cGVBbmFseXplIiwiZmllbGRPcmRlciIsIm1ldGEiLCJnZXRGaWVsZHNGcm9tRGF0YSIsInVwZGF0ZWRGaWVsZHMiLCJmaWVsZElkeCIsInRvdGFsIiwicHVzaCIsInNhbXBsZUNvdW50IiwiTWF0aCIsIm1pbiIsImQiLCJmb3JFYWNoIiwiaiIsInRyaW0iLCJpc0hleFdrYiIsInN0ciIsInRlc3QiLCJzbGljZSIsIm1ldGFkYXRhIiwicmVnZXgiLCJkYXRhVHlwZSIsImlnbm9yZWREYXRhVHlwZXMiLCJyZW5hbWVEdXBsaWNhdGVGaWVsZHMiLCJmaWVsZEJ5SW5kZXgiLCJyZXN1bHQiLCJmaWVsZE1ldGEiLCJtIiwia2V5Iiwic29tZSIsImlkIiwiZGlzcGxheU5hbWUiLCJhbmFseXplclR5cGVUb0ZpZWxkVHlwZSIsInZhbHVlQWNjZXNzb3IiLCJkYyIsInZhbHVlQXQiLCJyZWR1Y2UiLCJhY2N1IiwiYWxsTmFtZXMiLCJmaWVsZE5hbWUiLCJjb3VudGVyIiwiYVR5cGUiLCJkYXRlIiwiZ2VvanNvbiIsImFycmF5Iiwib2JqZWN0Iiwic3RyaW5nIiwiZ2xvYmFsQ29uc29sZSIsIndhcm4iLCJUSU1FX0RJU1BMQVkiLCJhZGRUaW1lTGFiZWwiLCJmb3JtYXRzIiwibGFiZWwiLCJUT09MVElQX0ZPUk1BVF9UWVBFUyIsIkRBVEVfVElNRSIsImdldEZpZWxkRm9ybWF0TGFiZWxzIiwiZmllbGRUeXBlIiwidG9vbHRpcFR5cGVzIiwiRklFTERfT1BUUyIsInRvb2x0aXAiLCJmb3JtYXRMYWJlbHMiLCJ2YWx1ZXMiLCJUT09MVElQX0ZPUk1BVFMiLCJ0Iiwi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RixNQUFQLENBQWNDLDBCQUFkLEVBQStCckksTUFBL0IsQ0FBc0MsVUFBQXNJLENBQUM7QUFBQSxXQUM3RU4sWUFBWSxDQUFDakYsUUFBYixDQUFzQnVGLENBQUMsQ0FBQ3BJLElBQXhCLENBRDZFO0FBQUEsR0FBdkMsQ0FBeEM7QUFHQSxTQUFPdUgsWUFBWSxDQUFDVSxZQUFELENBQW5CO0FBQ0Q7O0FBRU0sU0FBU0ksZUFBVCxDQUF5QjFJLE1BQXpCLEVBQWtEaUgsU0FBbEQsRUFBcUU7QUFBQTs7QUFDMUUsTUFBTWlCLFNBQVMsbUJBQUdsSSxNQUFNLENBQUNTLElBQVAsQ0FBWSxVQUFBUyxDQUFDO0FBQUEsV0FBSUEsQ0FBQyxDQUFDTCxJQUFGLEtBQVdvRyxTQUFmO0FBQUEsR0FBYixDQUFILGlEQUFHLGFBQXdDNUcsSUFBMUQ7QUFDQSxTQUFPNEgsb0JBQW9CLENBQUNDLFNBQUQsQ0FBM0I7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCB7Y29uc29sZSBhcyBnbG9iYWxDb25zb2xlfSBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCB7XG4gIEFMTF9GSUVMRF9UWVBFUyxcbiAgRklFTERfT1BUUyxcbiAgVE9PTFRJUF9GT1JNQVRTLFxuICBUT09MVElQX0ZPUk1BVF9UWVBFU1xufSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge0FuYWx5emVyLCBEQVRBX1RZUEVTIGFzIEFuYWx5emVyREFUQV9UWVBFU30gZnJvbSAndHlwZS1hbmFseXplcic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmltcG9ydCB7XG4gIFByb2Nlc3NvclJlc3VsdCxcbiAgUkdCQ29sb3IsXG4gIFJvd0RhdGEsXG4gIEZpZWxkLFxuICBGaWVsZFBhaXIsXG4gIFRpbWVMYWJlbEZvcm1hdCxcbiAgVG9vbHRpcEZpZWxkcyxcbiAgUHJvdG9EYXRhc2V0XG59IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuaW1wb3J0IHtUb29sdGlwRm9ybWF0fSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7aXNQbGFpbk9iamVjdH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge25vdE51bGxvclVuZGVmaW5lZCwgZ2V0Rm9ybWF0dGVyfSBmcm9tICcuL2RhdGEtdXRpbHMnO1xuaW1wb3J0IHtnZXRGb3JtYXRWYWx1ZX0gZnJvbSAnLi9mb3JtYXQnO1xuaW1wb3J0IHtyYW5nZX0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHtoZXhUb1JnYn0gZnJvbSAnLi9jb2xvci11dGlscyc7XG5cbi8vIGFwcGx5IGEgY29sb3IgZm9yIGVhY2ggZGF0YXNldFxuLy8gdG8gdXNlIGFzIGxhYmVsIGNvbG9yc1xuY29uc3QgZGF0YXNldENvbG9ycyA9IFtcbiAgJyM4RjJGQkYnLFxuICAnIzAwNUNGRicsXG4gICcjQzA2Qzg0JyxcbiAgJyNGOEIxOTUnLFxuICAnIzU0N0E4MicsXG4gICcjM0VBQ0E4JyxcbiAgJyNBMkQ0QUInXG5dLm1hcChoZXhUb1JnYik7XG5cbi8qKlxuICogUmFuZG9tIGNvbG9yIGdlbmVyYXRvclxuICovXG5mdW5jdGlvbiogZ2VuZXJhdGVDb2xvcigpOiBHZW5lcmF0b3I8UkdCQ29sb3I+IHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgZGF0YXNldENvbG9ycy5sZW5ndGggKyAxKSB7XG4gICAgaWYgKGluZGV4ID09PSBkYXRhc2V0Q29sb3JzLmxlbmd0aCkge1xuICAgICAgaW5kZXggPSAwO1xuICAgIH1cbiAgICB5aWVsZCBkYXRhc2V0Q29sb3JzW2luZGV4KytdO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkYXRhc2V0Q29sb3JNYWtlciA9IGdlbmVyYXRlQ29sb3IoKTtcblxuLyoqXG4gKiBGaWVsZCBuYW1lIHByZWZpeGVzIGFuZCBzdWZmaXhlcyB3aGljaCBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWRcbiAqIGFzIG1ldHJpY3MuIEZpZWxkcyB3aWxsIHN0aWxsIGJlIGluY2x1ZGVkIGlmIGEgJ21ldHJpYyB3b3JkJ1xuICogaXMgZm91bmQgb24gdGhlIGZpZWxkIG5hbWUsIGhvd2V2ZXIuXG4gKi9cbmNvbnN0IEVYQ0xVREVEX0RFRkFVTFRfRklFTERTID0gW1xuICAvLyBTZXJpYWwgbnVtYmVycyBhbmQgaWRlbnRpZmljYXRpb24gbnVtYmVyc1xuICAnX2lkJyxcbiAgJ2lkJyxcbiAgJ2luZGV4JyxcbiAgJ3V1aWQnLFxuICAnZ3VpZCcsXG4gICd1aWQnLFxuICAnZ2lkJyxcbiAgJ3NlcmlhbCcsXG4gIC8vIEdlb2dyYXBoaWMgSURzIGFyZSB1bmxpa2VseSB0byBiZSBpbnRlcmVzdGluZyB0byBjb2xvclxuICAnemlwJyxcbiAgJ2NvZGUnLFxuICAncG9zdCcsXG4gICdyZWdpb24nLFxuICAnZmlwcycsXG4gICdjYmdzJyxcbiAgJ2gzJyxcbiAgJ3MyJyxcbiAgLy8gR2VvZ3JhcGhpYyBjb29yZHMgKGJ1dCBub3Qgei9lbGV2YXRpb24vYWx0aXR1ZGVcbiAgLy8gc2luY2UgdGhhdCBtaWdodCBiZSBhIG1ldHJpYylcbiAgJ2xhdCcsXG4gICdsb24nLFxuICAnbG5nJyxcbiAgJ2xhdGl0dWRlJyxcbiAgJ2xvbmdpdHVkZScsXG4gICdfeCcsXG4gICdfeSdcbl07XG5cbi8qKlxuICogUHJlZml4ZXMgYW5kIHN1ZmZpeGVzIHRoYXQgaW5kaWNhdGUgYSBmaWVsZCBpcyBhIG1ldHJpYy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlc2UgYXJlIGluIG9yZGVyIG9mIHByZWZlcmVuY2UsIGZpcnN0IGJlaW5nXG4gKiBtb3N0IHByZWZlcnJlZC5cbiAqL1xuY29uc3QgTUVUUklDX0RFRkFVTFRfRklFTERTID0gW1xuICAnbWV0cmljJyxcbiAgJ3ZhbHVlJyxcbiAgJ3N1bScsXG4gICdjb3VudCcsXG4gICd1bmlxdWUnLFxuICAnbWVhbicsXG4gICdtb2RlJyxcbiAgJ21lZGlhbicsXG4gICdtYXgnLFxuICAnbWluJyxcbiAgJ2RldmlhdGlvbicsXG4gICd2YXJpYW5jZScsXG4gICdwOTknLFxuICAncDk1JyxcbiAgJ3A3NScsXG4gICdwNTAnLFxuICAncDI1JyxcbiAgJ3AwNScsXG4gIC8vIEFiYnJldmlhdGlvbnMgYXJlIGxlc3MgcHJlZmVycmVkXG4gICdjbnQnLFxuICAndmFsJ1xuXTtcblxuLyoqXG4gKiBDaG9vc2UgYSBmaWVsZCB0byB1c2UgYXMgdGhlIGRlZmF1bHQgY29sb3IgZmllbGQgb2YgYSBsYXllci5cbiAqXG4gKiBUaGUgaGV1cmlzdGljIGlzOlxuICpcbiAqIEZpcnN0LCBleGNsdWRlIGZpZWxkcyB0aGF0IGFyZSBvbiB0aGUgZXhjbHVzaW9uIGxpc3QgYW5kIGRvbid0XG4gKiBoYXZlIG5hbWVzIHRoYXQgc3VnZ2VzdCB0aGV5IGNvbnRhaW4gbWV0cmljcy4gQWxzbyBleGNsdWRlXG4gKiBmaWVsZCBuYW1lcyB0aGF0IGFyZSBibGFuay5cbiAqXG4gKiBOZXh0LCBsb29rIGZvciBhIGZpZWxkIHRoYXQgaXMgb2YgcmVhbCB0eXBlIGFuZCBjb250YWlucyBvbmVcbiAqIG9mIHRoZSBwcmVmZXJyZWQgbmFtZXMgKGluIG9yZGVyIG9mIHRoZSBwcmVmZXJyZWQgbmFtZXMpLlxuICpcbiAqIE5leHQsIGxvb2sgZm9yIGEgZmllbGQgdGhhdCBpcyBvZiBpbnRlZ2VyIHR5cGUgYW5kIGNvbnRhaW5zXG4gKiBvbmUgb2YgdGhlIHByZWZlcnJlZCBuYW1lcyAoaW4gb3JkZXIgb2YgdGhlIHByZWZlcnJlZCBuYW1lcykuXG4gKlxuICogTmV4dCwgbG9vayBmb3IgdGhlIGZpcnN0IGZpZWxkIHRoYXQgaXMgb2YgcmVhbCB0eXBlIChpbiBvcmRlclxuICogb2YgZmllbGQgaW5kZXgpLlxuICpcbiAqIE5leHQsIGxvb2sgZm9yIHRoZSBmaXJzdCBmaWVsZCB0aGF0IGlzIG9mIGludGVnZXIgdHlwZSAoaW5cbiAqIG9yZGVyIG9mIGZpZWxkIGluZGV4KS5cbiAqXG4gKiBJdCdzIHBvc3NpYmxlIG5vIGZpZWxkIHdpbGwgYmUgY2hvc2VuIChpLmUuIGJlY2F1c2UgYWxsIGZpZWxkc1xuICogYXJlIHN0cmluZ3MuKVxuICpcbiAqIEBwYXJhbSBkYXRhc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRGVmYXVsdENvbG9yRmllbGQoe1xuICBmaWVsZHMsXG4gIGZpZWxkUGFpcnMgPSBbXVxufToge1xuICBmaWVsZHM6IEZpZWxkW107XG4gIGZpZWxkUGFpcnM6IEZpZWxkUGFpcltdO1xufSk6IG51bGwgfCBGaWVsZCB7XG4gIGNvbnN0IGZpZWxkc1dpdGhvdXRFeGNsdWRlZCA9IGZpZWxkcy5maWx0ZXIoZmllbGQgPT4ge1xuICAgIGlmIChmaWVsZC50eXBlICE9PSBBTExfRklFTERfVFlQRVMucmVhbCAmJiBmaWVsZC50eXBlICE9PSBBTExfRklFTERfVFlQRVMuaW50ZWdlcikge1xuICAgICAgLy8gT25seSBzZWxlY3QgbnVtZXJpYyBmaWVsZHMuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGZpZWxkUGFpcnMuZmluZChcbiAgICAgICAgcGFpciA9PiBwYWlyLnBhaXIubGF0LnZhbHVlID09PSBmaWVsZC5uYW1lIHx8IHBhaXIucGFpci5sbmcudmFsdWUgPT09IGZpZWxkLm5hbWVcbiAgICAgIClcbiAgICApIHtcbiAgICAgIC8vIERvIG5vdCBwZXJtaXQgbGF0LCBsb24gZmllbGRzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZEZpZWxkTmFtZSA9IGZpZWxkLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobm9ybWFsaXplZEZpZWxkTmFtZSA9PT0gJycpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBleGNsdWRlZCBuYW1lIHdoZW4gdGhlIG5hbWUgaXMgYmxhbmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGhhc0V4Y2x1ZGVkID0gRVhDTFVERURfREVGQVVMVF9GSUVMRFMuZmluZChcbiAgICAgIGYgPT4gbm9ybWFsaXplZEZpZWxkTmFtZS5zdGFydHNXaXRoKGYpIHx8IG5vcm1hbGl6ZWRGaWVsZE5hbWUuZW5kc1dpdGgoZilcbiAgICApO1xuICAgIGNvbnN0IGhhc0luY2x1c2lvbiA9IE1FVFJJQ19ERUZBVUxUX0ZJRUxEUy5maW5kKFxuICAgICAgZiA9PiBub3JtYWxpemVkRmllbGROYW1lLnN0YXJ0c1dpdGgoZikgfHwgbm9ybWFsaXplZEZpZWxkTmFtZS5lbmRzV2l0aChmKVxuICAgICk7XG4gICAgcmV0dXJuICFoYXNFeGNsdWRlZCB8fCBoYXNJbmNsdXNpb247XG4gIH0pO1xuXG4gIGNvbnN0IHNvcnRlZEZpZWxkcyA9IGZpZWxkc1dpdGhvdXRFeGNsdWRlZC5zb3J0KChsZWZ0LCByaWdodCkgPT4ge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRMZWZ0ID0gbGVmdC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFJpZ2h0ID0gcmlnaHQubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGxlZnRIYXNJbmNsdXNpb24gPSBNRVRSSUNfREVGQVVMVF9GSUVMRFMuZmluZEluZGV4KFxuICAgICAgZiA9PiBub3JtYWxpemVkTGVmdC5zdGFydHNXaXRoKGYpIHx8IG5vcm1hbGl6ZWRMZWZ0LmVuZHNXaXRoKGYpXG4gICAgKTtcbiAgICBjb25zdCByaWdodEhhc0luY2x1c2lvbiA9IE1FVFJJQ19ERUZBVUxUX0ZJRUxEUy5maW5kSW5kZXgoXG4gICAgICBmID0+IG5vcm1hbGl6ZWRSaWdodC5zdGFydHNXaXRoKGYpIHx8IG5vcm1hbGl6ZWRSaWdodC5lbmRzV2l0aChmKVxuICAgICk7XG4gICAgaWYgKGxlZnRIYXNJbmNsdXNpb24gIT09IHJpZ2h0SGFzSW5jbHVzaW9uKSB7XG4gICAgICBpZiAobGVmdEhhc0luY2x1c2lvbiA9PT0gLTEpIHtcbiAgICAgICAgLy8gRWxlbWVudHMgdGhhdCBkbyBub3QgaGF2ZSB0aGUgaW5jbHVzaW9uIGxpc3Qgc2hvdWxkIGdvIGFmdGVyIHRob3NlIHRoYXQgZG8uXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChyaWdodEhhc0luY2x1c2lvbiA9PT0gLTEpIHtcbiAgICAgICAgLy8gRWxlbWVudHMgdGhhdCBkbyBoYXZlIHRoZSBpbmNsdXNpb24gbGlzdCBzaG91bGQgZ28gYmVmb3JlIHRob3NlIHRoYXQgZG9uJ3QuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBhcmUgYmFzZWQgb24gb3JkZXIgaW4gdGhlIGluY2x1c2lvbiBsaXN0XG4gICAgICByZXR1cm4gbGVmdEhhc0luY2x1c2lvbiAtIHJpZ2h0SGFzSW5jbHVzaW9uO1xuICAgIH1cblxuICAgIC8vIENvbXBhcmUgYmFzZWQgb24gdHlwZVxuICAgIGlmIChsZWZ0LnR5cGUgIT09IHJpZ2h0LnR5cGUpIHtcbiAgICAgIGlmIChsZWZ0LnR5cGUgPT09IEFMTF9GSUVMRF9UWVBFUy5yZWFsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIC8vIGxlZnQgaXMgYW4gaW50ZWdlciBhbmQgcmlnaHQgaXMgbm90XG4gICAgICAvLyBhbmQgcmVhbHMgY29tZSBiZWZvcmUgaW50ZWdlcnNcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIG9yZGVyIGJhc2VkIG9uIHRoZSBvcmRlciBpbiB0aGUgZGF0YXNldHMgY29sdW1uc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICB9KTtcblxuICBpZiAoc29ydGVkRmllbGRzLmxlbmd0aCkge1xuICAgIC8vIFRoZXJlIHdhcyBhIGJlc3QgbWF0Y2hcbiAgICByZXR1cm4gc29ydGVkRmllbGRzWzBdO1xuICB9XG4gIC8vIE5vIG1hdGNoZXNcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBjb25zdCBBQ0NFUFRFRF9BTkFMWVpFUl9UWVBFUyA9IFtcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLkRBVEUsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5USU1FLFxuICBBbmFseXplckRBVEFfVFlQRVMuREFURVRJTUUsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5OVU1CRVIsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5JTlQsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5GTE9BVCxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLkJPT0xFQU4sXG4gIEFuYWx5emVyREFUQV9UWVBFUy5TVFJJTkcsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5HRU9NRVRSWSxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLkdFT01FVFJZX0ZST01fU1RSSU5HLFxuICBBbmFseXplckRBVEFfVFlQRVMuUEFJUl9HRU9NRVRSWV9GUk9NX1NUUklORyxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLlpJUENPREUsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5BUlJBWSxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLk9CSkVDVFxuXTtcblxuY29uc3QgSUdOT1JFX0RBVEFfVFlQRVMgPSBPYmplY3Qua2V5cyhBbmFseXplckRBVEFfVFlQRVMpLmZpbHRlcihcbiAgdHlwZSA9PiAhQUNDRVBURURfQU5BTFlaRVJfVFlQRVMuaW5jbHVkZXModHlwZSlcbik7XG5cbi8qKlxuICogVmFsaWRhdGUgaW5wdXQgZGF0YSwgYWRkaW5nIG1pc3NpbmcgZmllbGQgdHlwZXMsIHJlbmFtZSBkdXBsaWNhdGUgY29sdW1uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVJbnB1dERhdGEoZGF0YTogUHJvdG9EYXRhc2V0WydkYXRhJ10pOiBQcm9jZXNzb3JSZXN1bHQge1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBhc3NlcnQoJ2FkZERhdGFUb01hcCBFcnJvcjogZGF0YXNldC5kYXRhIGNhbm5vdCBiZSBudWxsJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5maWVsZHMpKSB7XG4gICAgYXNzZXJ0KCdhZGREYXRhVG9NYXAgRXJyb3I6IGV4cGVjdCBkYXRhc2V0LmRhdGEuZmllbGRzIHRvIGJlIGFuIGFycmF5Jyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5yb3dzKSkge1xuICAgIGFzc2VydCgnYWRkRGF0YVRvTWFwIEVycm9yOiBleHBlY3QgZGF0YXNldC5kYXRhLnJvd3MgdG8gYmUgYW4gYXJyYXknKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHtmaWVsZHMsIHJvd3MsIGNvbHN9ID0gZGF0YTtcblxuICAvLyBjaGVjayBpZiBhbGwgZmllbGRzIGhhcyBuYW1lLCBmb3JtYXQgYW5kIHR5cGVcbiAgY29uc3QgYWxsVmFsaWQgPSBmaWVsZHMuZXZlcnkoKGYsIGkpID0+IHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgIGFzc2VydChgZmllbGRzIG5lZWRzIHRvIGJlIGFuIGFycmF5IG9mIG9iamVjdCwgYnV0IGZpbmQgJHt0eXBlb2YgZn1gKTtcbiAgICAgIGZpZWxkc1tpXSA9IHtuYW1lOiBgY29sdW1uXyR7aX1gfTtcbiAgICB9XG5cbiAgICBpZiAoIWYubmFtZSkge1xuICAgICAgYXNzZXJ0KGBmaWVsZC5uYW1lIGlzIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGluICR7SlNPTi5zdHJpbmdpZnkoZil9YCk7XG4gICAgICAvLyBhc3NpZ24gYSBuYW1lXG4gICAgICBmaWVsZHNbaV0ubmFtZSA9IGBjb2x1bW5fJHtpfWA7XG4gICAgfVxuXG4gICAgaWYgKCFmLnR5cGUgfHwgIUFMTF9GSUVMRF9UWVBFU1tmLnR5cGVdKSB7XG4gICAgICBhc3NlcnQoYHVua25vd24gZmllbGQgdHlwZSAke2YudHlwZX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWZpZWxkcy5ldmVyeShmaWVsZCA9PiBmaWVsZC5hbmFseXplclR5cGUpKSB7XG4gICAgICBhc3NlcnQoJ2ZpZWxkIG1pc3NpbmcgYW5hbHl6ZXJUeXBlJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdGltZSBmb3JtYXQgaXMgY29ycmVjdCBiYXNlZCBvbiBmaXJzdCAxMCBub3QgZW1wdHkgZWxlbWVudFxuICAgIGlmIChmLnR5cGUgPT09IEFMTF9GSUVMRF9UWVBFUy50aW1lc3RhbXApIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGZpbmROb25FbXB0eVJvd3NBdEZpZWxkKHJvd3MsIGksIDEwKS5tYXAociA9PiAoe3RzOiByW2ldfSkpO1xuICAgICAgY29uc3QgYW5hbHl6ZWRUeXBlID0gQW5hbHl6ZXIuY29tcHV0ZUNvbE1ldGEoc2FtcGxlKVswXTtcbiAgICAgIHJldHVybiBhbmFseXplZFR5cGUgJiYgYW5hbHl6ZWRUeXBlLmNhdGVnb3J5ID09PSAnVElNRScgJiYgYW5hbHl6ZWRUeXBlLmZvcm1hdCA9PT0gZi5mb3JtYXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIGlmIChhbGxWYWxpZCkge1xuICAgIHJldHVybiB7cm93cywgZmllbGRzLCBjb2xzfTtcbiAgfVxuXG4gIC8vIGlmIGFueSBmaWVsZCBoYXMgbWlzc2luZyB0eXBlLCByZWNhbGN1bGF0ZSBpdCBmb3IgZXZlcnlvbmVcbiAgLy8gYmVjYXVzZSB3ZSBzaW1wbHkgbG9zdCBmYWl0aCBpbiBodW1hbml0eVxuICBjb25zdCBzYW1wbGVEYXRhID0gZ2V0U2FtcGxlRm9yVHlwZUFuYWx5emUoe1xuICAgIGZpZWxkczogZmllbGRzLm1hcChmID0+IGYubmFtZSksXG4gICAgcm93c1xuICB9KTtcbiAgY29uc3QgZmllbGRPcmRlciA9IGZpZWxkcy5tYXAoZiA9PiBmLm5hbWUpO1xuICBjb25zdCBtZXRhID0gZ2V0RmllbGRzRnJvbURhdGEoc2FtcGxlRGF0YSwgZmllbGRPcmRlcik7XG4gIGNvbnN0IHVwZGF0ZWRGaWVsZHMgPSBmaWVsZHMubWFwKChmLCBpKSA9PiAoe1xuICAgIC4uLmYsXG4gICAgdHlwZTogbWV0YVtpXS50eXBlLFxuICAgIGZvcm1hdDogbWV0YVtpXS5mb3JtYXQsXG4gICAgYW5hbHl6ZXJUeXBlOiBtZXRhW2ldLmFuYWx5emVyVHlwZVxuICB9KSk7XG5cbiAgcmV0dXJuIHtmaWVsZHM6IHVwZGF0ZWRGaWVsZHMsIHJvd3N9O1xufVxuXG5mdW5jdGlvbiBmaW5kTm9uRW1wdHlSb3dzQXRGaWVsZChyb3dzOiB1bmtub3duW11bXSwgZmllbGRJZHg6IG51bWJlciwgdG90YWw6IG51bWJlcik6IGFueVtdIHtcbiAgY29uc3Qgc2FtcGxlOiBhbnlbXSA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChzYW1wbGUubGVuZ3RoIDwgdG90YWwgJiYgaSA8IHJvd3MubGVuZ3RoKSB7XG4gICAgaWYgKG5vdE51bGxvclVuZGVmaW5lZChyb3dzW2ldPy5bZmllbGRJZHhdKSkge1xuICAgICAgc2FtcGxlLnB1c2gocm93c1tpXSk7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4gc2FtcGxlO1xufVxuLyoqXG4gKiBHZXR0aW5nIHNhbXBsZSBkYXRhIGZvciBhbmFseXppbmcgZmllbGQgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNhbXBsZUZvclR5cGVBbmFseXplKHtcbiAgZmllbGRzLFxuICByb3dzLFxuICBzYW1wbGVDb3VudCA9IDUwXG59OiB7XG4gIGZpZWxkczogc3RyaW5nW107XG4gIHJvd3M6IHVua25vd25bXVtdO1xuICBzYW1wbGVDb3VudD86IG51bWJlcjtcbn0pOiBSb3dEYXRhIHtcbiAgY29uc3QgdG90YWwgPSBNYXRoLm1pbihzYW1wbGVDb3VudCwgcm93cy5sZW5ndGgpO1xuICAvLyBjb25zdCBmaWVsZE9yZGVyID0gZmllbGRzLm1hcChmID0+IGYubmFtZSk7XG4gIGNvbnN0IHNhbXBsZSA9IHJhbmdlKDAsIHRvdGFsLCAxKS5tYXAoZCA9PiAoe30pKTtcblxuICAvLyBjb2xsZWN0IHNhbXBsZSBkYXRhIGZvciBlYWNoIGZpZWxkXG4gIGZpZWxkcy5mb3JFYWNoKChmaWVsZCwgZmllbGRJZHgpID0+IHtcbiAgICAvLyBkYXRhIGNvdW50ZXJcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gc2FtcGxlIGNvdW50ZXJcbiAgICBsZXQgaiA9IDA7XG5cbiAgICB3aGlsZSAoaiA8IHRvdGFsKSB7XG4gICAgICBpZiAoaSA+PSByb3dzLmxlbmd0aCkge1xuICAgICAgICAvLyBpZiBkZXBsZXRlZCBkYXRhIHBvb2xcbiAgICAgICAgc2FtcGxlW2pdW2ZpZWxkXSA9IG51bGw7XG4gICAgICAgIGorKztcbiAgICAgIH0gZWxzZSBpZiAobm90TnVsbG9yVW5kZWZpbmVkKHJvd3NbaV1bZmllbGRJZHhdKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHJvd3NbaV1bZmllbGRJZHhdO1xuICAgICAgICBzYW1wbGVbal1bZmllbGRdID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xuICAgICAgICBqKys7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzYW1wbGU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgc3RyaW5nIGlzIGEgdmFsaWQgV2VsbC1rbm93biBiaW5hcnkgKFdLQikgaW4gSEVYIGZvcm1hdFxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2VsbC1rbm93bl90ZXh0X3JlcHJlc2VudGF0aW9uX29mX2dlb21ldHJ5XG4gKlxuICogQHBhcmFtIHN0ciBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHRydWUgaWYgc3RyaW5nIGlzIGEgdmFsaWQgV0tCIGluIEhFWCBmb3JtYXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4V2tiKHN0cjogc3RyaW5nIHwgbnVsbCk6IGJvb2xlYW4ge1xuICBpZiAoIXN0cikgcmV0dXJuIGZhbHNlO1xuICAvLyBjaGVjayBpZiB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgaXMgZXZlbiBhbmQgaXMgYXQgbGVhc3QgMTAgY2hhcmFjdGVycyBsb25nXG4gIGlmIChzdHIubGVuZ3RoIDwgMTAgfHwgc3RyLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gY2hlY2sgaWYgZmlyc3QgdHdvIGNoYXJhY3RlcnMgYXJlIDAwIG9yIDAxXG4gIGlmICghc3RyLnN0YXJ0c1dpdGgoJzAwJykgJiYgIXN0ci5zdGFydHNXaXRoKCcwMScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGNoZWNrIGlmIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBoZXhcbiAgcmV0dXJuIC9eWzAtOWEtZkEtRl0rJC8udGVzdChzdHIuc2xpY2UoMikpO1xufVxuXG4vKipcbiAqIEFuYWx5emUgZmllbGQgdHlwZXMgZnJvbSBkYXRhIGluIGBzdHJpbmdgIGZvcm1hdCwgZS5nLiB1cGxvYWRlZCBjc3YuXG4gKiBBc3NpZ24gYHR5cGVgLCBgZmllbGRJZHhgIGFuZCBgZm9ybWF0YCAodGltZXN0YW1wIG9ubHkpIHRvIGVhY2ggZmllbGRcbiAqXG4gKiBAcGFyYW0gZGF0YSBhcnJheSBvZiByb3cgb2JqZWN0XG4gKiBAcGFyYW0gZmllbGRPcmRlciBhcnJheSBvZiBmaWVsZCBuYW1lcyBhcyBzdHJpbmdcbiAqIEByZXR1cm5zIGZvcm1hdHRlZCBmaWVsZHNcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IHtnZXRGaWVsZHNGcm9tRGF0YX0gZnJvbSAna2VwbGVyLmdsL3Byb2Nlc3NvcnMnO1xuICogY29uc3QgZGF0YSA9IFt7XG4gKiAgIHRpbWU6ICcyMDE2LTA5LTE3IDAwOjA5OjU1JyxcbiAqICAgdmFsdWU6ICc0JyxcbiAqICAgc3VyZ2U6ICcxLjInLFxuICogICBpc1RyaXA6ICd0cnVlJyxcbiAqICAgemVyb09uZXM6ICcwJ1xuICogfSwge1xuICogICB0aW1lOiAnMjAxNi0wOS0xNyAwMDozMDowOCcsXG4gKiAgIHZhbHVlOiAnMycsXG4gKiAgIHN1cmdlOiBudWxsLFxuICogICBpc1RyaXA6ICdmYWxzZScsXG4gKiAgIHplcm9PbmVzOiAnMSdcbiAqIH0sIHtcbiAqICAgdGltZTogbnVsbCxcbiAqICAgdmFsdWU6ICcyJyxcbiAqICAgc3VyZ2U6ICcxLjMnLFxuICogICBpc1RyaXA6IG51bGwsXG4gKiAgIHplcm9PbmVzOiAnMSdcbiAqIH1dO1xuICpcbiAqIGNvbnN0IGZpZWxkT3JkZXIgPSBbJ3RpbWUnLCAndmFsdWUnLCAnc3VyZ2UnLCAnaXNUcmlwJywgJ3plcm9PbmVzJ107XG4gKiBjb25zdCBmaWVsZHMgPSBnZXRGaWVsZHNGcm9tRGF0YShkYXRhLCBmaWVsZE9yZGVyKTtcbiAqIC8vIGZpZWxkcyA9IFtcbiAqIC8vIHtuYW1lOiAndGltZScsIGZvcm1hdDogJ1lZWVktTS1EIEg6bTpzJywgZmllbGRJZHg6IDEsIHR5cGU6ICd0aW1lc3RhbXAnfSxcbiAqIC8vIHtuYW1lOiAndmFsdWUnLCBmb3JtYXQ6ICcnLCBmaWVsZElkeDogNCwgdHlwZTogJ2ludGVnZXInfSxcbiAqIC8vIHtuYW1lOiAnc3VyZ2UnLCBmb3JtYXQ6ICcnLCBmaWVsZElkeDogNSwgdHlwZTogJ3JlYWwnfSxcbiAqIC8vIHtuYW1lOiAnaXNUcmlwJywgZm9ybWF0OiAnJywgZmllbGRJZHg6IDYsIHR5cGU6ICdib29sZWFuJ30sXG4gKiAvLyB7bmFtZTogJ3plcm9PbmVzJywgZm9ybWF0OiAnJywgZmllbGRJZHg6IDcsIHR5cGU6ICdpbnRlZ2VyJ31dO1xuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkc0Zyb21EYXRhKGRhdGE6IFJvd0RhdGEsIGZpZWxkT3JkZXI6IHN0cmluZ1tdKTogRmllbGRbXSB7XG4gIC8vIGFkZCBhIGNoZWNrIGZvciBlcG9jaCB0aW1lc3RhbXBcbiAgY29uc3QgbWV0YWRhdGEgPSBBbmFseXplci5jb21wdXRlQ29sTWV0YShcbiAgICBkYXRhLFxuICAgIFtcbiAgICAgIHtyZWdleDogLy4qZ2VvanNvbnxhbGxfcG9pbnRzL2csIGRhdGFUeXBlOiAnR0VPTUVUUlknfSxcbiAgICAgIHtyZWdleDogLy4qY2Vuc3VzL2csIGRhdGFUeXBlOiAnU1RSSU5HJ31cbiAgICBdLFxuICAgIHtpZ25vcmVkRGF0YVR5cGVzOiBJR05PUkVfREFUQV9UWVBFU31cbiAgKTtcblxuICBjb25zdCB7ZmllbGRCeUluZGV4fSA9IHJlbmFtZUR1cGxpY2F0ZUZpZWxkcyhmaWVsZE9yZGVyKTtcblxuICBjb25zdCByZXN1bHQgPSBmaWVsZE9yZGVyLm1hcCgoZmllbGQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IGZpZWxkQnlJbmRleFtpbmRleF07XG5cbiAgICBjb25zdCBmaWVsZE1ldGEgPSBtZXRhZGF0YS5maW5kKG0gPT4gbS5rZXkgPT09IGZpZWxkKTtcblxuICAgIC8vIGZpZWxkTWV0YSBjb3VsZCBiZSB1bmRlZmluZWQgaWYgdGhlIGZpZWxkIGhhcyBubyBkYXRhIGFuZCBBbmFseXplci5jb21wdXRlQ29sTWV0YVxuICAgIC8vIHdpbGwgaWdub3JlIHRoZSBmaWVsZC4gSW4gdGhpcyBjYXNlLCB3ZSB3aWxsIHNpbXBseSBhc3NpZ24gdGhlIGZpZWxkIHR5cGUgdG8gU1RSSU5HXG4gICAgLy8gc2luY2UgZHJvcHBpbmcgdGhlIGNvbHVtbiBpbiB0aGUgUm93RGF0YSBjb3VsZCBiZSBleHBlbnNpdmVcbiAgICBsZXQgdHlwZSA9IGZpZWxkTWV0YT8udHlwZSB8fCAnU1RSSU5HJztcbiAgICBjb25zdCBmb3JtYXQgPSBmaWVsZE1ldGE/LmZvcm1hdCB8fCAnJztcblxuICAgIC8vIGNoZWNrIGlmIHN0cmluZyBpcyBoZXggd2tiXG4gICAgaWYgKHR5cGUgPT09IEFuYWx5emVyREFUQV9UWVBFUy5TVFJJTkcpIHtcbiAgICAgIHR5cGUgPSBkYXRhLnNvbWUoZCA9PiBpc0hleFdrYihkW25hbWVdKSkgPyBBbmFseXplckRBVEFfVFlQRVMuR0VPTUVUUlkgOiB0eXBlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lLFxuICAgICAgaWQ6IG5hbWUsXG4gICAgICBkaXNwbGF5TmFtZTogbmFtZSxcbiAgICAgIGZvcm1hdCxcbiAgICAgIGZpZWxkSWR4OiBpbmRleCxcbiAgICAgIHR5cGU6IGFuYWx5emVyVHlwZVRvRmllbGRUeXBlKHR5cGUpLFxuICAgICAgYW5hbHl6ZXJUeXBlOiB0eXBlLFxuICAgICAgdmFsdWVBY2Nlc3NvcjogZGMgPT4gZCA9PiB7XG4gICAgICAgIHJldHVybiBkYy52YWx1ZUF0KGQuaW5kZXgsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIHBhc3MgaW4gYW4gYXJyYXkgb2YgZmllbGQgbmFtZXMsIHJlbmFtZSBkdXBsaWNhdGVkIG9uZVxuICogYW5kIHJldHVybiBhIG1hcCBmcm9tIG9sZCBmaWVsZCBpbmRleCB0byBuZXcgbmFtZVxuICpcbiAqIEBwYXJhbSBmaWVsZE9yZGVyXG4gKiBAcmV0dXJucyBuZXcgZmllbGQgbmFtZSBieSBpbmRleFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuYW1lRHVwbGljYXRlRmllbGRzKFxuICBmaWVsZE9yZGVyOiBzdHJpbmdbXVxuKToge2FsbE5hbWVzOiBzdHJpbmdbXTsgZmllbGRCeUluZGV4OiBzdHJpbmdbXX0ge1xuICByZXR1cm4gZmllbGRPcmRlci5yZWR1Y2U8e2FsbE5hbWVzOiBzdHJpbmdbXTsgZmllbGRCeUluZGV4OiBzdHJpbmdbXX0+KFxuICAgIChhY2N1LCBmaWVsZCwgaSkgPT4ge1xuICAgICAgY29uc3Qge2FsbE5hbWVzfSA9IGFjY3U7XG4gICAgICBsZXQgZmllbGROYW1lID0gZmllbGQ7XG5cbiAgICAgIC8vIGFkZCBhIGNvdW50ZXIgdG8gZHVwbGljYXRlZCBuYW1lc1xuICAgICAgaWYgKGFsbE5hbWVzLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgIHdoaWxlIChhbGxOYW1lcy5pbmNsdWRlcyhgJHtmaWVsZH0tJHtjb3VudGVyfWApKSB7XG4gICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkTmFtZSA9IGAke2ZpZWxkfS0ke2NvdW50ZXJ9YDtcbiAgICAgIH1cblxuICAgICAgYWNjdS5maWVsZEJ5SW5kZXhbaV0gPSBmaWVsZE5hbWU7XG4gICAgICBhY2N1LmFsbE5hbWVzLnB1c2goZmllbGROYW1lKTtcblxuICAgICAgcmV0dXJuIGFjY3U7XG4gICAgfSxcbiAgICB7YWxsTmFtZXM6IFtdLCBmaWVsZEJ5SW5kZXg6IFtdfVxuICApO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdHlwZS1hbmFseXplciBvdXRwdXQgdG8ga2VwbGVyLmdsIGZpZWxkIHR5cGVzXG4gKlxuICogQHBhcmFtIGFUeXBlXG4gKiBAcmV0dXJucyBjb3JyZXNwb25kaW5nIHR5cGUgaW4gYEFMTF9GSUVMRF9UWVBFU2BcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuYWx5emVyVHlwZVRvRmllbGRUeXBlKGFUeXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCB7XG4gICAgREFURSxcbiAgICBUSU1FLFxuICAgIERBVEVUSU1FLFxuICAgIE5VTUJFUixcbiAgICBJTlQsXG4gICAgRkxPQVQsXG4gICAgQk9PTEVBTixcbiAgICBTVFJJTkcsXG4gICAgR0VPTUVUUlksXG4gICAgR0VPTUVUUllfRlJPTV9TVFJJTkcsXG4gICAgUEFJUl9HRU9NRVRSWV9GUk9NX1NUUklORyxcbiAgICBaSVBDT0RFLFxuICAgIEFSUkFZLFxuICAgIE9CSkVDVFxuICB9ID0gQW5hbHl6ZXJEQVRBX1RZUEVTO1xuXG4gIC8vIFRPRE86IHVuIHJlY29nbml6ZWQgdHlwZXNcbiAgLy8gQ1VSUkVOQ1kgUEVSQ0VOVCBOT05FXG4gIHN3aXRjaCAoYVR5cGUpIHtcbiAgICBjYXNlIERBVEU6XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLmRhdGU7XG4gICAgY2FzZSBUSU1FOlxuICAgIGNhc2UgREFURVRJTUU6XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLnRpbWVzdGFtcDtcbiAgICBjYXNlIEZMT0FUOlxuICAgICAgcmV0dXJuIEFMTF9GSUVMRF9UWVBFUy5yZWFsO1xuICAgIGNhc2UgSU5UOlxuICAgICAgcmV0dXJuIEFMTF9GSUVMRF9UWVBFUy5pbnRlZ2VyO1xuICAgIGNhc2UgQk9PTEVBTjpcbiAgICAgIHJldHVybiBBTExfRklFTERfVFlQRVMuYm9vbGVhbjtcbiAgICBjYXNlIEdFT01FVFJZOlxuICAgIGNhc2UgR0VPTUVUUllfRlJPTV9TVFJJTkc6XG4gICAgY2FzZSBQQUlSX0dFT01FVFJZX0ZST01fU1RSSU5HOlxuICAgICAgcmV0dXJuIEFMTF9GSUVMRF9UWVBFUy5nZW9qc29uO1xuICAgIGNhc2UgQVJSQVk6XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLmFycmF5O1xuICAgIGNhc2UgT0JKRUNUOlxuICAgICAgcmV0dXJuIEFMTF9GSUVMRF9UWVBFUy5vYmplY3Q7XG4gICAgY2FzZSBOVU1CRVI6XG4gICAgY2FzZSBTVFJJTkc6XG4gICAgY2FzZSBaSVBDT0RFOlxuICAgICAgcmV0dXJuIEFMTF9GSUVMRF9UWVBFUy5zdHJpbmc7XG4gICAgZGVmYXVsdDpcbiAgICAgIGdsb2JhbENvbnNvbGUud2FybihgVW5zdXBwb3J0ZWQgYW5hbHl6ZXIgdHlwZTogJHthVHlwZX1gKTtcbiAgICAgIHJldHVybiBBTExfRklFTERfVFlQRVMuc3RyaW5nO1xuICB9XG59XG5cbmNvbnN0IFRJTUVfRElTUExBWSA9ICcyMDIwLTA1LTExIDE0OjAwJztcblxuY29uc3QgYWRkVGltZUxhYmVsID0gKGZvcm1hdHM6IFRpbWVMYWJlbEZvcm1hdFtdKSA9PlxuICBmb3JtYXRzLm1hcChmID0+ICh7XG4gICAgLi4uZixcbiAgICBsYWJlbDpcbiAgICAgIGYudHlwZSA9PT0gVE9PTFRJUF9GT1JNQVRfVFlQRVMuREFURV9USU1FIHx8IGYudHlwZSA9PT0gVE9PTFRJUF9GT1JNQVRfVFlQRVMuREFURVxuICAgICAgICA/IGdldEZvcm1hdHRlcihnZXRGb3JtYXRWYWx1ZShmKSkoVElNRV9ESVNQTEFZKVxuICAgICAgICA6IGYubGFiZWxcbiAgfSkpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRGb3JtYXRMYWJlbHMoZmllbGRUeXBlPzogc3RyaW5nKTogVG9vbHRpcEZvcm1hdFtdIHtcbiAgY29uc3QgdG9vbHRpcFR5cGVzID0gKGZpZWxkVHlwZSAmJiBGSUVMRF9PUFRTW2ZpZWxkVHlwZV0uZm9ybWF0LnRvb2x0aXApIHx8IFtdO1xuICBjb25zdCBmb3JtYXRMYWJlbHM6IFRpbWVMYWJlbEZvcm1hdFtdID0gT2JqZWN0LnZhbHVlcyhUT09MVElQX0ZPUk1BVFMpLmZpbHRlcih0ID0+XG4gICAgdG9vbHRpcFR5cGVzLmluY2x1ZGVzKHQudHlwZSlcbiAgKTtcbiAgcmV0dXJuIGFkZFRpbWVMYWJlbChmb3JtYXRMYWJlbHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9ybWF0TGFiZWxzKGZpZWxkczogVG9vbHRpcEZpZWxkc1tdLCBmaWVsZE5hbWU6IHN0cmluZykge1xuICBjb25zdCBmaWVsZFR5cGUgPSBmaWVsZHMuZmluZChmID0+IGYubmFtZSA9PT0gZmllbGROYW1lKT8udHlwZTtcbiAgcmV0dXJuIGdldEZpZWxkRm9ybWF0TGFiZWxzKGZpZWxkVHlwZSk7XG59XG4iXX0=