"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _core = require("@deck.gl/core");

var _constants = _interopRequireDefault(require("@luma.gl/constants"));

var _filterShaderModule = _interopRequireDefault(require("./filter-shader-module"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var VALUE_FILTERED = 1;
var defaultProps = {
  getFiltered: {
    type: 'accessor',
    value: VALUE_FILTERED
  }
};

/**
 * FilterArrowExtension - a deck.gl extension to filter arrow layer
 *
 * A simple extension to filter arrow layer based on the result of CPU filteredIndex,
 * so we can avoid filtering on the raw Arrow table and recreating geometry attributes.
 * Specifically, an attribute `filtered` is added to the layer to indicate whether the feature has been Filtered
 * the shader module is modified to discard the feature if filtered value is 0
 * the accessor getFiltered is used to get the value of `filtered` based on the value `filteredIndex` in Arrowlayer
 */
var FilterArrowExtension = /*#__PURE__*/function (_LayerExtension) {
  (0, _inherits2["default"])(FilterArrowExtension, _LayerExtension);

  var _super = _createSuper(FilterArrowExtension);

  function FilterArrowExtension() {
    (0, _classCallCheck2["default"])(this, FilterArrowExtension);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(FilterArrowExtension, [{
    key: "getShaders",
    value: function getShaders(extension) {
      return {
        modules: [_filterShaderModule["default"]],
        defines: {}
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState(context, extension) {
      var attributeManager = this.getAttributeManager();

      if (attributeManager) {
        attributeManager.add({
          filtered: {
            size: 1,
            type: _constants["default"].FLOAT,
            accessor: 'getFiltered',
            shaderAttributes: {
              filtered: {
                divisor: 0
              },
              instanceFiltered: {
                divisor: 1
              }
            }
          }
        });
      }
    }
  }]);
  return FilterArrowExtension;
}(_core.LayerExtension);

exports["default"] = FilterArrowExtension;
(0, _defineProperty2["default"])(FilterArrowExtension, "defaultProps", defaultProps);
(0, _defineProperty2["default"])(FilterArrowExtension, "extensionName", 'FilterArrowExtension');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZWNrZ2wtZXh0ZW5zaW9ucy9maWx0ZXItYXJyb3ctbGF5ZXIudHMiXSwibmFtZXMiOlsiVkFMVUVfRklMVEVSRUQiLCJkZWZhdWx0UHJvcHMiLCJnZXRGaWx0ZXJlZCIsInR5cGUiLCJ2YWx1ZSIsIkZpbHRlckFycm93RXh0ZW5zaW9uIiwiZXh0ZW5zaW9uIiwibW9kdWxlcyIsInNoYWRlck1vZHVsZSIsImRlZmluZXMiLCJjb250ZXh0IiwiYXR0cmlidXRlTWFuYWdlciIsImdldEF0dHJpYnV0ZU1hbmFnZXIiLCJhZGQiLCJmaWx0ZXJlZCIsInNpemUiLCJHTCIsIkZMT0FUIiwiYWNjZXNzb3IiLCJzaGFkZXJBdHRyaWJ1dGVzIiwiZGl2aXNvciIsImluc3RhbmNlRmlsdGVyZWQiLCJMYXllckV4dGVuc2lvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7O0FBRUE7O0FBRUE7Ozs7OztBQUVBLElBQU1BLGNBQWMsR0FBRyxDQUF2QjtBQUVBLElBQU1DLFlBQVksR0FBRztBQUNuQkMsRUFBQUEsV0FBVyxFQUFFO0FBQUNDLElBQUFBLElBQUksRUFBRSxVQUFQO0FBQW1CQyxJQUFBQSxLQUFLLEVBQUVKO0FBQTFCO0FBRE0sQ0FBckI7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ3FCSyxvQjs7Ozs7Ozs7Ozs7O1dBSW5CLG9CQUFXQyxTQUFYLEVBQTJCO0FBQ3pCLGFBQU87QUFDTEMsUUFBQUEsT0FBTyxFQUFFLENBQUNDLDhCQUFELENBREo7QUFFTEMsUUFBQUEsT0FBTyxFQUFFO0FBRkosT0FBUDtBQUlEOzs7V0FFRCx5QkFBd0RDLE9BQXhELEVBQStFSixTQUEvRSxFQUFnRztBQUM5RixVQUFNSyxnQkFBZ0IsR0FBRyxLQUFLQyxtQkFBTCxFQUF6Qjs7QUFDQSxVQUFJRCxnQkFBSixFQUFzQjtBQUNwQkEsUUFBQUEsZ0JBQWdCLENBQUNFLEdBQWpCLENBQXFCO0FBQ25CQyxVQUFBQSxRQUFRLEVBQUU7QUFDUkMsWUFBQUEsSUFBSSxFQUFFLENBREU7QUFFUlosWUFBQUEsSUFBSSxFQUFFYSxzQkFBR0MsS0FGRDtBQUdSQyxZQUFBQSxRQUFRLEVBQUUsYUFIRjtBQUlSQyxZQUFBQSxnQkFBZ0IsRUFBRTtBQUNoQkwsY0FBQUEsUUFBUSxFQUFFO0FBQ1JNLGdCQUFBQSxPQUFPLEVBQUU7QUFERCxlQURNO0FBSWhCQyxjQUFBQSxnQkFBZ0IsRUFBRTtBQUNoQkQsZ0JBQUFBLE9BQU8sRUFBRTtBQURPO0FBSkY7QUFKVjtBQURTLFNBQXJCO0FBZUQ7QUFDRjs7O0VBOUIrQ0Usb0I7OztpQ0FBN0JqQixvQixrQkFDR0osWTtpQ0FESEksb0IsbUJBRUksc0IiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQge0xheWVyLCBMYXllckV4dGVuc2lvbn0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQge0xheWVyQ29udGV4dH0gZnJvbSAnQGRlY2suZ2wvY29yZS9saWIvbGF5ZXInO1xuaW1wb3J0IEdMIGZyb20gJ0BsdW1hLmdsL2NvbnN0YW50cyc7XG5cbmltcG9ydCBzaGFkZXJNb2R1bGUgZnJvbSAnLi9maWx0ZXItc2hhZGVyLW1vZHVsZSc7XG5cbmNvbnN0IFZBTFVFX0ZJTFRFUkVEID0gMTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBnZXRGaWx0ZXJlZDoge3R5cGU6ICdhY2Nlc3NvcicsIHZhbHVlOiBWQUxVRV9GSUxURVJFRH1cbn07XG5cbmV4cG9ydCB0eXBlIEZpbHRlckFycm93RXh0ZW5zaW9uUHJvcHMgPSB7XG4gIGdldEZpbHRlcmVkPzogKCkgPT4gbnVtYmVyO1xufTtcblxuLyoqXG4gKiBGaWx0ZXJBcnJvd0V4dGVuc2lvbiAtIGEgZGVjay5nbCBleHRlbnNpb24gdG8gZmlsdGVyIGFycm93IGxheWVyXG4gKlxuICogQSBzaW1wbGUgZXh0ZW5zaW9uIHRvIGZpbHRlciBhcnJvdyBsYXllciBiYXNlZCBvbiB0aGUgcmVzdWx0IG9mIENQVSBmaWx0ZXJlZEluZGV4LFxuICogc28gd2UgY2FuIGF2b2lkIGZpbHRlcmluZyBvbiB0aGUgcmF3IEFycm93IHRhYmxlIGFuZCByZWNyZWF0aW5nIGdlb21ldHJ5IGF0dHJpYnV0ZXMuXG4gKiBTcGVjaWZpY2FsbHksIGFuIGF0dHJpYnV0ZSBgZmlsdGVyZWRgIGlzIGFkZGVkIHRvIHRoZSBsYXllciB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBmZWF0dXJlIGhhcyBiZWVuIEZpbHRlcmVkXG4gKiB0aGUgc2hhZGVyIG1vZHVsZSBpcyBtb2RpZmllZCB0byBkaXNjYXJkIHRoZSBmZWF0dXJlIGlmIGZpbHRlcmVkIHZhbHVlIGlzIDBcbiAqIHRoZSBhY2Nlc3NvciBnZXRGaWx0ZXJlZCBpcyB1c2VkIHRvIGdldCB0aGUgdmFsdWUgb2YgYGZpbHRlcmVkYCBiYXNlZCBvbiB0aGUgdmFsdWUgYGZpbHRlcmVkSW5kZXhgIGluIEFycm93bGF5ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsdGVyQXJyb3dFeHRlbnNpb24gZXh0ZW5kcyBMYXllckV4dGVuc2lvbiB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4gIHN0YXRpYyBleHRlbnNpb25OYW1lID0gJ0ZpbHRlckFycm93RXh0ZW5zaW9uJztcblxuICBnZXRTaGFkZXJzKGV4dGVuc2lvbjogYW55KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZHVsZXM6IFtzaGFkZXJNb2R1bGVdLFxuICAgICAgZGVmaW5lczoge31cbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKHRoaXM6IExheWVyPEZpbHRlckFycm93RXh0ZW5zaW9uUHJvcHM+LCBjb250ZXh0OiBMYXllckNvbnRleHQsIGV4dGVuc2lvbjogdGhpcykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcbiAgICBpZiAoYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgICAgICBmaWx0ZXJlZDoge1xuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogR0wuRkxPQVQsXG4gICAgICAgICAgYWNjZXNzb3I6ICdnZXRGaWx0ZXJlZCcsXG4gICAgICAgICAgc2hhZGVyQXR0cmlidXRlczoge1xuICAgICAgICAgICAgZmlsdGVyZWQ6IHtcbiAgICAgICAgICAgICAgZGl2aXNvcjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc3RhbmNlRmlsdGVyZWQ6IHtcbiAgICAgICAgICAgICAgZGl2aXNvcjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iXX0=