"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValueFunc = getValueFunc;
exports.getScaleFunctor = getScaleFunctor;
exports.getGetValue = getGetValue;
exports.getDimensionSortedBins = getDimensionSortedBins;
exports.getDimensionValueDomain = getDimensionValueDomain;
exports.getDimensionScale = getDimensionScale;
exports.getAggregatedData = getAggregatedData;
exports["default"] = exports.defaultDimensions = exports.defaultElevationDimension = exports.defaultColorDimension = exports.defaultAggregation = exports.DECK_AGGREGATION_MAP = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _aggregationLayers = require("@deck.gl/aggregation-layers");

var _window = require("global/window");

var _utils = require("@kepler.gl/utils");

var _constants = require("@kepler.gl/constants");

var _DECK_AGGREGATION_MAP;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DECK_AGGREGATION_MAP = (_DECK_AGGREGATION_MAP = {}, (0, _defineProperty2["default"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.SUM, _constants.AGGREGATION_TYPES.sum), (0, _defineProperty2["default"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MEAN, _constants.AGGREGATION_TYPES.average), (0, _defineProperty2["default"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MIN, _constants.AGGREGATION_TYPES.minimum), (0, _defineProperty2["default"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MAX, _constants.AGGREGATION_TYPES.maximum), _DECK_AGGREGATION_MAP);
exports.DECK_AGGREGATION_MAP = DECK_AGGREGATION_MAP;

function getValueFunc(aggregation, accessor) {
  if (!aggregation || !_aggregationLayers.AGGREGATION_OPERATION[aggregation.toUpperCase()]) {
    _window.console.warn("Aggregation ".concat(aggregation, " is not supported"));
  }

  var op = _aggregationLayers.AGGREGATION_OPERATION[aggregation.toUpperCase()] || _aggregationLayers.AGGREGATION_OPERATION.SUM;

  var keplerOp = DECK_AGGREGATION_MAP[op];
  return function (pts) {
    return (0, _utils.aggregate)(pts.map(accessor), keplerOp);
  };
}

function getScaleFunctor(scaleType) {
  if (!scaleType || !_constants.SCALE_FUNC[scaleType]) {
    _window.console.warn("Scale ".concat(scaleType, " is not supported"));
  }

  return _constants.SCALE_FUNC[scaleType] || _constants.SCALE_FUNC.quantize;
}

function nop() {}

function getGetValue(step, props, dimensionUpdater) {
  var key = dimensionUpdater.key;
  var _step$triggers = step.triggers,
      value = _step$triggers.value,
      weight = _step$triggers.weight,
      aggregation = _step$triggers.aggregation;
  var getValue = props[value.prop];

  if (getValue === null) {
    // If `getValue` is not provided from props, build it with aggregation and weight.
    getValue = getValueFunc(props[aggregation.prop], props[weight.prop]);
  }

  if (getValue) {
    this._setDimensionState(key, {
      getValue: getValue
    });
  }
}

function getDimensionSortedBins(step, props, dimensionUpdater) {
  var key = dimensionUpdater.key;
  var getValue = this.state.dimensions[key].getValue; // @ts-expect-error

  var sortedBins = new _aggregationLayers._BinSorter(this.state.layerData.data || [], {
    getValue: getValue,
    filterData: props._filterData
  });

  this._setDimensionState(key, {
    sortedBins: sortedBins
  });
}

function getDimensionValueDomain(step, props, dimensionUpdater) {
  var key = dimensionUpdater.key;
  var _step$triggers2 = step.triggers,
      lowerPercentile = _step$triggers2.lowerPercentile,
      upperPercentile = _step$triggers2.upperPercentile,
      scaleType = _step$triggers2.scaleType;

  if (!this.state.dimensions[key].sortedBins) {
    // the previous step should set sortedBins, if not, something went wrong
    return;
  } // for log and sqrt scale, returns linear domain by default
  // TODO: support other scale function domain in bin sorter


  var valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);

  this._setDimensionState(key, {
    valueDomain: valueDomain
  });
}

function getDimensionScale(step, props, dimensionUpdater) {
  var key = dimensionUpdater.key;
  var _step$triggers3 = step.triggers,
      domain = _step$triggers3.domain,
      range = _step$triggers3.range,
      scaleType = _step$triggers3.scaleType;
  var onSet = step.onSet;

  if (!this.state.dimensions[key].valueDomain) {
    // the previous step should set valueDomain, if not, something went wrong
    return;
  }

  var dimensionRange = props[range.prop];
  var dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;
  var scaleFunctor = getScaleFunctor(scaleType && props[scaleType.prop])();
  var scaleFunc = scaleFunctor.domain(dimensionDomain).range(dimensionRange);

  if ((0, _typeof2["default"])(onSet) === 'object' && typeof props[onSet.props] === 'function') {
    props[onSet.props](scaleFunc.domain());
  }

  this._setDimensionState(key, {
    scaleFunc: scaleFunc
  });
}

function normalizeResult() {
  var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // support previous hexagonAggregator API
  if (result.hexagons) {
    return Object.assign({
      data: result.hexagons
    }, result);
  } else if (result.layerData) {
    return Object.assign({
      data: result.layerData
    }, result);
  }

  return result;
}

function getAggregatedData(step, props, aggregation, aggregationParams) {
  var aggr = step.triggers.aggregator;
  var aggregator = props[aggr.prop]; // result should contain a data array and other props
  // result = {data: [], ...other props}

  var result = aggregator(props, aggregationParams);
  this.setState({
    layerData: normalizeResult(result)
  });
}

var defaultAggregation = {
  key: 'position',
  updateSteps: [{
    key: 'aggregate',
    triggers: {
      cellSize: {
        prop: 'cellSize'
      },
      position: {
        prop: 'getPosition',
        updateTrigger: 'getPosition'
      },
      aggregator: {
        prop: 'gridAggregator'
      }
    },
    updater: getAggregatedData
  }]
};
exports.defaultAggregation = defaultAggregation;

function getSubLayerAccessor(dimensionState, dimension, layerProps) {
  return function (cell) {
    var sortedBins = dimensionState.sortedBins,
        scaleFunc = dimensionState.scaleFunc;
    var bin = sortedBins.binMap[cell.index];

    if (bin && bin.counts === 0) {
      // no points left in bin after filtering
      return dimension.nullValue;
    }

    var cv = bin && bin.value;
    var domain = scaleFunc.domain();
    var isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1]; // if cell value is outside domain, set alpha to 0

    return isValueInDomain ? scaleFunc(cv) : dimension.nullValue;
  };
}

var defaultColorDimension = {
  key: 'fillColor',
  accessor: 'getFillColor',
  getPickingInfo: function getPickingInfo(dimensionState, cell) {
    if (!cell) {
      return {};
    }

    var sortedBins = dimensionState.sortedBins;
    var colorValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;
    return {
      colorValue: colorValue
    };
  },
  nullValue: [0, 0, 0, 0],
  updateSteps: [{
    key: 'getValue',
    triggers: {
      value: {
        prop: 'getColorValue',
        updateTrigger: 'getColorValue'
      },
      weight: {
        prop: 'getColorWeight',
        updateTrigger: 'getColorWeight'
      },
      aggregation: {
        prop: 'colorAggregation'
      }
    },
    updater: getGetValue
  }, {
    key: 'getBins',
    triggers: {
      _filterData: {
        prop: '_filterData',
        updateTrigger: '_filterData'
      }
    },
    updater: getDimensionSortedBins
  }, {
    key: 'getDomain',
    triggers: {
      lowerPercentile: {
        prop: 'lowerPercentile'
      },
      upperPercentile: {
        prop: 'upperPercentile'
      },
      scaleType: {
        prop: 'colorScaleType'
      }
    },
    updater: getDimensionValueDomain
  }, {
    key: 'getScaleFunc',
    triggers: {
      domain: {
        prop: 'colorDomain'
      },
      range: {
        prop: 'colorRange'
      },
      scaleType: {
        prop: 'colorScaleType'
      }
    },
    onSet: {
      props: 'onSetColorDomain'
    },
    updater: getDimensionScale
  }],
  getSubLayerAccessor: getSubLayerAccessor
};
exports.defaultColorDimension = defaultColorDimension;
var defaultElevationDimension = {
  key: 'elevation',
  accessor: 'getElevation',
  getPickingInfo: function getPickingInfo(dimensionState, cell) {
    if (!cell) {
      return {};
    }

    var sortedBins = dimensionState.sortedBins;
    var elevationValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;
    return {
      elevationValue: elevationValue
    };
  },
  nullValue: -1,
  updateSteps: [{
    key: 'getValue',
    triggers: {
      value: {
        prop: 'getElevationValue',
        updateTrigger: 'getElevationValue'
      },
      weight: {
        prop: 'getElevationWeight',
        updateTrigger: 'getElevationWeight'
      },
      aggregation: {
        prop: 'elevationAggregation'
      }
    },
    updater: getGetValue
  }, {
    key: 'getBins',
    triggers: {
      _filterData: {
        prop: '_filterData',
        updateTrigger: '_filterData'
      }
    },
    updater: getDimensionSortedBins
  }, {
    key: 'getDomain',
    triggers: {
      lowerPercentile: {
        prop: 'elevationLowerPercentile'
      },
      upperPercentile: {
        prop: 'elevationUpperPercentile'
      },
      scaleType: {
        prop: 'elevationScaleType'
      }
    },
    updater: getDimensionValueDomain
  }, {
    key: 'getScaleFunc',
    triggers: {
      domain: {
        prop: 'elevationDomain'
      },
      range: {
        prop: 'elevationRange'
      },
      scaleType: {
        prop: 'elevationScaleType'
      }
    },
    onSet: {
      props: 'onSetElevationDomain'
    },
    updater: getDimensionScale
  }],
  getSubLayerAccessor: getSubLayerAccessor
};
exports.defaultElevationDimension = defaultElevationDimension;
var _defaultDimensions = [defaultColorDimension, defaultElevationDimension];
exports.defaultDimensions = _defaultDimensions;

var CPUAggregator = /*#__PURE__*/function () {
  function CPUAggregator() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, CPUAggregator);
    (0, _defineProperty2["default"])(this, "state", void 0);
    (0, _defineProperty2["default"])(this, "dimensionUpdaters", void 0);
    (0, _defineProperty2["default"])(this, "aggregationUpdater", void 0);
    this.state = _objectSpread({
      layerData: {},
      dimensions: {// color: {
        //   getValue: null,
        //   domain: null,
        //   sortedBins: null,
        //   scaleFunc: nop
        // },
        // elevation: {
        //   getValue: null,
        //   domain: null,
        //   sortedBins: null,
        //   scaleFunc: nop
        // }
      }
    }, opts.initialState);
    this.dimensionUpdaters = {};
    this.aggregationUpdater = opts.aggregation || defaultAggregation;

    this._addDimension(opts.dimensions || _defaultDimensions);
  }

  (0, _createClass2["default"])(CPUAggregator, [{
    key: "updateAllDimensions",
    value: function updateAllDimensions(props) {
      var dimensionChanges = []; // update all dimensions

      for (var dim in this.dimensionUpdaters) {
        var updaters = this._accumulateUpdaters(0, props, this.dimensionUpdaters[dim]);

        dimensionChanges = dimensionChanges.concat(updaters);
      }

      dimensionChanges.forEach(function (f) {
        return typeof f === 'function' && f();
      });
    }
  }, {
    key: "updateAggregation",
    value: function updateAggregation(props, aggregationParams) {
      var updaters = this._accumulateUpdaters(0, props, this.aggregationUpdater);

      updaters.forEach(function (f) {
        return typeof f === 'function' && f(aggregationParams);
      });
    }
  }, {
    key: "updateState",
    value: function updateState(opts, aggregationParams) {
      var oldProps = opts.oldProps,
          props = opts.props,
          changeFlags = opts.changeFlags;
      var dimensionChanges = [];

      if (changeFlags.dataChanged) {
        // if data changed update everything
        this.updateAggregation(props, aggregationParams);
        this.updateAllDimensions(props);
        return this.state;
      }

      var aggregationChanges = this._getAggregationChanges(oldProps, props, changeFlags);

      if (aggregationChanges && aggregationChanges.length) {
        // get aggregatedData
        aggregationChanges.forEach(function (f) {
          return typeof f === 'function' && f(aggregationParams);
        });
        this.updateAllDimensions(props);
      } else {
        // only update dimensions
        dimensionChanges = this._getDimensionChanges(oldProps, props, changeFlags) || [];
        dimensionChanges.forEach(function (f) {
          return typeof f === 'function' && f();
        });
      }

      return this.state;
    } // Update private state

  }, {
    key: "setState",
    value: function setState(updateObject) {
      this.state = Object.assign({}, this.state, updateObject);
    } // Update private state.dimensions

  }, {
    key: "_setDimensionState",
    value: function _setDimensionState(key, updateObject) {
      this.setState({
        dimensions: Object.assign({}, this.state.dimensions, (0, _defineProperty2["default"])({}, key, Object.assign({}, this.state.dimensions[key], updateObject)))
      });
    }
  }, {
    key: "_addAggregation",
    value: function _addAggregation(aggregation) {
      this.aggregationUpdater = aggregation;
    }
  }, {
    key: "_addDimension",
    value: function _addDimension() {
      var _this = this;

      var dimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      dimensions.forEach(function (dimension) {
        var key = dimension.key;
        _this.dimensionUpdaters[key] = dimension;
      });
    }
  }, {
    key: "_needUpdateStep",
    value: function _needUpdateStep(dimensionStep, oldProps, props, changeFlags) {
      // whether need to update current dimension step
      // dimension step is the value, domain, scaleFunction of each dimension
      // each step is an object with properties links to layer prop and whether the prop is
      // controlled by updateTriggers
      return Object.values(dimensionStep.triggers).some(function (item) {
        if (item.updateTrigger) {
          // check based on updateTriggers change first
          return changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);
        } // fallback to direct comparison


        return oldProps[item.prop] !== props[item.prop];
      });
    }
  }, {
    key: "_accumulateUpdaters",
    value: function _accumulateUpdaters(step, props, dimension) {
      var updaters = [];

      for (var i = step; i < dimension.updateSteps.length; i++) {
        var updater = dimension.updateSteps[i].updater;

        if (typeof updater === 'function') {
          updaters.push(updater.bind(this, dimension.updateSteps[i], props, dimension));
        }
      }

      return updaters;
    }
  }, {
    key: "_getAllUpdaters",
    value: function _getAllUpdaters(dimension, oldProps, props, changeFlags) {
      var _this2 = this;

      var updaters = [];
      var needUpdateStep = dimension.updateSteps.findIndex(function (step) {
        return _this2._needUpdateStep(step, oldProps, props, changeFlags);
      });

      if (needUpdateStep > -1) {
        updaters = updaters.concat(this._accumulateUpdaters(needUpdateStep, props, dimension));
      }

      return updaters;
    }
  }, {
    key: "_getAggregationChanges",
    value: function _getAggregationChanges(oldProps, props, changeFlags) {
      var updaters = this._getAllUpdaters(this.aggregationUpdater, oldProps, props, changeFlags);

      return updaters.length ? updaters : null;
    }
  }, {
    key: "_getDimensionChanges",
    value: function _getDimensionChanges(oldProps, props, changeFlags) {
      var updaters = []; // get dimension to be updated

      for (var _key in this.dimensionUpdaters) {
        // return the first triggered updater for each dimension
        var dimension = this.dimensionUpdaters[_key];

        var dimensionUpdaters = this._getAllUpdaters(dimension, oldProps, props, changeFlags);

        updaters = updaters.concat(dimensionUpdaters);
      }

      return updaters.length ? updaters : null;
    }
  }, {
    key: "getUpdateTriggers",
    value: function getUpdateTriggers(props) {
      var _this3 = this;

      var _updateTriggers = props.updateTriggers || {};

      var updateTriggers = {};

      var _loop = function _loop(_key2) {
        var _this3$dimensionUpdat = _this3.dimensionUpdaters[_key2],
            accessor = _this3$dimensionUpdat.accessor,
            updateSteps = _this3$dimensionUpdat.updateSteps; // fold dimension triggers into each accessor

        updateTriggers[accessor] = {};
        updateSteps.forEach(function (step) {
          Object.values(step.triggers || []).forEach(function (_ref) {
            var prop = _ref.prop,
                updateTrigger = _ref.updateTrigger;

            if (updateTrigger) {
              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight
              // and updateTriggers is passed in from layer prop
              // fold the updateTriggers into accessor
              var fromProp = _updateTriggers[updateTrigger];

              if ((0, _typeof2["default"])(fromProp) === 'object' && !Array.isArray(fromProp)) {
                // if updateTrigger is an object spread it
                Object.assign(updateTriggers[accessor], fromProp);
              } else if (fromProp !== undefined) {
                updateTriggers[accessor][prop] = fromProp;
              }
            } else {
              // if prop is not based on updateTrigger
              updateTriggers[accessor][prop] = props[prop];
            }
          });
        });
      };

      for (var _key2 in this.dimensionUpdaters) {
        _loop(_key2);
      }

      return updateTriggers;
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref2, layerProps) {
      var info = _ref2.info;
      var isPicked = info.picked && info.index > -1;
      var object = null;
      var cell = isPicked ? this.state.layerData.data[info.index] : null;

      if (cell) {
        var binInfo = {};

        for (var _key3 in this.dimensionUpdaters) {
          var getPickingInfo = this.dimensionUpdaters[_key3].getPickingInfo;

          if (typeof getPickingInfo === 'function') {
            binInfo = Object.assign({}, binInfo, getPickingInfo(this.state.dimensions[_key3], cell, layerProps));
          }
        }

        object = Object.assign(binInfo, cell, {
          points: cell.filteredPoints || cell.points
        });
      } // add bin  and  to info


      return Object.assign(info, {
        picked: Boolean(object),
        // override object with picked cell
        object: object
      });
    }
  }, {
    key: "getAccessor",
    value: function getAccessor(dimensionKey, layerProps) {
      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {
        return nop;
      }

      return this.dimensionUpdaters[dimensionKey].getSubLayerAccessor(this.state.dimensions[dimensionKey], this.dimensionUpdaters[dimensionKey], layerProps);
    }
  }], [{
    key: "defaultDimensions",
    value: function defaultDimensions() {
      return _defaultDimensions;
    }
  }]);
  return CPUAggregator;
}();

exports["default"] = CPUAggregator;
(0, _defineProperty2["default"])(CPUAggregator, "getDimensionScale", void 0);
CPUAggregator.getDimensionScale = getDimensionScale;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXllci11dGlscy9jcHUtYWdncmVnYXRvci50cyJdLCJuYW1lcyI6WyJERUNLX0FHR1JFR0FUSU9OX01BUCIsIkFHR1JFR0FUSU9OX09QRVJBVElPTiIsIlNVTSIsIkFHR1JFR0FUSU9OX1RZUEVTIiwic3VtIiwiTUVBTiIsImF2ZXJhZ2UiLCJNSU4iLCJtaW5pbXVtIiwiTUFYIiwibWF4aW11bSIsImdldFZhbHVlRnVuYyIsImFnZ3JlZ2F0aW9uIiwiYWNjZXNzb3IiLCJ0b1VwcGVyQ2FzZSIsIkNvbnNvbGUiLCJ3YXJuIiwib3AiLCJrZXBsZXJPcCIsInB0cyIsIm1hcCIsImdldFNjYWxlRnVuY3RvciIsInNjYWxlVHlwZSIsIlNDQUxFX0ZVTkMiLCJxdWFudGl6ZSIsIm5vcCIsImdldEdldFZhbHVlIiwic3RlcCIsInByb3BzIiwiZGltZW5zaW9uVXBkYXRlciIsImtleSIsInRyaWdnZXJzIiwidmFsdWUiLCJ3ZWlnaHQiLCJnZXRWYWx1ZSIsInByb3AiLCJfc2V0RGltZW5zaW9uU3RhdGUiLCJnZXREaW1lbnNpb25Tb3J0ZWRCaW5zIiwic3RhdGUiLCJkaW1lbnNpb25zIiwic29ydGVkQmlucyIsIkJpblNvcnRlciIsImxheWVyRGF0YSIsImRhdGEiLCJmaWx0ZXJEYXRhIiwiX2ZpbHRlckRhdGEiLCJnZXREaW1lbnNpb25WYWx1ZURvbWFpbiIsImxvd2VyUGVyY2VudGlsZSIsInVwcGVyUGVyY2VudGlsZSIsInZhbHVlRG9tYWluIiwiZ2V0VmFsdWVEb21haW5CeVNjYWxlIiwiZ2V0RGltZW5zaW9uU2NhbGUiLCJkb21haW4iLCJyYW5nZSIsIm9uU2V0IiwiZGltZW5zaW9uUmFuZ2UiLCJkaW1lbnNpb25Eb21haW4iLCJzY2FsZUZ1bmN0b3IiLCJzY2FsZUZ1bmMiLCJub3JtYWxpemVSZXN1bHQiLCJyZXN1bHQiLCJoZXhhZ29ucyIsIk9iamVjdCIsImFzc2lnbiIsImdldEFnZ3JlZ2F0ZWREYXRhIiwiYWdncmVnYXRpb25QYXJhbXMiLCJhZ2dyIiwiYWdncmVnYXRvciIsInNldFN0YXRlIiwiZGVmYXVsdEFnZ3JlZ2F0aW9uIiwidXBkYXRlU3RlcHMiLCJjZWxsU2l6ZSIsInBvc2l0aW9uIiwidXBkYXRlVHJpZ2dlciIsInVwZGF0ZXIiLCJnZXRTdWJMYXllckFjY2Vzc29yIiwiZGltZW5zaW9uU3RhdGUiLCJkaW1lbnNpb24iLCJsYXllclByb3BzIiwiY2VsbCIsImJpbiIsImJpbk1hcCIsImluZGV4IiwiY291bnRzIiwibnVsbFZhbHVlIiwiY3YiLCJpc1ZhbHVlSW5Eb21haW4iLCJsZW5ndGgiLCJkZWZhdWx0Q29sb3JEaW1lbnNpb24iLCJnZXRQaWNraW5nSW5mbyIsImNvbG9yVmFsdWUiLCJkZWZhdWx0RWxldmF0aW9uRGltZW5zaW9uIiwiZWxldmF0aW9uVmFsdWUiLCJkZWZhdWx0RGltZW5zaW9ucyIsIkNQVUFnZ3JlZ2F0b3IiLCJvcHRzIiwiaW5pdGlhbFN0YXRlIiwiZGltZW5zaW9uVXBkYXRlcnMiLCJhZ2dyZWdhdGlvblVwZGF0ZXIiLCJfYWRkRGltZW5zaW9uIiwiZGltZW5zaW9uQ2hhbmdlcyIsImRpbSIsInVwZGF0ZXJzIiwiX2FjY3VtdWxhdGVVcGRhdGVycyIsImNvbmNhdCIsImZvckVhY2giLCJmIiwib2xkUHJvcHMiLCJjaGFuZ2VGbGFncyIsImRhdGFDaGFuZ2VkIiwidXBkYXRlQWdncmVnYXRpb24iLCJ1cGRhdGVBbGxEaW1lbnNpb25zIiwiYWdncmVnYXRpb25DaGFuZ2VzIiwiX2dldEFnZ3JlZ2F0aW9uQ2hhbmdlcyIsIl9nZXREaW1lbnNpb25DaGFuZ2VzIiwidXBkYXRlT2JqZWN0IiwiZGltZW5zaW9uU3RlcCIsInZhbHVlcyIsInNvbWUiLCJpdGVtIiwidXBkYXRlVHJpZ2dlcnNDaGFuZ2VkIiwiYWxsIiwiaSIsInB1c2giLCJiaW5kIiwibmVlZFVwZGF0ZVN0ZXAiLCJmaW5kSW5kZXgiLCJfbmVlZFVwZGF0ZVN0ZXAiLCJfZ2V0QWxsVXBkYXRlcnMiLCJfdXBkYXRlVHJpZ2dlcnMiLCJ1cGRhdGVUcmlnZ2VycyIsImZyb21Qcm9wIiwiQXJyYXkiLCJpc0FycmF5IiwidW5kZWZpbmVkIiwiaW5mbyIsImlzUGlja2VkIiwicGlja2VkIiwib2JqZWN0IiwiYmluSW5mbyIsInBvaW50cyIsImZpbHRlcmVkUG9pbnRzIiwiQm9vbGVhbiIsImRpbWVuc2lvbktleSIsImhhc093blByb3BlcnR5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7QUFxRE8sSUFBTUEsb0JBQW9CLHdGQUM5QkMseUNBQXNCQyxHQURRLEVBQ0ZDLDZCQUFrQkMsR0FEaEIsMkRBRTlCSCx5Q0FBc0JJLElBRlEsRUFFREYsNkJBQWtCRyxPQUZqQiwyREFHOUJMLHlDQUFzQk0sR0FIUSxFQUdGSiw2QkFBa0JLLE9BSGhCLDJEQUk5QlAseUNBQXNCUSxHQUpRLEVBSUZOLDZCQUFrQk8sT0FKaEIseUJBQTFCOzs7QUFPQSxTQUFTQyxZQUFULENBQXNCQyxXQUF0QixFQUFtQ0MsUUFBbkMsRUFBNkM7QUFDbEQsTUFBSSxDQUFDRCxXQUFELElBQWdCLENBQUNYLHlDQUFzQlcsV0FBVyxDQUFDRSxXQUFaLEVBQXRCLENBQXJCLEVBQXVFO0FBQ3JFQyxvQkFBUUMsSUFBUix1QkFBNEJKLFdBQTVCO0FBQ0Q7O0FBRUQsTUFBTUssRUFBRSxHQUFHaEIseUNBQXNCVyxXQUFXLENBQUNFLFdBQVosRUFBdEIsS0FBb0RiLHlDQUFzQkMsR0FBckY7O0FBQ0EsTUFBTWdCLFFBQVEsR0FBR2xCLG9CQUFvQixDQUFDaUIsRUFBRCxDQUFyQztBQUVBLFNBQU8sVUFBQUUsR0FBRztBQUFBLFdBQUksc0JBQVVBLEdBQUcsQ0FBQ0MsR0FBSixDQUFRUCxRQUFSLENBQVYsRUFBNkJLLFFBQTdCLENBQUo7QUFBQSxHQUFWO0FBQ0Q7O0FBRU0sU0FBU0csZUFBVCxDQUF5QkMsU0FBekIsRUFBb0M7QUFDekMsTUFBSSxDQUFDQSxTQUFELElBQWMsQ0FBQ0Msc0JBQVdELFNBQVgsQ0FB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ZCxFQUFvQjtBQUN6QkUsUUFBQUEsTUFBTSxFQUFFSyxPQUFPLENBQUNKLE1BQUQsQ0FEVTtBQUV6QjtBQUNBQSxRQUFBQSxNQUFNLEVBQU5BO0FBSHlCLE9BQXBCLENBQVA7QUFLRDs7O1dBRUQscUJBQVlLLFlBQVosRUFBMEJqRSxVQUExQixFQUFzQztBQUNwQyxVQUFJLENBQUMsS0FBS21CLGlCQUFMLENBQXVCK0MsY0FBdkIsQ0FBc0NELFlBQXRDLENBQUwsRUFBMEQ7QUFDeEQsZUFBT3RILEdBQVA7QUFDRDs7QUFDRCxhQUFPLEtBQUt3RSxpQkFBTCxDQUF1QjhDLFlBQXZCLEVBQXFDcEUsbUJBQXJDLENBQ0wsS0FBS3JDLEtBQUwsQ0FBV0MsVUFBWCxDQUFzQndHLFlBQXRCLENBREssRUFFTCxLQUFLOUMsaUJBQUwsQ0FBdUI4QyxZQUF2QixDQUZLLEVBR0xqRSxVQUhLLENBQVA7QUFLRDs7O1dBeE9ELDZCQUEyQjtBQUN6QixhQUFPZSxrQkFBUDtBQUNEOzs7Ozs7aUNBeENrQkMsYTtBQWlSckJBLGFBQWEsQ0FBQzNDLGlCQUFkLEdBQWtDQSxpQkFBbEMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbmltcG9ydCB7QUdHUkVHQVRJT05fT1BFUkFUSU9OLCBfQmluU29ydGVyIGFzIEJpblNvcnRlcn0gZnJvbSAnQGRlY2suZ2wvYWdncmVnYXRpb24tbGF5ZXJzJztcbmltcG9ydCB7Y29uc29sZSBhcyBDb25zb2xlfSBmcm9tICdnbG9iYWwvd2luZG93JztcblxuaW1wb3J0IHthZ2dyZWdhdGV9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtBR0dSRUdBVElPTl9UWVBFUywgU0NBTEVfRlVOQ30gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtSR0JBQ29sb3J9IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBVcGRhdGVyVHlwZSA9ICh0aGlzOiBDUFVBZ2dyZWdhdG9yLCBzdGVwLCBwcm9wcywgZGltZW5zaW9uVXBkYXRlcikgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIEJpbmRlZFVwZGF0ZXJUeXBlID0gKCkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIEFnZ3JlZ2F0ZWRVcGRhdGVyVHlwZSA9IChcbiAgdGhpczogQ1BVQWdncmVnYXRvcixcbiAgc3RlcCxcbiAgcHJvcHMsXG4gIGFnZ3JlZ2F0aW9uLFxuICBhZ2dyZWdhdGlvblBhcmFtc1xuKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgQmluZGVkQWdncmVnYXRlZFVwZGF0ZXJUeXBlID0gKGFnZ3JlZ2F0aW9uUGFyYW1zKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBVcGRhdGVTdGVwc1R5cGUgPSB7XG4gIGtleTogc3RyaW5nO1xuICB0cmlnZ2Vyczoge1xuICAgIFtrZXk6IHN0cmluZ106IHtcbiAgICAgIHByb3A6IHN0cmluZztcbiAgICAgIHVwZGF0ZVRyaWdnZXI/OiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgb25TZXQ/OiB7XG4gICAgcHJvcHM6IHN0cmluZztcbiAgfTtcbiAgdXBkYXRlcjogVXBkYXRlclR5cGU7XG59O1xuXG5leHBvcnQgdHlwZSBEaW1lbnNpb25UeXBlPFZhbHVlVHlwZSA9IGFueT4gPSB7XG4gIGtleTogc3RyaW5nO1xuICBhY2Nlc3Nvcjogc3RyaW5nO1xuICBnZXRQaWNraW5nSW5mbzogKGRpbWVuc2lvblN0YXRlLCBjZWxsLCBsYXllclByb3BzPykgPT4gYW55O1xuICBudWxsVmFsdWU6IFZhbHVlVHlwZTtcbiAgdXBkYXRlU3RlcHM6IFVwZGF0ZVN0ZXBzVHlwZVtdO1xuICBnZXRTdWJMYXllckFjY2Vzc29yO1xufTtcblxuZXhwb3J0IHR5cGUgQWdncmVnYXRpb25VcGRhdGVTdGVwc1R5cGUgPSB7XG4gIGtleTogc3RyaW5nO1xuICB0cmlnZ2Vyczoge1xuICAgIFtrZXk6IHN0cmluZ106IHtcbiAgICAgIHByb3A6IHN0cmluZztcbiAgICAgIHVwZGF0ZVRyaWdnZXI/OiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgdXBkYXRlcjogQWdncmVnYXRlZFVwZGF0ZXJUeXBlO1xufTtcblxuZXhwb3J0IHR5cGUgQWdncmVnYXRpb25UeXBlID0ge1xuICBrZXk6IHN0cmluZztcbiAgdXBkYXRlU3RlcHM6IEFnZ3JlZ2F0aW9uVXBkYXRlU3RlcHNUeXBlW107XG59O1xuXG5leHBvcnQgY29uc3QgREVDS19BR0dSRUdBVElPTl9NQVAgPSB7XG4gIFtBR0dSRUdBVElPTl9PUEVSQVRJT04uU1VNXTogQUdHUkVHQVRJT05fVFlQRVMuc3VtLFxuICBbQUdHUkVHQVRJT05fT1BFUkFUSU9OLk1FQU5dOiBBR0dSRUdBVElPTl9UWVBFUy5hdmVyYWdlLFxuICBbQUdHUkVHQVRJT05fT1BFUkFUSU9OLk1JTl06IEFHR1JFR0FUSU9OX1RZUEVTLm1pbmltdW0sXG4gIFtBR0dSRUdBVElPTl9PUEVSQVRJT04uTUFYXTogQUdHUkVHQVRJT05fVFlQRVMubWF4aW11bVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlRnVuYyhhZ2dyZWdhdGlvbiwgYWNjZXNzb3IpIHtcbiAgaWYgKCFhZ2dyZWdhdGlvbiB8fCAhQUdHUkVHQVRJT05fT1BFUkFUSU9OW2FnZ3JlZ2F0aW9uLnRvVXBwZXJDYXNlKCldKSB7XG4gICAgQ29uc29sZS53YXJuKGBBZ2dyZWdhdGlvbiAke2FnZ3JlZ2F0aW9ufSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gIH1cblxuICBjb25zdCBvcCA9IEFHR1JFR0FUSU9OX09QRVJBVElPTlthZ2dyZWdhdGlvbi50b1VwcGVyQ2FzZSgpXSB8fCBBR0dSRUdBVElPTl9PUEVSQVRJT04uU1VNO1xuICBjb25zdCBrZXBsZXJPcCA9IERFQ0tfQUdHUkVHQVRJT05fTUFQW29wXTtcblxuICByZXR1cm4gcHRzID0+IGFnZ3JlZ2F0ZShwdHMubWFwKGFjY2Vzc29yKSwga2VwbGVyT3ApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGVGdW5jdG9yKHNjYWxlVHlwZSkge1xuICBpZiAoIXNjYWxlVHlwZSB8fCAhU0NBTEVfRlVOQ1tzY2FsZVR5cGVdKSB7XG4gICAgQ29uc29sZS53YXJuKGBTY2FsZSAke3NjYWxlVHlwZX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIHJldHVybiBTQ0FMRV9GVU5DW3NjYWxlVHlwZV0gfHwgU0NBTEVfRlVOQy5xdWFudGl6ZTtcbn1cblxuZnVuY3Rpb24gbm9wKCkge31cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdldFZhbHVlKHRoaXM6IENQVUFnZ3JlZ2F0b3IsIHN0ZXAsIHByb3BzLCBkaW1lbnNpb25VcGRhdGVyKSB7XG4gIGNvbnN0IHtrZXl9ID0gZGltZW5zaW9uVXBkYXRlcjtcbiAgY29uc3Qge3ZhbHVlLCB3ZWlnaHQsIGFnZ3JlZ2F0aW9ufSA9IHN0ZXAudHJpZ2dlcnM7XG5cbiAgbGV0IGdldFZhbHVlID0gcHJvcHNbdmFsdWUucHJvcF07XG5cbiAgaWYgKGdldFZhbHVlID09PSBudWxsKSB7XG4gICAgLy8gSWYgYGdldFZhbHVlYCBpcyBub3QgcHJvdmlkZWQgZnJvbSBwcm9wcywgYnVpbGQgaXQgd2l0aCBhZ2dyZWdhdGlvbiBhbmQgd2VpZ2h0LlxuICAgIGdldFZhbHVlID0gZ2V0VmFsdWVGdW5jKHByb3BzW2FnZ3JlZ2F0aW9uLnByb3BdLCBwcm9wc1t3ZWlnaHQucHJvcF0pO1xuICB9XG5cbiAgaWYgKGdldFZhbHVlKSB7XG4gICAgdGhpcy5fc2V0RGltZW5zaW9uU3RhdGUoa2V5LCB7Z2V0VmFsdWV9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGltZW5zaW9uU29ydGVkQmlucyh0aGlzOiBDUFVBZ2dyZWdhdG9yLCBzdGVwLCBwcm9wcywgZGltZW5zaW9uVXBkYXRlcikge1xuICBjb25zdCB7a2V5fSA9IGRpbWVuc2lvblVwZGF0ZXI7XG4gIGNvbnN0IHtnZXRWYWx1ZX0gPSB0aGlzLnN0YXRlLmRpbWVuc2lvbnNba2V5XTtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBjb25zdCBzb3J0ZWRCaW5zID0gbmV3IEJpblNvcnRlcih0aGlzLnN0YXRlLmxheWVyRGF0YS5kYXRhIHx8IFtdLCB7XG4gICAgZ2V0VmFsdWUsXG4gICAgZmlsdGVyRGF0YTogcHJvcHMuX2ZpbHRlckRhdGFcbiAgfSk7XG4gIHRoaXMuX3NldERpbWVuc2lvblN0YXRlKGtleSwge3NvcnRlZEJpbnN9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpbWVuc2lvblZhbHVlRG9tYWluKHRoaXM6IENQVUFnZ3JlZ2F0b3IsIHN0ZXAsIHByb3BzLCBkaW1lbnNpb25VcGRhdGVyKSB7XG4gIGNvbnN0IHtrZXl9ID0gZGltZW5zaW9uVXBkYXRlcjtcbiAgY29uc3Qge1xuICAgIHRyaWdnZXJzOiB7bG93ZXJQZXJjZW50aWxlLCB1cHBlclBlcmNlbnRpbGUsIHNjYWxlVHlwZX1cbiAgfSA9IHN0ZXA7XG5cbiAgaWYgKCF0aGlzLnN0YXRlLmRpbWVuc2lvbnNba2V5XS5zb3J0ZWRCaW5zKSB7XG4gICAgLy8gdGhlIHByZXZpb3VzIHN0ZXAgc2hvdWxkIHNldCBzb3J0ZWRCaW5zLCBpZiBub3QsIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZm9yIGxvZyBhbmQgc3FydCBzY2FsZSwgcmV0dXJucyBsaW5lYXIgZG9tYWluIGJ5IGRlZmF1bHRcbiAgLy8gVE9ETzogc3VwcG9ydCBvdGhlciBzY2FsZSBmdW5jdGlvbiBkb21haW4gaW4gYmluIHNvcnRlclxuICBjb25zdCB2YWx1ZURvbWFpbiA9IHRoaXMuc3RhdGUuZGltZW5zaW9uc1trZXldLnNvcnRlZEJpbnMuZ2V0VmFsdWVEb21haW5CeVNjYWxlKFxuICAgIHByb3BzW3NjYWxlVHlwZS5wcm9wXSxcbiAgICBbcHJvcHNbbG93ZXJQZXJjZW50aWxlLnByb3BdLCBwcm9wc1t1cHBlclBlcmNlbnRpbGUucHJvcF1dXG4gICk7XG5cbiAgdGhpcy5fc2V0RGltZW5zaW9uU3RhdGUoa2V5LCB7dmFsdWVEb21haW59KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpbWVuc2lvblNjYWxlKHRoaXM6IENQVUFnZ3JlZ2F0b3IsIHN0ZXAsIHByb3BzLCBkaW1lbnNpb25VcGRhdGVyKSB7XG4gIGNvbnN0IHtrZXl9ID0gZGltZW5zaW9uVXBkYXRlcjtcbiAgY29uc3Qge2RvbWFpbiwgcmFuZ2UsIHNjYWxlVHlwZX0gPSBzdGVwLnRyaWdnZXJzO1xuICBjb25zdCB7b25TZXR9ID0gc3RlcDtcbiAgaWYgKCF0aGlzLnN0YXRlLmRpbWVuc2lvbnNba2V5XS52YWx1ZURvbWFpbikge1xuICAgIC8vIHRoZSBwcmV2aW91cyBzdGVwIHNob3VsZCBzZXQgdmFsdWVEb21haW4sIGlmIG5vdCwgc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBkaW1lbnNpb25SYW5nZSA9IHByb3BzW3JhbmdlLnByb3BdO1xuICBjb25zdCBkaW1lbnNpb25Eb21haW4gPSBwcm9wc1tkb21haW4ucHJvcF0gfHwgdGhpcy5zdGF0ZS5kaW1lbnNpb25zW2tleV0udmFsdWVEb21haW47XG5cbiAgY29uc3Qgc2NhbGVGdW5jdG9yID0gZ2V0U2NhbGVGdW5jdG9yKHNjYWxlVHlwZSAmJiBwcm9wc1tzY2FsZVR5cGUucHJvcF0pKCk7XG5cbiAgY29uc3Qgc2NhbGVGdW5jID0gc2NhbGVGdW5jdG9yLmRvbWFpbihkaW1lbnNpb25Eb21haW4pLnJhbmdlKGRpbWVuc2lvblJhbmdlKTtcblxuICBpZiAodHlwZW9mIG9uU2V0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvcHNbb25TZXQucHJvcHNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvcHNbb25TZXQucHJvcHNdKHNjYWxlRnVuYy5kb21haW4oKSk7XG4gIH1cbiAgdGhpcy5fc2V0RGltZW5zaW9uU3RhdGUoa2V5LCB7c2NhbGVGdW5jfSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlc3VsdChyZXN1bHQ6IHtoZXhhZ29ucz87IGxheWVyRGF0YT99ID0ge30pIHtcbiAgLy8gc3VwcG9ydCBwcmV2aW91cyBoZXhhZ29uQWdncmVnYXRvciBBUElcbiAgaWYgKHJlc3VsdC5oZXhhZ29ucykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtkYXRhOiByZXN1bHQuaGV4YWdvbnN9LCByZXN1bHQpO1xuICB9IGVsc2UgaWYgKHJlc3VsdC5sYXllckRhdGEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7ZGF0YTogcmVzdWx0LmxheWVyRGF0YX0sIHJlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWdncmVnYXRlZERhdGEoXG4gIHRoaXM6IENQVUFnZ3JlZ2F0b3IsXG4gIHN0ZXAsXG4gIHByb3BzLFxuICBhZ2dyZWdhdGlvbixcbiAgYWdncmVnYXRpb25QYXJhbXNcbikge1xuICBjb25zdCB7XG4gICAgdHJpZ2dlcnM6IHthZ2dyZWdhdG9yOiBhZ2dyfVxuICB9ID0gc3RlcDtcbiAgY29uc3QgYWdncmVnYXRvciA9IHByb3BzW2FnZ3IucHJvcF07XG5cbiAgLy8gcmVzdWx0IHNob3VsZCBjb250YWluIGEgZGF0YSBhcnJheSBhbmQgb3RoZXIgcHJvcHNcbiAgLy8gcmVzdWx0ID0ge2RhdGE6IFtdLCAuLi5vdGhlciBwcm9wc31cbiAgY29uc3QgcmVzdWx0ID0gYWdncmVnYXRvcihwcm9wcywgYWdncmVnYXRpb25QYXJhbXMpO1xuICB0aGlzLnNldFN0YXRlKHtcbiAgICBsYXllckRhdGE6IG5vcm1hbGl6ZVJlc3VsdChyZXN1bHQpXG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdEFnZ3JlZ2F0aW9uOiBBZ2dyZWdhdGlvblR5cGUgPSB7XG4gIGtleTogJ3Bvc2l0aW9uJyxcbiAgdXBkYXRlU3RlcHM6IFtcbiAgICB7XG4gICAgICBrZXk6ICdhZ2dyZWdhdGUnLFxuICAgICAgdHJpZ2dlcnM6IHtcbiAgICAgICAgY2VsbFNpemU6IHtcbiAgICAgICAgICBwcm9wOiAnY2VsbFNpemUnXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgcHJvcDogJ2dldFBvc2l0aW9uJyxcbiAgICAgICAgICB1cGRhdGVUcmlnZ2VyOiAnZ2V0UG9zaXRpb24nXG4gICAgICAgIH0sXG4gICAgICAgIGFnZ3JlZ2F0b3I6IHtcbiAgICAgICAgICBwcm9wOiAnZ3JpZEFnZ3JlZ2F0b3InXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGVyOiBnZXRBZ2dyZWdhdGVkRGF0YVxuICAgIH1cbiAgXVxufTtcblxuZnVuY3Rpb24gZ2V0U3ViTGF5ZXJBY2Nlc3NvcihkaW1lbnNpb25TdGF0ZSwgZGltZW5zaW9uLCBsYXllclByb3BzKSB7XG4gIHJldHVybiBjZWxsID0+IHtcbiAgICBjb25zdCB7c29ydGVkQmlucywgc2NhbGVGdW5jfSA9IGRpbWVuc2lvblN0YXRlO1xuICAgIGNvbnN0IGJpbiA9IHNvcnRlZEJpbnMuYmluTWFwW2NlbGwuaW5kZXhdO1xuXG4gICAgaWYgKGJpbiAmJiBiaW4uY291bnRzID09PSAwKSB7XG4gICAgICAvLyBubyBwb2ludHMgbGVmdCBpbiBiaW4gYWZ0ZXIgZmlsdGVyaW5nXG4gICAgICByZXR1cm4gZGltZW5zaW9uLm51bGxWYWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBjdiA9IGJpbiAmJiBiaW4udmFsdWU7XG4gICAgY29uc3QgZG9tYWluID0gc2NhbGVGdW5jLmRvbWFpbigpO1xuXG4gICAgY29uc3QgaXNWYWx1ZUluRG9tYWluID0gY3YgPj0gZG9tYWluWzBdICYmIGN2IDw9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG5cbiAgICAvLyBpZiBjZWxsIHZhbHVlIGlzIG91dHNpZGUgZG9tYWluLCBzZXQgYWxwaGEgdG8gMFxuICAgIHJldHVybiBpc1ZhbHVlSW5Eb21haW4gPyBzY2FsZUZ1bmMoY3YpIDogZGltZW5zaW9uLm51bGxWYWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRDb2xvckRpbWVuc2lvbjogRGltZW5zaW9uVHlwZTxSR0JBQ29sb3I+ID0ge1xuICBrZXk6ICdmaWxsQ29sb3InLFxuICBhY2Nlc3NvcjogJ2dldEZpbGxDb2xvcicsXG4gIGdldFBpY2tpbmdJbmZvOiAoZGltZW5zaW9uU3RhdGUsIGNlbGwpID0+IHtcbiAgICBpZiAoIWNlbGwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3Qge3NvcnRlZEJpbnN9ID0gZGltZW5zaW9uU3RhdGU7XG4gICAgY29uc3QgY29sb3JWYWx1ZSA9IHNvcnRlZEJpbnMuYmluTWFwW2NlbGwuaW5kZXhdICYmIHNvcnRlZEJpbnMuYmluTWFwW2NlbGwuaW5kZXhdLnZhbHVlO1xuICAgIHJldHVybiB7Y29sb3JWYWx1ZX07XG4gIH0sXG4gIG51bGxWYWx1ZTogWzAsIDAsIDAsIDBdLFxuICB1cGRhdGVTdGVwczogW1xuICAgIHtcbiAgICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgcHJvcDogJ2dldENvbG9yVmFsdWUnLFxuICAgICAgICAgIHVwZGF0ZVRyaWdnZXI6ICdnZXRDb2xvclZhbHVlJ1xuICAgICAgICB9LFxuICAgICAgICB3ZWlnaHQ6IHtcbiAgICAgICAgICBwcm9wOiAnZ2V0Q29sb3JXZWlnaHQnLFxuICAgICAgICAgIHVwZGF0ZVRyaWdnZXI6ICdnZXRDb2xvcldlaWdodCdcbiAgICAgICAgfSxcbiAgICAgICAgYWdncmVnYXRpb246IHtcbiAgICAgICAgICBwcm9wOiAnY29sb3JBZ2dyZWdhdGlvbidcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZXI6IGdldEdldFZhbHVlXG4gICAgfSxcbiAgICB7XG4gICAgICBrZXk6ICdnZXRCaW5zJyxcbiAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgIF9maWx0ZXJEYXRhOiB7XG4gICAgICAgICAgcHJvcDogJ19maWx0ZXJEYXRhJyxcbiAgICAgICAgICB1cGRhdGVUcmlnZ2VyOiAnX2ZpbHRlckRhdGEnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGVyOiBnZXREaW1lbnNpb25Tb3J0ZWRCaW5zXG4gICAgfSxcbiAgICB7XG4gICAgICBrZXk6ICdnZXREb21haW4nLFxuICAgICAgdHJpZ2dlcnM6IHtcbiAgICAgICAgbG93ZXJQZXJjZW50aWxlOiB7XG4gICAgICAgICAgcHJvcDogJ2xvd2VyUGVyY2VudGlsZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBwZXJQZXJjZW50aWxlOiB7XG4gICAgICAgICAgcHJvcDogJ3VwcGVyUGVyY2VudGlsZSdcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGVUeXBlOiB7cHJvcDogJ2NvbG9yU2NhbGVUeXBlJ31cbiAgICAgIH0sXG4gICAgICB1cGRhdGVyOiBnZXREaW1lbnNpb25WYWx1ZURvbWFpblxuICAgIH0sXG4gICAge1xuICAgICAga2V5OiAnZ2V0U2NhbGVGdW5jJyxcbiAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgIGRvbWFpbjoge3Byb3A6ICdjb2xvckRvbWFpbid9LFxuICAgICAgICByYW5nZToge3Byb3A6ICdjb2xvclJhbmdlJ30sXG4gICAgICAgIHNjYWxlVHlwZToge3Byb3A6ICdjb2xvclNjYWxlVHlwZSd9XG4gICAgICB9LFxuICAgICAgb25TZXQ6IHtcbiAgICAgICAgcHJvcHM6ICdvblNldENvbG9yRG9tYWluJ1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZXI6IGdldERpbWVuc2lvblNjYWxlXG4gICAgfVxuICBdLFxuICBnZXRTdWJMYXllckFjY2Vzc29yXG59O1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdEVsZXZhdGlvbkRpbWVuc2lvbjogRGltZW5zaW9uVHlwZTxudW1iZXI+ID0ge1xuICBrZXk6ICdlbGV2YXRpb24nLFxuICBhY2Nlc3NvcjogJ2dldEVsZXZhdGlvbicsXG4gIGdldFBpY2tpbmdJbmZvOiAoZGltZW5zaW9uU3RhdGUsIGNlbGwpID0+IHtcbiAgICBpZiAoIWNlbGwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3Qge3NvcnRlZEJpbnN9ID0gZGltZW5zaW9uU3RhdGU7XG4gICAgY29uc3QgZWxldmF0aW9uVmFsdWUgPSBzb3J0ZWRCaW5zLmJpbk1hcFtjZWxsLmluZGV4XSAmJiBzb3J0ZWRCaW5zLmJpbk1hcFtjZWxsLmluZGV4XS52YWx1ZTtcbiAgICByZXR1cm4ge2VsZXZhdGlvblZhbHVlfTtcbiAgfSxcbiAgbnVsbFZhbHVlOiAtMSxcbiAgdXBkYXRlU3RlcHM6IFtcbiAgICB7XG4gICAgICBrZXk6ICdnZXRWYWx1ZScsXG4gICAgICB0cmlnZ2Vyczoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHByb3A6ICdnZXRFbGV2YXRpb25WYWx1ZScsXG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcjogJ2dldEVsZXZhdGlvblZhbHVlJ1xuICAgICAgICB9LFxuICAgICAgICB3ZWlnaHQ6IHtcbiAgICAgICAgICBwcm9wOiAnZ2V0RWxldmF0aW9uV2VpZ2h0JyxcbiAgICAgICAgICB1cGRhdGVUcmlnZ2VyOiAnZ2V0RWxldmF0aW9uV2VpZ2h0J1xuICAgICAgICB9LFxuICAgICAgICBhZ2dyZWdhdGlvbjoge1xuICAgICAgICAgIHByb3A6ICdlbGV2YXRpb25BZ2dyZWdhdGlvbidcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZXI6IGdldEdldFZhbHVlXG4gICAgfSxcbiAgICB7XG4gICAgICBrZXk6ICdnZXRCaW5zJyxcbiAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgIF9maWx0ZXJEYXRhOiB7XG4gICAgICAgICAgcHJvcDogJ19maWx0ZXJEYXRhJyxcbiAgICAgICAgICB1cGRhdGVUcmlnZ2VyOiAnX2ZpbHRlckRhdGEnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGVyOiBnZXREaW1lbnNpb25Tb3J0ZWRCaW5zXG4gICAgfSxcbiAgICB7XG4gICAgICBrZXk6ICdnZXREb21haW4nLFxuICAgICAgdHJpZ2dlcnM6IHtcbiAgICAgICAgbG93ZXJQZXJjZW50aWxlOiB7XG4gICAgICAgICAgcHJvcDogJ2VsZXZhdGlvbkxvd2VyUGVyY2VudGlsZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBwZXJQZXJjZW50aWxlOiB7XG4gICAgICAgICAgcHJvcDogJ2VsZXZhdGlvblVwcGVyUGVyY2VudGlsZSdcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGVUeXBlOiB7cHJvcDogJ2VsZXZhdGlvblNjYWxlVHlwZSd9XG4gICAgICB9LFxuICAgICAgdXBkYXRlcjogZ2V0RGltZW5zaW9uVmFsdWVEb21haW5cbiAgICB9LFxuICAgIHtcbiAgICAgIGtleTogJ2dldFNjYWxlRnVuYycsXG4gICAgICB0cmlnZ2Vyczoge1xuICAgICAgICBkb21haW46IHtwcm9wOiAnZWxldmF0aW9uRG9tYWluJ30sXG4gICAgICAgIHJhbmdlOiB7cHJvcDogJ2VsZXZhdGlvblJhbmdlJ30sXG4gICAgICAgIHNjYWxlVHlwZToge3Byb3A6ICdlbGV2YXRpb25TY2FsZVR5cGUnfVxuICAgICAgfSxcbiAgICAgIG9uU2V0OiB7XG4gICAgICAgIHByb3BzOiAnb25TZXRFbGV2YXRpb25Eb21haW4nXG4gICAgICB9LFxuICAgICAgdXBkYXRlcjogZ2V0RGltZW5zaW9uU2NhbGVcbiAgICB9XG4gIF0sXG4gIGdldFN1YkxheWVyQWNjZXNzb3Jcbn07XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0RGltZW5zaW9ucyA9IFtkZWZhdWx0Q29sb3JEaW1lbnNpb24sIGRlZmF1bHRFbGV2YXRpb25EaW1lbnNpb25dO1xuXG5leHBvcnQgdHlwZSBDUFVBZ2dyZWdhdG9yU3RhdGUgPSB7bGF5ZXJEYXRhOiB7ZGF0YT99OyBkaW1lbnNpb25zOiB7fTsgZ2VvSlNPTj87IGNsdXN0ZXJCdWlsZGVyP307XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENQVUFnZ3JlZ2F0b3Ige1xuICBzdGF0aWMgZ2V0RGltZW5zaW9uU2NhbGU6IGFueTtcbiAgc3RhdGU6IENQVUFnZ3JlZ2F0b3JTdGF0ZTtcbiAgZGltZW5zaW9uVXBkYXRlcnM6IHtba2V5OiBzdHJpbmddOiBEaW1lbnNpb25UeXBlfTtcbiAgYWdncmVnYXRpb25VcGRhdGVyOiBBZ2dyZWdhdGlvblR5cGU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgb3B0czoge1xuICAgICAgaW5pdGlhbFN0YXRlPzogQ1BVQWdncmVnYXRvclN0YXRlO1xuICAgICAgZGltZW5zaW9ucz86IERpbWVuc2lvblR5cGVbXTtcbiAgICAgIGFnZ3JlZ2F0aW9uPzogQWdncmVnYXRpb25UeXBlO1xuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbGF5ZXJEYXRhOiB7fSxcbiAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgLy8gY29sb3I6IHtcbiAgICAgICAgLy8gICBnZXRWYWx1ZTogbnVsbCxcbiAgICAgICAgLy8gICBkb21haW46IG51bGwsXG4gICAgICAgIC8vICAgc29ydGVkQmluczogbnVsbCxcbiAgICAgICAgLy8gICBzY2FsZUZ1bmM6IG5vcFxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyBlbGV2YXRpb246IHtcbiAgICAgICAgLy8gICBnZXRWYWx1ZTogbnVsbCxcbiAgICAgICAgLy8gICBkb21haW46IG51bGwsXG4gICAgICAgIC8vICAgc29ydGVkQmluczogbnVsbCxcbiAgICAgICAgLy8gICBzY2FsZUZ1bmM6IG5vcFxuICAgICAgICAvLyB9XG4gICAgICB9LFxuICAgICAgLi4ub3B0cy5pbml0aWFsU3RhdGVcbiAgICB9O1xuXG4gICAgdGhpcy5kaW1lbnNpb25VcGRhdGVycyA9IHt9O1xuICAgIHRoaXMuYWdncmVnYXRpb25VcGRhdGVyID0gb3B0cy5hZ2dyZWdhdGlvbiB8fCBkZWZhdWx0QWdncmVnYXRpb247XG5cbiAgICB0aGlzLl9hZGREaW1lbnNpb24ob3B0cy5kaW1lbnNpb25zIHx8IGRlZmF1bHREaW1lbnNpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0RGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gZGVmYXVsdERpbWVuc2lvbnM7XG4gIH1cblxuICB1cGRhdGVBbGxEaW1lbnNpb25zKHByb3BzKSB7XG4gICAgbGV0IGRpbWVuc2lvbkNoYW5nZXM6IEJpbmRlZFVwZGF0ZXJUeXBlW10gPSBbXTtcbiAgICAvLyB1cGRhdGUgYWxsIGRpbWVuc2lvbnNcbiAgICBmb3IgKGNvbnN0IGRpbSBpbiB0aGlzLmRpbWVuc2lvblVwZGF0ZXJzKSB7XG4gICAgICBjb25zdCB1cGRhdGVycyA9IHRoaXMuX2FjY3VtdWxhdGVVcGRhdGVycygwLCBwcm9wcywgdGhpcy5kaW1lbnNpb25VcGRhdGVyc1tkaW1dKTtcbiAgICAgIGRpbWVuc2lvbkNoYW5nZXMgPSBkaW1lbnNpb25DaGFuZ2VzLmNvbmNhdCh1cGRhdGVycyk7XG4gICAgfVxuXG4gICAgZGltZW5zaW9uQ2hhbmdlcy5mb3JFYWNoKGYgPT4gdHlwZW9mIGYgPT09ICdmdW5jdGlvbicgJiYgZigpKTtcbiAgfVxuXG4gIHVwZGF0ZUFnZ3JlZ2F0aW9uKHByb3BzLCBhZ2dyZWdhdGlvblBhcmFtcykge1xuICAgIGNvbnN0IHVwZGF0ZXJzID0gdGhpcy5fYWNjdW11bGF0ZVVwZGF0ZXJzKDAsIHByb3BzLCB0aGlzLmFnZ3JlZ2F0aW9uVXBkYXRlcik7XG4gICAgdXBkYXRlcnMuZm9yRWFjaChmID0+IHR5cGVvZiBmID09PSAnZnVuY3Rpb24nICYmIGYoYWdncmVnYXRpb25QYXJhbXMpKTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKG9wdHMsIGFnZ3JlZ2F0aW9uUGFyYW1zKSB7XG4gICAgY29uc3Qge29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9ID0gb3B0cztcbiAgICBsZXQgZGltZW5zaW9uQ2hhbmdlczogQmluZGVkVXBkYXRlclR5cGVbXSA9IFtdO1xuXG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAvLyBpZiBkYXRhIGNoYW5nZWQgdXBkYXRlIGV2ZXJ5dGhpbmdcbiAgICAgIHRoaXMudXBkYXRlQWdncmVnYXRpb24ocHJvcHMsIGFnZ3JlZ2F0aW9uUGFyYW1zKTtcbiAgICAgIHRoaXMudXBkYXRlQWxsRGltZW5zaW9ucyhwcm9wcyk7XG5cbiAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICAgIH1cblxuICAgIGNvbnN0IGFnZ3JlZ2F0aW9uQ2hhbmdlcyA9IHRoaXMuX2dldEFnZ3JlZ2F0aW9uQ2hhbmdlcyhvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzKTtcblxuICAgIGlmIChhZ2dyZWdhdGlvbkNoYW5nZXMgJiYgYWdncmVnYXRpb25DaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgLy8gZ2V0IGFnZ3JlZ2F0ZWREYXRhXG4gICAgICBhZ2dyZWdhdGlvbkNoYW5nZXMuZm9yRWFjaChmID0+IHR5cGVvZiBmID09PSAnZnVuY3Rpb24nICYmIGYoYWdncmVnYXRpb25QYXJhbXMpKTtcbiAgICAgIHRoaXMudXBkYXRlQWxsRGltZW5zaW9ucyhwcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9ubHkgdXBkYXRlIGRpbWVuc2lvbnNcbiAgICAgIGRpbWVuc2lvbkNoYW5nZXMgPSB0aGlzLl9nZXREaW1lbnNpb25DaGFuZ2VzKG9sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3MpIHx8IFtdO1xuICAgICAgZGltZW5zaW9uQ2hhbmdlcy5mb3JFYWNoKGYgPT4gdHlwZW9mIGYgPT09ICdmdW5jdGlvbicgJiYgZigpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBwcml2YXRlIHN0YXRlXG4gIHNldFN0YXRlKHVwZGF0ZU9iamVjdCkge1xuICAgIHRoaXMuc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLCB1cGRhdGVPYmplY3QpO1xuICB9XG5cbiAgLy8gVXBkYXRlIHByaXZhdGUgc3RhdGUuZGltZW5zaW9uc1xuICBfc2V0RGltZW5zaW9uU3RhdGUoa2V5LCB1cGRhdGVPYmplY3QpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRpbWVuc2lvbnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuZGltZW5zaW9ucywge1xuICAgICAgICBba2V5XTogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5kaW1lbnNpb25zW2tleV0sIHVwZGF0ZU9iamVjdClcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cblxuICBfYWRkQWdncmVnYXRpb24oYWdncmVnYXRpb246IEFnZ3JlZ2F0aW9uVHlwZSkge1xuICAgIHRoaXMuYWdncmVnYXRpb25VcGRhdGVyID0gYWdncmVnYXRpb247XG4gIH1cblxuICBfYWRkRGltZW5zaW9uKGRpbWVuc2lvbnM6IERpbWVuc2lvblR5cGVbXSA9IFtdKSB7XG4gICAgZGltZW5zaW9ucy5mb3JFYWNoKGRpbWVuc2lvbiA9PiB7XG4gICAgICBjb25zdCB7a2V5fSA9IGRpbWVuc2lvbjtcbiAgICAgIHRoaXMuZGltZW5zaW9uVXBkYXRlcnNba2V5XSA9IGRpbWVuc2lvbjtcbiAgICB9KTtcbiAgfVxuXG4gIF9uZWVkVXBkYXRlU3RlcChcbiAgICBkaW1lbnNpb25TdGVwOiBVcGRhdGVTdGVwc1R5cGUgfCBBZ2dyZWdhdGlvblVwZGF0ZVN0ZXBzVHlwZSxcbiAgICBvbGRQcm9wcyxcbiAgICBwcm9wcyxcbiAgICBjaGFuZ2VGbGFnc1xuICApIHtcbiAgICAvLyB3aGV0aGVyIG5lZWQgdG8gdXBkYXRlIGN1cnJlbnQgZGltZW5zaW9uIHN0ZXBcbiAgICAvLyBkaW1lbnNpb24gc3RlcCBpcyB0aGUgdmFsdWUsIGRvbWFpbiwgc2NhbGVGdW5jdGlvbiBvZiBlYWNoIGRpbWVuc2lvblxuICAgIC8vIGVhY2ggc3RlcCBpcyBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGxpbmtzIHRvIGxheWVyIHByb3AgYW5kIHdoZXRoZXIgdGhlIHByb3AgaXNcbiAgICAvLyBjb250cm9sbGVkIGJ5IHVwZGF0ZVRyaWdnZXJzXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZGltZW5zaW9uU3RlcC50cmlnZ2Vycykuc29tZShpdGVtID0+IHtcbiAgICAgIGlmIChpdGVtLnVwZGF0ZVRyaWdnZXIpIHtcbiAgICAgICAgLy8gY2hlY2sgYmFzZWQgb24gdXBkYXRlVHJpZ2dlcnMgY2hhbmdlIGZpcnN0XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkICYmXG4gICAgICAgICAgKGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZC5hbGwgfHxcbiAgICAgICAgICAgIGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZFtpdGVtLnVwZGF0ZVRyaWdnZXJdKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gZmFsbGJhY2sgdG8gZGlyZWN0IGNvbXBhcmlzb25cbiAgICAgIHJldHVybiBvbGRQcm9wc1tpdGVtLnByb3BdICE9PSBwcm9wc1tpdGVtLnByb3BdO1xuICAgIH0pO1xuICB9XG5cbiAgX2FjY3VtdWxhdGVVcGRhdGVyczxVcGRhdGVyT2JqZWN0VHlwZSBleHRlbmRzIERpbWVuc2lvblR5cGUgfCBBZ2dyZWdhdGlvblR5cGU+KFxuICAgIHN0ZXAsXG4gICAgcHJvcHMsXG4gICAgZGltZW5zaW9uOiBVcGRhdGVyT2JqZWN0VHlwZVxuICApIHtcbiAgICB0eXBlIExvY2FsVXBkYXRlclR5cGUgPSBVcGRhdGVyT2JqZWN0VHlwZSBleHRlbmRzIERpbWVuc2lvblR5cGVcbiAgICAgID8gQmluZGVkVXBkYXRlclR5cGVcbiAgICAgIDogQmluZGVkQWdncmVnYXRlZFVwZGF0ZXJUeXBlO1xuICAgIGNvbnN0IHVwZGF0ZXJzOiBMb2NhbFVwZGF0ZXJUeXBlW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gc3RlcDsgaSA8IGRpbWVuc2lvbi51cGRhdGVTdGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdXBkYXRlciA9IGRpbWVuc2lvbi51cGRhdGVTdGVwc1tpXS51cGRhdGVyO1xuICAgICAgaWYgKHR5cGVvZiB1cGRhdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHVwZGF0ZXJzLnB1c2goXG4gICAgICAgICAgdXBkYXRlci5iaW5kKHRoaXMsIGRpbWVuc2lvbi51cGRhdGVTdGVwc1tpXSwgcHJvcHMsIGRpbWVuc2lvbikgYXMgTG9jYWxVcGRhdGVyVHlwZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVycztcbiAgfVxuXG4gIF9nZXRBbGxVcGRhdGVyczxVcGRhdGVyT2JqZWN0VHlwZSBleHRlbmRzIERpbWVuc2lvblR5cGUgfCBBZ2dyZWdhdGlvblR5cGU+KFxuICAgIGRpbWVuc2lvbjogVXBkYXRlck9iamVjdFR5cGUsXG4gICAgb2xkUHJvcHMsXG4gICAgcHJvcHMsXG4gICAgY2hhbmdlRmxhZ3NcbiAgKSB7XG4gICAgdHlwZSBMb2NhbFVwZGF0ZXJUeXBlID0gVXBkYXRlck9iamVjdFR5cGUgZXh0ZW5kcyBEaW1lbnNpb25UeXBlXG4gICAgICA/IEJpbmRlZFVwZGF0ZXJUeXBlXG4gICAgICA6IEJpbmRlZEFnZ3JlZ2F0ZWRVcGRhdGVyVHlwZTtcbiAgICBsZXQgdXBkYXRlcnM6IExvY2FsVXBkYXRlclR5cGVbXSA9IFtdO1xuICAgIGNvbnN0IG5lZWRVcGRhdGVTdGVwID0gZGltZW5zaW9uLnVwZGF0ZVN0ZXBzLmZpbmRJbmRleChzdGVwID0+XG4gICAgICB0aGlzLl9uZWVkVXBkYXRlU3RlcChzdGVwLCBvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzKVxuICAgICk7XG5cbiAgICBpZiAobmVlZFVwZGF0ZVN0ZXAgPiAtMSkge1xuICAgICAgdXBkYXRlcnMgPSB1cGRhdGVycy5jb25jYXQodGhpcy5fYWNjdW11bGF0ZVVwZGF0ZXJzKG5lZWRVcGRhdGVTdGVwLCBwcm9wcywgZGltZW5zaW9uKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZXJzO1xuICB9XG5cbiAgX2dldEFnZ3JlZ2F0aW9uQ2hhbmdlcyhvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzKSB7XG4gICAgY29uc3QgdXBkYXRlcnMgPSB0aGlzLl9nZXRBbGxVcGRhdGVycyh0aGlzLmFnZ3JlZ2F0aW9uVXBkYXRlciwgb2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFncyk7XG4gICAgcmV0dXJuIHVwZGF0ZXJzLmxlbmd0aCA/IHVwZGF0ZXJzIDogbnVsbDtcbiAgfVxuXG4gIF9nZXREaW1lbnNpb25DaGFuZ2VzKG9sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3MpIHtcbiAgICBsZXQgdXBkYXRlcnM6IEJpbmRlZFVwZGF0ZXJUeXBlW10gPSBbXTtcblxuICAgIC8vIGdldCBkaW1lbnNpb24gdG8gYmUgdXBkYXRlZFxuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZGltZW5zaW9uVXBkYXRlcnMpIHtcbiAgICAgIC8vIHJldHVybiB0aGUgZmlyc3QgdHJpZ2dlcmVkIHVwZGF0ZXIgZm9yIGVhY2ggZGltZW5zaW9uXG4gICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmRpbWVuc2lvblVwZGF0ZXJzW2tleV07XG4gICAgICBjb25zdCBkaW1lbnNpb25VcGRhdGVycyA9IHRoaXMuX2dldEFsbFVwZGF0ZXJzKGRpbWVuc2lvbiwgb2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFncyk7XG4gICAgICB1cGRhdGVycyA9IHVwZGF0ZXJzLmNvbmNhdChkaW1lbnNpb25VcGRhdGVycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZXJzLmxlbmd0aCA/IHVwZGF0ZXJzIDogbnVsbDtcbiAgfVxuXG4gIGdldFVwZGF0ZVRyaWdnZXJzKHByb3BzKSB7XG4gICAgY29uc3QgX3VwZGF0ZVRyaWdnZXJzID0gcHJvcHMudXBkYXRlVHJpZ2dlcnMgfHwge307XG4gICAgY29uc3QgdXBkYXRlVHJpZ2dlcnMgPSB7fTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZGltZW5zaW9uVXBkYXRlcnMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWNjZXNzb3IsXG4gICAgICAgIHVwZGF0ZVN0ZXBzXG4gICAgICB9OiB7YWNjZXNzb3I7IHVwZGF0ZVN0ZXBzOiBVcGRhdGVTdGVwc1R5cGVbXX0gPSB0aGlzLmRpbWVuc2lvblVwZGF0ZXJzW2tleV07XG4gICAgICAvLyBmb2xkIGRpbWVuc2lvbiB0cmlnZ2VycyBpbnRvIGVhY2ggYWNjZXNzb3JcbiAgICAgIHVwZGF0ZVRyaWdnZXJzW2FjY2Vzc29yXSA9IHt9O1xuXG4gICAgICB1cGRhdGVTdGVwcy5mb3JFYWNoKHN0ZXAgPT4ge1xuICAgICAgICBPYmplY3QudmFsdWVzKHN0ZXAudHJpZ2dlcnMgfHwgW10pLmZvckVhY2goKHtwcm9wLCB1cGRhdGVUcmlnZ2VyfSkgPT4ge1xuICAgICAgICAgIGlmICh1cGRhdGVUcmlnZ2VyKSB7XG4gICAgICAgICAgICAvLyBpZiBwcm9wIGlzIGJhc2VkIG9uIHVwZGF0ZVRyaWdnZXIgZS5nLiBnZXRDb2xvclZhbHVlLCBnZXRDb2xvcldlaWdodFxuICAgICAgICAgICAgLy8gYW5kIHVwZGF0ZVRyaWdnZXJzIGlzIHBhc3NlZCBpbiBmcm9tIGxheWVyIHByb3BcbiAgICAgICAgICAgIC8vIGZvbGQgdGhlIHVwZGF0ZVRyaWdnZXJzIGludG8gYWNjZXNzb3JcbiAgICAgICAgICAgIGNvbnN0IGZyb21Qcm9wID0gX3VwZGF0ZVRyaWdnZXJzW3VwZGF0ZVRyaWdnZXJdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcm9tUHJvcCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoZnJvbVByb3ApKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHVwZGF0ZVRyaWdnZXIgaXMgYW4gb2JqZWN0IHNwcmVhZCBpdFxuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHVwZGF0ZVRyaWdnZXJzW2FjY2Vzc29yXSwgZnJvbVByb3ApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmcm9tUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZVRyaWdnZXJzW2FjY2Vzc29yXVtwcm9wXSA9IGZyb21Qcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBwcm9wIGlzIG5vdCBiYXNlZCBvbiB1cGRhdGVUcmlnZ2VyXG4gICAgICAgICAgICB1cGRhdGVUcmlnZ2Vyc1thY2Nlc3Nvcl1bcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZVRyaWdnZXJzO1xuICB9XG5cbiAgZ2V0UGlja2luZ0luZm8oe2luZm99LCBsYXllclByb3BzKSB7XG4gICAgY29uc3QgaXNQaWNrZWQgPSBpbmZvLnBpY2tlZCAmJiBpbmZvLmluZGV4ID4gLTE7XG4gICAgbGV0IG9iamVjdCA9IG51bGw7XG4gICAgY29uc3QgY2VsbCA9IGlzUGlja2VkID8gdGhpcy5zdGF0ZS5sYXllckRhdGEuZGF0YVtpbmZvLmluZGV4XSA6IG51bGw7XG4gICAgaWYgKGNlbGwpIHtcbiAgICAgIGxldCBiaW5JbmZvID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmRpbWVuc2lvblVwZGF0ZXJzKSB7XG4gICAgICAgIGNvbnN0IHtnZXRQaWNraW5nSW5mb30gPSB0aGlzLmRpbWVuc2lvblVwZGF0ZXJzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0UGlja2luZ0luZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBiaW5JbmZvID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgYmluSW5mbyxcbiAgICAgICAgICAgIGdldFBpY2tpbmdJbmZvKHRoaXMuc3RhdGUuZGltZW5zaW9uc1trZXldLCBjZWxsLCBsYXllclByb3BzKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb2JqZWN0ID0gT2JqZWN0LmFzc2lnbihiaW5JbmZvLCBjZWxsLCB7XG4gICAgICAgIHBvaW50czogY2VsbC5maWx0ZXJlZFBvaW50cyB8fCBjZWxsLnBvaW50c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJpbiAgYW5kICB0byBpbmZvXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oaW5mbywge1xuICAgICAgcGlja2VkOiBCb29sZWFuKG9iamVjdCksXG4gICAgICAvLyBvdmVycmlkZSBvYmplY3Qgd2l0aCBwaWNrZWQgY2VsbFxuICAgICAgb2JqZWN0XG4gICAgfSk7XG4gIH1cblxuICBnZXRBY2Nlc3NvcihkaW1lbnNpb25LZXksIGxheWVyUHJvcHMpIHtcbiAgICBpZiAoIXRoaXMuZGltZW5zaW9uVXBkYXRlcnMuaGFzT3duUHJvcGVydHkoZGltZW5zaW9uS2V5KSkge1xuICAgICAgcmV0dXJuIG5vcDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uVXBkYXRlcnNbZGltZW5zaW9uS2V5XS5nZXRTdWJMYXllckFjY2Vzc29yKFxuICAgICAgdGhpcy5zdGF0ZS5kaW1lbnNpb25zW2RpbWVuc2lvbktleV0sXG4gICAgICB0aGlzLmRpbWVuc2lvblVwZGF0ZXJzW2RpbWVuc2lvbktleV0sXG4gICAgICBsYXllclByb3BzXG4gICAgKTtcbiAgfVxufVxuXG5DUFVBZ2dyZWdhdG9yLmdldERpbWVuc2lvblNjYWxlID0gZ2V0RGltZW5zaW9uU2NhbGU7XG4iXX0=