"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assignPointPairToLayerColumn = assignPointPairToLayerColumn;
exports.getGeojsonLayerMetaFromArrow = getGeojsonLayerMetaFromArrow;
exports.isLayerHoveredFromArrow = isLayerHoveredFromArrow;
exports.getHoveredObjectFromArrow = getHoveredObjectFromArrow;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _arrow = require("@loaders.gl/arrow");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function assignPointPairToLayerColumn(pair, hasAlt) {
  var _pair$pair = pair.pair,
      lat = _pair$pair.lat,
      lng = _pair$pair.lng,
      alt = _pair$pair.alt;

  if (!hasAlt) {
    return {
      lat: lat,
      lng: lng
    };
  }

  var defaultAltColumn = {
    value: null,
    fieldIdx: -1,
    optional: true
  };
  return {
    lat: lat,
    lng: lng,
    altitude: alt ? _objectSpread(_objectSpread({}, defaultAltColumn), alt) : defaultAltColumn
  };
}

function getGeojsonLayerMetaFromArrow(_ref) {
  var _arrowField$metadata;

  var dataContainer = _ref.dataContainer,
      getGeoColumn = _ref.getGeoColumn,
      getGeoField = _ref.getGeoField,
      chunkIndex = _ref.chunkIndex;
  var geoColumn = getGeoColumn(dataContainer);
  var arrowField = getGeoField(dataContainer);
  var encoding = arrowField === null || arrowField === void 0 ? void 0 : (_arrowField$metadata = arrowField.metadata) === null || _arrowField$metadata === void 0 ? void 0 : _arrowField$metadata.get('ARROW:extension:name');

  var options = _objectSpread(_objectSpread({}, chunkIndex !== undefined && chunkIndex >= 0 ? {
    chunkIndex: chunkIndex,
    chunkOffset: geoColumn.data[0].length * chunkIndex
  } : {}), {}, {
    triangulate: true,
    calculateMeanCenters: true
  }); // create binary data from arrow data for GeoJsonLayer


  var _getBinaryGeometriesF = (0, _arrow.getBinaryGeometriesFromArrow)(geoColumn, encoding, options),
      binaryGeometries = _getBinaryGeometriesF.binaryGeometries,
      featureTypes = _getBinaryGeometriesF.featureTypes,
      bounds = _getBinaryGeometriesF.bounds,
      meanCenters = _getBinaryGeometriesF.meanCenters; // since there is no feature.properties.radius, we set fixedRadius to false


  var fixedRadius = false;
  return {
    dataToFeature: binaryGeometries,
    featureTypes: featureTypes,
    bounds: bounds,
    fixedRadius: fixedRadius,
    centroids: meanCenters
  };
}

function isLayerHoveredFromArrow(objectInfo, layerId) {
  // there could be multiple deck.gl layers created from multiple chunks in arrow table
  // the objectInfo.layer id should be `${this.id}-${i}`
  if (objectInfo !== null && objectInfo !== void 0 && objectInfo.picked) {
    var _objectInfo$layer, _objectInfo$layer$pro;

    var deckLayerId = objectInfo === null || objectInfo === void 0 ? void 0 : (_objectInfo$layer = objectInfo.layer) === null || _objectInfo$layer === void 0 ? void 0 : (_objectInfo$layer$pro = _objectInfo$layer.props) === null || _objectInfo$layer$pro === void 0 ? void 0 : _objectInfo$layer$pro.id;
    return deckLayerId.startsWith(layerId);
  }

  return false;
}

function getHoveredObjectFromArrow(objectInfo, dataContainer, layerId, columnAccessor, fieldAccessor) {
  // hover object returns the index of the object in the data array
  // NOTE: this could be done in Deck.gl getPickingInfo(params) and binaryToGeojson()
  if (isLayerHoveredFromArrow(objectInfo, layerId) && objectInfo.index >= 0 && dataContainer) {
    var _field$metadata;

    var col = columnAccessor(dataContainer);
    var rawGeometry = col === null || col === void 0 ? void 0 : col.get(objectInfo.index);
    var field = fieldAccessor(dataContainer);
    var encoding = field === null || field === void 0 ? void 0 : (_field$metadata = field.metadata) === null || _field$metadata === void 0 ? void 0 : _field$metadata.get('ARROW:extension:name');
    var hoveredFeature = (0, _arrow.parseGeometryFromArrow)(rawGeometry, encoding);
    var properties = dataContainer.rowAsArray(objectInfo.index).reduce(function (prev, cur, i) {
      var _dataContainer$getFie;

      var fieldName = dataContainer === null || dataContainer === void 0 ? void 0 : (_dataContainer$getFie = dataContainer.getField) === null || _dataContainer$getFie === void 0 ? void 0 : _dataContainer$getFie.call(dataContainer, i).name;

      if (fieldName !== field.name) {
        prev[fieldName] = cur;
      }

      return prev;
    }, {});
    return hoveredFeature ? {
      type: 'Feature',
      geometry: hoveredFeature,
      properties: _objectSpread(_objectSpread({}, properties), {}, {
        index: objectInfo.index
      })
    } : null;
  }

  return null;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9sYXllci11dGlscy50cyJdLCJuYW1lcyI6WyJhc3NpZ25Qb2ludFBhaXJUb0xheWVyQ29sdW1uIiwicGFpciIsImhhc0FsdCIsImxhdCIsImxuZyIsImFsdCIsImRlZmF1bHRBbHRDb2x1bW4iLCJ2YWx1ZSIsImZpZWxkSWR4Iiwib3B0aW9uYWwiLCJhbHRpdHVkZSIsImdldEdlb2pzb25MYXllck1ldGFGcm9tQXJyb3ciLCJkYXRhQ29udGFpbmVyIiwiZ2V0R2VvQ29sdW1uIiwiZ2V0R2VvRmllbGQiLCJjaHVua0luZGV4IiwiZ2VvQ29sdW1uIiwiYXJyb3dGaWVsZCIsImVuY29kaW5nIiwibWV0YWRhdGEiLCJnZXQiLCJvcHRpb25zIiwidW5kZWZpbmVkIiwiY2h1bmtPZmZzZXQiLCJkYXRhIiwibGVuZ3RoIiwidHJpYW5ndWxhdGUiLCJjYWxjdWxhdGVNZWFuQ2VudGVycyIsImJpbmFyeUdlb21ldHJpZXMiLCJmZWF0dXJlVHlwZXMiLCJib3VuZHMiLCJtZWFuQ2VudGVycyIsImZpeGVkUmFkaXVzIiwiZGF0YVRvRmVhdHVyZSIsImNlbnRyb2lkcyIsImlzTGF5ZXJIb3ZlcmVkRnJvbUFycm93Iiwib2JqZWN0SW5mbyIsImxheWVySWQiLCJwaWNrZWQiLCJkZWNrTGF5ZXJJZCIsImxheWVyIiwicHJvcHMiLCJpZCIsInN0YXJ0c1dpdGgiLCJnZXRIb3ZlcmVkT2JqZWN0RnJvbUFycm93IiwiY29sdW1uQWNjZXNzb3IiLCJmaWVsZEFjY2Vzc29yIiwiaW5kZXgiLCJjb2wiLCJyYXdHZW9tZXRyeSIsImZpZWxkIiwiaG92ZXJlZEZlYXR1cmUiLCJwcm9wZXJ0aWVzIiwicm93QXNBcnJheSIsInJlZHVjZSIsInByZXYiLCJjdXIiLCJpIiwiZmllbGROYW1lIiwiZ2V0RmllbGQiLCJuYW1lIiwidHlwZSIsImdlb21ldHJ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQU9BOzs7Ozs7QUFRTyxTQUFTQSw0QkFBVCxDQUFzQ0MsSUFBdEMsRUFBdURDLE1BQXZELEVBQXdFO0FBQUEsbUJBQ3JERCxJQUFJLENBQUNBLElBRGdEO0FBQUEsTUFDdEVFLEdBRHNFLGNBQ3RFQSxHQURzRTtBQUFBLE1BQ2pFQyxHQURpRSxjQUNqRUEsR0FEaUU7QUFBQSxNQUM1REMsR0FENEQsY0FDNURBLEdBRDREOztBQUU3RSxNQUFJLENBQUNILE1BQUwsRUFBYTtBQUNYLFdBQU87QUFBQ0MsTUFBQUEsR0FBRyxFQUFIQSxHQUFEO0FBQU1DLE1BQUFBLEdBQUcsRUFBSEE7QUFBTixLQUFQO0FBQ0Q7O0FBRUQsTUFBTUUsZ0JBQWdCLEdBQUc7QUFBQ0MsSUFBQUEsS0FBSyxFQUFFLElBQVI7QUFBY0MsSUFBQUEsUUFBUSxFQUFFLENBQUMsQ0FBekI7QUFBNEJDLElBQUFBLFFBQVEsRUFBRTtBQUF0QyxHQUF6QjtBQUVBLFNBQU87QUFDTE4sSUFBQUEsR0FBRyxFQUFIQSxHQURLO0FBRUxDLElBQUFBLEdBQUcsRUFBSEEsR0FGSztBQUdMTSxJQUFBQSxRQUFRLEVBQUVMLEdBQUcsbUNBQU9DLGdCQUFQLEdBQTRCRCxHQUE1QixJQUFtQ0M7QUFIM0MsR0FBUDtBQUtEOztBQVVNLFNBQVNLLDRCQUFULE9BVW1CO0FBQUE7O0FBQUEsTUFUeEJDLGFBU3dCLFFBVHhCQSxhQVN3QjtBQUFBLE1BUnhCQyxZQVF3QixRQVJ4QkEsWUFRd0I7QUFBQSxNQVB4QkMsV0FPd0IsUUFQeEJBLFdBT3dCO0FBQUEsTUFOeEJDLFVBTXdCLFFBTnhCQSxVQU13QjtBQUN4QixNQUFNQyxTQUFTLEdBQUdILFlBQVksQ0FBQ0QsYUFBRCxDQUE5QjtBQUNBLE1BQU1LLFVBQVUsR0FBR0gsV0FBVyxDQUFDRixhQUFELENBQTlCO0FBRUEsTUFBTU0sUUFBUSxHQUFHRCxVQUFILGFBQUdBLFVBQUgsK0NBQUdBLFVBQVUsQ0FBRUUsUUFBZix5REFBRyxxQkFBc0JDLEdBQXRCLENBQTBCLHNCQUExQixDQUFqQjs7QUFDQSxNQUFNQyxPQUF5QyxtQ0FDekNOLFVBQVUsS0FBS08sU0FBZixJQUE0QlAsVUFBVSxJQUFJLENBQTFDLEdBQ0E7QUFDRUEsSUFBQUEsVUFBVSxFQUFWQSxVQURGO0FBRUVRLElBQUFBLFdBQVcsRUFBRVAsU0FBUyxDQUFDUSxJQUFWLENBQWUsQ0FBZixFQUFrQkMsTUFBbEIsR0FBMkJWO0FBRjFDLEdBREEsR0FLQSxFQU55QztBQU83Q1csSUFBQUEsV0FBVyxFQUFFLElBUGdDO0FBUTdDQyxJQUFBQSxvQkFBb0IsRUFBRTtBQVJ1QixJQUEvQyxDQUx3QixDQWV4Qjs7O0FBZndCLDhCQWdCc0MseUNBQzVEWCxTQUQ0RCxFQUU1REUsUUFGNEQsRUFHNURHLE9BSDRELENBaEJ0QztBQUFBLE1BZ0JqQk8sZ0JBaEJpQix5QkFnQmpCQSxnQkFoQmlCO0FBQUEsTUFnQkNDLFlBaEJELHlCQWdCQ0EsWUFoQkQ7QUFBQSxNQWdCZUMsTUFoQmYseUJBZ0JlQSxNQWhCZjtBQUFBLE1BZ0J1QkMsV0FoQnZCLHlCQWdCdUJBLFdBaEJ2QixFQXNCeEI7OztBQUNBLE1BQU1DLFdBQVcsR0FBRyxLQUFwQjtBQUVBLFNBQU87QUFDTEMsSUFBQUEsYUFBYSxFQUFFTCxnQkFEVjtBQUVMQyxJQUFBQSxZQUFZLEVBQVpBLFlBRks7QUFHTEMsSUFBQUEsTUFBTSxFQUFOQSxNQUhLO0FBSUxFLElBQUFBLFdBQVcsRUFBWEEsV0FKSztBQUtMRSxJQUFBQSxTQUFTLEVBQUVIO0FBTE4sR0FBUDtBQU9EOztBQUVNLFNBQVNJLHVCQUFULENBQWlDQyxVQUFqQyxFQUE2Q0MsT0FBN0MsRUFBdUU7QUFDNUU7QUFDQTtBQUNBLE1BQUlELFVBQUosYUFBSUEsVUFBSixlQUFJQSxVQUFVLENBQUVFLE1BQWhCLEVBQXdCO0FBQUE7O0FBQ3RCLFFBQU1DLFdBQVcsR0FBR0gsVUFBSCxhQUFHQSxVQUFILDRDQUFHQSxVQUFVLENBQUVJLEtBQWYsK0VBQUcsa0JBQW1CQyxLQUF0QiwwREFBRyxzQkFBMEJDLEVBQTlDO0FBQ0EsV0FBT0gsV0FBVyxDQUFDSSxVQUFaLENBQXVCTixPQUF2QixDQUFQO0FBQ0Q7O0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7O0FBRU0sU0FBU08seUJBQVQsQ0FDTFIsVUFESyxFQUVMeEIsYUFGSyxFQUdMeUIsT0FISyxFQUlMUSxjQUpLLEVBS0xDLGFBTEssRUFNVztBQUNoQjtBQUNBO0FBQ0EsTUFBSVgsdUJBQXVCLENBQUNDLFVBQUQsRUFBYUMsT0FBYixDQUF2QixJQUFnREQsVUFBVSxDQUFDVyxLQUFYLElBQW9CLENBQXBFLElBQXlFbkMsYUFBN0UsRUFBNEY7QUFBQTs7QUFDMUYsUUFBTW9DLEdBQUcsR0FBR0gsY0FBYyxDQUFDakMsYUFBRCxDQUExQjtBQUNBLFFBQU1xQyxXQUFXLEdBQUdELEdBQUgsYUFBR0EsR0FBSCx1QkFBR0EsR0FBRyxDQUFFNUIsR0FBTCxDQUFTZ0IsVUFBVSxDQUFDVyxLQUFwQixDQUFwQjtBQUVBLFFBQU1HLEtBQUssR0FBR0osYUFBYSxDQUFDbEMsYUFBRCxDQUEzQjtBQUNBLFFBQU1NLFFBQVEsR0FBR2dDLEtBQUgsYUFBR0EsS0FBSCwwQ0FBR0EsS0FBSyxDQUFFL0IsUUFBVixvREFBRyxnQkFBaUJDLEdBQWpCLENBQXFCLHNCQUFyQixDQUFqQjtBQUVBLFFBQU0rQixjQUFjLEdBQUcsbUNBQXVCRixXQUF2QixFQUFvQy9CLFFBQXBDLENBQXZCO0FBRUEsUUFBTWtDLFVBQVUsR0FBR3hDLGFBQWEsQ0FBQ3lDLFVBQWQsQ0FBeUJqQixVQUFVLENBQUNXLEtBQXBDLEVBQTJDTyxNQUEzQyxDQUFrRCxVQUFDQyxJQUFELEVBQU9DLEdBQVAsRUFBWUMsQ0FBWixFQUFrQjtBQUFBOztBQUNyRixVQUFNQyxTQUFTLEdBQUc5QyxhQUFILGFBQUdBLGFBQUgsZ0RBQUdBLGFBQWEsQ0FBRStDLFFBQWxCLDBEQUFHLDJCQUFBL0MsYUFBYSxFQUFhNkMsQ0FBYixDQUFiLENBQTZCRyxJQUEvQzs7QUFDQSxVQUFJRixTQUFTLEtBQUtSLEtBQUssQ0FBQ1UsSUFBeEIsRUFBOEI7QUFDNUJMLFFBQUFBLElBQUksQ0FBQ0csU0FBRCxDQUFKLEdBQWtCRixHQUFsQjtBQUNEOztBQUNELGFBQU9ELElBQVA7QUFDRCxLQU5rQixFQU1oQixFQU5nQixDQUFuQjtBQVFBLFdBQU9KLGNBQWMsR0FDakI7QUFDRVUsTUFBQUEsSUFBSSxFQUFFLFNBRFI7QUFFRUMsTUFBQUEsUUFBUSxFQUFFWCxjQUZaO0FBR0VDLE1BQUFBLFVBQVUsa0NBQ0xBLFVBREs7QUFFUkwsUUFBQUEsS0FBSyxFQUFFWCxVQUFVLENBQUNXO0FBRlY7QUFIWixLQURpQixHQVNqQixJQVRKO0FBVUQ7O0FBQ0QsU0FBTyxJQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuaW1wb3J0IHtGZWF0dXJlLCBCQm94fSBmcm9tICdnZW9qc29uJztcbmltcG9ydCB7RmllbGQsIEZpZWxkUGFpcn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0RhdGFDb250YWluZXJJbnRlcmZhY2V9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtcbiAgZ2V0QmluYXJ5R2VvbWV0cmllc0Zyb21BcnJvdyxcbiAgcGFyc2VHZW9tZXRyeUZyb21BcnJvdyxcbiAgQmluYXJ5R2VvbWV0cmllc0Zyb21BcnJvd09wdGlvbnNcbn0gZnJvbSAnQGxvYWRlcnMuZ2wvYXJyb3cnO1xuXG5pbXBvcnQge0RlY2tHbEdlb1R5cGVzLCBHZW9qc29uRGF0YU1hcHN9IGZyb20gJy4vZ2VvanNvbi1sYXllci9nZW9qc29uLXV0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnblBvaW50UGFpclRvTGF5ZXJDb2x1bW4ocGFpcjogRmllbGRQYWlyLCBoYXNBbHQ6IGJvb2xlYW4pIHtcbiAgY29uc3Qge2xhdCwgbG5nLCBhbHR9ID0gcGFpci5wYWlyO1xuICBpZiAoIWhhc0FsdCkge1xuICAgIHJldHVybiB7bGF0LCBsbmd9O1xuICB9XG5cbiAgY29uc3QgZGVmYXVsdEFsdENvbHVtbiA9IHt2YWx1ZTogbnVsbCwgZmllbGRJZHg6IC0xLCBvcHRpb25hbDogdHJ1ZX07XG5cbiAgcmV0dXJuIHtcbiAgICBsYXQsXG4gICAgbG5nLFxuICAgIGFsdGl0dWRlOiBhbHQgPyB7Li4uZGVmYXVsdEFsdENvbHVtbiwgLi4uYWx0fSA6IGRlZmF1bHRBbHRDb2x1bW5cbiAgfTtcbn1cblxuZXhwb3J0IHR5cGUgR2VvanNvbkxheWVyTWV0YVByb3BzID0ge1xuICBkYXRhVG9GZWF0dXJlOiBHZW9qc29uRGF0YU1hcHM7XG4gIGZlYXR1cmVUeXBlczogRGVja0dsR2VvVHlwZXM7XG4gIGJvdW5kczogQkJveCB8IG51bGw7XG4gIGZpeGVkUmFkaXVzOiBib29sZWFuO1xuICBjZW50cm9pZHM/OiBBcnJheTxudW1iZXJbXSB8IG51bGw+O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdlb2pzb25MYXllck1ldGFGcm9tQXJyb3coe1xuICBkYXRhQ29udGFpbmVyLFxuICBnZXRHZW9Db2x1bW4sXG4gIGdldEdlb0ZpZWxkLFxuICBjaHVua0luZGV4XG59OiB7XG4gIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2U7XG4gIGdldEdlb0NvbHVtbjogKGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2UpID0+IHVua25vd247XG4gIGdldEdlb0ZpZWxkOiAoZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZSkgPT4gRmllbGQgfCBudWxsO1xuICBjaHVua0luZGV4PzogbnVtYmVyO1xufSk6IEdlb2pzb25MYXllck1ldGFQcm9wcyB7XG4gIGNvbnN0IGdlb0NvbHVtbiA9IGdldEdlb0NvbHVtbihkYXRhQ29udGFpbmVyKSBhcyBhcnJvdy5WZWN0b3I7XG4gIGNvbnN0IGFycm93RmllbGQgPSBnZXRHZW9GaWVsZChkYXRhQ29udGFpbmVyKTtcblxuICBjb25zdCBlbmNvZGluZyA9IGFycm93RmllbGQ/Lm1ldGFkYXRhPy5nZXQoJ0FSUk9XOmV4dGVuc2lvbjpuYW1lJyk7XG4gIGNvbnN0IG9wdGlvbnM6IEJpbmFyeUdlb21ldHJpZXNGcm9tQXJyb3dPcHRpb25zID0ge1xuICAgIC4uLihjaHVua0luZGV4ICE9PSB1bmRlZmluZWQgJiYgY2h1bmtJbmRleCA+PSAwXG4gICAgICA/IHtcbiAgICAgICAgICBjaHVua0luZGV4LFxuICAgICAgICAgIGNodW5rT2Zmc2V0OiBnZW9Db2x1bW4uZGF0YVswXS5sZW5ndGggKiBjaHVua0luZGV4XG4gICAgICAgIH1cbiAgICAgIDoge30pLFxuICAgIHRyaWFuZ3VsYXRlOiB0cnVlLFxuICAgIGNhbGN1bGF0ZU1lYW5DZW50ZXJzOiB0cnVlXG4gIH07XG4gIC8vIGNyZWF0ZSBiaW5hcnkgZGF0YSBmcm9tIGFycm93IGRhdGEgZm9yIEdlb0pzb25MYXllclxuICBjb25zdCB7YmluYXJ5R2VvbWV0cmllcywgZmVhdHVyZVR5cGVzLCBib3VuZHMsIG1lYW5DZW50ZXJzfSA9IGdldEJpbmFyeUdlb21ldHJpZXNGcm9tQXJyb3coXG4gICAgZ2VvQ29sdW1uLFxuICAgIGVuY29kaW5nLFxuICAgIG9wdGlvbnNcbiAgKTtcblxuICAvLyBzaW5jZSB0aGVyZSBpcyBubyBmZWF0dXJlLnByb3BlcnRpZXMucmFkaXVzLCB3ZSBzZXQgZml4ZWRSYWRpdXMgdG8gZmFsc2VcbiAgY29uc3QgZml4ZWRSYWRpdXMgPSBmYWxzZTtcblxuICByZXR1cm4ge1xuICAgIGRhdGFUb0ZlYXR1cmU6IGJpbmFyeUdlb21ldHJpZXMsXG4gICAgZmVhdHVyZVR5cGVzLFxuICAgIGJvdW5kcyxcbiAgICBmaXhlZFJhZGl1cyxcbiAgICBjZW50cm9pZHM6IG1lYW5DZW50ZXJzXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xheWVySG92ZXJlZEZyb21BcnJvdyhvYmplY3RJbmZvLCBsYXllcklkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgLy8gdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGVjay5nbCBsYXllcnMgY3JlYXRlZCBmcm9tIG11bHRpcGxlIGNodW5rcyBpbiBhcnJvdyB0YWJsZVxuICAvLyB0aGUgb2JqZWN0SW5mby5sYXllciBpZCBzaG91bGQgYmUgYCR7dGhpcy5pZH0tJHtpfWBcbiAgaWYgKG9iamVjdEluZm8/LnBpY2tlZCkge1xuICAgIGNvbnN0IGRlY2tMYXllcklkID0gb2JqZWN0SW5mbz8ubGF5ZXI/LnByb3BzPy5pZDtcbiAgICByZXR1cm4gZGVja0xheWVySWQuc3RhcnRzV2l0aChsYXllcklkKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlcmVkT2JqZWN0RnJvbUFycm93KFxuICBvYmplY3RJbmZvLFxuICBkYXRhQ29udGFpbmVyLFxuICBsYXllcklkLFxuICBjb2x1bW5BY2Nlc3NvcixcbiAgZmllbGRBY2Nlc3NvclxuKTogRmVhdHVyZSB8IG51bGwge1xuICAvLyBob3ZlciBvYmplY3QgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG9iamVjdCBpbiB0aGUgZGF0YSBhcnJheVxuICAvLyBOT1RFOiB0aGlzIGNvdWxkIGJlIGRvbmUgaW4gRGVjay5nbCBnZXRQaWNraW5nSW5mbyhwYXJhbXMpIGFuZCBiaW5hcnlUb0dlb2pzb24oKVxuICBpZiAoaXNMYXllckhvdmVyZWRGcm9tQXJyb3cob2JqZWN0SW5mbywgbGF5ZXJJZCkgJiYgb2JqZWN0SW5mby5pbmRleCA+PSAwICYmIGRhdGFDb250YWluZXIpIHtcbiAgICBjb25zdCBjb2wgPSBjb2x1bW5BY2Nlc3NvcihkYXRhQ29udGFpbmVyKTtcbiAgICBjb25zdCByYXdHZW9tZXRyeSA9IGNvbD8uZ2V0KG9iamVjdEluZm8uaW5kZXgpO1xuXG4gICAgY29uc3QgZmllbGQgPSBmaWVsZEFjY2Vzc29yKGRhdGFDb250YWluZXIpO1xuICAgIGNvbnN0IGVuY29kaW5nID0gZmllbGQ/Lm1ldGFkYXRhPy5nZXQoJ0FSUk9XOmV4dGVuc2lvbjpuYW1lJyk7XG5cbiAgICBjb25zdCBob3ZlcmVkRmVhdHVyZSA9IHBhcnNlR2VvbWV0cnlGcm9tQXJyb3cocmF3R2VvbWV0cnksIGVuY29kaW5nKTtcblxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkYXRhQ29udGFpbmVyLnJvd0FzQXJyYXkob2JqZWN0SW5mby5pbmRleCkucmVkdWNlKChwcmV2LCBjdXIsIGkpID0+IHtcbiAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGRhdGFDb250YWluZXI/LmdldEZpZWxkPy4oaSkubmFtZTtcbiAgICAgIGlmIChmaWVsZE5hbWUgIT09IGZpZWxkLm5hbWUpIHtcbiAgICAgICAgcHJldltmaWVsZE5hbWVdID0gY3VyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIGhvdmVyZWRGZWF0dXJlXG4gICAgICA/IHtcbiAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgZ2VvbWV0cnk6IGhvdmVyZWRGZWF0dXJlLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIC4uLnByb3BlcnRpZXMsXG4gICAgICAgICAgICBpbmRleDogb2JqZWN0SW5mby5pbmRleFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgOiBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuIl19