"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.getChildPos = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _lodash2 = _interopRequireDefault(require("lodash.isequal"));

var _exenv = require("exenv");

var _styledComponents = require("styled-components");

var _context = require("../context");

var _reactModal = _interopRequireDefault(require("react-modal"));

var _window = _interopRequireDefault(require("global/window"));

var _styles = require("@kepler.gl/styles");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var listeners = {};

var startListening = function startListening() {
  return Object.keys(listeners).forEach(function (key) {
    return listeners[key]();
  });
};

var getPageOffset = function getPageOffset() {
  return {
    x: _window["default"].pageXOffset !== undefined ? _window["default"].pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft,
    y: _window["default"].pageYOffset !== undefined ? _window["default"].pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop
  };
};

var addEventListeners = function addEventListeners() {
  if (document && document.body) document.body.addEventListener('mousewheel', (0, _lodash["default"])(startListening, 100, {
    leading: true
  }));

  _window["default"].addEventListener('resize', (0, _lodash["default"])(startListening, 50, {
    leading: true
  }));
};

var getChildPos = function getChildPos(_ref) {
  var offsets = _ref.offsets,
      rect = _ref.rect,
      childRect = _ref.childRect,
      pageOffset = _ref.pageOffset,
      padding = _ref.padding;
  var topOffset = offsets.topOffset,
      leftOffset = offsets.leftOffset,
      rightOffset = offsets.rightOffset;
  var anchorLeft = leftOffset !== undefined;

  var pos = _objectSpread({
    top: pageOffset.y + rect.top + (topOffset || 0)
  }, anchorLeft ? {
    left: pageOffset.x + rect.left + leftOffset
  } : {
    right: _window["default"].innerWidth - rect.right - pageOffset.x + (rightOffset || 0)
  });

  var leftOrRight = anchorLeft ? 'left' : 'right';

  if (pos[leftOrRight] && pos[leftOrRight] < 0) {
    pos[leftOrRight] = padding;
  } else if (pos[leftOrRight] && pos[leftOrRight] + childRect.width > _window["default"].innerWidth) {
    pos[leftOrRight] = _window["default"].innerWidth - childRect.width - padding;
  }

  if (pos.top < 0) {
    pos.top = padding;
  } else if (pos.top + childRect.height > _window["default"].innerHeight) {
    pos.top = _window["default"].innerHeight - childRect.height - padding;
  }

  return pos;
};

exports.getChildPos = getChildPos;

if (_exenv.canUseDOM) {
  if (document.body) {
    addEventListeners();
  } else {
    document.addEventListener('DOMContentLoaded', addEventListeners);
  }
}

var listenerIdCounter = 0;

function subscribe(fn) {
  listenerIdCounter += 1;
  var id = listenerIdCounter;
  listeners[id] = fn;
  return function () {
    return delete listeners[id];
  };
}

var defaultModalStyle = {
  content: {
    top: 0,
    left: 0,
    border: 0,
    right: 'auto',
    bottom: 'auto',
    padding: '0px 0px 0px 0px'
  },
  overlay: {
    right: 'auto',
    bottom: 'auto',
    width: '100vw',
    height: '100vh',
    backgroundColor: 'rgba(0, 0, 0, 0)'
  }
};
var WINDOW_PAD = 40;

var noop = function noop() {};

var Portaled = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(Portaled, _Component);

  var _super = _createSuper(Portaled);

  function Portaled() {
    var _this;

    (0, _classCallCheck2["default"])(this, Portaled);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "state", {
      pos: null,
      isVisible: false
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "unsubscribe", undefined);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_unmounted", false);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "element", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "child", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handleScroll", function () {
      if (_this.child.current && _this.element.current) {
        var rect = _this.element.current.getBoundingClientRect();

        var childRect = _this.child.current.getBoundingClientRect();

        var pageOffset = getPageOffset();
        var _this$props = _this.props,
            topOffset = _this$props.top,
            _this$props$left = _this$props.left,
            leftOffset = _this$props$left === void 0 ? 0 : _this$props$left,
            rightOffset = _this$props.right;
        var pos = getChildPos({
          offsets: {
            topOffset: topOffset,
            leftOffset: leftOffset,
            rightOffset: rightOffset
          },
          rect: rect,
          childRect: childRect,
          pageOffset: pageOffset,
          padding: WINDOW_PAD
        });

        if (!(0, _lodash2["default"])(pos, _this.state.pos)) {
          _this.setState({
            pos: pos
          });
        }
      }
    });
    return _this;
  }

  (0, _createClass2["default"])(Portaled, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // relative
      this.unsubscribe = subscribe(this.handleScroll);
      this.handleScroll();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this2 = this;

      var didOpen = this.props.isOpened && !prevProps.isOpened;
      var didClose = !this.props.isOpened && prevProps.isOpened;

      if (didOpen || didClose) {
        _window["default"].requestAnimationFrame(function () {
          if (_this2._unmounted) return;

          _this2.setState({
            isVisible: Boolean(didOpen)
          });
        });
      }

      this.handleScroll();
    } // ColorPicker will throw a cross-origin error when it is closed
    // when the app is within an iframe.
    // This is a known issue of react-color component:
    // see: https://github.com/casesandberg/react-color/issues/806

  }, {
    key: "componentDidCatch",
    value: function componentDidCatch() {// Do nothing here, since React will try to recreate this component
      // tree from scratch using the error boundary, which is this component
      // itself. This is a temporal fix for a crash.
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._unmounted = true; // @ts-ignore

      this.unsubscribe();
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props2 = this.props,
          Comp = _this$props2.component,
          overlayZIndex = _this$props2.overlayZIndex,
          isOpened = _this$props2.isOpened,
          onClose = _this$props2.onClose,
          children = _this$props2.children,
          modalProps = _this$props2.modalProps,
          _this$props2$modalSty = _this$props2.modalStyle,
          modalStyle = _this$props2$modalSty === void 0 ? {} : _this$props2$modalSty;
      var _this$state = this.state,
          isVisible = _this$state.isVisible,
          pos = _this$state.pos;

      var newModalStyle = _objectSpread(_objectSpread({}, defaultModalStyle), {}, {
        content: _objectSpread({}, modalStyle.content || {}),
        overlay: _objectSpread(_objectSpread(_objectSpread({}, defaultModalStyle.overlay), modalStyle.overlay || {}), {}, {
          // needs to be on top of existing modal
          zIndex: overlayZIndex || 9999
        })
      });

      return /*#__PURE__*/_react["default"].createElement(_context.RootContext.Consumer, null, function (context) {
        return /*#__PURE__*/_react["default"].createElement(Comp, {
          ref: _this3.element
        }, isOpened ? /*#__PURE__*/_react["default"].createElement(_reactModal["default"], (0, _extends2["default"])({
          className: "modal-portal"
        }, modalProps, {
          ariaHideApp: false,
          isOpen: true,
          style: newModalStyle,
          parentSelector: function parentSelector() {
            // React modal issue: https://github.com/reactjs/react-modal/issues/769
            // failed to execute removeChild on parent node when it is already unmounted
            return context && context.current || document.body;
          },
          onRequestClose: onClose
        }), /*#__PURE__*/_react["default"].createElement("div", {
          className: "portaled-content",
          key: "item",
          style: _objectSpread({
            position: 'fixed',
            opacity: isVisible ? 1 : 0,
            transition: _this3.props.theme.transitionFast,
            marginTop: isVisible ? '0px' : '14px'
          }, pos)
        }, /*#__PURE__*/_react["default"].createElement("div", {
          ref: _this3.child,
          style: {
            position: 'absolute',
            zIndex: overlayZIndex ? overlayZIndex + 1 : 10000
          }
        }, children))) : null);
      });
    }
  }], [{
    key: "getDerivedStateFromError",
    value: // Make Portaled a component with Error Boundary, so React can recreate
    // this component if the child 'ColorPicker' throws cross-origin error.
    // see function componentDidCatch()
    function getDerivedStateFromError() {
      return {
        hasError: true
      };
    }
  }]);
  return Portaled;
}(_react.Component);

(0, _defineProperty2["default"])(Portaled, "defaultProps", {
  component: 'div',
  onClose: noop,
  theme: _styles.theme
});

var _default = (0, _styledComponents.withTheme)(Portaled);

exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21tb24vcG9ydGFsZWQudHN4Il0sIm5hbWVzIjpbImxpc3RlbmVycyIsInN0YXJ0TGlzdGVuaW5nIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJnZXRQYWdlT2Zmc2V0IiwieCIsIndpbmRvdyIsInBhZ2VYT2Zmc2V0IiwidW5kZWZpbmVkIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJib2R5IiwicGFyZW50Tm9kZSIsInNjcm9sbExlZnQiLCJ5IiwicGFnZVlPZmZzZXQiLCJzY3JvbGxUb3AiLCJhZGRFdmVudExpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJsZWFkaW5nIiwiZ2V0Q2hpbGRQb3MiLCJvZmZzZXRzIiwicmVjdCIsImNoaWxkUmVjdCIsInBhZ2VPZmZzZXQiLCJwYWRkaW5nIiwidG9wT2Zmc2V0IiwibGVmdE9mZnNldCIsInJpZ2h0T2Zmc2V0IiwiYW5jaG9yTGVmdCIsInBvcyIsInRvcCIsImxlZnQiLCJyaWdodCIsImlubmVyV2lkdGgiLCJsZWZ0T3JSaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJjYW5Vc2VET00iLCJsaXN0ZW5lcklkQ291bnRlciIsInN1YnNjcmliZSIsImZuIiwiaWQiLCJkZWZhdWx0TW9kYWxTdHlsZSIsImNvbnRlbnQiLCJib3JkZXIiLCJib3R0b20iLCJvdmVybGF5IiwiYmFja2dyb3VuZENvbG9yIiwiV0lORE9XX1BBRCIsIm5vb3AiLCJQb3J0YWxlZCIsImlzVmlzaWJsZSIsImNoaWxkIiwiY3VycmVudCIsImVsZW1lbnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwcm9wcyIsInN0YXRlIiwic2V0U3RhdGUiLCJ1bnN1YnNjcmliZSIsImhhbmRsZVNjcm9sbCIsInByZXZQcm9wcyIsImRpZE9wZW4iLCJpc09wZW5lZCIsImRpZENsb3NlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX3VubW91bnRlZCIsIkJvb2xlYW4iLCJDb21wIiwiY29tcG9uZW50Iiwib3ZlcmxheVpJbmRleCIsIm9uQ2xvc2UiLCJjaGlsZHJlbiIsIm1vZGFsUHJvcHMiLCJtb2RhbFN0eWxlIiwibmV3TW9kYWxTdHlsZSIsInpJbmRleCIsImNvbnRleHQiLCJwb3NpdGlvbiIsIm9wYWNpdHkiLCJ0cmFuc2l0aW9uIiwidGhlbWUiLCJ0cmFuc2l0aW9uRmFzdCIsIm1hcmdpblRvcCIsImhhc0Vycm9yIiwiQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztBQUVBLElBQU1BLFNBQVMsR0FBRyxFQUFsQjs7QUFFQSxJQUFNQyxjQUFjLEdBQUcsU0FBakJBLGNBQWlCO0FBQUEsU0FBTUMsTUFBTSxDQUFDQyxJQUFQLENBQVlILFNBQVosRUFBdUJJLE9BQXZCLENBQStCLFVBQUFDLEdBQUc7QUFBQSxXQUFJTCxTQUFTLENBQUNLLEdBQUQsQ0FBVCxFQUFKO0FBQUEsR0FBbEMsQ0FBTjtBQUFBLENBQXZCOztBQUVBLElBQU1DLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0I7QUFBQSxTQUFPO0FBQzNCQyxJQUFBQSxDQUFDLEVBQ0NDLG1CQUFPQyxXQUFQLEtBQXVCQyxTQUF2QixHQUNJRixtQkFBT0MsV0FEWCxHQUVJLENBQUNFLFFBQVEsQ0FBQ0MsZUFBVCxJQUE0QkQsUUFBUSxDQUFDRSxJQUFULENBQWNDLFVBQTFDLElBQXdESCxRQUFRLENBQUNFLElBQWxFLEVBQXdFRSxVQUpuRDtBQUszQkMsSUFBQUEsQ0FBQyxFQUNDUixtQkFBT1MsV0FBUCxLQUF1QlAsU0FBdkIsR0FDSUYsbUJBQU9TLFdBRFgsR0FFSSxDQUFDTixRQUFRLENBQUNDLGVBQVQsSUFBNEJELFFBQVEsQ0FBQ0UsSUFBVCxDQUFjQyxVQUExQyxJQUF3REgsUUFBUSxDQUFDRSxJQUFsRSxFQUF3RUs7QUFSbkQsR0FBUDtBQUFBLENBQXRCOztB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QUN3QixLQURaO0FBRUUsVUFBQSxLQUFLLEVBQUU7QUFDTDBCLFlBQUFBLFFBQVEsRUFBRSxVQURMO0FBRUxGLFlBQUFBLE1BQU0sRUFBRU4sYUFBYSxHQUFHQSxhQUFhLEdBQUcsQ0FBbkIsR0FBdUI7QUFGdkM7QUFGVCxXQU9HRSxRQVBILENBWkYsQ0FiRixDQURPLEdBcUNMLElBdENOLENBRE07QUFBQSxPQURWLENBREY7QUE4Q0Q7OztXQTVKRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBa0M7QUFDaEMsYUFBTztBQUFDWSxRQUFBQSxRQUFRLEVBQUU7QUFBWCxPQUFQO0FBQ0Q7OztFQU5vQkMsZ0I7O2lDQUFqQm5DLFEsa0JBUWtCO0FBQ3BCbUIsRUFBQUEsU0FBUyxFQUFFLEtBRFM7QUFFcEJFLEVBQUFBLE9BQU8sRUFBRXRCLElBRlc7QUFHcEJnQyxFQUFBQSxLQUFLLEVBQUxBO0FBSG9CLEM7O2VBd0pULGlDQUFVL0IsUUFBVixDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50LCBjcmVhdGVSZWYsIEVsZW1lbnRUeXBlLCBQcm9wc1dpdGhDaGlsZHJlbn0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC5kZWJvdW5jZSc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2guaXNlcXVhbCc7XG5cbmltcG9ydCB7Y2FuVXNlRE9NfSBmcm9tICdleGVudic7XG5pbXBvcnQge3dpdGhUaGVtZX0gZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xuaW1wb3J0IHtSb290Q29udGV4dH0gZnJvbSAnLi4vY29udGV4dCc7XG5pbXBvcnQgTW9kYWwgZnJvbSAncmVhY3QtbW9kYWwnO1xuaW1wb3J0IHdpbmRvdyBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCB7dGhlbWV9IGZyb20gJ0BrZXBsZXIuZ2wvc3R5bGVzJztcblxuY29uc3QgbGlzdGVuZXJzID0ge307XG5cbmNvbnN0IHN0YXJ0TGlzdGVuaW5nID0gKCkgPT4gT2JqZWN0LmtleXMobGlzdGVuZXJzKS5mb3JFYWNoKGtleSA9PiBsaXN0ZW5lcnNba2V5XSgpKTtcblxuY29uc3QgZ2V0UGFnZU9mZnNldCA9ICgpID0+ICh7XG4gIHg6XG4gICAgd2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gd2luZG93LnBhZ2VYT2Zmc2V0XG4gICAgICA6IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbExlZnQsXG4gIHk6XG4gICAgd2luZG93LnBhZ2VZT2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICA6IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcFxufSk7XG5cbmNvbnN0IGFkZEV2ZW50TGlzdGVuZXJzID0gKCkgPT4ge1xuICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuYm9keSlcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBkZWJvdW5jZShzdGFydExpc3RlbmluZywgMTAwLCB7bGVhZGluZzogdHJ1ZX0pKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlYm91bmNlKHN0YXJ0TGlzdGVuaW5nLCA1MCwge2xlYWRpbmc6IHRydWV9KSk7XG59O1xuXG5pbnRlcmZhY2UgR2V0Q2hpbGRQb3NQcm9wcyB7XG4gIG9mZnNldHM6IFBhcnRpYWw8e1xuICAgIHRvcE9mZnNldDogbnVtYmVyO1xuICAgIGxlZnRPZmZzZXQ6IG51bWJlcjtcbiAgICByaWdodE9mZnNldDogbnVtYmVyO1xuICB9PjtcbiAgcmVjdDogRE9NUmVjdDtcbiAgY2hpbGRSZWN0OiBET01SZWN0O1xuICBwYWdlT2Zmc2V0OiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgfTtcbiAgcGFkZGluZzogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0Q2hpbGRQb3MgPSAoe29mZnNldHMsIHJlY3QsIGNoaWxkUmVjdCwgcGFnZU9mZnNldCwgcGFkZGluZ306IEdldENoaWxkUG9zUHJvcHMpID0+IHtcbiAgY29uc3Qge3RvcE9mZnNldCwgbGVmdE9mZnNldCwgcmlnaHRPZmZzZXR9ID0gb2Zmc2V0cztcblxuICBjb25zdCBhbmNob3JMZWZ0ID0gbGVmdE9mZnNldCAhPT0gdW5kZWZpbmVkO1xuICBjb25zdCBwb3MgPSB7XG4gICAgdG9wOiBwYWdlT2Zmc2V0LnkgKyByZWN0LnRvcCArICh0b3BPZmZzZXQgfHwgMCksXG4gICAgLi4uKGFuY2hvckxlZnRcbiAgICAgID8ge2xlZnQ6IHBhZ2VPZmZzZXQueCArIHJlY3QubGVmdCArIGxlZnRPZmZzZXQhfVxuICAgICAgOiB7cmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoIC0gcmVjdC5yaWdodCAtIHBhZ2VPZmZzZXQueCArIChyaWdodE9mZnNldCB8fCAwKX0pXG4gIH07XG5cbiAgY29uc3QgbGVmdE9yUmlnaHQgPSBhbmNob3JMZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICBpZiAocG9zW2xlZnRPclJpZ2h0XSAmJiBwb3NbbGVmdE9yUmlnaHRdIDwgMCkge1xuICAgIHBvc1tsZWZ0T3JSaWdodF0gPSBwYWRkaW5nO1xuICB9IGVsc2UgaWYgKHBvc1tsZWZ0T3JSaWdodF0gJiYgcG9zW2xlZnRPclJpZ2h0XSArIGNoaWxkUmVjdC53aWR0aCA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgcG9zW2xlZnRPclJpZ2h0XSA9IHdpbmRvdy5pbm5lcldpZHRoIC0gY2hpbGRSZWN0LndpZHRoIC0gcGFkZGluZztcbiAgfVxuXG4gIGlmIChwb3MudG9wIDwgMCkge1xuICAgIHBvcy50b3AgPSBwYWRkaW5nO1xuICB9IGVsc2UgaWYgKHBvcy50b3AgKyBjaGlsZFJlY3QuaGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgcG9zLnRvcCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGNoaWxkUmVjdC5oZWlnaHQgLSBwYWRkaW5nO1xuICB9XG5cbiAgcmV0dXJuIHBvcztcbn07XG5cbmlmIChjYW5Vc2VET00pIHtcbiAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICBhZGRFdmVudExpc3RlbmVycygpO1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBhZGRFdmVudExpc3RlbmVycyk7XG4gIH1cbn1cblxubGV0IGxpc3RlbmVySWRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIHN1YnNjcmliZShmbikge1xuICBsaXN0ZW5lcklkQ291bnRlciArPSAxO1xuICBjb25zdCBpZCA9IGxpc3RlbmVySWRDb3VudGVyO1xuICBsaXN0ZW5lcnNbaWRdID0gZm47XG4gIHJldHVybiAoKSA9PiBkZWxldGUgbGlzdGVuZXJzW2lkXTtcbn1cblxuY29uc3QgZGVmYXVsdE1vZGFsU3R5bGUgPSB7XG4gIGNvbnRlbnQ6IHtcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICBib3JkZXI6IDAsXG4gICAgcmlnaHQ6ICdhdXRvJyxcbiAgICBib3R0b206ICdhdXRvJyxcbiAgICBwYWRkaW5nOiAnMHB4IDBweCAwcHggMHB4J1xuICB9LFxuICBvdmVybGF5OiB7XG4gICAgcmlnaHQ6ICdhdXRvJyxcbiAgICBib3R0b206ICdhdXRvJyxcbiAgICB3aWR0aDogJzEwMHZ3JyxcbiAgICBoZWlnaHQ6ICcxMDB2aCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwKSdcbiAgfVxufTtcblxuY29uc3QgV0lORE9XX1BBRCA9IDQwO1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbnR5cGUgUG9ydGFsZWRQcm9wcyA9IFByb3BzV2l0aENoaWxkcmVuPHtcbiAgY29tcG9uZW50OiBFbGVtZW50VHlwZTtcbiAgb25DbG9zZT86IChcbiAgICBldmVudDogUmVhY3QuTW91c2VFdmVudDxFbGVtZW50LCBnbG9iYWxUaGlzLk1vdXNlRXZlbnQ+IHwgUmVhY3QuS2V5Ym9hcmRFdmVudDxFbGVtZW50PlxuICApID0+IHZvaWQ7XG4gIHRoZW1lPzogYW55O1xuICBpc09wZW5lZD86IGJvb2xlYW47XG4gIHRvcDogbnVtYmVyO1xuICBsZWZ0PzogbnVtYmVyO1xuICByaWdodD86IG51bWJlcjtcbiAgb3ZlcmxheVpJbmRleD86IG51bWJlcjtcbiAgbW9kYWxQcm9wcz86IFBhcnRpYWw8UmVhY3RNb2RhbC5Qcm9wcz47XG4gIG1vZGFsU3R5bGU/OiBQYXJ0aWFsPHR5cGVvZiBkZWZhdWx0TW9kYWxTdHlsZT47XG59PjtcblxuaW50ZXJmYWNlIFBvcnRhbGVkU3RhdGUge1xuICBwb3M6XG4gICAgfCB7XG4gICAgICAgIGxlZnQ6IG51bWJlcjtcbiAgICAgICAgdG9wOiBudW1iZXI7XG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIHJpZ2h0OiBudW1iZXI7XG4gICAgICAgIHRvcDogbnVtYmVyO1xuICAgICAgfVxuICAgIHwgbnVsbDtcbiAgaXNWaXNpYmxlOiBib29sZWFuO1xufVxuXG5jbGFzcyBQb3J0YWxlZCBleHRlbmRzIENvbXBvbmVudDxQb3J0YWxlZFByb3BzLCBQb3J0YWxlZFN0YXRlPiB7XG4gIC8vIE1ha2UgUG9ydGFsZWQgYSBjb21wb25lbnQgd2l0aCBFcnJvciBCb3VuZGFyeSwgc28gUmVhY3QgY2FuIHJlY3JlYXRlXG4gIC8vIHRoaXMgY29tcG9uZW50IGlmIHRoZSBjaGlsZCAnQ29sb3JQaWNrZXInIHRocm93cyBjcm9zcy1vcmlnaW4gZXJyb3IuXG4gIC8vIHNlZSBmdW5jdGlvbiBjb21wb25lbnREaWRDYXRjaCgpXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSB7XG4gICAgcmV0dXJuIHtoYXNFcnJvcjogdHJ1ZX07XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbXBvbmVudDogJ2RpdicsXG4gICAgb25DbG9zZTogbm9vcCxcbiAgICB0aGVtZVxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIHBvczogbnVsbCxcbiAgICBpc1Zpc2libGU6IGZhbHNlXG4gIH07XG5cbiAgdW5zdWJzY3JpYmU6ICgoKSA9PiBib29sZWFuKSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgX3VubW91bnRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIHJlbGF0aXZlXG4gICAgdGhpcy51bnN1YnNjcmliZSA9IHN1YnNjcmliZSh0aGlzLmhhbmRsZVNjcm9sbCk7XG4gICAgdGhpcy5oYW5kbGVTY3JvbGwoKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBjb25zdCBkaWRPcGVuID0gdGhpcy5wcm9wcy5pc09wZW5lZCAmJiAhcHJldlByb3BzLmlzT3BlbmVkO1xuICAgIGNvbnN0IGRpZENsb3NlID0gIXRoaXMucHJvcHMuaXNPcGVuZWQgJiYgcHJldlByb3BzLmlzT3BlbmVkO1xuICAgIGlmIChkaWRPcGVuIHx8IGRpZENsb3NlKSB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3VubW91bnRlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtpc1Zpc2libGU6IEJvb2xlYW4oZGlkT3Blbil9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlU2Nyb2xsKCk7XG4gIH1cblxuICAvLyBDb2xvclBpY2tlciB3aWxsIHRocm93IGEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdoZW4gaXQgaXMgY2xvc2VkXG4gIC8vIHdoZW4gdGhlIGFwcCBpcyB3aXRoaW4gYW4gaWZyYW1lLlxuICAvLyBUaGlzIGlzIGEga25vd24gaXNzdWUgb2YgcmVhY3QtY29sb3IgY29tcG9uZW50OlxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9jYXNlc2FuZGJlcmcvcmVhY3QtY29sb3IvaXNzdWVzLzgwNlxuICBjb21wb25lbnREaWRDYXRjaCgpIHtcbiAgICAvLyBEbyBub3RoaW5nIGhlcmUsIHNpbmNlIFJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50XG4gICAgLy8gdHJlZSBmcm9tIHNjcmF0Y2ggdXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5LCB3aGljaCBpcyB0aGlzIGNvbXBvbmVudFxuICAgIC8vIGl0c2VsZi4gVGhpcyBpcyBhIHRlbXBvcmFsIGZpeCBmb3IgYSBjcmFzaC5cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX3VubW91bnRlZCA9IHRydWU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIGVsZW1lbnQgPSBjcmVhdGVSZWY8SFRNTERpdkVsZW1lbnQ+KCk7XG4gIGNoaWxkID0gY3JlYXRlUmVmPEhUTUxEaXZFbGVtZW50PigpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGhhbmRsZVNjcm9sbCA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5jaGlsZC5jdXJyZW50ICYmIHRoaXMuZWxlbWVudC5jdXJyZW50KSB7XG4gICAgICBjb25zdCByZWN0ID0gdGhpcy5lbGVtZW50LmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjaGlsZFJlY3QgPSB0aGlzLmNoaWxkLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBwYWdlT2Zmc2V0ID0gZ2V0UGFnZU9mZnNldCgpO1xuICAgICAgY29uc3Qge3RvcDogdG9wT2Zmc2V0LCBsZWZ0OiBsZWZ0T2Zmc2V0ID0gMCwgcmlnaHQ6IHJpZ2h0T2Zmc2V0fSA9IHRoaXMucHJvcHM7XG5cbiAgICAgIGNvbnN0IHBvcyA9IGdldENoaWxkUG9zKHtcbiAgICAgICAgb2Zmc2V0czoge3RvcE9mZnNldCwgbGVmdE9mZnNldCwgcmlnaHRPZmZzZXR9LFxuICAgICAgICByZWN0LFxuICAgICAgICBjaGlsZFJlY3QsXG4gICAgICAgIHBhZ2VPZmZzZXQsXG4gICAgICAgIHBhZGRpbmc6IFdJTkRPV19QQURcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWlzRXF1YWwocG9zLCB0aGlzLnN0YXRlLnBvcykpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7cG9zfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICAvLyByZWxhdGl2ZVxuICAgICAgY29tcG9uZW50OiBDb21wLFxuICAgICAgb3ZlcmxheVpJbmRleCxcbiAgICAgIGlzT3BlbmVkLFxuICAgICAgb25DbG9zZSxcblxuICAgICAgLy8gTW9kYWxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbW9kYWxQcm9wcyxcbiAgICAgIG1vZGFsU3R5bGUgPSB7fVxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3Qge2lzVmlzaWJsZSwgcG9zfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBuZXdNb2RhbFN0eWxlID0ge1xuICAgICAgLi4uZGVmYXVsdE1vZGFsU3R5bGUsXG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIC4uLihtb2RhbFN0eWxlLmNvbnRlbnQgfHwge30pXG4gICAgICB9LFxuICAgICAgb3ZlcmxheToge1xuICAgICAgICAuLi5kZWZhdWx0TW9kYWxTdHlsZS5vdmVybGF5LFxuICAgICAgICAuLi4obW9kYWxTdHlsZS5vdmVybGF5IHx8IHt9KSxcbiAgICAgICAgLy8gbmVlZHMgdG8gYmUgb24gdG9wIG9mIGV4aXN0aW5nIG1vZGFsXG4gICAgICAgIHpJbmRleDogb3ZlcmxheVpJbmRleCB8fCA5OTk5XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICA8Um9vdENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgIHtjb250ZXh0ID0+IChcbiAgICAgICAgICA8Q29tcCByZWY9e3RoaXMuZWxlbWVudH0+XG4gICAgICAgICAgICB7aXNPcGVuZWQgPyAoXG4gICAgICAgICAgICAgIDxNb2RhbFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1vZGFsLXBvcnRhbFwiXG4gICAgICAgICAgICAgICAgey4uLm1vZGFsUHJvcHN9XG4gICAgICAgICAgICAgICAgYXJpYUhpZGVBcHA9e2ZhbHNlfVxuICAgICAgICAgICAgICAgIGlzT3BlblxuICAgICAgICAgICAgICAgIHN0eWxlPXtuZXdNb2RhbFN0eWxlfVxuICAgICAgICAgICAgICAgIHBhcmVudFNlbGVjdG9yPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAvLyBSZWFjdCBtb2RhbCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtbW9kYWwvaXNzdWVzLzc2OVxuICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIHRvIGV4ZWN1dGUgcmVtb3ZlQ2hpbGQgb24gcGFyZW50IG5vZGUgd2hlbiBpdCBpcyBhbHJlYWR5IHVubW91bnRlZFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0ICYmIGNvbnRleHQuY3VycmVudCkgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uUmVxdWVzdENsb3NlPXtvbkNsb3NlfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicG9ydGFsZWQtY29udGVudFwiXG4gICAgICAgICAgICAgICAgICBrZXk9XCJpdGVtXCJcbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBpc1Zpc2libGUgPyAxIDogMCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy5wcm9wcy50aGVtZS50cmFuc2l0aW9uRmFzdCxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBpc1Zpc2libGUgPyAnMHB4JyA6ICcxNHB4JyxcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAuLi5wb3NcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICByZWY9e3RoaXMuY2hpbGR9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgekluZGV4OiBvdmVybGF5WkluZGV4ID8gb3ZlcmxheVpJbmRleCArIDEgOiAxMDAwMFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9Nb2RhbD5cbiAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgIDwvQ29tcD5cbiAgICAgICAgKX1cbiAgICAgIDwvUm9vdENvbnRleHQuQ29uc3VtZXI+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoVGhlbWUoUG9ydGFsZWQpO1xuIl19