"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.togglePanelListViewUpdater = exports.setLocaleUpdater = exports.showDatasetTableUpdater = exports.toggleSplitMapUpdater = exports.loadFilesErrUpdater = exports.loadFilesSuccessUpdater = exports.loadFilesUpdater = exports.removeNotificationUpdater = exports.addNotificationUpdater = exports.setExportMapHTMLModeUpdater = exports.setExportMapFormatUpdater = exports.setUserMapboxAccessTokenUpdater = exports.setExportDataUpdater = exports.setExportFilteredUpdater = exports.setExportDataTypeUpdater = exports.setExportSelectedDatasetUpdater = exports.startExportingImageUpdater = exports.cleanupExportImageUpdater = exports.setExportImageErrorUpdater = exports.setExportImageDataUriUpdater = exports.setExportImageSettingUpdater = exports.openDeleteModalUpdater = exports.setMapControlVisibilityUpdater = exports.toggleMapControlUpdater = exports.toggleSidePanelCloseButtonUpdater = exports.hideExportDropdownUpdater = exports.showExportDropdownUpdater = exports.toggleModalUpdater = exports.toggleSidePanelUpdater = exports.initUiStateUpdater = exports.INITIAL_UI_STATE = exports.DEFAULT_EXPORT_MAP = exports.DEFAULT_EXPORT_JSON = exports.DEFAULT_EXPORT_HTML = exports.DEFAULT_NOTIFICATIONS = exports.DEFAULT_EXPORT_DATA = exports.DEFAULT_LOAD_FILES = exports.DEFAULT_EXPORT_IMAGE = exports.DEFAULT_MAP_CONTROLS = exports.DEFAULT_MODAL = exports.DEFAULT_ACTIVE_SIDE_PANEL = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("@kepler.gl/constants");

var _localization = require("@kepler.gl/localization");

var _utils = require("@kepler.gl/utils");

var _composerHelpers = require("./composer-helpers");

var _DEFAULT_EXPORT_MAP;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_ACTIVE_SIDE_PANEL = 'layer';
exports.DEFAULT_ACTIVE_SIDE_PANEL = DEFAULT_ACTIVE_SIDE_PANEL;
var DEFAULT_MODAL = _constants.ADD_DATA_ID;
/**
 * Updaters for `uiState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 *
 * @public
 * @example
 *
 * import keplerGlReducer, {uiStateUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // click button to close side panel
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             uiState: uiStateUpdaters.toggleSidePanelUpdater(
 *               uiState, {payload: null}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */
// @ts-ignore

exports.DEFAULT_MODAL = DEFAULT_MODAL;
var uiStateUpdaters = null;
/* eslint-enable no-unused-vars */

var DEFAULT_MAP_CONTROLS_FEATURES = {
  show: true,
  active: false,
  disableClose: false,
  // defines which map index users are interacting with (through map controls)
  activeMapIndex: 0
};
/**
 * A list of map control visibility and whether is it active.
 * @memberof uiStateUpdaters
 * @constant
 * @property visibleLayers Default: `{show: true, active: false}`
 * @property mapLegend Default: `{show: true, active: false}`
 * @property toggle3d Default: `{show: true}`
 * @property splitMap Default: `{show: true}`
 * @property mapDraw Default: `{show: true, active: false}`
 * @property mapLocale Default: `{show: false, active: false}`
 * @public
 */

var DEFAULT_MAP_CONTROLS = Object.keys(_constants.MAP_CONTROLS).reduce(function (_final, current) {
  return _objectSpread(_objectSpread({}, _final), {}, (0, _defineProperty2["default"])({}, current, DEFAULT_MAP_CONTROLS_FEATURES));
}, {});
/**
 * Default image export config
 * @memberof uiStateUpdaters
 * @constant
 * @property ratio Default: `'SCREEN'`,
 * @property resolution Default: `'ONE_X'`,
 * @property legend Default: `false`,
 * @property mapH Default: 0,
 * @property mapW Default: 0,
 * @property imageSize Default: {zoomOffset: 0, scale: 1, imageW: 0, imageH: 0},
 * @property imageDataUri Default: `''`,
 * @property exporting Default: `false`
 * @property error Default: `false`
 * @property escapeXhtmlForWebpack Default: `true`
 * @public
 */

exports.DEFAULT_MAP_CONTROLS = DEFAULT_MAP_CONTROLS;
var DEFAULT_EXPORT_IMAGE = {
  // user options
  ratio: _constants.EXPORT_IMG_RATIOS.SCREEN,
  resolution: _constants.RESOLUTIONS.ONE_X,
  legend: false,
  mapH: 0,
  mapW: 0,
  imageSize: {
    zoomOffset: 0,
    scale: 1,
    imageW: 0,
    imageH: 0
  },
  // when this is set to true, the mock map viewport will move to the center of data
  center: false,
  // exporting state
  imageDataUri: '',
  // exporting: used to attach plot-container to dom
  exporting: false,
  // processing: used as loading indicator when export image is being produced
  processing: false,
  error: false,
  // whether to apply fix for uglify error in dom-to-image (should be true for webpack builds)
  escapeXhtmlForWebpack: true
};
exports.DEFAULT_EXPORT_IMAGE = DEFAULT_EXPORT_IMAGE;
var DEFAULT_LOAD_FILES = {
  fileLoading: false
};
/**
 * Default initial `exportData` settings
 * @memberof uiStateUpdaters
 * @constant
 * @property selectedDataset Default: `''`,
 * @property dataType Default: `'csv'`,
 * @property filtered Default: `true`,
 * @public
 */

exports.DEFAULT_LOAD_FILES = DEFAULT_LOAD_FILES;
var DEFAULT_EXPORT_DATA = {
  selectedDataset: '',
  dataType: _constants.EXPORT_DATA_TYPE.CSV,
  filtered: true
};
/**
 * @constant
 */

exports.DEFAULT_EXPORT_DATA = DEFAULT_EXPORT_DATA;
var DEFAULT_NOTIFICATIONS = [];
/**
 * @constant
 * @property exportMapboxAccessToken - Default: null, this is used when we provide a default mapbox token for users to take advantage of
 * @property userMapboxToken - Default: '', mapbox token provided by user through input field
 * @property mode - Default: 'READ', read only or editable
 * @public
 */

exports.DEFAULT_NOTIFICATIONS = DEFAULT_NOTIFICATIONS;
var DEFAULT_EXPORT_HTML = {
  exportMapboxAccessToken: null,
  userMapboxToken: '',
  mode: _constants.EXPORT_HTML_MAP_MODES.READ
};
/**
 * @constant
 * @property hasData - Default: 'true',
 * @public
 */

exports.DEFAULT_EXPORT_HTML = DEFAULT_EXPORT_HTML;
var DEFAULT_EXPORT_JSON = {
  hasData: true
};
/**
 * Export Map Config
 * @constant
 * @property HTML - Default: 'DEFAULT_EXPORT_HTML',
 * @property JSON - Default: 'DEFAULT_EXPORT_JSON',
 * @property format - Default: 'HTML',
 * @public
 */

exports.DEFAULT_EXPORT_JSON = DEFAULT_EXPORT_JSON;
var DEFAULT_EXPORT_MAP = (_DEFAULT_EXPORT_MAP = {}, (0, _defineProperty2["default"])(_DEFAULT_EXPORT_MAP, _constants.EXPORT_MAP_FORMATS.HTML, DEFAULT_EXPORT_HTML), (0, _defineProperty2["default"])(_DEFAULT_EXPORT_MAP, _constants.EXPORT_MAP_FORMATS.JSON, DEFAULT_EXPORT_JSON), (0, _defineProperty2["default"])(_DEFAULT_EXPORT_MAP, "format", _constants.EXPORT_MAP_FORMATS.HTML), _DEFAULT_EXPORT_MAP);
/**
 * Default initial `uiState`
 * @memberof uiStateUpdaters
 * @constant
 * @property readOnly Default: `false`
 * @property activeSidePanel Default: `'layer'`
 * @property currentModal Default: `'addData'`
 * @property datasetKeyToRemove Default: `null`
 * @property visibleDropdown Default: `null`
 * @property exportImage Default: [`DEFAULT_EXPORT_IMAGE`](#default_export_image)
 * @property exportData Default: [`DEFAULT_EXPORT_DATA`](#default_export_data)
 * @property exportMap Default: [`DEFAULT_EXPORT_MAP`](#default_export_map)
 * @property mapControls Default: [`DEFAULT_MAP_CONTROLS`](#default_map_controls)
 * @property notifications Default: `[]`
 * @property notifications Default: `[]`
 * @property loadFiles
 * @property isSidePanelCloseButtonVisible Default: `true`
 * @public
 */

exports.DEFAULT_EXPORT_MAP = DEFAULT_EXPORT_MAP;
var INITIAL_UI_STATE = {
  readOnly: false,
  activeSidePanel: DEFAULT_ACTIVE_SIDE_PANEL,
  currentModal: DEFAULT_MODAL,
  datasetKeyToRemove: null,
  visibleDropdown: null,
  // export image modal ui
  exportImage: DEFAULT_EXPORT_IMAGE,
  // export data modal ui
  exportData: DEFAULT_EXPORT_DATA,
  // html export
  exportMap: DEFAULT_EXPORT_MAP,
  // map control panels
  mapControls: DEFAULT_MAP_CONTROLS,
  // ui notifications
  notifications: DEFAULT_NOTIFICATIONS,
  // load files
  loadFiles: DEFAULT_LOAD_FILES,
  // Locale of the UI
  locale: _localization.LOCALE_CODES.en,
  layerPanelListView: 'list',
  filterPanelListView: 'list',
  isSidePanelCloseButtonVisible: true
};
/* Updaters */

/**
 * @memberof uiStateUpdaters
 */

exports.INITIAL_UI_STATE = INITIAL_UI_STATE;

var initUiStateUpdater = function initUiStateUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), (action.payload || {}).initialUiState);
};
/**
 * Toggle active side panel
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action
 * @param action.payload id of side panel to be shown, one of `layer`, `filter`, `interaction`, `map`. close side panel if `null`
 * @returns nextState
 * @public
 */


exports.initUiStateUpdater = initUiStateUpdater;

var toggleSidePanelUpdater = function toggleSidePanelUpdater(state, _ref) {
  var id = _ref.payload;
  return id === state.activeSidePanel ? state : _objectSpread(_objectSpread({}, state), {}, {
    activeSidePanel: id
  });
};
/**
 * Show and hide modal dialog
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action
 * @paramaction.payload id of modal to be shown, null to hide modals. One of:
 *  - [`DATA_TABLE_ID`](../constants/default-settings.md#data_table_id)
 *  - [`DELETE_DATA_ID`](../constants/default-settings.md#delete_data_id)
 *  - [`ADD_DATA_ID`](../constants/default-settings.md#add_data_id)
 *  - [`EXPORT_IMAGE_ID`](../constants/default-settings.md#export_image_id)
 *  - [`EXPORT_DATA_ID`](../constants/default-settings.md#export_data_id)
 *  - [`ADD_MAP_STYLE_ID`](../constants/default-settings.md#add_map_style_id)
 * @returns nextState
 * @public
 */


exports.toggleSidePanelUpdater = toggleSidePanelUpdater;

var toggleModalUpdater = function toggleModalUpdater(state, _ref2) {
  var id = _ref2.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    currentModal: id
  });
};
/**
 * Hide and show side panel header dropdown, activated by clicking the share link on top of the side panel
 * @memberof uiStateUpdaters
 * @public
 */


exports.toggleModalUpdater = toggleModalUpdater;

var showExportDropdownUpdater = function showExportDropdownUpdater(state, _ref3) {
  var id = _ref3.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    visibleDropdown: id
  });
};
/**
 * Hide side panel header dropdown, activated by clicking the share link on top of the side panel
 * @memberof uiStateUpdaters
 * @public
 */


exports.showExportDropdownUpdater = showExportDropdownUpdater;

var hideExportDropdownUpdater = function hideExportDropdownUpdater(state) {
  return _objectSpread(_objectSpread({}, state), {}, {
    visibleDropdown: null
  });
};
/**
 * Toggle side panel close button on top left of the side panel
 * @memberof uiStateUpdaters
 * @public
 */


exports.hideExportDropdownUpdater = hideExportDropdownUpdater;

var toggleSidePanelCloseButtonUpdater = function toggleSidePanelCloseButtonUpdater(state, _ref4) {
  var show = _ref4.payload.show;
  return _objectSpread(_objectSpread({}, state), {}, {
    isSidePanelCloseButtonVisible: show
  });
};
/**
 * Toggle active map control panel
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action action
 * @param action.payload map control panel id, one of the keys of: [`DEFAULT_MAP_CONTROLS`](#default_map_controls)
 * @returns nextState
 * @public
 */


exports.toggleSidePanelCloseButtonUpdater = toggleSidePanelCloseButtonUpdater;

var toggleMapControlUpdater = function toggleMapControlUpdater(state, _ref5) {
  var _ref5$payload = _ref5.payload,
      panelId = _ref5$payload.panelId,
      _ref5$payload$index = _ref5$payload.index,
      index = _ref5$payload$index === void 0 ? 0 : _ref5$payload$index;
  return _objectSpread(_objectSpread({}, state), {}, {
    mapControls: _objectSpread(_objectSpread({}, state.mapControls), {}, (0, _defineProperty2["default"])({}, panelId, _objectSpread(_objectSpread({}, state.mapControls[panelId]), {}, {
      active: !state.mapControls[panelId].active,
      activeMapIndex: index
    })))
  });
};
/**
 * Toggle map control visibility
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action action
 * @param action.payload map control panel id, one of the keys of: [`DEFAULT_MAP_CONTROLS`](#default_map_controls)
 * @returns nextState
 * @public
 */


exports.toggleMapControlUpdater = toggleMapControlUpdater;

var setMapControlVisibilityUpdater = function setMapControlVisibilityUpdater(state, _ref6) {
  var _state$mapControls;

  var _ref6$payload = _ref6.payload,
      panelId = _ref6$payload.panelId,
      show = _ref6$payload.show;

  if (!((_state$mapControls = state.mapControls) !== null && _state$mapControls !== void 0 && _state$mapControls[panelId])) {
    return state;
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    mapControls: _objectSpread(_objectSpread({}, state.mapControls), {}, (0, _defineProperty2["default"])({}, panelId, _objectSpread(_objectSpread({}, state.mapControls[panelId]), {}, {
      show: Boolean(show)
    })))
  });
};
/**
 * Toggle active map control panel
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action
 * @param action.payload dataset id
 * @returns nextState
 * @public
 */


exports.setMapControlVisibilityUpdater = setMapControlVisibilityUpdater;

var openDeleteModalUpdater = function openDeleteModalUpdater(state, _ref7) {
  var datasetKeyToRemove = _ref7.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    currentModal: _constants.DELETE_DATA_ID,
    datasetKeyToRemove: datasetKeyToRemove
  });
};
/**
 * Set `exportImage.legend` to `true` or `false`
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @returns nextState
 * @public
 */


exports.openDeleteModalUpdater = openDeleteModalUpdater;

var setExportImageSettingUpdater = function setExportImageSettingUpdater(state, _ref8) {
  var newSetting = _ref8.payload;

  var updated = _objectSpread(_objectSpread({}, state.exportImage), newSetting);

  var imageSize = (0, _utils.calculateExportImageSize)(updated) || state.exportImage.imageSize;
  return _objectSpread(_objectSpread({}, state), {}, {
    exportImage: _objectSpread(_objectSpread({}, updated), {}, {
      // @ts-expect-error
      // TODO: calculateExportImageSize does not return imageSize.zoomOffset,
      // do we need take this value from current state, or return defaul value = 0
      imageSize: imageSize
    })
  });
};
/**
 * Set `exportImage.setExportImageDataUri` to a image dataUri
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action
 * @param action.payload export image data uri
 * @returns nextState
 * @public
 */


exports.setExportImageSettingUpdater = setExportImageSettingUpdater;

var setExportImageDataUriUpdater = function setExportImageDataUriUpdater(state, _ref9) {
  var dataUri = _ref9.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    exportImage: _objectSpread(_objectSpread({}, state.exportImage), {}, {
      processing: false,
      imageDataUri: dataUri
    })
  });
};
/**
 * @memberof uiStateUpdaters
 * @public
 */


exports.setExportImageDataUriUpdater = setExportImageDataUriUpdater;

var setExportImageErrorUpdater = function setExportImageErrorUpdater(state, _ref10) {
  var error = _ref10.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    exportImage: _objectSpread(_objectSpread({}, state.exportImage), {}, {
      processing: false,
      error: error
    })
  });
};
/**
 * Delete cached export image
 * @memberof uiStateUpdaters
 * @public
 */


exports.setExportImageErrorUpdater = setExportImageErrorUpdater;

var cleanupExportImageUpdater = function cleanupExportImageUpdater(state) {
  return _objectSpread(_objectSpread({}, state), {}, {
    exportImage: _objectSpread(_objectSpread({}, state.exportImage), {}, {
      exporting: false,
      imageDataUri: '',
      error: false,
      processing: false,
      center: false
    })
  });
};
/**
 * Start image exporting flow
 * @memberof uiStateUpdaters
 * @param state
 * @param options
 * @returns {UiState}
 * @public
 */


exports.cleanupExportImageUpdater = cleanupExportImageUpdater;

var startExportingImageUpdater = function startExportingImageUpdater(state, _ref11) {
  var _ref11$payload = _ref11.payload,
      options = _ref11$payload === void 0 ? {} : _ref11$payload;

  var imageSettings = _objectSpread(_objectSpread({}, options), {}, {
    exporting: true
  });

  return (0, _composerHelpers.compose_)([cleanupExportImageUpdater, (0, _composerHelpers.apply_)(setExportImageSettingUpdater, (0, _composerHelpers.payload_)(imageSettings))])(state);
};
/**
 * Set selected dataset for export
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action
 * @param action.payload dataset id
 * @returns nextState
 * @public
 */


exports.startExportingImageUpdater = startExportingImageUpdater;

var setExportSelectedDatasetUpdater = function setExportSelectedDatasetUpdater(state, _ref12) {
  var dataset = _ref12.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    exportData: _objectSpread(_objectSpread({}, state.exportData), {}, {
      selectedDataset: dataset
    })
  });
};
/**
 * Set data format for exporting data
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action
 * @param action.payload one of `'text/csv'`
 * @returns nextState
 * @public
 */


exports.setExportSelectedDatasetUpdater = setExportSelectedDatasetUpdater;

var setExportDataTypeUpdater = function setExportDataTypeUpdater(state, _ref13) {
  var dataType = _ref13.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    exportData: _objectSpread(_objectSpread({}, state.exportData), {}, {
      dataType: dataType
    })
  });
};
/**
 * Whether to export filtered data, `true` or `false`
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action
 * @param action.payload
 * @returns nextState
 * @public
 */


exports.setExportDataTypeUpdater = setExportDataTypeUpdater;

var setExportFilteredUpdater = function setExportFilteredUpdater(state, _ref14) {
  var filtered = _ref14.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    exportData: _objectSpread(_objectSpread({}, state.exportData), {}, {
      filtered: filtered
    })
  });
};
/**
 * Whether to including data in map config, toggle between `true` or `false`
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @returns nextState
 * @public
 */


exports.setExportFilteredUpdater = setExportFilteredUpdater;

var setExportDataUpdater = function setExportDataUpdater(state) {
  return _objectSpread(_objectSpread({}, state), {}, {
    exportMap: _objectSpread(_objectSpread({}, state.exportMap), {}, (0, _defineProperty2["default"])({}, _constants.EXPORT_MAP_FORMATS.JSON, _objectSpread(_objectSpread({}, state.exportMap[_constants.EXPORT_MAP_FORMATS.JSON]), {}, {
      hasData: !state.exportMap[_constants.EXPORT_MAP_FORMATS.JSON].hasData
    })))
  });
};
/**
 * whether to export a mapbox access to HTML single page
 * @param state - `uiState`
 * @param action
 * @param action.payload
 * @returns nextState
 * @public
 */


exports.setExportDataUpdater = setExportDataUpdater;

var setUserMapboxAccessTokenUpdater = function setUserMapboxAccessTokenUpdater(state, _ref15) {
  var userMapboxToken = _ref15.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    exportMap: _objectSpread(_objectSpread({}, state.exportMap), {}, (0, _defineProperty2["default"])({}, _constants.EXPORT_MAP_FORMATS.HTML, _objectSpread(_objectSpread({}, state.exportMap[_constants.EXPORT_MAP_FORMATS.HTML]), {}, {
      userMapboxToken: userMapboxToken
    })))
  });
};
/**
 * Sets the export map format
 * @param state - `uiState`
 * @param action
 * @param action.payload format to use to export the map into
 * @return nextState
 */


exports.setUserMapboxAccessTokenUpdater = setUserMapboxAccessTokenUpdater;

var setExportMapFormatUpdater = function setExportMapFormatUpdater(state, _ref16) {
  var format = _ref16.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    exportMap: _objectSpread(_objectSpread({}, state.exportMap), {}, {
      // @ts-expect-error
      format: format
    })
  });
};
/**
 * Set the export html map mode
 * @param state - `uiState`
 * @param action
 * @param action.payload to be set (available modes: EXPORT_HTML_MAP_MODES)
 * @return nextState
 */


exports.setExportMapFormatUpdater = setExportMapFormatUpdater;

var setExportMapHTMLModeUpdater = function setExportMapHTMLModeUpdater(state, _ref17) {
  var mode = _ref17.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    exportMap: _objectSpread(_objectSpread({}, state.exportMap), {}, (0, _defineProperty2["default"])({}, _constants.EXPORT_MAP_FORMATS.HTML, _objectSpread(_objectSpread({}, state.exportMap[_constants.EXPORT_MAP_FORMATS.HTML]), {}, {
      mode: mode
    })))
  });
};
/**
 * Adds a new notification.
 * Updates a notification in case of matching ids.
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action
 * @param action.payload Params of a notification
 * @returns nextState
 * @public
 */


exports.setExportMapHTMLModeUpdater = setExportMapHTMLModeUpdater;

var addNotificationUpdater = function addNotificationUpdater(state, _ref18) {
  var payload = _ref18.payload;
  var oldNotifications = state.notifications || []; // @ts-expect-error

  var payloadId = payload === null || payload === void 0 ? void 0 : payload.id;
  var notificationToUpdate = payloadId ? oldNotifications.find(function (n) {
    return n.id === payloadId;
  }) : null;
  var notifications;

  if (notificationToUpdate) {
    notifications = oldNotifications.map(function (n) {
      return n.id === payloadId ? (0, _utils.createNotification)(_objectSpread(_objectSpread({}, payload), {}, {
        count: n.count + 1
      })) : n;
    });
  } else {
    notifications = [].concat((0, _toConsumableArray2["default"])(oldNotifications), [(0, _utils.createNotification)(payload)]);
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    notifications: notifications
  });
};
/**
 * Remove a notification
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action
 * @param action.payload id of the notification to be removed
 * @returns nextState
 * @public
 */


exports.addNotificationUpdater = addNotificationUpdater;

var removeNotificationUpdater = function removeNotificationUpdater(state, _ref19) {
  var id = _ref19.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    notifications: state.notifications.filter(function (n) {
      return n.id !== id;
    })
  });
};
/**
 * Fired when file loading begin
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @returns nextState
 * @public
 */


exports.removeNotificationUpdater = removeNotificationUpdater;

var loadFilesUpdater = function loadFilesUpdater(state) {
  return _objectSpread(_objectSpread({}, state), {}, {
    loadFiles: _objectSpread(_objectSpread({}, state.loadFiles), {}, {
      fileLoading: true
    })
  });
};
/**
 * Handles loading file success and set fileLoading property to false
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @returns nextState
 */


exports.loadFilesUpdater = loadFilesUpdater;

var loadFilesSuccessUpdater = function loadFilesSuccessUpdater(state) {
  return _objectSpread(_objectSpread({}, state), {}, {
    loadFiles: _objectSpread(_objectSpread({}, state.loadFiles), {}, {
      fileLoading: false
    })
  });
};
/**
 * Handles load file error and set fileLoading property to false
 * @memberof uiStateUpdaters
 * @param state
 * @param action
 * @param action.error
 * @returns nextState
 * @public
 */


exports.loadFilesSuccessUpdater = loadFilesSuccessUpdater;

var loadFilesErrUpdater = function loadFilesErrUpdater(state, _ref20) {
  var error = _ref20.error;
  return addNotificationUpdater(_objectSpread(_objectSpread({}, state), {}, {
    loadFiles: _objectSpread(_objectSpread({}, state.loadFiles), {}, {
      fileLoading: false
    })
  }), {
    payload: (0, _utils.errorNotification)({
      message: (error || {}).message || 'Failed to upload files',
      topic: _constants.DEFAULT_NOTIFICATION_TOPICS.global
    })
  });
};
/**
 * Handles toggle map split and reset all map control index to 0
 * @memberof uiStateUpdaters
 * @param state
 * @returns nextState
 * @public
 */


exports.loadFilesErrUpdater = loadFilesErrUpdater;

var toggleSplitMapUpdater = function toggleSplitMapUpdater(state) {
  return _objectSpread(_objectSpread({}, state), {}, {
    mapControls: Object.entries(state.mapControls).reduce(function (acc, entry) {
      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, entry[0], _objectSpread(_objectSpread({}, entry[1]), {}, {
        activeMapIndex: 0
      })));
    }, {})
  });
};
/**
 * Toggle modal data
 * @memberof uiStateUpdaters
 * @param state
 * @returns nextState
 * @public
 */


exports.toggleSplitMapUpdater = toggleSplitMapUpdater;

var showDatasetTableUpdater = function showDatasetTableUpdater(state) {
  return toggleModalUpdater(state, {
    payload: _constants.DATA_TABLE_ID
  });
};
/**
 * Set the locale of the UI
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action
 * @param action.payload
 * @param action.payload.locale locale
 * @returns nextState
 * @public
 */


exports.showDatasetTableUpdater = showDatasetTableUpdater;

var setLocaleUpdater = function setLocaleUpdater(state, _ref21) {
  var locale = _ref21.payload.locale;
  return _objectSpread(_objectSpread({}, state), {}, {
    locale: locale
  });
};
/**
 * Toggle layer panel list view
 * @memberof uiStateUpdaters
 * @param state `uiState`
 * @param action
 * @param action.payload layer panel listView value. Can be 'list' or 'sortByDataset'
 * @returns nextState
 * @public
 */


exports.setLocaleUpdater = setLocaleUpdater;

var togglePanelListViewUpdater = function togglePanelListViewUpdater(state, _ref22) {
  var _ref22$payload = _ref22.payload,
      panelId = _ref22$payload.panelId,
      listView = _ref22$payload.listView;
  var stateProp = panelId === 'layer' ? 'layerPanelListView' : panelId === 'filter' ? 'filterPanelListView' : null;

  if (!stateProp || state[stateProp] === listView) {
    return state;
  }

  return _objectSpread(_objectSpread({}, state), {}, (0, _defineProperty2["default"])({}, stateProp, listView));
};

exports.togglePanelListViewUpdater = togglePanelListViewUpdater;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91aS1zdGF0ZS11cGRhdGVycy50cyJdLCJuYW1lcyI6WyJERUZBVUxUX0FDVElWRV9TSURFX1BBTkVMIiwiREVGQVVMVF9NT0RBTCIsIkFERF9EQVRBX0lEIiwidWlTdGF0ZVVwZGF0ZXJzIiwiREVGQVVMVF9NQVBfQ09OVFJPTFNfRkVBVFVSRVMiLCJzaG93IiwiYWN0aXZlIiwiZGlzYWJsZUNsb3NlIiwiYWN0aXZlTWFwSW5kZXgiLCJERUZBVUxUX01BUF9DT05UUk9MUyIsIk9iamVjdCIsImtleXMiLCJNQVBfQ09OVFJPTFMiLCJyZWR1Y2UiLCJmaW5hbCIsImN1cnJlbnQiLCJERUZBVUxUX0VYUE9SVF9JTUFHRSIsInJhdGlvIiwiRVhQT1JUX0lNR19SQVRJT1MiLCJTQ1JFRU4iLCJyZXNvbHV0aW9uIiwiUkVTT0xVVElPTlMiLCJPTkVfWCIsImxlZ2VuZCIsIm1hcEgiLCJtYXBXIiwiaW1hZ2VTaXplIiwiem9vbU9mZnNldCIsInNjYWxlIiwiaW1hZ2VXIiwiaW1hZ2VIIiwiY2VudGVyIiwiaW1hZ2VEYXRhVXJpIiwiZXhwb3J0aW5nIiwicHJvY2Vzc2luZyIsImVycm9yIiwiZXNjYXBlWGh0bWxGb3JXZWJwYWNrIiwiREVGQVVMVF9MT0FEX0ZJTEVTIiwiZmlsZUxvYWRpbmciLCJERUZBVUxUX0VYUE9SVF9EQVRBIiwic2VsZWN0ZWREYXRhc2V0IiwiZGF0YVR5cGUiLCJFWFBPUlRfREFUQV9UWVBFIiwiQ1NWIiwiZmlsdGVyZWQiLCJERUZBVUxUX05PVElGSUNBVElPTlMiLCJERUZBVUxUX0VYUE9SVF9IVE1MIiwiZXhwb3J0TWFwYm94QWNjZXNzVG9rZW4iLCJ1c2VyTWFwYm94VG9rZW4iLCJtb2RlIiwiRVhQT1JUX0hUTUxfTUFQX01PREVTIiwiUkVBRCIsIkRFRkFVTFRfRVhQT1JUX0pTT04iLCJoYXNEYXRhIiwiREVGQVVMVF9FWFBPUlRfTUFQIiwiRVhQT1JUX01BUF9GT1JNQVRTIiwiSFRNTCIsIkpTT04iLCJJTklUSUFMX1VJX1NUQVRFIiwicmVhZE9ubHkiLCJhY3RpdmVTaWRlUGFuZWwiLCJjdXJyZW50TW9kYWwiLCJkYXRhc2V0S2V5VG9SZW1vdmUiLCJ2aXNpYmxlRHJvcGRvd24iLCJleHBvcnRJbWFnZSIsImV4cG9ydERhdGEiLCJleHBvcnRNYXAiLCJtYXBDb250cm9scyIsIm5vdGlmaWNhdGlvbnMiLCJsb2FkRmlsZXMiLCJsb2NhbGUiLCJMT0NBTEVfQ09ERVMiLCJlbiIsImxheWVyUGFuZWxMaXN0VmlldyIsImZpbHRlclBhbmVsTGlzdFZpZXciLCJpc1NpZGVQYW5lbENsb3NlQnV0dG9uVmlzaWJsZSIsImluaXRVaVN0YXRlVXBkYXRlciIsInN0YXRlIiwiYWN0aW9uIiwicGF5bG9hZCIsImluaXRpYWxVaVN0YXRlIiwidG9nZ2xlU2lkZVBhbmVsVXBkYXRlciIsImlkIiwidG9nZ2xlTW9kYWxVcGRhdGVyIiwic2hvd0V4cG9ydERyb3Bkb3duVXBkYXRlciIsImhpZGVFeHBvcnREcm9wZG93blVwZGF0ZXIiLCJ0b2dnbGVTaWRlUGFuZWxDbG9zZUJ1dHRvblVwZGF0ZXIiLCJ0b2dnbGVNYXBDb250cm9sVXBkYXRlciIsInBhbmVsSWQiLCJpbmRleCIsInNldE1hcENvbnRyb2xWaXNpYmlsaXR5VXBkYXRlciIsIkJvb2xlYW4iLCJvcGVuRGVsZXRlTW9kYWxVcGRhdGVyIiwiREVMRVRFX0RBVEFfSUQiLCJzZXRFeHBvcnRJbWFnZVNldHRpbmdVcGRhdGVyIiwibmV3U2V0dGluZyIsInVwZGF0ZWQiLCJzZXRFeHBvcnRJbWFnZURhdGFVcmlVcGRhdGVyIiwiZGF0YVVyaSIsInNldEV4cG9ydEltYWdlRXJyb3JVcGRhdGVyIiwiY2xlYW51cEV4cG9ydEltYWdlVXBkYXRlciIsInN0YXJ0RXhwb3J0aW5nSW1hZ2VVcGRhdGVyIiwib3B0aW9ucyIsImltYWdlU2V0dGluZ3MiLCJzZXRFeHBvcnRTZWxlY3RlZERhdGFzZXRVcGRhdGVyIiwiZGF0YXNldCIsInNldEV4cG9ydERhdGFUeXBlVXBkYXRlciIsInNldEV4cG9ydEZpbHRlcmVkVXBkYXRlciIsInNldEV4cG9ydERhdGFVcGRhdGVyIiwic2V0VXNlck1hcGJveEFjY2Vzc1Rva2VuVXBkYXRlciIsInNldEV4cG9ydE1hcEZvcm1hdFVwZGF0ZXIiLCJmb3JtYXQiLCJzZXRFeHBvcnRNYXBIVE1MTW9kZVVwZGF0ZXIiLCJhZGROb3RpZmljYXRpb25VcGRhdGVyIiwib2xkTm90aWZpY2F0aW9ucyIsInBheWxvYWRJZCIsIm5vdGlmaWNhdGlvblRvVXBkYXRlIiwiZmluZCIsIm4iLCJtYXAiLCJjb3VudCIsInJlbW92ZU5vdGlmaWNhdGlvblVwZGF0ZXIiLCJmaWx0ZXIiLCJsb2FkRmlsZXNVcGRhdGVyIiwibG9hZEZpbGVzU3VjY2Vzc1VwZGF0ZXIiLCJsb2FkRmlsZXNFcnJVcGRhdGVyIiwibWVzc2FnZSIsInRvcGljIiwiREVGQVVMVF9OT1RJRklDQVRJT05fVE9QSUNTIiwiZ2xvYmFsIiwidG9nZ2xlU3BsaXRNYXBVcGRhdGVyIiwiZW50cmllcyIsImFjYyIsImVudHJ5Iiwic2hvd0RhdGFzZXRUYWJsZVVwZGF0ZXIiLCJEQVRBX1RBQkxFX0lEIiwic2V0TG9jYWxlVXBkYXRlciIsInRvZ2dsZVBhbmVsTGlzdFZpZXdVcGRhdGVyIiwibGlzdFZpZXciLCJzdGF0ZVByb3AiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFHQTs7QUFhQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFrQk8sSUFBTUEseUJBQXlCLEdBQUcsT0FBbEM7O0FBQ0EsSUFBTUMsYUFBYSxHQUFHQyxzQkFBdEI7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBQ0EsSUFBTUMsZUFBZSxHQUFHLElB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LEtBQUssT0FBWixHQUNJLG9CQURKLEdBRUlBLE9BQU8sS0FBSyxRQUFaLEdBQ0EscUJBREEsR0FFQSxJQUxOOztBQU1BLE1BQUksQ0FBQ21ELFNBQUQsSUFBYzlELEtBQUssQ0FBQzhELFNBQUQsQ0FBTCxLQUFxQkQsUUFBdkMsRUFBaUQ7QUFDL0MsV0FBTzdELEtBQVA7QUFDRDs7QUFDRCx5Q0FDS0EsS0FETCw0Q0FFRzhELFNBRkgsRUFFZUQsUUFGZjtBQUlELENBakJNIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IHtcbiAgQUREX0RBVEFfSUQsXG4gIERBVEFfVEFCTEVfSUQsXG4gIERFRkFVTFRfTk9USUZJQ0FUSU9OX1RPUElDUyxcbiAgREVMRVRFX0RBVEFfSUQsXG4gIEVYUE9SVF9EQVRBX1RZUEUsXG4gIEVYUE9SVF9IVE1MX01BUF9NT0RFUyxcbiAgRVhQT1JUX0lNR19SQVRJT1MsXG4gIEVYUE9SVF9NQVBfRk9STUFUUyxcbiAgUkVTT0xVVElPTlMsXG4gIE1BUF9DT05UUk9MUyxcbiAgRXhwb3J0SW1hZ2Vcbn0gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtMT0NBTEVfQ09ERVN9IGZyb20gJ0BrZXBsZXIuZ2wvbG9jYWxpemF0aW9uJztcbmltcG9ydCB7Y3JlYXRlTm90aWZpY2F0aW9uLCBlcnJvck5vdGlmaWNhdGlvbiwgY2FsY3VsYXRlRXhwb3J0SW1hZ2VTaXplfSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7cGF5bG9hZF8sIGFwcGx5XywgY29tcG9zZV99IGZyb20gJy4vY29tcG9zZXItaGVscGVycyc7XG5cbmltcG9ydCB7XG4gIEFjdGlvblR5cGVzLFxuICBLZXBsZXJHbEluaXRQYXlsb2FkLFxuICBMb2FkRmlsZXNFcnJVcGRhdGVyQWN0aW9uLFxuICBVSVN0YXRlQWN0aW9uc1xufSBmcm9tICdAa2VwbGVyLmdsL2FjdGlvbnMnO1xuaW1wb3J0IHtcbiAgRXhwb3J0RGF0YSxcbiAgRXhwb3J0SHRtbCxcbiAgRXhwb3J0SnNvbixcbiAgRXhwb3J0TWFwLFxuICBNYXBDb250cm9sSXRlbSxcbiAgTWFwQ29udHJvbHMsXG4gIFVpU3RhdGVcbn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0FDVElWRV9TSURFX1BBTkVMID0gJ2xheWVyJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX01PREFMID0gQUREX0RBVEFfSUQ7XG5cbi8qKlxuICogVXBkYXRlcnMgZm9yIGB1aVN0YXRlYCByZWR1Y2VyLiBDYW4gYmUgdXNlZCBpbiB5b3VyIHJvb3QgcmVkdWNlciB0byBkaXJlY3RseSBtb2RpZnkga2VwbGVyLmdsJ3Mgc3RhdGUuXG4gKiBSZWFkIG1vcmUgYWJvdXQgW1VzaW5nIHVwZGF0ZXJzXSguLi9hZHZhbmNlZC11c2FnZS91c2luZy11cGRhdGVycy5tZClcbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBrZXBsZXJHbFJlZHVjZXIsIHt1aVN0YXRlVXBkYXRlcnN9IGZyb20gJ2tlcGxlci5nbC9yZWR1Y2Vycyc7XG4gKiAvLyBSb290IFJlZHVjZXJcbiAqIGNvbnN0IHJlZHVjZXJzID0gY29tYmluZVJlZHVjZXJzKHtcbiAqICBrZXBsZXJHbDoga2VwbGVyR2xSZWR1Y2VyLFxuICogIGFwcDogYXBwUmVkdWNlclxuICogfSk7XG4gKlxuICogY29uc3QgY29tcG9zZWRSZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAqICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gKiAgICAvLyBjbGljayBidXR0b24gdG8gY2xvc2Ugc2lkZSBwYW5lbFxuICogICAgY2FzZSAnQ0xJQ0tfQlVUVE9OJzpcbiAqICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAuLi5zdGF0ZSxcbiAqICAgICAgICBrZXBsZXJHbDoge1xuICogICAgICAgICAgLi4uc3RhdGUua2VwbGVyR2wsXG4gKiAgICAgICAgICBmb286IHtcbiAqICAgICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLmZvbyxcbiAqICAgICAgICAgICAgIHVpU3RhdGU6IHVpU3RhdGVVcGRhdGVycy50b2dnbGVTaWRlUGFuZWxVcGRhdGVyKFxuICogICAgICAgICAgICAgICB1aVN0YXRlLCB7cGF5bG9hZDogbnVsbH1cbiAqICAgICAgICAgICAgIClcbiAqICAgICAgICAgIH1cbiAqICAgICAgICB9XG4gKiAgICAgIH07XG4gKiAgfVxuICogIHJldHVybiByZWR1Y2VycyhzdGF0ZSwgYWN0aW9uKTtcbiAqIH07XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgY29tcG9zZWRSZWR1Y2VyO1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgdWlTdGF0ZVVwZGF0ZXJzID0gbnVsbDtcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuY29uc3QgREVGQVVMVF9NQVBfQ09OVFJPTFNfRkVBVFVSRVM6IE1hcENvbnRyb2xJdGVtID0ge1xuICBzaG93OiB0cnVlLFxuICBhY3RpdmU6IGZhbHNlLFxuICBkaXNhYmxlQ2xvc2U6IGZhbHNlLFxuICAvLyBkZWZpbmVzIHdoaWNoIG1hcCBpbmRleCB1c2VycyBhcmUgaW50ZXJhY3Rpbmcgd2l0aCAodGhyb3VnaCBtYXAgY29udHJvbHMpXG4gIGFjdGl2ZU1hcEluZGV4OiAwXG59O1xuXG4vKipcbiAqIEEgbGlzdCBvZiBtYXAgY29udHJvbCB2aXNpYmlsaXR5IGFuZCB3aGV0aGVyIGlzIGl0IGFjdGl2ZS5cbiAqIEBtZW1iZXJvZiB1aVN0YXRlVXBkYXRlcnNcbiAqIEBjb25zdGFudFxuICogQHByb3BlcnR5IHZpc2libGVMYXllcnMgRGVmYXVsdDogYHtzaG93OiB0cnVlLCBhY3RpdmU6IGZhbHNlfWBcbiAqIEBwcm9wZXJ0eSBtYXBMZWdlbmQgRGVmYXVsdDogYHtzaG93OiB0cnVlLCBhY3RpdmU6IGZhbHNlfWBcbiAqIEBwcm9wZXJ0eSB0b2dnbGUzZCBEZWZhdWx0OiBge3Nob3c6IHRydWV9YFxuICogQHByb3BlcnR5IHNwbGl0TWFwIERlZmF1bHQ6IGB7c2hvdzogdHJ1ZX1gXG4gKiBAcHJvcGVydHkgbWFwRHJhdyBEZWZhdWx0OiBge3Nob3c6IHRydWUsIGFjdGl2ZTogZmFsc2V9YFxuICogQHByb3BlcnR5IG1hcExvY2FsZSBEZWZhdWx0OiBge3Nob3c6IGZhbHNlLCBhY3RpdmU6IGZhbHNlfWBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFQX0NPTlRST0xTOiBNYXBDb250cm9scyA9IChPYmplY3Qua2V5cyhNQVBfQ09OVFJPTFMpIGFzIEFycmF5PFxuICBrZXlvZiB0eXBlb2YgTUFQX0NPTlRST0xTXG4+KS5yZWR1Y2UoXG4gIChmaW5hbCwgY3VycmVudCkgPT4gKHtcbiAgICAuLi5maW5hbCxcbiAgICBbY3VycmVudF06IERFRkFVTFRfTUFQX0NPTlRST0xTX0ZFQVRVUkVTXG4gIH0pLFxuICB7fSBhcyBNYXBDb250cm9sc1xuKTtcblxuLyoqXG4gKiBEZWZhdWx0IGltYWdlIGV4cG9ydCBjb25maWdcbiAqIEBtZW1iZXJvZiB1aVN0YXRlVXBkYXRlcnNcbiAqIEBjb25zdGFudFxuICogQHByb3BlcnR5IHJhdGlvIERlZmF1bHQ6IGAnU0NSRUVOJ2AsXG4gKiBAcHJvcGVydHkgcmVzb2x1dGlvbiBEZWZhdWx0OiBgJ09ORV9YJ2AsXG4gKiBAcHJvcGVydHkgbGVnZW5kIERlZmF1bHQ6IGBmYWxzZWAsXG4gKiBAcHJvcGVydHkgbWFwSCBEZWZhdWx0OiAwLFxuICogQHByb3BlcnR5IG1hcFcgRGVmYXVsdDogMCxcbiAqIEBwcm9wZXJ0eSBpbWFnZVNpemUgRGVmYXVsdDoge3pvb21PZmZzZXQ6IDAsIHNjYWxlOiAxLCBpbWFnZVc6IDAsIGltYWdlSDogMH0sXG4gKiBAcHJvcGVydHkgaW1hZ2VEYXRhVXJpIERlZmF1bHQ6IGAnJ2AsXG4gKiBAcHJvcGVydHkgZXhwb3J0aW5nIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwcm9wZXJ0eSBlcnJvciBEZWZhdWx0OiBgZmFsc2VgXG4gKiBAcHJvcGVydHkgZXNjYXBlWGh0bWxGb3JXZWJwYWNrIERlZmF1bHQ6IGB0cnVlYFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9FWFBPUlRfSU1BR0U6IEV4cG9ydEltYWdlID0ge1xuICAvLyB1c2VyIG9wdGlvbnNcbiAgcmF0aW86IEVYUE9SVF9JTUdfUkFUSU9TLlNDUkVFTixcbiAgcmVzb2x1dGlvbjogUkVTT0xVVElPTlMuT05FX1gsXG4gIGxlZ2VuZDogZmFsc2UsXG4gIG1hcEg6IDAsXG4gIG1hcFc6IDAsXG4gIGltYWdlU2l6ZToge1xuICAgIHpvb21PZmZzZXQ6IDAsXG4gICAgc2NhbGU6IDEsXG4gICAgaW1hZ2VXOiAwLFxuICAgIGltYWdlSDogMFxuICB9LFxuICAvLyB3aGVuIHRoaXMgaXMgc2V0IHRvIHRydWUsIHRoZSBtb2NrIG1hcCB2aWV3cG9ydCB3aWxsIG1vdmUgdG8gdGhlIGNlbnRlciBvZiBkYXRhXG4gIGNlbnRlcjogZmFsc2UsXG4gIC8vIGV4cG9ydGluZyBzdGF0ZVxuICBpbWFnZURhdGFVcmk6ICcnLFxuICAvLyBleHBvcnRpbmc6IHVzZWQgdG8gYXR0YWNoIHBsb3QtY29udGFpbmVyIHRvIGRvbVxuICBleHBvcnRpbmc6IGZhbHNlLFxuICAvLyBwcm9jZXNzaW5nOiB1c2VkIGFzIGxvYWRpbmcgaW5kaWNhdG9yIHdoZW4gZXhwb3J0IGltYWdlIGlzIGJlaW5nIHByb2R1Y2VkXG4gIHByb2Nlc3Npbmc6IGZhbHNlLFxuICBlcnJvcjogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gYXBwbHkgZml4IGZvciB1Z2xpZnkgZXJyb3IgaW4gZG9tLXRvLWltYWdlIChzaG91bGQgYmUgdHJ1ZSBmb3Igd2VicGFjayBidWlsZHMpXG4gIGVzY2FwZVhodG1sRm9yV2VicGFjazogdHJ1ZVxufTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTE9BRF9GSUxFUyA9IHtcbiAgZmlsZUxvYWRpbmc6IGZhbHNlXG59O1xuXG4vKipcbiAqIERlZmF1bHQgaW5pdGlhbCBgZXhwb3J0RGF0YWAgc2V0dGluZ3NcbiAqIEBtZW1iZXJvZiB1aVN0YXRlVXBkYXRlcnNcbiAqIEBjb25zdGFudFxuICogQHByb3BlcnR5IHNlbGVjdGVkRGF0YXNldCBEZWZhdWx0OiBgJydgLFxuICogQHByb3BlcnR5IGRhdGFUeXBlIERlZmF1bHQ6IGAnY3N2J2AsXG4gKiBAcHJvcGVydHkgZmlsdGVyZWQgRGVmYXVsdDogYHRydWVgLFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9FWFBPUlRfREFUQTogRXhwb3J0RGF0YSA9IHtcbiAgc2VsZWN0ZWREYXRhc2V0OiAnJyxcbiAgZGF0YVR5cGU6IEVYUE9SVF9EQVRBX1RZUEUuQ1NWLFxuICBmaWx0ZXJlZDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTk9USUZJQ0FUSU9OUyA9IFtdO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHByb3BlcnR5IGV4cG9ydE1hcGJveEFjY2Vzc1Rva2VuIC0gRGVmYXVsdDogbnVsbCwgdGhpcyBpcyB1c2VkIHdoZW4gd2UgcHJvdmlkZSBhIGRlZmF1bHQgbWFwYm94IHRva2VuIGZvciB1c2VycyB0byB0YWtlIGFkdmFudGFnZSBvZlxuICogQHByb3BlcnR5IHVzZXJNYXBib3hUb2tlbiAtIERlZmF1bHQ6ICcnLCBtYXBib3ggdG9rZW4gcHJvdmlkZWQgYnkgdXNlciB0aHJvdWdoIGlucHV0IGZpZWxkXG4gKiBAcHJvcGVydHkgbW9kZSAtIERlZmF1bHQ6ICdSRUFEJywgcmVhZCBvbmx5IG9yIGVkaXRhYmxlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX0VYUE9SVF9IVE1MOiBFeHBvcnRIdG1sID0ge1xuICBleHBvcnRNYXBib3hBY2Nlc3NUb2tlbjogbnVsbCxcbiAgdXNlck1hcGJveFRva2VuOiAnJyxcbiAgbW9kZTogRVhQT1JUX0hUTUxfTUFQX01PREVTLlJFQURcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAcHJvcGVydHkgaGFzRGF0YSAtIERlZmF1bHQ6ICd0cnVlJyxcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfRVhQT1JUX0pTT046IEV4cG9ydEpzb24gPSB7XG4gIGhhc0RhdGE6IHRydWVcbn07XG5cbi8qKlxuICogRXhwb3J0IE1hcCBDb25maWdcbiAqIEBjb25zdGFudFxuICogQHByb3BlcnR5IEhUTUwgLSBEZWZhdWx0OiAnREVGQVVMVF9FWFBPUlRfSFRNTCcsXG4gKiBAcHJvcGVydHkgSlNPTiAtIERlZmF1bHQ6ICdERUZBVUxUX0VYUE9SVF9KU09OJyxcbiAqIEBwcm9wZXJ0eSBmb3JtYXQgLSBEZWZhdWx0OiAnSFRNTCcsXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX0VYUE9SVF9NQVA6IEV4cG9ydE1hcCA9IHtcbiAgW0VYUE9SVF9NQVBfRk9STUFUUy5IVE1MXTogREVGQVVMVF9FWFBPUlRfSFRNTCxcbiAgW0VYUE9SVF9NQVBfRk9STUFUUy5KU09OXTogREVGQVVMVF9FWFBPUlRfSlNPTixcbiAgZm9ybWF0OiBFWFBPUlRfTUFQX0ZPUk1BVFMuSFRNTFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IGluaXRpYWwgYHVpU3RhdGVgXG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAY29uc3RhbnRcbiAqIEBwcm9wZXJ0eSByZWFkT25seSBEZWZhdWx0OiBgZmFsc2VgXG4gKiBAcHJvcGVydHkgYWN0aXZlU2lkZVBhbmVsIERlZmF1bHQ6IGAnbGF5ZXInYFxuICogQHByb3BlcnR5IGN1cnJlbnRNb2RhbCBEZWZhdWx0OiBgJ2FkZERhdGEnYFxuICogQHByb3BlcnR5IGRhdGFzZXRLZXlUb1JlbW92ZSBEZWZhdWx0OiBgbnVsbGBcbiAqIEBwcm9wZXJ0eSB2aXNpYmxlRHJvcGRvd24gRGVmYXVsdDogYG51bGxgXG4gKiBAcHJvcGVydHkgZXhwb3J0SW1hZ2UgRGVmYXVsdDogW2BERUZBVUxUX0VYUE9SVF9JTUFHRWBdKCNkZWZhdWx0X2V4cG9ydF9pbWFnZSlcbiAqIEBwcm9wZXJ0eSBleHBvcnREYXRhIERlZmF1bHQ6IFtgREVGQVVMVF9FWFBPUlRfREFUQWBdKCNkZWZhdWx0X2V4cG9ydF9kYXRhKVxuICogQHByb3BlcnR5IGV4cG9ydE1hcCBEZWZhdWx0OiBbYERFRkFVTFRfRVhQT1JUX01BUGBdKCNkZWZhdWx0X2V4cG9ydF9tYXApXG4gKiBAcHJvcGVydHkgbWFwQ29udHJvbHMgRGVmYXVsdDogW2BERUZBVUxUX01BUF9DT05UUk9MU2BdKCNkZWZhdWx0X21hcF9jb250cm9scylcbiAqIEBwcm9wZXJ0eSBub3RpZmljYXRpb25zIERlZmF1bHQ6IGBbXWBcbiAqIEBwcm9wZXJ0eSBub3RpZmljYXRpb25zIERlZmF1bHQ6IGBbXWBcbiAqIEBwcm9wZXJ0eSBsb2FkRmlsZXNcbiAqIEBwcm9wZXJ0eSBpc1NpZGVQYW5lbENsb3NlQnV0dG9uVmlzaWJsZSBEZWZhdWx0OiBgdHJ1ZWBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IElOSVRJQUxfVUlfU1RBVEU6IFVpU3RhdGUgPSB7XG4gIHJlYWRPbmx5OiBmYWxzZSxcbiAgYWN0aXZlU2lkZVBhbmVsOiBERUZBVUxUX0FDVElWRV9TSURFX1BBTkVMLFxuICBjdXJyZW50TW9kYWw6IERFRkFVTFRfTU9EQUwsXG4gIGRhdGFzZXRLZXlUb1JlbW92ZTogbnVsbCxcbiAgdmlzaWJsZURyb3Bkb3duOiBudWxsLFxuICAvLyBleHBvcnQgaW1hZ2UgbW9kYWwgdWlcbiAgZXhwb3J0SW1hZ2U6IERFRkFVTFRfRVhQT1JUX0lNQUdFLFxuICAvLyBleHBvcnQgZGF0YSBtb2RhbCB1aVxuICBleHBvcnREYXRhOiBERUZBVUxUX0VYUE9SVF9EQVRBLFxuICAvLyBodG1sIGV4cG9ydFxuICBleHBvcnRNYXA6IERFRkFVTFRfRVhQT1JUX01BUCxcbiAgLy8gbWFwIGNvbnRyb2wgcGFuZWxzXG4gIG1hcENvbnRyb2xzOiBERUZBVUxUX01BUF9DT05UUk9MUyxcbiAgLy8gdWkgbm90aWZpY2F0aW9uc1xuICBub3RpZmljYXRpb25zOiBERUZBVUxUX05PVElGSUNBVElPTlMsXG4gIC8vIGxvYWQgZmlsZXNcbiAgbG9hZEZpbGVzOiBERUZBVUxUX0xPQURfRklMRVMsXG4gIC8vIExvY2FsZSBvZiB0aGUgVUlcbiAgbG9jYWxlOiBMT0NBTEVfQ09ERVMuZW4sXG4gIGxheWVyUGFuZWxMaXN0VmlldzogJ2xpc3QnLFxuICBmaWx0ZXJQYW5lbExpc3RWaWV3OiAnbGlzdCcsXG4gIGlzU2lkZVBhbmVsQ2xvc2VCdXR0b25WaXNpYmxlOiB0cnVlXG59O1xuXG4vKiBVcGRhdGVycyAqL1xuLyoqXG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0VWlTdGF0ZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBVaVN0YXRlLFxuICBhY3Rpb246IHtcbiAgICB0eXBlPzogdHlwZW9mIEFjdGlvblR5cGVzWydJTklUJ107XG4gICAgcGF5bG9hZDogS2VwbGVyR2xJbml0UGF5bG9hZDtcbiAgfVxuKTogVWlTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgLi4uKGFjdGlvbi5wYXlsb2FkIHx8IHt9KS5pbml0aWFsVWlTdGF0ZVxufSk7XG5cbi8qKlxuICogVG9nZ2xlIGFjdGl2ZSBzaWRlIHBhbmVsXG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0gc3RhdGUgYHVpU3RhdGVgXG4gKiBAcGFyYW0gYWN0aW9uXG4gKiBAcGFyYW0gYWN0aW9uLnBheWxvYWQgaWQgb2Ygc2lkZSBwYW5lbCB0byBiZSBzaG93biwgb25lIG9mIGBsYXllcmAsIGBmaWx0ZXJgLCBgaW50ZXJhY3Rpb25gLCBgbWFwYC4gY2xvc2Ugc2lkZSBwYW5lbCBpZiBgbnVsbGBcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlU2lkZVBhbmVsVXBkYXRlciA9IChcbiAgc3RhdGU6IFVpU3RhdGUsXG4gIHtwYXlsb2FkOiBpZH06IFVJU3RhdGVBY3Rpb25zLlRvZ2dsZVNpZGVQYW5lbFVwZGF0ZXJBY3Rpb25cbik6IFVpU3RhdGUgPT4ge1xuICByZXR1cm4gaWQgPT09IHN0YXRlLmFjdGl2ZVNpZGVQYW5lbFxuICAgID8gc3RhdGVcbiAgICA6IHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGFjdGl2ZVNpZGVQYW5lbDogaWRcbiAgICAgIH07XG59O1xuXG4vKipcbiAqIFNob3cgYW5kIGhpZGUgbW9kYWwgZGlhbG9nXG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0gc3RhdGUgYHVpU3RhdGVgXG4gKiBAcGFyYW0gYWN0aW9uXG4gKiBAcGFyYW1hY3Rpb24ucGF5bG9hZCBpZCBvZiBtb2RhbCB0byBiZSBzaG93biwgbnVsbCB0byBoaWRlIG1vZGFscy4gT25lIG9mOlxuICogIC0gW2BEQVRBX1RBQkxFX0lEYF0oLi4vY29uc3RhbnRzL2RlZmF1bHQtc2V0dGluZ3MubWQjZGF0YV90YWJsZV9pZClcbiAqICAtIFtgREVMRVRFX0RBVEFfSURgXSguLi9jb25zdGFudHMvZGVmYXVsdC1zZXR0aW5ncy5tZCNkZWxldGVfZGF0YV9pZClcbiAqICAtIFtgQUREX0RBVEFfSURgXSguLi9jb25zdGFudHMvZGVmYXVsdC1zZXR0aW5ncy5tZCNhZGRfZGF0YV9pZClcbiAqICAtIFtgRVhQT1JUX0lNQUdFX0lEYF0oLi4vY29uc3RhbnRzL2RlZmF1bHQtc2V0dGluZ3MubWQjZXhwb3J0X2ltYWdlX2lkKVxuICogIC0gW2BFWFBPUlRfREFUQV9JRGBdKC4uL2NvbnN0YW50cy9kZWZhdWx0LXNldHRpbmdzLm1kI2V4cG9ydF9kYXRhX2lkKVxuICogIC0gW2BBRERfTUFQX1NUWUxFX0lEYF0oLi4vY29uc3RhbnRzL2RlZmF1bHQtc2V0dGluZ3MubWQjYWRkX21hcF9zdHlsZV9pZClcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlTW9kYWxVcGRhdGVyID0gKFxuICBzdGF0ZTogVWlTdGF0ZSxcbiAge3BheWxvYWQ6IGlkfTogVUlTdGF0ZUFjdGlvbnMuVG9nZ2xlTW9kYWxVcGRhdGVyQWN0aW9uXG4pOiBVaVN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBjdXJyZW50TW9kYWw6IGlkXG59KTtcblxuLyoqXG4gKiBIaWRlIGFuZCBzaG93IHNpZGUgcGFuZWwgaGVhZGVyIGRyb3Bkb3duLCBhY3RpdmF0ZWQgYnkgY2xpY2tpbmcgdGhlIHNoYXJlIGxpbmsgb24gdG9wIG9mIHRoZSBzaWRlIHBhbmVsXG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzaG93RXhwb3J0RHJvcGRvd25VcGRhdGVyID0gKFxuICBzdGF0ZTogVWlTdGF0ZSxcbiAge3BheWxvYWQ6IGlkfTogVUlTdGF0ZUFjdGlvbnMuU2hvd0V4cG9ydERyb3Bkb3duVXBkYXRlckFjdGlvblxuKTogVWlTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgdmlzaWJsZURyb3Bkb3duOiBpZFxufSk7XG5cbi8qKlxuICogSGlkZSBzaWRlIHBhbmVsIGhlYWRlciBkcm9wZG93biwgYWN0aXZhdGVkIGJ5IGNsaWNraW5nIHRoZSBzaGFyZSBsaW5rIG9uIHRvcCBvZiB0aGUgc2lkZSBwYW5lbFxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgaGlkZUV4cG9ydERyb3Bkb3duVXBkYXRlciA9IChzdGF0ZTogVWlTdGF0ZSk6IFVpU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIHZpc2libGVEcm9wZG93bjogbnVsbFxufSk7XG5cbi8qKlxuICogVG9nZ2xlIHNpZGUgcGFuZWwgY2xvc2UgYnV0dG9uIG9uIHRvcCBsZWZ0IG9mIHRoZSBzaWRlIHBhbmVsXG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVTaWRlUGFuZWxDbG9zZUJ1dHRvblVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBVaVN0YXRlLFxuICB7cGF5bG9hZDoge3Nob3d9fTogVUlTdGF0ZUFjdGlvbnMuVG9nZ2xlU2lkZVBhbmVsQ2xvc2VCdXR0b25VcGRhdGVyQWN0aW9uXG4pOiBVaVN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBpc1NpZGVQYW5lbENsb3NlQnV0dG9uVmlzaWJsZTogc2hvd1xufSk7XG5cbi8qKlxuICogVG9nZ2xlIGFjdGl2ZSBtYXAgY29udHJvbCBwYW5lbFxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGB1aVN0YXRlYFxuICogQHBhcmFtIGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSBhY3Rpb24ucGF5bG9hZCBtYXAgY29udHJvbCBwYW5lbCBpZCwgb25lIG9mIHRoZSBrZXlzIG9mOiBbYERFRkFVTFRfTUFQX0NPTlRST0xTYF0oI2RlZmF1bHRfbWFwX2NvbnRyb2xzKVxuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVNYXBDb250cm9sVXBkYXRlciA9IChcbiAgc3RhdGU6IFVpU3RhdGUsXG4gIHtwYXlsb2FkOiB7cGFuZWxJZCwgaW5kZXggPSAwfX06IFVJU3RhdGVBY3Rpb25zLlRvZ2dsZU1hcENvbnRyb2xVcGRhdGVyQWN0aW9uXG4pOiBVaVN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBtYXBDb250cm9sczoge1xuICAgIC4uLnN0YXRlLm1hcENvbnRyb2xzLFxuICAgIFtwYW5lbElkXToge1xuICAgICAgLi4uc3RhdGUubWFwQ29udHJvbHNbcGFuZWxJZF0sXG4gICAgICBhY3RpdmU6ICFzdGF0ZS5tYXBDb250cm9sc1twYW5lbElkXS5hY3RpdmUsXG4gICAgICBhY3RpdmVNYXBJbmRleDogaW5kZXhcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRvZ2dsZSBtYXAgY29udHJvbCB2aXNpYmlsaXR5XG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0gc3RhdGUgYHVpU3RhdGVgXG4gKiBAcGFyYW0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkIG1hcCBjb250cm9sIHBhbmVsIGlkLCBvbmUgb2YgdGhlIGtleXMgb2Y6IFtgREVGQVVMVF9NQVBfQ09OVFJPTFNgXSgjZGVmYXVsdF9tYXBfY29udHJvbHMpXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldE1hcENvbnRyb2xWaXNpYmlsaXR5VXBkYXRlciA9IChcbiAgc3RhdGU6IFVpU3RhdGUsXG4gIHtwYXlsb2FkOiB7cGFuZWxJZCwgc2hvd319OiBVSVN0YXRlQWN0aW9ucy5zZXRNYXBDb250cm9sVmlzaWJpbGl0eVVwZGF0ZXJBY3Rpb25cbik6IFVpU3RhdGUgPT4ge1xuICBpZiAoIXN0YXRlLm1hcENvbnRyb2xzPy5bcGFuZWxJZF0pIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIG1hcENvbnRyb2xzOiB7XG4gICAgICAuLi5zdGF0ZS5tYXBDb250cm9scyxcbiAgICAgIFtwYW5lbElkXToge1xuICAgICAgICAuLi5zdGF0ZS5tYXBDb250cm9sc1twYW5lbElkXSxcbiAgICAgICAgc2hvdzogQm9vbGVhbihzaG93KVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogVG9nZ2xlIGFjdGl2ZSBtYXAgY29udHJvbCBwYW5lbFxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGB1aVN0YXRlYFxuICogQHBhcmFtIGFjdGlvblxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkIGRhdGFzZXQgaWRcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgb3BlbkRlbGV0ZU1vZGFsVXBkYXRlciA9IChcbiAgc3RhdGU6IFVpU3RhdGUsXG4gIHtwYXlsb2FkOiBkYXRhc2V0S2V5VG9SZW1vdmV9OiBVSVN0YXRlQWN0aW9ucy5PcGVuRGVsZXRlTW9kYWxVcGRhdGVyQWN0aW9uXG4pOiBVaVN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBjdXJyZW50TW9kYWw6IERFTEVURV9EQVRBX0lELFxuICBkYXRhc2V0S2V5VG9SZW1vdmVcbn0pO1xuXG4vKipcbiAqIFNldCBgZXhwb3J0SW1hZ2UubGVnZW5kYCB0byBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGB1aVN0YXRlYFxuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRFeHBvcnRJbWFnZVNldHRpbmdVcGRhdGVyID0gKFxuICBzdGF0ZTogVWlTdGF0ZSxcbiAge3BheWxvYWQ6IG5ld1NldHRpbmd9OiBVSVN0YXRlQWN0aW9ucy5TZXRFeHBvcnRJbWFnZVNldHRpbmdVcGRhdGVyQWN0aW9uXG4pOiBVaVN0YXRlID0+IHtcbiAgY29uc3QgdXBkYXRlZCA9IHsuLi5zdGF0ZS5leHBvcnRJbWFnZSwgLi4ubmV3U2V0dGluZ307XG4gIGNvbnN0IGltYWdlU2l6ZSA9IGNhbGN1bGF0ZUV4cG9ydEltYWdlU2l6ZSh1cGRhdGVkKSB8fCBzdGF0ZS5leHBvcnRJbWFnZS5pbWFnZVNpemU7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBleHBvcnRJbWFnZToge1xuICAgICAgLi4udXBkYXRlZCxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIC8vIFRPRE86IGNhbGN1bGF0ZUV4cG9ydEltYWdlU2l6ZSBkb2VzIG5vdCByZXR1cm4gaW1hZ2VTaXplLnpvb21PZmZzZXQsXG4gICAgICAvLyBkbyB3ZSBuZWVkIHRha2UgdGhpcyB2YWx1ZSBmcm9tIGN1cnJlbnQgc3RhdGUsIG9yIHJldHVybiBkZWZhdWwgdmFsdWUgPSAwXG4gICAgICBpbWFnZVNpemVcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFNldCBgZXhwb3J0SW1hZ2Uuc2V0RXhwb3J0SW1hZ2VEYXRhVXJpYCB0byBhIGltYWdlIGRhdGFVcmlcbiAqIEBtZW1iZXJvZiB1aVN0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSBzdGF0ZSBgdWlTdGF0ZWBcbiAqIEBwYXJhbSBhY3Rpb25cbiAqIEBwYXJhbSBhY3Rpb24ucGF5bG9hZCBleHBvcnQgaW1hZ2UgZGF0YSB1cmlcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgc2V0RXhwb3J0SW1hZ2VEYXRhVXJpVXBkYXRlciA9IChcbiAgc3RhdGU6IFVpU3RhdGUsXG4gIHtwYXlsb2FkOiBkYXRhVXJpfTogVUlTdGF0ZUFjdGlvbnMuU2V0RXhwb3J0SW1hZ2VEYXRhVXJpVXBkYXRlckFjdGlvblxuKTogVWlTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZXhwb3J0SW1hZ2U6IHtcbiAgICAuLi5zdGF0ZS5leHBvcnRJbWFnZSxcbiAgICBwcm9jZXNzaW5nOiBmYWxzZSxcbiAgICBpbWFnZURhdGFVcmk6IGRhdGFVcmlcbiAgfVxufSk7XG5cbi8qKlxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgc2V0RXhwb3J0SW1hZ2VFcnJvclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBVaVN0YXRlLFxuICB7cGF5bG9hZDogZXJyb3J9OiBVSVN0YXRlQWN0aW9ucy5TZXRFeHBvcnRJbWFnZUVycm9yVXBkYXRlckFjdGlvblxuKTogVWlTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZXhwb3J0SW1hZ2U6IHtcbiAgICAuLi5zdGF0ZS5leHBvcnRJbWFnZSxcbiAgICBwcm9jZXNzaW5nOiBmYWxzZSxcbiAgICBlcnJvclxuICB9XG59KTtcblxuLyoqXG4gKiBEZWxldGUgY2FjaGVkIGV4cG9ydCBpbWFnZVxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgY2xlYW51cEV4cG9ydEltYWdlVXBkYXRlciA9IChzdGF0ZTogVWlTdGF0ZSk6IFVpU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGV4cG9ydEltYWdlOiB7XG4gICAgLi4uc3RhdGUuZXhwb3J0SW1hZ2UsXG4gICAgZXhwb3J0aW5nOiBmYWxzZSxcbiAgICBpbWFnZURhdGFVcmk6ICcnLFxuICAgIGVycm9yOiBmYWxzZSxcbiAgICBwcm9jZXNzaW5nOiBmYWxzZSxcbiAgICBjZW50ZXI6IGZhbHNlXG4gIH1cbn0pO1xuXG4vKipcbiAqIFN0YXJ0IGltYWdlIGV4cG9ydGluZyBmbG93XG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0gc3RhdGVcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7VWlTdGF0ZX1cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHN0YXJ0RXhwb3J0aW5nSW1hZ2VVcGRhdGVyID0gKFxuICBzdGF0ZTogVWlTdGF0ZSxcbiAge3BheWxvYWQ6IG9wdGlvbnMgPSB7fX06IHtwYXlsb2FkOiBQYXJ0aWFsPEV4cG9ydEltYWdlPn1cbik6IFVpU3RhdGUgPT4ge1xuICBjb25zdCBpbWFnZVNldHRpbmdzID0ge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgZXhwb3J0aW5nOiB0cnVlXG4gIH07XG5cbiAgcmV0dXJuIGNvbXBvc2VfKFtcbiAgICBjbGVhbnVwRXhwb3J0SW1hZ2VVcGRhdGVyLFxuICAgIGFwcGx5XyhzZXRFeHBvcnRJbWFnZVNldHRpbmdVcGRhdGVyLCBwYXlsb2FkXyhpbWFnZVNldHRpbmdzKSlcbiAgXSkoc3RhdGUpO1xufTtcblxuLyoqXG4gKiBTZXQgc2VsZWN0ZWQgZGF0YXNldCBmb3IgZXhwb3J0XG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0gc3RhdGUgYHVpU3RhdGVgXG4gKiBAcGFyYW0gYWN0aW9uXG4gKiBAcGFyYW0gYWN0aW9uLnBheWxvYWQgZGF0YXNldCBpZFxuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRFeHBvcnRTZWxlY3RlZERhdGFzZXRVcGRhdGVyID0gKFxuICBzdGF0ZTogVWlTdGF0ZSxcbiAge3BheWxvYWQ6IGRhdGFzZXR9OiBVSVN0YXRlQWN0aW9ucy5TZXRFeHBvcnRTZWxlY3RlZERhdGFzZXRVcGRhdGVyQWN0aW9uXG4pOiBVaVN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBleHBvcnREYXRhOiB7XG4gICAgLi4uc3RhdGUuZXhwb3J0RGF0YSxcbiAgICBzZWxlY3RlZERhdGFzZXQ6IGRhdGFzZXRcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IGRhdGEgZm9ybWF0IGZvciBleHBvcnRpbmcgZGF0YVxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGB1aVN0YXRlYFxuICogQHBhcmFtIGFjdGlvblxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkIG9uZSBvZiBgJ3RleHQvY3N2J2BcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgc2V0RXhwb3J0RGF0YVR5cGVVcGRhdGVyID0gKFxuICBzdGF0ZTogVWlTdGF0ZSxcbiAge3BheWxvYWQ6IGRhdGFUeXBlfTogVUlTdGF0ZUFjdGlvbnMuU2V0RXhwb3J0RGF0YVR5cGVVcGRhdGVyQWN0aW9uXG4pOiBVaVN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBleHBvcnREYXRhOiB7XG4gICAgLi4uc3RhdGUuZXhwb3J0RGF0YSxcbiAgICBkYXRhVHlwZVxuICB9XG59KTtcblxuLyoqXG4gKiBXaGV0aGVyIHRvIGV4cG9ydCBmaWx0ZXJlZCBkYXRhLCBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGB1aVN0YXRlYFxuICogQHBhcmFtIGFjdGlvblxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEV4cG9ydEZpbHRlcmVkVXBkYXRlciA9IChcbiAgc3RhdGU6IFVpU3RhdGUsXG4gIHtwYXlsb2FkOiBmaWx0ZXJlZH06IFVJU3RhdGVBY3Rpb25zLlNldEV4cG9ydEZpbHRlcmVkVXBkYXRlckFjdGlvblxuKTogVWlTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZXhwb3J0RGF0YToge1xuICAgIC4uLnN0YXRlLmV4cG9ydERhdGEsXG4gICAgZmlsdGVyZWRcbiAgfVxufSk7XG5cbi8qKlxuICogV2hldGhlciB0byBpbmNsdWRpbmcgZGF0YSBpbiBtYXAgY29uZmlnLCB0b2dnbGUgYmV0d2VlbiBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGB1aVN0YXRlYFxuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRFeHBvcnREYXRhVXBkYXRlciA9IChzdGF0ZTogVWlTdGF0ZSk6IFVpU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGV4cG9ydE1hcDoge1xuICAgIC4uLnN0YXRlLmV4cG9ydE1hcCxcbiAgICBbRVhQT1JUX01BUF9GT1JNQVRTLkpTT05dOiB7XG4gICAgICAuLi5zdGF0ZS5leHBvcnRNYXBbRVhQT1JUX01BUF9GT1JNQVRTLkpTT05dLFxuICAgICAgaGFzRGF0YTogIXN0YXRlLmV4cG9ydE1hcFtFWFBPUlRfTUFQX0ZPUk1BVFMuSlNPTl0uaGFzRGF0YVxuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogd2hldGhlciB0byBleHBvcnQgYSBtYXBib3ggYWNjZXNzIHRvIEhUTUwgc2luZ2xlIHBhZ2VcbiAqIEBwYXJhbSBzdGF0ZSAtIGB1aVN0YXRlYFxuICogQHBhcmFtIGFjdGlvblxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldFVzZXJNYXBib3hBY2Nlc3NUb2tlblVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBVaVN0YXRlLFxuICB7cGF5bG9hZDogdXNlck1hcGJveFRva2VufTogVUlTdGF0ZUFjdGlvbnMuU2V0VXNlck1hcGJveEFjY2Vzc1Rva2VuVXBkYXRlckFjdGlvblxuKTogVWlTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZXhwb3J0TWFwOiB7XG4gICAgLi4uc3RhdGUuZXhwb3J0TWFwLFxuICAgIFtFWFBPUlRfTUFQX0ZPUk1BVFMuSFRNTF06IHtcbiAgICAgIC4uLnN0YXRlLmV4cG9ydE1hcFtFWFBPUlRfTUFQX0ZPUk1BVFMuSFRNTF0sXG4gICAgICB1c2VyTWFwYm94VG9rZW5cbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIFNldHMgdGhlIGV4cG9ydCBtYXAgZm9ybWF0XG4gKiBAcGFyYW0gc3RhdGUgLSBgdWlTdGF0ZWBcbiAqIEBwYXJhbSBhY3Rpb25cbiAqIEBwYXJhbSBhY3Rpb24ucGF5bG9hZCBmb3JtYXQgdG8gdXNlIHRvIGV4cG9ydCB0aGUgbWFwIGludG9cbiAqIEByZXR1cm4gbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRFeHBvcnRNYXBGb3JtYXRVcGRhdGVyID0gKFxuICBzdGF0ZTogVWlTdGF0ZSxcbiAge3BheWxvYWQ6IGZvcm1hdH06IFVJU3RhdGVBY3Rpb25zLlNldEV4cG9ydE1hcEZvcm1hdFVwZGF0ZXJBY3Rpb25cbik6IFVpU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGV4cG9ydE1hcDoge1xuICAgIC4uLnN0YXRlLmV4cG9ydE1hcCxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgZm9ybWF0XG4gIH1cbn0pO1xuXG4vKipcbiAqIFNldCB0aGUgZXhwb3J0IGh0bWwgbWFwIG1vZGVcbiAqIEBwYXJhbSBzdGF0ZSAtIGB1aVN0YXRlYFxuICogQHBhcmFtIGFjdGlvblxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkIHRvIGJlIHNldCAoYXZhaWxhYmxlIG1vZGVzOiBFWFBPUlRfSFRNTF9NQVBfTU9ERVMpXG4gKiBAcmV0dXJuIG5leHRTdGF0ZVxuICovXG5leHBvcnQgY29uc3Qgc2V0RXhwb3J0TWFwSFRNTE1vZGVVcGRhdGVyID0gKFxuICBzdGF0ZTogVWlTdGF0ZSxcbiAge3BheWxvYWQ6IG1vZGV9OiBVSVN0YXRlQWN0aW9ucy5TZXRFeHBvcnRIVE1MTWFwTW9kZVVwZGF0ZXJBY3Rpb25cbik6IFVpU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGV4cG9ydE1hcDoge1xuICAgIC4uLnN0YXRlLmV4cG9ydE1hcCxcbiAgICBbRVhQT1JUX01BUF9GT1JNQVRTLkhUTUxdOiB7XG4gICAgICAuLi5zdGF0ZS5leHBvcnRNYXBbRVhQT1JUX01BUF9GT1JNQVRTLkhUTUxdLFxuICAgICAgbW9kZVxuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogQWRkcyBhIG5ldyBub3RpZmljYXRpb24uXG4gKiBVcGRhdGVzIGEgbm90aWZpY2F0aW9uIGluIGNhc2Ugb2YgbWF0Y2hpbmcgaWRzLlxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGB1aVN0YXRlYFxuICogQHBhcmFtIGFjdGlvblxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkIFBhcmFtcyBvZiBhIG5vdGlmaWNhdGlvblxuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBhZGROb3RpZmljYXRpb25VcGRhdGVyID0gKFxuICBzdGF0ZTogVWlTdGF0ZSxcbiAge3BheWxvYWR9OiBVSVN0YXRlQWN0aW9ucy5BZGROb3RpZmljYXRpb25VcGRhdGVyQWN0aW9uXG4pOiBVaVN0YXRlID0+IHtcbiAgY29uc3Qgb2xkTm90aWZpY2F0aW9ucyA9IHN0YXRlLm5vdGlmaWNhdGlvbnMgfHwgW107XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgY29uc3QgcGF5bG9hZElkID0gcGF5bG9hZD8uaWQ7XG4gIGNvbnN0IG5vdGlmaWNhdGlvblRvVXBkYXRlID0gcGF5bG9hZElkID8gb2xkTm90aWZpY2F0aW9ucy5maW5kKG4gPT4gbi5pZCA9PT0gcGF5bG9hZElkKSA6IG51bGw7XG5cbiAgbGV0IG5vdGlmaWNhdGlvbnM7XG4gIGlmIChub3RpZmljYXRpb25Ub1VwZGF0ZSkge1xuICAgIG5vdGlmaWNhdGlvbnMgPSBvbGROb3RpZmljYXRpb25zLm1hcChuID0+XG4gICAgICBuLmlkID09PSBwYXlsb2FkSWQgPyBjcmVhdGVOb3RpZmljYXRpb24oey4uLnBheWxvYWQsIGNvdW50OiBuLmNvdW50ICsgMX0pIDogblxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbm90aWZpY2F0aW9ucyA9IFsuLi5vbGROb3RpZmljYXRpb25zLCBjcmVhdGVOb3RpZmljYXRpb24ocGF5bG9hZCldO1xuICB9XG5cbiAgcmV0dXJuIHsuLi5zdGF0ZSwgbm90aWZpY2F0aW9uc307XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIG5vdGlmaWNhdGlvblxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGB1aVN0YXRlYFxuICogQHBhcmFtIGFjdGlvblxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkIGlkIG9mIHRoZSBub3RpZmljYXRpb24gdG8gYmUgcmVtb3ZlZFxuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVOb3RpZmljYXRpb25VcGRhdGVyID0gKFxuICBzdGF0ZTogVWlTdGF0ZSxcbiAge3BheWxvYWQ6IGlkfTogVUlTdGF0ZUFjdGlvbnMuUmVtb3ZlTm90aWZpY2F0aW9uVXBkYXRlckFjdGlvblxuKTogVWlTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgbm90aWZpY2F0aW9uczogc3RhdGUubm90aWZpY2F0aW9ucy5maWx0ZXIobiA9PiBuLmlkICE9PSBpZClcbn0pO1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gZmlsZSBsb2FkaW5nIGJlZ2luXG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0gc3RhdGUgYHVpU3RhdGVgXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRGaWxlc1VwZGF0ZXIgPSAoc3RhdGU6IFVpU3RhdGUpOiBVaVN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBsb2FkRmlsZXM6IHtcbiAgICAuLi5zdGF0ZS5sb2FkRmlsZXMsXG4gICAgZmlsZUxvYWRpbmc6IHRydWVcbiAgfVxufSk7XG5cbi8qKlxuICogSGFuZGxlcyBsb2FkaW5nIGZpbGUgc3VjY2VzcyBhbmQgc2V0IGZpbGVMb2FkaW5nIHByb3BlcnR5IHRvIGZhbHNlXG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0gc3RhdGUgYHVpU3RhdGVgXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRGaWxlc1N1Y2Nlc3NVcGRhdGVyID0gKHN0YXRlOiBVaVN0YXRlKTogVWlTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgbG9hZEZpbGVzOiB7XG4gICAgLi4uc3RhdGUubG9hZEZpbGVzLFxuICAgIGZpbGVMb2FkaW5nOiBmYWxzZVxuICB9XG59KTtcblxuLyoqXG4gKiBIYW5kbGVzIGxvYWQgZmlsZSBlcnJvciBhbmQgc2V0IGZpbGVMb2FkaW5nIHByb3BlcnR5IHRvIGZhbHNlXG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0gc3RhdGVcbiAqIEBwYXJhbSBhY3Rpb25cbiAqIEBwYXJhbSBhY3Rpb24uZXJyb3JcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbG9hZEZpbGVzRXJyVXBkYXRlciA9IChzdGF0ZTogVWlTdGF0ZSwge2Vycm9yfTogTG9hZEZpbGVzRXJyVXBkYXRlckFjdGlvbik6IFVpU3RhdGUgPT5cbiAgYWRkTm90aWZpY2F0aW9uVXBkYXRlcihcbiAgICB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGxvYWRGaWxlczoge1xuICAgICAgICAuLi5zdGF0ZS5sb2FkRmlsZXMsXG4gICAgICAgIGZpbGVMb2FkaW5nOiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgcGF5bG9hZDogZXJyb3JOb3RpZmljYXRpb24oe1xuICAgICAgICBtZXNzYWdlOiAoZXJyb3IgfHwge30pLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB1cGxvYWQgZmlsZXMnLFxuICAgICAgICB0b3BpYzogREVGQVVMVF9OT1RJRklDQVRJT05fVE9QSUNTLmdsb2JhbFxuICAgICAgfSlcbiAgICB9XG4gICk7XG5cbi8qKlxuICogSGFuZGxlcyB0b2dnbGUgbWFwIHNwbGl0IGFuZCByZXNldCBhbGwgbWFwIGNvbnRyb2wgaW5kZXggdG8gMFxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZVNwbGl0TWFwVXBkYXRlciA9IChzdGF0ZTogVWlTdGF0ZSk6IFVpU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIG1hcENvbnRyb2xzOiBPYmplY3QuZW50cmllcyhzdGF0ZS5tYXBDb250cm9scykucmVkdWNlKFxuICAgIChhY2MsIGVudHJ5KSA9PiAoe1xuICAgICAgLi4uYWNjLFxuICAgICAgW2VudHJ5WzBdXToge1xuICAgICAgICAuLi5lbnRyeVsxXSxcbiAgICAgICAgYWN0aXZlTWFwSW5kZXg6IDBcbiAgICAgIH1cbiAgICB9KSxcbiAgICB7fSBhcyBNYXBDb250cm9sc1xuICApXG59KTtcblxuLyoqXG4gKiBUb2dnbGUgbW9kYWwgZGF0YVxuICogQG1lbWJlcm9mIHVpU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNob3dEYXRhc2V0VGFibGVVcGRhdGVyID0gKHN0YXRlOiBVaVN0YXRlKTogVWlTdGF0ZSA9PlxuICB0b2dnbGVNb2RhbFVwZGF0ZXIoc3RhdGUsIHtwYXlsb2FkOiBEQVRBX1RBQkxFX0lEfSk7XG5cbi8qKlxuICogU2V0IHRoZSBsb2NhbGUgb2YgdGhlIFVJXG4gKiBAbWVtYmVyb2YgdWlTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0gc3RhdGUgYHVpU3RhdGVgXG4gKiBAcGFyYW0gYWN0aW9uXG4gKiBAcGFyYW0gYWN0aW9uLnBheWxvYWRcbiAqIEBwYXJhbSBhY3Rpb24ucGF5bG9hZC5sb2NhbGUgbG9jYWxlXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldExvY2FsZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBVaVN0YXRlLFxuICB7cGF5bG9hZDoge2xvY2FsZX19OiBVSVN0YXRlQWN0aW9ucy5TZXRMb2NhbGVVcGRhdGVyQWN0aW9uXG4pOiBVaVN0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBsb2NhbGVcbn0pO1xuXG4vKipcbiAqIFRvZ2dsZSBsYXllciBwYW5lbCBsaXN0IHZpZXdcbiAqIEBtZW1iZXJvZiB1aVN0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSBzdGF0ZSBgdWlTdGF0ZWBcbiAqIEBwYXJhbSBhY3Rpb25cbiAqIEBwYXJhbSBhY3Rpb24ucGF5bG9hZCBsYXllciBwYW5lbCBsaXN0VmlldyB2YWx1ZS4gQ2FuIGJlICdsaXN0JyBvciAnc29ydEJ5RGF0YXNldCdcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlUGFuZWxMaXN0Vmlld1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBVaVN0YXRlLFxuICB7cGF5bG9hZDoge3BhbmVsSWQsIGxpc3RWaWV3fX06IFVJU3RhdGVBY3Rpb25zLlRvZ2dsZVBhbmVsTGlzdFZpZXdBY3Rpb25cbik6IFVpU3RhdGUgPT4ge1xuICBjb25zdCBzdGF0ZVByb3AgPVxuICAgIHBhbmVsSWQgPT09ICdsYXllcidcbiAgICAgID8gJ2xheWVyUGFuZWxMaXN0VmlldydcbiAgICAgIDogcGFuZWxJZCA9PT0gJ2ZpbHRlcidcbiAgICAgID8gJ2ZpbHRlclBhbmVsTGlzdFZpZXcnXG4gICAgICA6IG51bGw7XG4gIGlmICghc3RhdGVQcm9wIHx8IHN0YXRlW3N0YXRlUHJvcF0gPT09IGxpc3RWaWV3KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgW3N0YXRlUHJvcF06IGxpc3RWaWV3XG4gIH07XG59O1xuIl19