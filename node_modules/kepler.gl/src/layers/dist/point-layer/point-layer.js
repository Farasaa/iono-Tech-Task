"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.pointVisConfigs = exports.pointOptionalColumns = exports.pointRequiredColumns = exports.pointPosAccessor = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extensions = require("@deck.gl/extensions");

var _layers = require("@deck.gl/layers");

var _baseLayer = _interopRequireDefault(require("../base-layer"));

var _utils = require("@kepler.gl/utils");

var _pointLayerIcon = _interopRequireDefault(require("./point-layer-icon"));

var _constants = require("@kepler.gl/constants");

var _layerTextLabel = require("../layer-text-label");

var _layerUtils = require("../layer-utils");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var pointPosAccessor = function pointPosAccessor(_ref) {
  var lat = _ref.lat,
      lng = _ref.lng,
      altitude = _ref.altitude;
  return function (dc) {
    return function (d) {
      return [dc.valueAt(d.index, lng.fieldIdx), dc.valueAt(d.index, lat.fieldIdx), altitude && altitude.fieldIdx > -1 ? dc.valueAt(d.index, altitude.fieldIdx) : 0];
    };
  };
};

exports.pointPosAccessor = pointPosAccessor;
var pointRequiredColumns = ['lat', 'lng'];
exports.pointRequiredColumns = pointRequiredColumns;
var pointOptionalColumns = ['altitude'];
exports.pointOptionalColumns = pointOptionalColumns;
var brushingExtension = new _extensions.BrushingExtension();
var pointVisConfigs = {
  radius: 'radius',
  fixedRadius: 'fixedRadius',
  opacity: 'opacity',
  outline: 'outline',
  thickness: 'thickness',
  strokeColor: 'strokeColor',
  colorRange: 'colorRange',
  strokeColorRange: 'strokeColorRange',
  radiusRange: 'radiusRange',
  filled: _objectSpread(_objectSpread({}, _constants.LAYER_VIS_CONFIGS.filled), {}, {
    type: 'boolean',
    label: 'layer.fillColor',
    defaultValue: true,
    property: 'filled'
  })
};
exports.pointVisConfigs = pointVisConfigs;

var PointLayer = /*#__PURE__*/function (_Layer) {
  (0, _inherits2["default"])(PointLayer, _Layer);

  var _super = _createSuper(PointLayer);

  function PointLayer(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, PointLayer);
    _this = _super.call(this, props);

    _this.registerVisConfig(pointVisConfigs);

    _this.getPositionAccessor = function (dataContainer) {
      return pointPosAccessor(_this.config.columns)(dataContainer);
    };

    return _this;
  }

  (0, _createClass2["default"])(PointLayer, [{
    key: "type",
    get: function get() {
      return 'point';
    }
  }, {
    key: "isAggregated",
    get: function get() {
      return false;
    }
  }, {
    key: "layerIcon",
    get: function get() {
      return _pointLayerIcon["default"];
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return pointRequiredColumns;
    }
  }, {
    key: "optionalColumns",
    get: function get() {
      return pointOptionalColumns;
    }
  }, {
    key: "columnPairs",
    get: function get() {
      return this.defaultPointColumnPairs;
    }
  }, {
    key: "noneLayerDataAffectingProps",
    get: function get() {
      return [].concat((0, _toConsumableArray2["default"])((0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "noneLayerDataAffectingProps", this)), ['radius']);
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return {
        color: _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "visualChannels", this).color), {}, {
          accessor: 'getFillColor',
          condition: function condition(config) {
            return config.visConfig.filled;
          },
          defaultValue: function defaultValue(config) {
            return config.color;
          }
        }),
        strokeColor: {
          property: 'strokeColor',
          key: 'strokeColor',
          field: 'strokeColorField',
          scale: 'strokeColorScale',
          domain: 'strokeColorDomain',
          range: 'strokeColorRange',
          channelScaleType: _constants.CHANNEL_SCALES.color,
          accessor: 'getLineColor',
          condition: function condition(config) {
            return config.visConfig.outline;
          },
          defaultValue: function defaultValue(config) {
            return config.visConfig.strokeColor || config.color;
          }
        },
        size: _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "visualChannels", this).size), {}, {
          property: 'radius',
          range: 'radiusRange',
          fixed: 'fixedRadius',
          channelScaleType: 'radius',
          accessor: 'getRadius',
          defaultValue: 1
        })
      };
    }
  }, {
    key: "setInitialLayerConfig",
    value: function setInitialLayerConfig(dataset) {
      if (!dataset.dataContainer.numRows()) {
        return this;
      }

      var defaultColorField = (0, _utils.findDefaultColorField)(dataset);

      if (defaultColorField) {
        this.updateLayerConfig({
          // @ts-expect-error Remove this after updateLayerConfig converted into generic function
          colorField: defaultColorField
        });
        this.updateLayerVisualChannel(dataset, 'color');
      }

      return this;
    }
  }, {
    key: "getDefaultLayerConfig",
    value: function getDefaultLayerConfig(props) {
      return _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "getDefaultLayerConfig", this).call(this, props)), {}, {
        // add stroke color visual channel
        strokeColorField: null,
        strokeColorDomain: [0, 1],
        strokeColorScale: 'quantile'
      });
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(_ref2, getPosition) {
      var filteredIndex = _ref2.filteredIndex;
      var data = [];

      for (var i = 0; i < filteredIndex.length; i++) {
        var index = filteredIndex[i];
        var pos = getPosition({
          index: index
        }); // if doesn't have point lat or lng, do not add the point
        // deck.gl can't handle position = null

        if (pos.every(Number.isFinite)) {
          data.push({
            position: pos,
            index: index
          });
        }
      }

      return data;
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData) {
      if (this.config.dataId === null) {
        return {};
      }

      var textLabel = this.config.textLabel;
      var _datasets$this$config = datasets[this.config.dataId],
          gpuFilter = _datasets$this$config.gpuFilter,
          dataContainer = _datasets$this$config.dataContainer;

      var _this$updateData = this.updateData(datasets, oldLayerData),
          data = _this$updateData.data,
          triggerChanged = _this$updateData.triggerChanged;

      var getPosition = this.getPositionAccessor(dataContainer); // get all distinct characters in the text labels

      var textLabels = (0, _layerTextLabel.formatTextLabelData)({
        textLabel: textLabel,
        triggerChanged: triggerChanged,
        oldLayerData: oldLayerData,
        data: data,
        dataContainer: dataContainer
      });
      var accessors = this.getAttributeAccessors({
        dataContainer: dataContainer
      });
      return _objectSpread({
        data: data,
        getPosition: getPosition,
        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(),
        textLabels: textLabels
      }, accessors);
    }
    /* eslint-enable complexity */

  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataContainer) {
      var getPosition = this.getPositionAccessor(dataContainer);
      var bounds = this.getPointsBounds(dataContainer, getPosition);
      this.updateMeta({
        bounds: bounds
      });
    }
  }, {
    key: "renderLayer",
    value: function renderLayer(opts) {
      var _this$config$columns$;

      var data = opts.data,
          gpuFilter = opts.gpuFilter,
          objectHovered = opts.objectHovered,
          mapState = opts.mapState,
          interactionConfig = opts.interactionConfig; // if no field size is defined we need to pass fixed radius = false

      var fixedRadius = this.config.visConfig.fixedRadius && Boolean(this.config.sizeField);
      var radiusScale = this.getRadiusScaleByZoom(mapState, fixedRadius);

      var layerProps = _objectSpread({
        stroked: this.config.visConfig.outline,
        filled: this.config.visConfig.filled,
        lineWidthScale: this.config.visConfig.thickness,
        radiusScale: radiusScale
      }, this.config.visConfig.fixedRadius ? {} : {
        radiusMaxPixels: 500
      });

      var updateTriggers = _objectSpread({
        getPosition: this.config.columns,
        getFilterValue: gpuFilter.filterValueUpdateTriggers
      }, this.getVisualChannelUpdateTriggers());

      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);
      var brushingProps = this.getBrushingExtensionProps(interactionConfig);
      var getPixelOffset = (0, _layerTextLabel.getTextOffsetByRadius)(radiusScale, data.getRadius, mapState);
      var extensions = [].concat((0, _toConsumableArray2["default"])(defaultLayerProps.extensions), [brushingExtension]);

      var sharedProps = _objectSpread({
        getFilterValue: data.getFilterValue,
        extensions: extensions,
        filterRange: defaultLayerProps.filterRange,
        visible: defaultLayerProps.visible
      }, brushingProps);

      var hoveredObject = this.hasHoveredObject(objectHovered);
      return [new _layers.ScatterplotLayer(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), brushingProps), layerProps), data), {}, {
        parameters: {
          // circles will be flat on the map when the altitude column is not used
          depthTest: ((_this$config$columns$ = this.config.columns.altitude) === null || _this$config$columns$ === void 0 ? void 0 : _this$config$columns$.fieldIdx) > -1
        },
        lineWidthUnits: 'pixels',
        updateTriggers: updateTriggers,
        extensions: extensions
      }))].concat((0, _toConsumableArray2["default"])(hoveredObject ? [new _layers.ScatterplotLayer(_objectSpread(_objectSpread(_objectSpread({}, this.getDefaultHoverLayerProps()), layerProps), {}, {
        visible: defaultLayerProps.visible,
        data: [hoveredObject],
        getLineColor: this.config.highlightColor,
        getFillColor: this.config.highlightColor,
        getRadius: data.getRadius,
        getPosition: data.getPosition
      }))] : []), (0, _toConsumableArray2["default"])(this.renderTextLabelLayer({
        getPosition: data.getPosition,
        sharedProps: sharedProps,
        getPixelOffset: getPixelOffset,
        updateTriggers: updateTriggers
      }, opts)));
    }
  }], [{
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(_ref3) {
      var _ref3$fieldPairs = _ref3.fieldPairs,
          fieldPairs = _ref3$fieldPairs === void 0 ? [] : _ref3$fieldPairs;
      var props = []; // Make layer for each pair

      fieldPairs.forEach(function (pair) {
        var latField = pair.pair.lat;
        var prop = {
          label: pair.defaultName || 'Point'
        }; // default layer color for begintrip and dropoff point

        if (latField.value in _constants.DEFAULT_LAYER_COLOR) {
          prop.color = (0, _utils.hexToRgb)(_constants.DEFAULT_LAYER_COLOR[latField.value]);
        } // set the first layer to be visible


        if (props.length === 0) {
          prop.isVisible = true;
        }

        prop.columns = (0, _layerUtils.assignPointPairToLayerColumn)(pair, true);
        props.push(prop);
      });
      return {
        props: props
      };
    }
  }]);
  return PointLayer;
}(_baseLayer["default"]);

exports["default"] = PointLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wb2ludC1sYXllci9wb2ludC1sYXllci50cyJdLCJuYW1lcyI6WyJwb2ludFBvc0FjY2Vzc29yIiwibGF0IiwibG5nIiwiYWx0aXR1ZGUiLCJkYyIsImQiLCJ2YWx1ZUF0IiwiaW5kZXgiLCJmaWVsZElkeCIsInBvaW50UmVxdWlyZWRDb2x1bW5zIiwicG9pbnRPcHRpb25hbENvbHVtbnMiLCJicnVzaGluZ0V4dGVuc2lvbiIsIkJydXNoaW5nRXh0ZW5zaW9uIiwicG9pbnRWaXNDb25maWdzIiwicmFkaXVzIiwiZml4ZWRSYWRpdXMiLCJvcGFjaXR5Iiwib3V0bGluZSIsInRoaWNrbmVzcyIsInN0cm9rZUNvbG9yIiwiY29sb3JSYW5nZSIsInN0cm9rZUNvbG9yUmFuZ2UiLCJyYWRpdXNSYW5nZSIsImZpbGxlZCIsIkxBWUVSX1ZJU19DT05GSUdTIiwidHlwZSIsImxhYmVsIiwiZGVmYXVsdFZhbHVlIiwicHJvcGVydHkiLCJQb2ludExheWVyIiwicHJvcHMiLCJyZWdpc3RlclZpc0NvbmZpZyIsImdldFBvc2l0aW9uQWNjZXNzb3IiLCJkYXRhQ29udGFpbmVyIiwiY29uZmlnIiwiY29sdW1ucyIsIlBvaW50TGF5ZXJJY29uIiwiZGVmYXVsdFBvaW50Q29sdW1uUGFpcnMiLCJjb2xvciIsImFjY2Vzc29yIiwiY29uZGl0aW9uIiwidmlzQ29uZmlnIiwia2V5IiwiZmllbGQiLCJzY2FsZSIsImRvbWFpbiIsInJhbmdlIiwiY2hhbm5lbFNjYWxlVHlwZSIsIkNIQU5ORUxfU0NBTEVTIiwic2l6ZSIsImZpeGVkIiwiZGF0YXNldCIsIm51bVJvd3MiLCJkZWZhdWx0Q29sb3JGaWVsZCIsInVwZGF0ZUxheWVyQ29uZmlnIiwiY29sb3JGaWVsZCIsInVwZGF0ZUxheWVyVmlzdWFsQ2hhbm5lbCIsInN0cm9rZUNvbG9yRmllbGQiLCJzdHJva2VDb2xvckRvbWFpbiIsInN0cm9rZUNvbG9yU2NhbGUiLCJnZXRQb3NpdGlvbiIsImZpbHRlcmVkSW5kZXgiLCJkYXRhIiwiaSIsImxlbmd0aCIsInBvcyIsImV2ZXJ5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwdXNoIiwicG9zaXRpb24iLCJkYXRhc2V0cyIsIm9sZExheWVyRGF0YSIsImRhdGFJZCIsInRleHRMYWJlbCIsImdwdUZpbHRlciIsInVwZGF0ZURhdGEiLCJ0cmlnZ2VyQ2hhbmdlZCIsInRleHRMYWJlbHMiLCJhY2Nlc3NvcnMiLCJnZXRBdHRyaWJ1dGVBY2Nlc3NvcnMiLCJnZXRGaWx0ZXJWYWx1ZSIsImZpbHRlclZhbHVlQWNjZXNzb3IiLCJib3VuZHMiLCJnZXRQb2ludHNCb3VuZHMiLCJ1cGRhdGVNZXRhIiwib3B0cyIsIm9iamVjdEhvdmVyZWQiLCJtYXBTdGF0ZSIsImludGVyYWN0aW9uQ29uZmlnIiwiQm9vbGVhbiIsInNpemVGaWVsZCIsInJhZGl1c1NjYWxlIiwiZ2V0UmFkaXVzU2NhbGVCeVpvb20iLCJsYXllclByb3BzIiwic3Ryb2tlZCIsImxpbmVXaWR0aFNjYWxlIiwicmFkaXVzTWF4UGl4ZWxzIiwidXBkYXRlVHJpZ2dlcnMiLCJmaWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzIiwiZ2V0VmlzdWFsQ2hhbm5lbFVwZGF0ZVRyaWdnZXJzIiwiZGVmYXVsdExheWVyUHJvcHMiLCJnZXREZWZhdWx0RGVja0xheWVyUHJvcHMiLCJicnVzaGluZ1Byb3BzIiwiZ2V0QnJ1c2hpbmdFeHRlbnNpb25Qcm9wcyIsImdldFBpeGVsT2Zmc2V0IiwiZ2V0UmFkaXVzIiwiZXh0ZW5zaW9ucyIsInNoYXJlZFByb3BzIiwiZmlsdGVyUmFuZ2UiLCJ2aXNpYmxlIiwiaG92ZXJlZE9iamVjdCIsImhhc0hvdmVyZWRPYmplY3QiLCJTY2F0dGVycGxvdExheWVyIiwicGFyYW1ldGVycyIsImRlcHRoVGVzdCIsImxpbmVXaWR0aFVuaXRzIiwiZ2V0RGVmYXVsdEhvdmVyTGF5ZXJQcm9wcyIsImdldExpbmVDb2xvciIsImhpZ2hsaWdodENvbG9yIiwiZ2V0RmlsbENvbG9yIiwicmVuZGVyVGV4dExhYmVsTGF5ZXIiLCJmaWVsZFBhaXJzIiwiZm9yRWFjaCIsInBhaXIiLCJsYXRGaWVsZCIsInByb3AiLCJkZWZhdWx0TmFtZSIsInZhbHVlIiwiREVGQVVMVF9MQVlFUl9DT0xPUiIsImlzVmlzaWJsZSIsIkxheWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7O0FBQ0E7O0FBRUE7O0FBUUE7O0FBRUE7O0FBQ0E7O0FBT0E7O0FBQ0E7Ozs7Ozs7Ozs7QUF3RE8sSUFBTUEsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQjtBQUFBLE1BQUVDLEdBQUYsUUFBRUEsR0FBRjtBQUFBLE1BQU9DLEdBQVAsUUFBT0EsR0FBUDtBQUFBLE1BQVlDLFFBQVosUUFBWUEsUUFBWjtBQUFBLFNBQW1ELFVBQUFDLEVBQUU7QUFBQSxXQUFJLFVBQUFDLENBQUM7QUFBQSxhQUFJLENBQzVGRCxFQUFFLENBQUNFLE9BQUgsQ0FBV0QsQ0FBQyxDQUFDRSxLQUFiLEVBQW9CTCxHQUFHLENBQUNNLFFBQXhCLENBRDRGLEVBRTVGSixFQUFFLENBQUNFLE9BQUgsQ0FBV0QsQ0FBQyxDQUFDRSxLQUFiLEVBQW9CTixHQUFHLENBQUNPLFFBQXhCLENBRjRGLEVBRzVGTCxRQUFRLElBQUlBLFFBQVEsQ0FBQ0ssUUFBVCxHQUFvQixDQUFDLENBQWpDLEdBQXFDSixFQUFFLENBQUNFLE9BQUgsQ0FBV0QsQ0FBQyxDQUFDRSxLQUFiLEVBQW9CSixRQUFRLENBQUNLLFFBQTdCLENBQXJDLEdBQThFLENBSGMsQ0FBSjtBQUFBLEtBQUw7QUFBQSxHQUFyRDtBQUFBLENBQXpCOzs7QUFNQSxJQUFNQyxvQkFBb0MsR0FBRyxDQUFDLEtBQUQsRUFBUSxLQUFSLENBQTdDOztBQUNBLElBQU1DLG9CQUFrQyxHQUFHLENBQUMsVUFBRCxDQUEzQzs7QUFFUCxJQUFNQyxpQkFBaUIsR0FBRyxJQUFJQyw2QkFBSixFQUExQjtBQUVPLElBQU1DLGVBV1osR0FBRztBQUNGQyxFQUFBQSxNQUFNLEVBQUUsUUFETjtBQUVGQyxFQUFB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LENBQVUzSCxHQUEzQjtBQUVBLFlBQU02SCxJQUtMLEdBQUc7QUFDRnBHLFVBQUFBLEtBQUssRUFBRWtHLElBQUksQ0FBQ0csV0FBTCxJQUFvQjtBQUR6QixTQUxKLENBSHlCLENBWXpCOztBQUNBLFlBQUlGLFFBQVEsQ0FBQ0csS0FBVCxJQUFrQkMsOEJBQXRCLEVBQTJDO0FBQ3pDSCxVQUFBQSxJQUFJLENBQUN4RixLQUFMLEdBQWEscUJBQVMyRiwrQkFBb0JKLFFBQVEsQ0FBQ0csS0FBN0IsQ0FBVCxDQUFiO0FBQ0QsU0Fmd0IsQ0FpQnpCOzs7QUFDQSxZQUFJbEcsS0FBSyxDQUFDa0MsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QjhELFVBQUFBLElBQUksQ0FBQ0ksU0FBTCxHQUFpQixJQUFqQjtBQUNEOztBQUNESixRQUFBQSxJQUFJLENBQUMzRixPQUFMLEdBQWUsOENBQTZCeUYsSUFBN0IsRUFBbUMsSUFBbkMsQ0FBZjtBQUVBOUYsUUFBQUEsS0FBSyxDQUFDdUMsSUFBTixDQUFXeUQsSUFBWDtBQUNELE9BeEJEO0FBMEJBLGFBQU87QUFBQ2hHLFFBQUFBLEtBQUssRUFBTEE7QUFBRCxPQUFQO0FBQ0Q7OztFQTNIcUNxRyxxQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCB7QnJ1c2hpbmdFeHRlbnNpb259IGZyb20gJ0BkZWNrLmdsL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHtTY2F0dGVycGxvdExheWVyfSBmcm9tICdAZGVjay5nbC9sYXllcnMnO1xuXG5pbXBvcnQgTGF5ZXIsIHtcbiAgTGF5ZXJCYXNlQ29uZmlnLFxuICBMYXllckJhc2VDb25maWdQYXJ0aWFsLFxuICBMYXllckNvbG9yQ29uZmlnLFxuICBMYXllckNvbHVtbixcbiAgTGF5ZXJTaXplQ29uZmlnLFxuICBMYXllclN0cm9rZUNvbG9yQ29uZmlnXG59IGZyb20gJy4uL2Jhc2UtbGF5ZXInO1xuaW1wb3J0IHtoZXhUb1JnYiwgZmluZERlZmF1bHRDb2xvckZpZWxkfSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBLZXBsZXJUYWJsZX0gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5pbXBvcnQgUG9pbnRMYXllckljb24gZnJvbSAnLi9wb2ludC1sYXllci1pY29uJztcbmltcG9ydCB7XG4gIExBWUVSX1ZJU19DT05GSUdTLFxuICBERUZBVUxUX0xBWUVSX0NPTE9SLFxuICBDSEFOTkVMX1NDQUxFUyxcbiAgQ29sb3JSYW5nZVxufSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7Z2V0VGV4dE9mZnNldEJ5UmFkaXVzLCBmb3JtYXRUZXh0TGFiZWxEYXRhfSBmcm9tICcuLi9sYXllci10ZXh0LWxhYmVsJztcbmltcG9ydCB7YXNzaWduUG9pbnRQYWlyVG9MYXllckNvbHVtbn0gZnJvbSAnLi4vbGF5ZXItdXRpbHMnO1xuaW1wb3J0IHtcbiAgTWVyZ2UsXG4gIFJHQkNvbG9yLFxuICBWaXNDb25maWdCb29sZWFuLFxuICBWaXNDb25maWdDb2xvclJhbmdlLFxuICBWaXNDb25maWdDb2xvclNlbGVjdCxcbiAgVmlzQ29uZmlnTnVtYmVyLFxuICBWaXNDb25maWdSYW5nZVxufSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgUG9pbnRMYXllclZpc0NvbmZpZ1NldHRpbmdzID0ge1xuICByYWRpdXM6IFZpc0NvbmZpZ051bWJlcjtcbiAgZml4ZWRSYWRpdXM6IFZpc0NvbmZpZ0Jvb2xlYW47XG4gIG9wYWNpdHk6IFZpc0NvbmZpZ051bWJlcjtcbiAgb3V0bGluZTogVmlzQ29uZmlnQm9vbGVhbjtcbiAgdGhpY2tuZXNzOiBWaXNDb25maWdOdW1iZXI7XG4gIHN0cm9rZUNvbG9yOiBWaXNDb25maWdDb2xvclNlbGVjdDtcbiAgY29sb3JSYW5nZTogVmlzQ29uZmlnQ29sb3JSYW5nZTtcbiAgc3Ryb2tlQ29sb3JSYW5nZTogVmlzQ29uZmlnQ29sb3JSYW5nZTtcbiAgcmFkaXVzUmFuZ2U6IFZpc0NvbmZpZ1JhbmdlO1xuICBmaWxsZWQ6IFZpc0NvbmZpZ0Jvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBQb2ludExheWVyQ29sdW1uc0NvbmZpZyA9IHtcbiAgbGF0OiBMYXllckNvbHVtbjtcbiAgbG5nOiBMYXllckNvbHVtbjtcbiAgYWx0aXR1ZGU/OiBMYXllckNvbHVtbjtcbn07XG5cbmV4cG9ydCB0eXBlIFBvaW50TGF5ZXJWaXNDb25maWcgPSB7XG4gIHJhZGl1czogbnVtYmVyO1xuICBmaXhlZFJhZGl1czogYm9vbGVhbjtcbiAgb3BhY2l0eTogbnVtYmVyO1xuICBvdXRsaW5lOiBib29sZWFuO1xuICB0aGlja25lc3M6IG51bWJlcjtcbiAgc3Ryb2tlQ29sb3I6IFJHQkNvbG9yO1xuICBjb2xvclJhbmdlOiBDb2xvclJhbmdlO1xuICBzdHJva2VDb2xvclJhbmdlOiBDb2xvclJhbmdlO1xuICByYWRpdXNSYW5nZTogW251bWJlciwgbnVtYmVyXTtcbiAgZmlsbGVkOiBib29sZWFuO1xufTtcbmV4cG9ydCB0eXBlIFBvaW50TGF5ZXJWaXN1YWxDaGFubmVsQ29uZmlnID0gTGF5ZXJDb2xvckNvbmZpZyAmXG4gIExheWVyU2l6ZUNvbmZpZyAmXG4gIExheWVyU3Ryb2tlQ29sb3JDb25maWc7XG5leHBvcnQgdHlwZSBQb2ludExheWVyQ29uZmlnID0gTWVyZ2U8XG4gIExheWVyQmFzZUNvbmZpZyxcbiAge2NvbHVtbnM6IFBvaW50TGF5ZXJDb2x1bW5zQ29uZmlnOyB2aXNDb25maWc6IFBvaW50TGF5ZXJWaXNDb25maWd9XG4+ICZcbiAgUG9pbnRMYXllclZpc3VhbENoYW5uZWxDb25maWc7XG5cbmV4cG9ydCB0eXBlIFBvaW50TGF5ZXJEYXRhID0ge1xuICBwb3NpdGlvbjogbnVtYmVyW107XG4gIGluZGV4OiBudW1iZXI7XG59O1xuXG5leHBvcnQgY29uc3QgcG9pbnRQb3NBY2Nlc3NvciA9ICh7bGF0LCBsbmcsIGFsdGl0dWRlfTogUG9pbnRMYXllckNvbHVtbnNDb25maWcpID0+IGRjID0+IGQgPT4gW1xuICBkYy52YWx1ZUF0KGQuaW5kZXgsIGxuZy5maWVsZElkeCksXG4gIGRjLnZhbHVlQXQoZC5pbmRleCwgbGF0LmZpZWxkSWR4KSxcbiAgYWx0aXR1ZGUgJiYgYWx0aXR1ZGUuZmllbGRJZHggPiAtMSA/IGRjLnZhbHVlQXQoZC5pbmRleCwgYWx0aXR1ZGUuZmllbGRJZHgpIDogMFxuXTtcblxuZXhwb3J0IGNvbnN0IHBvaW50UmVxdWlyZWRDb2x1bW5zOiBbJ2xhdCcsICdsbmcnXSA9IFsnbGF0JywgJ2xuZyddO1xuZXhwb3J0IGNvbnN0IHBvaW50T3B0aW9uYWxDb2x1bW5zOiBbJ2FsdGl0dWRlJ10gPSBbJ2FsdGl0dWRlJ107XG5cbmNvbnN0IGJydXNoaW5nRXh0ZW5zaW9uID0gbmV3IEJydXNoaW5nRXh0ZW5zaW9uKCk7XG5cbmV4cG9ydCBjb25zdCBwb2ludFZpc0NvbmZpZ3M6IHtcbiAgcmFkaXVzOiAncmFkaXVzJztcbiAgZml4ZWRSYWRpdXM6ICdmaXhlZFJhZGl1cyc7XG4gIG9wYWNpdHk6ICdvcGFjaXR5JztcbiAgb3V0bGluZTogJ291dGxpbmUnO1xuICB0aGlja25lc3M6ICd0aGlja25lc3MnO1xuICBzdHJva2VDb2xvcjogJ3N0cm9rZUNvbG9yJztcbiAgY29sb3JSYW5nZTogJ2NvbG9yUmFuZ2UnO1xuICBzdHJva2VDb2xvclJhbmdlOiAnc3Ryb2tlQ29sb3JSYW5nZSc7XG4gIHJhZGl1c1JhbmdlOiAncmFkaXVzUmFuZ2UnO1xuICBmaWxsZWQ6IFZpc0NvbmZpZ0Jvb2xlYW47XG59ID0ge1xuICByYWRpdXM6ICdyYWRpdXMnLFxuICBmaXhlZFJhZGl1czogJ2ZpeGVkUmFkaXVzJyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvdXRsaW5lOiAnb3V0bGluZScsXG4gIHRoaWNrbmVzczogJ3RoaWNrbmVzcycsXG4gIHN0cm9rZUNvbG9yOiAnc3Ryb2tlQ29sb3InLFxuICBjb2xvclJhbmdlOiAnY29sb3JSYW5nZScsXG4gIHN0cm9rZUNvbG9yUmFuZ2U6ICdzdHJva2VDb2xvclJhbmdlJyxcbiAgcmFkaXVzUmFuZ2U6ICdyYWRpdXNSYW5nZScsXG4gIGZpbGxlZDoge1xuICAgIC4uLkxBWUVSX1ZJU19DT05GSUdTLmZpbGxlZCxcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgbGFiZWw6ICdsYXllci5maWxsQ29sb3InLFxuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICBwcm9wZXJ0eTogJ2ZpbGxlZCdcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRMYXllciBleHRlbmRzIExheWVyIHtcbiAgZGVjbGFyZSBjb25maWc6IFBvaW50TGF5ZXJDb25maWc7XG4gIGRlY2xhcmUgdmlzQ29uZmlnU2V0dGluZ3M6IFBvaW50TGF5ZXJWaXNDb25maWdTZXR0aW5ncztcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyVmlzQ29uZmlnKHBvaW50VmlzQ29uZmlncyk7XG4gICAgdGhpcy5nZXRQb3NpdGlvbkFjY2Vzc29yID0gZGF0YUNvbnRhaW5lciA9PlxuICAgICAgcG9pbnRQb3NBY2Nlc3Nvcih0aGlzLmNvbmZpZy5jb2x1bW5zKShkYXRhQ29udGFpbmVyKTtcbiAgfVxuXG4gIGdldCB0eXBlKCk6ICdwb2ludCcge1xuICAgIHJldHVybiAncG9pbnQnO1xuICB9XG5cbiAgZ2V0IGlzQWdncmVnYXRlZCgpOiBmYWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0IGxheWVySWNvbigpIHtcbiAgICByZXR1cm4gUG9pbnRMYXllckljb247XG4gIH1cbiAgZ2V0IHJlcXVpcmVkTGF5ZXJDb2x1bW5zKCkge1xuICAgIHJldHVybiBwb2ludFJlcXVpcmVkQ29sdW1ucztcbiAgfVxuXG4gIGdldCBvcHRpb25hbENvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHBvaW50T3B0aW9uYWxDb2x1bW5zO1xuICB9XG5cbiAgZ2V0IGNvbHVtblBhaXJzKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRQb2ludENvbHVtblBhaXJzO1xuICB9XG5cbiAgZ2V0IG5vbmVMYXllckRhdGFBZmZlY3RpbmdQcm9wcygpIHtcbiAgICByZXR1cm4gWy4uLnN1cGVyLm5vbmVMYXllckRhdGFBZmZlY3RpbmdQcm9wcywgJ3JhZGl1cyddO1xuICB9XG5cbiAgZ2V0IHZpc3VhbENoYW5uZWxzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICAuLi5zdXBlci52aXN1YWxDaGFubmVscy5jb2xvcixcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRGaWxsQ29sb3InLFxuICAgICAgICBjb25kaXRpb246IGNvbmZpZyA9PiBjb25maWcudmlzQ29uZmlnLmZpbGxlZCxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBjb25maWcgPT4gY29uZmlnLmNvbG9yXG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IHtcbiAgICAgICAgcHJvcGVydHk6ICdzdHJva2VDb2xvcicsXG4gICAgICAgIGtleTogJ3N0cm9rZUNvbG9yJyxcbiAgICAgICAgZmllbGQ6ICdzdHJva2VDb2xvckZpZWxkJyxcbiAgICAgICAgc2NhbGU6ICdzdHJva2VDb2xvclNjYWxlJyxcbiAgICAgICAgZG9tYWluOiAnc3Ryb2tlQ29sb3JEb21haW4nLFxuICAgICAgICByYW5nZTogJ3N0cm9rZUNvbG9yUmFuZ2UnLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlOiBDSEFOTkVMX1NDQUxFUy5jb2xvcixcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRMaW5lQ29sb3InLFxuICAgICAgICBjb25kaXRpb246IGNvbmZpZyA9PiBjb25maWcudmlzQ29uZmlnLm91dGxpbmUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogY29uZmlnID0+IGNvbmZpZy52aXNDb25maWcuc3Ryb2tlQ29sb3IgfHwgY29uZmlnLmNvbG9yXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5zdXBlci52aXN1YWxDaGFubmVscy5zaXplLFxuICAgICAgICBwcm9wZXJ0eTogJ3JhZGl1cycsXG4gICAgICAgIHJhbmdlOiAncmFkaXVzUmFuZ2UnLFxuICAgICAgICBmaXhlZDogJ2ZpeGVkUmFkaXVzJyxcbiAgICAgICAgY2hhbm5lbFNjYWxlVHlwZTogJ3JhZGl1cycsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0UmFkaXVzJyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAxXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHNldEluaXRpYWxMYXllckNvbmZpZyhkYXRhc2V0KSB7XG4gICAgaWYgKCFkYXRhc2V0LmRhdGFDb250YWluZXIubnVtUm93cygpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdENvbG9yRmllbGQgPSBmaW5kRGVmYXVsdENvbG9yRmllbGQoZGF0YXNldCk7XG5cbiAgICBpZiAoZGVmYXVsdENvbG9yRmllbGQpIHtcbiAgICAgIHRoaXMudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFJlbW92ZSB0aGlzIGFmdGVyIHVwZGF0ZUxheWVyQ29uZmlnIGNvbnZlcnRlZCBpbnRvIGdlbmVyaWMgZnVuY3Rpb25cbiAgICAgICAgY29sb3JGaWVsZDogZGVmYXVsdENvbG9yRmllbGRcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVMYXllclZpc3VhbENoYW5uZWwoZGF0YXNldCwgJ2NvbG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgZmluZERlZmF1bHRMYXllclByb3BzKHtmaWVsZFBhaXJzID0gW119OiBLZXBsZXJUYWJsZSkge1xuICAgIGNvbnN0IHByb3BzOiB7XG4gICAgICBsYWJlbDogc3RyaW5nO1xuICAgICAgY29sb3I/OiBSR0JDb2xvcjtcbiAgICAgIGlzVmlzaWJsZT86IGJvb2xlYW47XG4gICAgICBjb2x1bW5zPzogUG9pbnRMYXllckNvbHVtbnNDb25maWc7XG4gICAgfVtdID0gW107XG5cbiAgICAvLyBNYWtlIGxheWVyIGZvciBlYWNoIHBhaXJcbiAgICBmaWVsZFBhaXJzLmZvckVhY2gocGFpciA9PiB7XG4gICAgICBjb25zdCBsYXRGaWVsZCA9IHBhaXIucGFpci5sYXQ7XG5cbiAgICAgIGNvbnN0IHByb3A6IHtcbiAgICAgICAgbGFiZWw6IHN0cmluZztcbiAgICAgICAgY29sb3I/OiBSR0JDb2xvcjtcbiAgICAgICAgaXNWaXNpYmxlPzogYm9vbGVhbjtcbiAgICAgICAgY29sdW1ucz86IFBvaW50TGF5ZXJDb2x1bW5zQ29uZmlnO1xuICAgICAgfSA9IHtcbiAgICAgICAgbGFiZWw6IHBhaXIuZGVmYXVsdE5hbWUgfHwgJ1BvaW50J1xuICAgICAgfTtcblxuICAgICAgLy8gZGVmYXVsdCBsYXllciBjb2xvciBmb3IgYmVnaW50cmlwIGFuZCBkcm9wb2ZmIHBvaW50XG4gICAgICBpZiAobGF0RmllbGQudmFsdWUgaW4gREVGQVVMVF9MQVlFUl9DT0xPUikge1xuICAgICAgICBwcm9wLmNvbG9yID0gaGV4VG9SZ2IoREVGQVVMVF9MQVlFUl9DT0xPUltsYXRGaWVsZC52YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIGZpcnN0IGxheWVyIHRvIGJlIHZpc2libGVcbiAgICAgIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcHJvcC5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcHJvcC5jb2x1bW5zID0gYXNzaWduUG9pbnRQYWlyVG9MYXllckNvbHVtbihwYWlyLCB0cnVlKTtcblxuICAgICAgcHJvcHMucHVzaChwcm9wKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7cHJvcHN9O1xuICB9XG5cbiAgZ2V0RGVmYXVsdExheWVyQ29uZmlnKHByb3BzOiBMYXllckJhc2VDb25maWdQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmdldERlZmF1bHRMYXllckNvbmZpZyhwcm9wcyksXG5cbiAgICAgIC8vIGFkZCBzdHJva2UgY29sb3IgdmlzdWFsIGNoYW5uZWxcbiAgICAgIHN0cm9rZUNvbG9yRmllbGQ6IG51bGwsXG4gICAgICBzdHJva2VDb2xvckRvbWFpbjogWzAsIDFdLFxuICAgICAgc3Ryb2tlQ29sb3JTY2FsZTogJ3F1YW50aWxlJ1xuICAgIH07XG4gIH1cblxuICBjYWxjdWxhdGVEYXRhQXR0cmlidXRlKHtmaWx0ZXJlZEluZGV4fTogS2VwbGVyVGFibGUsIGdldFBvc2l0aW9uKSB7XG4gICAgY29uc3QgZGF0YTogUG9pbnRMYXllckRhdGFbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJlZEluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGZpbHRlcmVkSW5kZXhbaV07XG4gICAgICBjb25zdCBwb3MgPSBnZXRQb3NpdGlvbih7aW5kZXh9KTtcblxuICAgICAgLy8gaWYgZG9lc24ndCBoYXZlIHBvaW50IGxhdCBvciBsbmcsIGRvIG5vdCBhZGQgdGhlIHBvaW50XG4gICAgICAvLyBkZWNrLmdsIGNhbid0IGhhbmRsZSBwb3NpdGlvbiA9IG51bGxcbiAgICAgIGlmIChwb3MuZXZlcnkoTnVtYmVyLmlzRmluaXRlKSkge1xuICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgZm9ybWF0TGF5ZXJEYXRhKGRhdGFzZXRzLCBvbGRMYXllckRhdGEpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZGF0YUlkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHt0ZXh0TGFiZWx9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qge2dwdUZpbHRlciwgZGF0YUNvbnRhaW5lcn0gPSBkYXRhc2V0c1t0aGlzLmNvbmZpZy5kYXRhSWRdO1xuICAgIGNvbnN0IHtkYXRhLCB0cmlnZ2VyQ2hhbmdlZH0gPSB0aGlzLnVwZGF0ZURhdGEoZGF0YXNldHMsIG9sZExheWVyRGF0YSk7XG4gICAgY29uc3QgZ2V0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uQWNjZXNzb3IoZGF0YUNvbnRhaW5lcik7XG5cbiAgICAvLyBnZXQgYWxsIGRpc3RpbmN0IGNoYXJhY3RlcnMgaW4gdGhlIHRleHQgbGFiZWxzXG4gICAgY29uc3QgdGV4dExhYmVscyA9IGZvcm1hdFRleHRMYWJlbERhdGEoe1xuICAgICAgdGV4dExhYmVsLFxuICAgICAgdHJpZ2dlckNoYW5nZWQsXG4gICAgICBvbGRMYXllckRhdGEsXG4gICAgICBkYXRhLFxuICAgICAgZGF0YUNvbnRhaW5lclxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjZXNzb3JzID0gdGhpcy5nZXRBdHRyaWJ1dGVBY2Nlc3NvcnMoe2RhdGFDb250YWluZXJ9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgZ2V0UG9zaXRpb24sXG4gICAgICBnZXRGaWx0ZXJWYWx1ZTogZ3B1RmlsdGVyLmZpbHRlclZhbHVlQWNjZXNzb3IoZGF0YUNvbnRhaW5lcikoKSxcbiAgICAgIHRleHRMYWJlbHMsXG4gICAgICAuLi5hY2Nlc3NvcnNcbiAgICB9O1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIHVwZGF0ZUxheWVyTWV0YShkYXRhQ29udGFpbmVyKSB7XG4gICAgY29uc3QgZ2V0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uQWNjZXNzb3IoZGF0YUNvbnRhaW5lcik7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRQb2ludHNCb3VuZHMoZGF0YUNvbnRhaW5lciwgZ2V0UG9zaXRpb24pO1xuICAgIHRoaXMudXBkYXRlTWV0YSh7Ym91bmRzfSk7XG4gIH1cblxuICByZW5kZXJMYXllcihvcHRzKSB7XG4gICAgY29uc3Qge2RhdGEsIGdwdUZpbHRlciwgb2JqZWN0SG92ZXJlZCwgbWFwU3RhdGUsIGludGVyYWN0aW9uQ29uZmlnfSA9IG9wdHM7XG5cbiAgICAvLyBpZiBubyBmaWVsZCBzaXplIGlzIGRlZmluZWQgd2UgbmVlZCB0byBwYXNzIGZpeGVkIHJhZGl1cyA9IGZhbHNlXG4gICAgY29uc3QgZml4ZWRSYWRpdXMgPSB0aGlzLmNvbmZpZy52aXNDb25maWcuZml4ZWRSYWRpdXMgJiYgQm9vbGVhbih0aGlzLmNvbmZpZy5zaXplRmllbGQpO1xuICAgIGNvbnN0IHJhZGl1c1NjYWxlID0gdGhpcy5nZXRSYWRpdXNTY2FsZUJ5Wm9vbShtYXBTdGF0ZSwgZml4ZWRSYWRpdXMpO1xuXG4gICAgY29uc3QgbGF5ZXJQcm9wcyA9IHtcbiAgICAgIHN0cm9rZWQ6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5vdXRsaW5lLFxuICAgICAgZmlsbGVkOiB0aGlzLmNvbmZpZy52aXNDb25maWcuZmlsbGVkLFxuICAgICAgbGluZVdpZHRoU2NhbGU6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy50aGlja25lc3MsXG4gICAgICByYWRpdXNTY2FsZSxcbiAgICAgIC4uLih0aGlzLmNvbmZpZy52aXNDb25maWcuZml4ZWRSYWRpdXMgPyB7fSA6IHtyYWRpdXNNYXhQaXhlbHM6IDUwMH0pXG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZVRyaWdnZXJzID0ge1xuICAgICAgZ2V0UG9zaXRpb246IHRoaXMuY29uZmlnLmNvbHVtbnMsXG4gICAgICBnZXRGaWx0ZXJWYWx1ZTogZ3B1RmlsdGVyLmZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnMsXG4gICAgICAuLi50aGlzLmdldFZpc3VhbENoYW5uZWxVcGRhdGVUcmlnZ2VycygpXG4gICAgfTtcblxuICAgIGNvbnN0IGRlZmF1bHRMYXllclByb3BzID0gdGhpcy5nZXREZWZhdWx0RGVja0xheWVyUHJvcHMob3B0cyk7XG4gICAgY29uc3QgYnJ1c2hpbmdQcm9wcyA9IHRoaXMuZ2V0QnJ1c2hpbmdFeHRlbnNpb25Qcm9wcyhpbnRlcmFjdGlvbkNvbmZpZyk7XG4gICAgY29uc3QgZ2V0UGl4ZWxPZmZzZXQgPSBnZXRUZXh0T2Zmc2V0QnlSYWRpdXMocmFkaXVzU2NhbGUsIGRhdGEuZ2V0UmFkaXVzLCBtYXBTdGF0ZSk7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IFsuLi5kZWZhdWx0TGF5ZXJQcm9wcy5leHRlbnNpb25zLCBicnVzaGluZ0V4dGVuc2lvbl07XG5cbiAgICBjb25zdCBzaGFyZWRQcm9wcyA9IHtcbiAgICAgIGdldEZpbHRlclZhbHVlOiBkYXRhLmdldEZpbHRlclZhbHVlLFxuICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgIGZpbHRlclJhbmdlOiBkZWZhdWx0TGF5ZXJQcm9wcy5maWx0ZXJSYW5nZSxcbiAgICAgIHZpc2libGU6IGRlZmF1bHRMYXllclByb3BzLnZpc2libGUsXG4gICAgICAuLi5icnVzaGluZ1Byb3BzXG4gICAgfTtcbiAgICBjb25zdCBob3ZlcmVkT2JqZWN0ID0gdGhpcy5oYXNIb3ZlcmVkT2JqZWN0KG9iamVjdEhvdmVyZWQpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBTY2F0dGVycGxvdExheWVyKHtcbiAgICAgICAgLi4uZGVmYXVsdExheWVyUHJvcHMsXG4gICAgICAgIC4uLmJydXNoaW5nUHJvcHMsXG4gICAgICAgIC4uLmxheWVyUHJvcHMsXG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAvLyBjaXJjbGVzIHdpbGwgYmUgZmxhdCBvbiB0aGUgbWFwIHdoZW4gdGhlIGFsdGl0dWRlIGNvbHVtbiBpcyBub3QgdXNlZFxuICAgICAgICAgIGRlcHRoVGVzdDogKHRoaXMuY29uZmlnLmNvbHVtbnMuYWx0aXR1ZGU/LmZpZWxkSWR4IGFzIG51bWJlcikgPiAtMVxuICAgICAgICB9LFxuICAgICAgICBsaW5lV2lkdGhVbml0czogJ3BpeGVscycsXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzLFxuICAgICAgICBleHRlbnNpb25zXG4gICAgICB9KSxcbiAgICAgIC8vIGhvdmVyIGxheWVyXG4gICAgICAuLi4oaG92ZXJlZE9iamVjdFxuICAgICAgICA/IFtcbiAgICAgICAgICAgIG5ldyBTY2F0dGVycGxvdExheWVyKHtcbiAgICAgICAgICAgICAgLi4udGhpcy5nZXREZWZhdWx0SG92ZXJMYXllclByb3BzKCksXG4gICAgICAgICAgICAgIC4uLmxheWVyUHJvcHMsXG4gICAgICAgICAgICAgIHZpc2libGU6IGRlZmF1bHRMYXllclByb3BzLnZpc2libGUsXG4gICAgICAgICAgICAgIGRhdGE6IFtob3ZlcmVkT2JqZWN0XSxcbiAgICAgICAgICAgICAgZ2V0TGluZUNvbG9yOiB0aGlzLmNvbmZpZy5oaWdobGlnaHRDb2xvcixcbiAgICAgICAgICAgICAgZ2V0RmlsbENvbG9yOiB0aGlzLmNvbmZpZy5oaWdobGlnaHRDb2xvcixcbiAgICAgICAgICAgICAgZ2V0UmFkaXVzOiBkYXRhLmdldFJhZGl1cyxcbiAgICAgICAgICAgICAgZ2V0UG9zaXRpb246IGRhdGEuZ2V0UG9zaXRpb25cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXVxuICAgICAgICA6IFtdKSxcbiAgICAgIC8vIHRleHQgbGFiZWwgbGF5ZXJcbiAgICAgIC4uLnRoaXMucmVuZGVyVGV4dExhYmVsTGF5ZXIoXG4gICAgICAgIHtcbiAgICAgICAgICBnZXRQb3NpdGlvbjogZGF0YS5nZXRQb3NpdGlvbixcbiAgICAgICAgICBzaGFyZWRQcm9wcyxcbiAgICAgICAgICBnZXRQaXhlbE9mZnNldCxcbiAgICAgICAgICB1cGRhdGVUcmlnZ2Vyc1xuICAgICAgICB9LFxuICAgICAgICBvcHRzXG4gICAgICApXG4gICAgXTtcbiAgfVxufVxuIl19