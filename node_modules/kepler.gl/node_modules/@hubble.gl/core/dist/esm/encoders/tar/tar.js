import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import * as utils from './utils';
import * as header from './header';
var blockSize;
var recordSize = 512;

var Tar = function () {
  function Tar(recordsPerBlock) {
    _classCallCheck(this, Tar);

    _defineProperty(this, "blocks", void 0);

    this.written = 0;
    blockSize = (recordsPerBlock || 20) * recordSize;
    this.out = utils.clean(blockSize);
    this.blocks = [];
    this.length = 0;
    this.save = this.save.bind(this);
    this.clear = this.clear.bind(this);
    this.append = this.append.bind(this);
  }

  _createClass(Tar, [{
    key: "append",
    value: function append(filepath, input, opts) {
      var checksum;

      if (typeof input === 'string') {
        input = utils.stringToUint8(input);
      } else if (input.constructor !== Uint8Array.prototype.constructor) {
        var errorInput = input.constructor.toString().match(/function\s*([$A-Za-z_][0-9A-Za-z_]*)\s*\(/)[1];
        var errorMessage = "Invalid input type. You gave me: ".concat(errorInput);
        throw errorMessage;
      }

      opts = opts || {};
      var mode = opts.mode || parseInt('777', 8) & 0xfff;
      var mtime = opts.mtime || Math.floor(Number(new Date()) / 1000);
      var uid = opts.uid || 0;
      var gid = opts.gid || 0;
      var data = {
        fileName: filepath,
        fileMode: utils.pad(mode, 7),
        uid: utils.pad(uid, 7),
        gid: utils.pad(gid, 7),
        fileSize: utils.pad(input.length, 11),
        mtime: utils.pad(mtime, 11),
        checksum: '        ',
        type: '0',
        ustar: 'ustar  ',
        owner: opts.owner || '',
        group: opts.group || ''
      };
      checksum = 0;
      Object.keys(data).forEach(function (key) {
        var i;
        var value = data[key];
        var length;

        for (i = 0, length = value.length; i < length; i += 1) {
          checksum += value.charCodeAt(i);
        }
      });
      data.checksum = "".concat(utils.pad(checksum, 6), "\0 ");
      var headerArr = header.format(data);
      var headerLength = Math.ceil(headerArr.length / recordSize) * recordSize;
      var inputLength = Math.ceil(input.length / recordSize) * recordSize;
      this.blocks.push({
        header: headerArr,
        input: input,
        headerLength: headerLength,
        inputLength: inputLength
      });
    }
  }, {
    key: "save",
    value: function save() {
      var buffers = [];
      var chunks = [];
      var length = 0;
      var max = Math.pow(2, 20);
      var chunk = [];
      this.blocks.forEach(function (b) {
        if (length + b.headerLength + b.inputLength > max) {
          chunks.push({
            blocks: chunk,
            length: length
          });
          chunk = [];
          length = 0;
        }

        chunk.push(b);
        length += b.headerLength + b.inputLength;
      });
      chunks.push({
        blocks: chunk,
        length: length
      });
      chunks.forEach(function (c) {
        var buffer = new Uint8Array(c.length);
        var written = 0;
        c.blocks.forEach(function (b) {
          buffer.set(b.header, written);
          written += b.headerLength;
          buffer.set(b.input, written);
          written += b.inputLength;
        });
        buffers.push(buffer);
      });
      buffers.push(new Uint8Array(2 * recordSize));
      return new Blob(buffers, {
        type: 'octet/stream'
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      this.written = 0;
      this.out = utils.clean(blockSize);
    }
  }]);

  return Tar;
}();

export default Tar;
//# sourceMappingURL=tar.js.map