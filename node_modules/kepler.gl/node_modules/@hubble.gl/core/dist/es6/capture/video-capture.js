import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import download from 'downloadjs';
import { FrameEncoder } from '../encoders';
import { guid } from './utils';
export class VideoCapture {
  constructor() {
    _defineProperty(this, "recording", void 0);

    _defineProperty(this, "capturing", void 0);

    _defineProperty(this, "timeMs", void 0);

    _defineProperty(this, "endTimeMs", void 0);

    _defineProperty(this, "durationMs", void 0);

    _defineProperty(this, "framerate", void 0);

    _defineProperty(this, "encoder", void 0);

    _defineProperty(this, "filename", void 0);

    _defineProperty(this, "encoderSettings", void 0);

    this.recording = false;
    this.capturing = false;
    this.timeMs = 0;
    this.encoder = null;
    this.encoderSettings = null;
    this._getNextTimeMs = this._getNextTimeMs.bind(this);
    this._step = this._step.bind(this);
    this._capture = this._capture.bind(this);
    this.capture = this.capture.bind(this);
    this.render = this.render.bind(this);
    this.stop = this.stop.bind(this);
    this.save = this.save.bind(this);
  }

  parseEncoderSettings(encoderSettings, sceneLengthMs) {
    const parsedSettings = { ...encoderSettings
    };

    if (!parsedSettings.startOffsetMs) {
      parsedSettings.startOffsetMs = 0;
    }

    this.timeMs = parsedSettings.startOffsetMs;

    if (parsedSettings.durationMs) {
      this.endTimeMs = parsedSettings.startOffsetMs + parsedSettings.durationMs;
    } else {
      parsedSettings.durationMs = sceneLengthMs - parsedSettings.startOffsetMs;
      this.endTimeMs = sceneLengthMs;
    }

    if (this.endTimeMs > sceneLengthMs) {
      throw new Error("Recording end time (".concat(this.endTimeMs, ") cannot be greater then scene length (").concat(sceneLengthMs, ")"));
    }

    if (parsedSettings.durationMs <= 0) {
      throw new Error("Invalid recording length in ms (".concat(parsedSettings.durationMs, ").  Must be greater than 0."));
    }

    this.durationMs = parsedSettings.durationMs;

    if (!parsedSettings.filename) {
      parsedSettings.filename = guid();
    }

    this.filename = parsedSettings.filename;
    return parsedSettings;
  }

  isRecording() {
    return this.recording;
  }

  render(Encoder, encoderSettings, sceneLengthMs, onStop = undefined) {
    if (!this.isRecording()) {
      console.time('render');
      this.encoderSettings = this.parseEncoderSettings(encoderSettings, sceneLengthMs);
      console.log("Starting recording for ".concat(this.durationMs, "ms."));
      this.onStop = onStop;
      this.encoder = new Encoder(this.encoderSettings);
      this.recording = true;
      this.encoder.start();
    }
  }

  capture(canvas, proceedToNextFrame) {
    if (!this.capturing && this.isRecording()) {
      this.capturing = true;

      this._capture(canvas).then(data => {
        this.capturing = false;

        if (data.kind === 'step') {
          console.log("data.nextTimeMs: ".concat(data.nextTimeMs));
          proceedToNextFrame(data.nextTimeMs);
        } else if (data.error === 'STOP') {
          console.log('data.error: STOP');
          this.stop(this.onStop);
        } else {
          console.log(data);
        }
      });
    }
  }

  stop(callback = undefined) {
    if (this.isRecording()) {
      console.log("Stopping recording.  Recorded for ".concat(this.durationMs, "ms."));
      this.recording = false;
      this.capturing = false;
      this.encoderSettings = null;
      this.save();

      if (callback) {
        callback();
      }
    }
  }

  save(callback) {
    console.timeEnd('render');

    if (!callback) {
      callback = blob => {
        console.timeEnd('save');

        if (blob) {
          download(blob, this.filename + this.encoder.extension, this.encoder.mimeType);
        }

        return false;
      };
    }

    console.time('save');
    this.encoder.save().then(callback);
  }

  async _capture(canvas) {
    if (!this.isRecording()) {
      return {
        kind: 'error',
        error: 'NOT_RECORDING'
      };
    }

    return await this.encoder.add(canvas).then(this._step).catch(reason => ({
      kind: 'error',
      error: reason
    }));
  }

  _step() {
    this.timeMs = this._getNextTimeMs();

    if (this.timeMs > this.endTimeMs) {
      return {
        kind: 'error',
        error: 'STOP'
      };
    }

    return {
      kind: 'step',
      nextTimeMs: this.timeMs
    };
  }

  _getNextTimeMs() {
    const frameLengthMs = parseInt(1000.0 / this.encoder.framerate, 10);
    return this.timeMs + frameLengthMs;
  }

}
//# sourceMappingURL=video-capture.js.map