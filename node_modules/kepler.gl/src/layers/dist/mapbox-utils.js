"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateMapboxLayers = generateMapboxLayers;
exports.updateMapboxLayers = updateMapboxLayers;
exports.geoJsonFromData = geoJsonFromData;
exports.gpuFilterToMapboxFilter = gpuFilterToMapboxFilter;
exports.prefixGpuField = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _baseLayer = require("./base-layer");

var _utils = require("@kepler.gl/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This function will convert layers to mapbox layers
 * @param layers the layers to be converted
 * @param layerData extra layer information
 * @param layerOrder the order by which we should convert layers
 * @param layersToRender {[id]: true | false} object whether each layer should be rendered
 * @returns
 */
function generateMapboxLayers() {
  var layers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var layerData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var layerOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var layersToRender = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (layerData.length > 0) {
    return layerOrder.slice().reverse().filter(function (layerId) {
      var layer = (0, _utils.findById)(layerId)(layers);
      return (layer === null || layer === void 0 ? void 0 : layer.overlayType) === _baseLayer.OVERLAY_TYPE_CONST.mapboxgl && layersToRender[layerId];
    }).reduce(function (acc, layerId) {
      var layerIndex = layers.findIndex(function (l) {
        return l.id === layerId;
      });

      if (layerIndex === -1) {
        return acc;
      }

      var layer = layers[layerIndex];

      if (!(layer.overlayType === _baseLayer.OVERLAY_TYPE_CONST.mapboxgl && layersToRender[layerId])) {
        return acc;
      }

      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, layer.id, {
        id: layer.id,
        data: layerData[layerIndex].data,
        isVisible: layer.config.isVisible,
        config: layerData[layerIndex].config,
        hidden: layer.config.hidden,
        sourceId: layerData[layerIndex].config.source
      }));
    }, {});
  }

  return {};
}

/**
 * Update mapbox layers on the given map
 * @param map
 * @param newLayers Map of new mapbox layers to be displayed
 * @param oldLayers Map of the old layers to be compare with the current ones to detect deleted layers
 *                  {layerId: sourceId}
 */
function updateMapboxLayers(map) {
  var newLayers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var oldLayers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  // delete no longer existed old layers
  if (oldLayers) {
    checkAndRemoveOldLayers(map, oldLayers, newLayers);
  } // insert or update new layer


  Object.values(newLayers).forEach(function (overlay) {
    var layerId = overlay.id,
        config = overlay.config,
        data = overlay.data,
        sourceId = overlay.sourceId,
        isVisible = overlay.isVisible;

    if (!data && !config) {
      return;
    }

    var _ref = oldLayers && oldLayers[layerId] || {},
        oldData = _ref.data,
        oldConfig = _ref.config;

    if (data && data !== oldData) {
      updateSourceData(map, sourceId, data);
    } // compare with previous configs


    if (oldConfig !== config) {
      updateLayerConfig(map, layerId, config, isVisible);
    }
  });
}

function checkAndRemoveOldLayers(map, oldLayers, newLayers) {
  Object.keys(oldLayers).forEach(function (layerId) {
    if (!newLayers[layerId]) {
      map.removeLayer(layerId);
    }
  });
}

function updateLayerConfig(map, layerId, config, isVisible) {
  var mapboxLayer = map.getLayer(layerId);

  if (mapboxLayer) {
    // check if layer already is set
    // remove it if exists
    map.removeLayer(layerId);
  }

  map.addLayer(config);
  map.setLayoutProperty(layerId, 'visibility', isVisible ? 'visible' : 'none');
}

function updateSourceData(map, sourceId, data) {
  var source = map.getSource(sourceId);

  if (!source) {
    map.addSource(sourceId, {
      type: 'geojson',
      data: data
    });
  } else {
    source.setData(data);
  }
}
/**
 *
 * @param filteredIndex
 * @param getGeometry {({index: number}) => any}
 * @param getProperties {({index: number}) => any}
 * @returns FeatureCollection
 */


function geoJsonFromData() {
  var filteredIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var getGeometry = arguments.length > 1 ? arguments[1] : undefined;
  var getProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (d) {};
  var geojson = {
    type: 'FeatureCollection',
    features: []
  };

  for (var i = 0; i < filteredIndex.length; i++) {
    var index = filteredIndex[i];
    var rowIndex = {
      index: index
    };
    var geometry = getGeometry(rowIndex);

    if (geometry) {
      geojson.features.push({
        type: 'Feature',
        properties: _objectSpread({
          index: index
        }, getProperties(rowIndex)),
        geometry: geometry
      });
    }
  }

  return geojson;
}

var prefixGpuField = function prefixGpuField(name) {
  return "gpu:".concat(name);
};

exports.prefixGpuField = prefixGpuField;

function gpuFilterToMapboxFilter(gpuFilter) {
  var filterRange = gpuFilter.filterRange,
      filterValueUpdateTriggers = gpuFilter.filterValueUpdateTriggers;
  var hasFilter = Object.values(filterValueUpdateTriggers).filter(function (d) {
    return d;
  });

  if (!hasFilter.length) {
    return null;
  }

  var condition = ['all']; // [">=", key, value]
  // ["<=", key, value]

  var expressions = Object.values(filterValueUpdateTriggers).reduce(function (accu, name, i) {
    return name ? [].concat((0, _toConsumableArray2["default"])(accu), [['>=', prefixGpuField(name), filterRange[i][0]], ['<=', prefixGpuField(name), filterRange[i][1]]]) : accu;
  }, condition);
  return expressions;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYXBib3gtdXRpbHMudHMiXSwibmFtZXMiOlsiZ2VuZXJhdGVNYXBib3hMYXllcnMiLCJsYXllcnMiLCJsYXllckRhdGEiLCJsYXllck9yZGVyIiwibGF5ZXJzVG9SZW5kZXIiLCJsZW5ndGgiLCJzbGljZSIsInJldmVyc2UiLCJmaWx0ZXIiLCJsYXllcklkIiwibGF5ZXIiLCJvdmVybGF5VHlwZSIsIk9WRVJMQVlfVFlQRV9DT05TVCIsIm1hcGJveGdsIiwicmVkdWNlIiwiYWNjIiwibGF5ZXJJbmRleCIsImZpbmRJbmRleCIsImwiLCJpZCIsImRhdGEiLCJpc1Zpc2libGUiLCJjb25maWciLCJoaWRkZW4iLCJzb3VyY2VJZCIsInNvdXJjZSIsInVwZGF0ZU1hcGJveExheWVycyIsIm1hcCIsIm5ld0xheWVycyIsIm9sZExheWVycyIsImNoZWNrQW5kUmVtb3ZlT2xkTGF5ZXJzIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsIm92ZXJsYXkiLCJvbGREYXRhIiwib2xkQ29uZmlnIiwidXBkYXRlU291cmNlRGF0YSIsInVwZGF0ZUxheWVyQ29uZmlnIiwia2V5cyIsInJlbW92ZUxheWVyIiwibWFwYm94TGF5ZXIiLCJnZXRMYXllciIsImFkZExheWVyIiwic2V0TGF5b3V0UHJvcGVydHkiLCJnZXRTb3VyY2UiLCJhZGRTb3VyY2UiLCJ0eXBlIiwic2V0RGF0YSIsImdlb0pzb25Gcm9tRGF0YSIsImZpbHRlcmVkSW5kZXgiLCJnZXRHZW9tZXRyeSIsImdldFByb3BlcnRpZXMiLCJkIiwiZ2VvanNvbiIsImZlYXR1cmVzIiwiaSIsImluZGV4Iiwicm93SW5kZXgiLCJnZW9tZXRyeSIsInB1c2giLCJwcm9wZXJ0aWVzIiwicHJlZml4R3B1RmllbGQiLCJuYW1lIiwiZ3B1RmlsdGVyVG9NYXBib3hGaWx0ZXIiLCJncHVGaWx0ZXIiLCJmaWx0ZXJSYW5nZSIsImZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnMiLCJoYXNGaWx0ZXIiLCJjb25kaXRp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TyxJQUFJLGlEQUVLUSxJQUZMLElBR0UsQ0FBQyxJQUFELEVBQU9ULGNBQWMsQ0FBQ0MsSUFBRCxDQUFyQixFQUE2QkcsV0FBVyxDQUFDVixDQUFELENBQVgsQ0FBZSxDQUFmLENBQTdCLENBSEYsRUFJRSxDQUFDLElBQUQsRUFBT00sY0FBYyxDQUFDQyxJQUFELENBQXJCLEVBQTZCRyxXQUFXLENBQUNWLENBQUQsQ0FBWCxDQUFlLENBQWYsQ0FBN0IsQ0FKRixLQU1BZSxJQVBOO0FBQUEsR0FEa0IsRUFTbEJGLFNBVGtCLENBQXBCO0FBWUEsU0FBT0MsV0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IExheWVyLCB7T1ZFUkxBWV9UWVBFX0NPTlNUfSBmcm9tICcuL2Jhc2UtbGF5ZXInO1xuaW1wb3J0IHtGZWF0dXJlfSBmcm9tICdnZW9qc29uJztcblxuaW1wb3J0IHtmaW5kQnlJZH0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgbGF5ZXJzIHRvIG1hcGJveCBsYXllcnNcbiAqIEBwYXJhbSBsYXllcnMgdGhlIGxheWVycyB0byBiZSBjb252ZXJ0ZWRcbiAqIEBwYXJhbSBsYXllckRhdGEgZXh0cmEgbGF5ZXIgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSBsYXllck9yZGVyIHRoZSBvcmRlciBieSB3aGljaCB3ZSBzaG91bGQgY29udmVydCBsYXllcnNcbiAqIEBwYXJhbSBsYXllcnNUb1JlbmRlciB7W2lkXTogdHJ1ZSB8IGZhbHNlfSBvYmplY3Qgd2hldGhlciBlYWNoIGxheWVyIHNob3VsZCBiZSByZW5kZXJlZFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTWFwYm94TGF5ZXJzKFxuICBsYXllcnM6IExheWVyW10gPSBbXSxcbiAgbGF5ZXJEYXRhOiBhbnlbXSA9IFtdLFxuICBsYXllck9yZGVyOiBzdHJpbmdbXSA9IFtdLFxuICBsYXllcnNUb1JlbmRlcjoge1trZXk6IHN0cmluZ106IGJvb2xlYW59ID0ge31cbik6IHtba2V5OiBzdHJpbmddOiBMYXllcn0ge1xuICBpZiAobGF5ZXJEYXRhLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gbGF5ZXJPcmRlclxuICAgICAgLnNsaWNlKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maWx0ZXIobGF5ZXJJZCA9PiB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gZmluZEJ5SWQobGF5ZXJJZCkobGF5ZXJzKTtcbiAgICAgICAgcmV0dXJuIGxheWVyPy5vdmVybGF5VHlwZSA9PT0gT1ZFUkxBWV9UWVBFX0NPTlNULm1hcGJveGdsICYmIGxheWVyc1RvUmVuZGVyW2xheWVySWRdO1xuICAgICAgfSlcbiAgICAgIC5yZWR1Y2UoKGFjYywgbGF5ZXJJZCkgPT4ge1xuICAgICAgICBjb25zdCBsYXllckluZGV4ID0gbGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IGxheWVySWQpO1xuICAgICAgICBpZiAobGF5ZXJJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGF5ZXIgPSBsYXllcnNbbGF5ZXJJbmRleF07XG5cbiAgICAgICAgaWYgKCEobGF5ZXIub3ZlcmxheVR5cGUgPT09IE9WRVJMQVlfVFlQRV9DT05TVC5tYXBib3hnbCAmJiBsYXllcnNUb1JlbmRlcltsYXllcklkXSkpIHtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgW2xheWVyLmlkXToge1xuICAgICAgICAgICAgaWQ6IGxheWVyLmlkLFxuICAgICAgICAgICAgZGF0YTogbGF5ZXJEYXRhW2xheWVySW5kZXhdLmRhdGEsXG4gICAgICAgICAgICBpc1Zpc2libGU6IGxheWVyLmNvbmZpZy5pc1Zpc2libGUsXG4gICAgICAgICAgICBjb25maWc6IGxheWVyRGF0YVtsYXllckluZGV4XS5jb25maWcsXG4gICAgICAgICAgICBoaWRkZW46IGxheWVyLmNvbmZpZy5oaWRkZW4sXG4gICAgICAgICAgICBzb3VyY2VJZDogbGF5ZXJEYXRhW2xheWVySW5kZXhdLmNvbmZpZy5zb3VyY2VcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LCB7fSk7XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbnR5cGUgbmV3TGF5ZXJzVHlwZSA9IHtcbiAgW2tleTogc3RyaW5nXTogTGF5ZXIgJiBQYXJ0aWFsPHtkYXRhOiBhbnk7IHNvdXJjZUlkOiBhbnk7IGlzVmlzaWJsZTogYm9vbGVhbn0+O1xufTtcbnR5cGUgb2xkTGF5ZXJzVHlwZSA9IHtba2V5OiBzdHJpbmddOiBMYXllciAmIHtkYXRhPzogYW55fX07XG4vKipcbiAqIFVwZGF0ZSBtYXBib3ggbGF5ZXJzIG9uIHRoZSBnaXZlbiBtYXBcbiAqIEBwYXJhbSBtYXBcbiAqIEBwYXJhbSBuZXdMYXllcnMgTWFwIG9mIG5ldyBtYXBib3ggbGF5ZXJzIHRvIGJlIGRpc3BsYXllZFxuICogQHBhcmFtIG9sZExheWVycyBNYXAgb2YgdGhlIG9sZCBsYXllcnMgdG8gYmUgY29tcGFyZSB3aXRoIHRoZSBjdXJyZW50IG9uZXMgdG8gZGV0ZWN0IGRlbGV0ZWQgbGF5ZXJzXG4gKiAgICAgICAgICAgICAgICAgIHtsYXllcklkOiBzb3VyY2VJZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZU1hcGJveExheWVycyhcbiAgbWFwLFxuICBuZXdMYXllcnM6IG5ld0xheWVyc1R5cGUgPSB7fSxcbiAgb2xkTGF5ZXJzOiBvbGRMYXllcnNUeXBlIHwgbnVsbCA9IG51bGxcbikge1xuICAvLyBkZWxldGUgbm8gbG9uZ2VyIGV4aXN0ZWQgb2xkIGxheWVyc1xuICBpZiAob2xkTGF5ZXJzKSB7XG4gICAgY2hlY2tBbmRSZW1vdmVPbGRMYXllcnMobWFwLCBvbGRMYXllcnMsIG5ld0xheWVycyk7XG4gIH1cblxuICAvLyBpbnNlcnQgb3IgdXBkYXRlIG5ldyBsYXllclxuICBPYmplY3QudmFsdWVzKG5ld0xheWVycykuZm9yRWFjaChvdmVybGF5ID0+IHtcbiAgICBjb25zdCB7aWQ6IGxheWVySWQsIGNvbmZpZywgZGF0YSwgc291cmNlSWQsIGlzVmlzaWJsZX0gPSBvdmVybGF5O1xuICAgIGlmICghZGF0YSAmJiAhY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge2RhdGE6IG9sZERhdGEsIGNvbmZpZzogb2xkQ29uZmlnfSA9IChvbGRMYXllcnMgJiYgb2xkTGF5ZXJzW2xheWVySWRdKSB8fCB7fTtcblxuICAgIGlmIChkYXRhICYmIGRhdGEgIT09IG9sZERhdGEpIHtcbiAgICAgIHVwZGF0ZVNvdXJjZURhdGEobWFwLCBzb3VyY2VJZCwgZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB3aXRoIHByZXZpb3VzIGNvbmZpZ3NcbiAgICBpZiAob2xkQ29uZmlnICE9PSBjb25maWcpIHtcbiAgICAgIHVwZGF0ZUxheWVyQ29uZmlnKG1hcCwgbGF5ZXJJZCwgY29uZmlnLCBpc1Zpc2libGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQW5kUmVtb3ZlT2xkTGF5ZXJzKG1hcCwgb2xkTGF5ZXJzOiBvbGRMYXllcnNUeXBlLCBuZXdMYXllcnM6IG5ld0xheWVyc1R5cGUpIHtcbiAgT2JqZWN0LmtleXMob2xkTGF5ZXJzKS5mb3JFYWNoKGxheWVySWQgPT4ge1xuICAgIGlmICghbmV3TGF5ZXJzW2xheWVySWRdKSB7XG4gICAgICBtYXAucmVtb3ZlTGF5ZXIobGF5ZXJJZCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGF5ZXJDb25maWcobWFwLCBsYXllcklkLCBjb25maWcsIGlzVmlzaWJsZSkge1xuICBjb25zdCBtYXBib3hMYXllciA9IG1hcC5nZXRMYXllcihsYXllcklkKTtcblxuICBpZiAobWFwYm94TGF5ZXIpIHtcbiAgICAvLyBjaGVjayBpZiBsYXllciBhbHJlYWR5IGlzIHNldFxuICAgIC8vIHJlbW92ZSBpdCBpZiBleGlzdHNcbiAgICBtYXAucmVtb3ZlTGF5ZXIobGF5ZXJJZCk7XG4gIH1cblxuICBtYXAuYWRkTGF5ZXIoY29uZmlnKTtcbiAgbWFwLnNldExheW91dFByb3BlcnR5KGxheWVySWQsICd2aXNpYmlsaXR5JywgaXNWaXNpYmxlID8gJ3Zpc2libGUnIDogJ25vbmUnKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU291cmNlRGF0YShtYXAsIHNvdXJjZUlkLCBkYXRhKSB7XG4gIGNvbnN0IHNvdXJjZSA9IG1hcC5nZXRTb3VyY2Uoc291cmNlSWQpO1xuXG4gIGlmICghc291cmNlKSB7XG4gICAgbWFwLmFkZFNvdXJjZShzb3VyY2VJZCwge1xuICAgICAgdHlwZTogJ2dlb2pzb24nLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNvdXJjZS5zZXREYXRhKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBmaWx0ZXJlZEluZGV4XG4gKiBAcGFyYW0gZ2V0R2VvbWV0cnkgeyh7aW5kZXg6IG51bWJlcn0pID0+IGFueX1cbiAqIEBwYXJhbSBnZXRQcm9wZXJ0aWVzIHsoe2luZGV4OiBudW1iZXJ9KSA9PiBhbnl9XG4gKiBAcmV0dXJucyBGZWF0dXJlQ29sbGVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VvSnNvbkZyb21EYXRhKFxuICBmaWx0ZXJlZEluZGV4OiBudW1iZXJbXSA9IFtdLFxuICBnZXRHZW9tZXRyeTogeyh7aW5kZXg6IG51bWJlcn0pOiBhbnl9LFxuICBnZXRQcm9wZXJ0aWVzOiB7KHtpbmRleDogbnVtYmVyfSk6IGFueX0gPSBkID0+IHt9XG4pIHtcbiAgY29uc3QgZ2VvanNvbjoge3R5cGU6IHN0cmluZzsgZmVhdHVyZXM6IEZlYXR1cmVbXX0gPSB7XG4gICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICBmZWF0dXJlczogW11cbiAgfTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmVkSW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpbmRleCA9IGZpbHRlcmVkSW5kZXhbaV07XG4gICAgY29uc3Qgcm93SW5kZXggPSB7aW5kZXh9O1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkocm93SW5kZXgpO1xuXG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICBnZW9qc29uLmZlYXR1cmVzLnB1c2goe1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAuLi5nZXRQcm9wZXJ0aWVzKHJvd0luZGV4KVxuICAgICAgICB9LFxuICAgICAgICBnZW9tZXRyeVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdlb2pzb247XG59XG5cbmV4cG9ydCBjb25zdCBwcmVmaXhHcHVGaWVsZCA9IG5hbWUgPT4gYGdwdToke25hbWV9YDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdwdUZpbHRlclRvTWFwYm94RmlsdGVyKGdwdUZpbHRlcikge1xuICBjb25zdCB7ZmlsdGVyUmFuZ2UsIGZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnN9ID0gZ3B1RmlsdGVyO1xuXG4gIGNvbnN0IGhhc0ZpbHRlciA9IE9iamVjdC52YWx1ZXMoZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VycykuZmlsdGVyKGQgPT4gZCk7XG5cbiAgaWYgKCFoYXNGaWx0ZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBjb25kaXRpb24gPSBbJ2FsbCddO1xuXG4gIC8vIFtcIj49XCIsIGtleSwgdmFsdWVdXG4gIC8vIFtcIjw9XCIsIGtleSwgdmFsdWVdXG4gIGNvbnN0IGV4cHJlc3Npb25zID0gT2JqZWN0LnZhbHVlcyhmaWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzKS5yZWR1Y2UoXG4gICAgKGFjY3U6IGFueVtdLCBuYW1lLCBpKSA9PlxuICAgICAgbmFtZVxuICAgICAgICA/IFtcbiAgICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgICBbJz49JywgcHJlZml4R3B1RmllbGQobmFtZSksIGZpbHRlclJhbmdlW2ldWzBdXSxcbiAgICAgICAgICAgIFsnPD0nLCBwcmVmaXhHcHVGaWVsZChuYW1lKSwgZmlsdGVyUmFuZ2VbaV1bMV1dXG4gICAgICAgICAgXVxuICAgICAgICA6IGFjY3UsXG4gICAgY29uZGl0aW9uXG4gICk7XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25zO1xufVxuIl19