"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapViewStateContextProvider = exports.MapViewStateContext = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _lodash = _interopRequireDefault(require("lodash.isequal"));

var _lodash2 = _interopRequireDefault(require("lodash.pick"));

var _reducers = require("@kepler.gl/reducers");

// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
var MapViewStateContext = /*#__PURE__*/(0, _react.createContext)({
  getInternalViewState: function getInternalViewState() {
    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return {
      latitude: 0,
      longitude: 0,
      zoom: 0
    };
  },
  setInternalViewState: function setInternalViewState(viewState) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  }
});
/**
 * This context provider is used to localize the map view state so
 * that changes to the map view state do not affect the rest of the app,
 * mainly to prevent issues we experienced with basemap/deck viewport syncing.
 */

exports.MapViewStateContext = MapViewStateContext;

var MapViewStateContextProvider = function MapViewStateContextProvider(_ref) {
  var mapState = _ref.mapState,
      children = _ref.children;

  var _ref2 = mapState || {},
      isSplit = _ref2.isSplit,
      isViewportSynced = _ref2.isViewportSynced; // Store locally map view states by mapIndex


  var _useState = (0, _react.useState)([mapState]),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      viewStates = _useState2[0],
      setViewStates = _useState2[1]; // Detect and apply outside viewport changes
  // (e.g. from geocoder or when switching to 3d mode)


  (0, _react.useEffect)(function () {
    if (!mapState) return;
    var primaryState = viewStates[0];
    if (primaryState === mapState) return;
    var props = Object.keys(primaryState).filter(function (key) {
      return !key.startsWith('transition');
    });

    var hasChanged = function hasChanged(a, b) {
      return !(0, _lodash["default"])((0, _lodash2["default"])(a, props), (0, _lodash2["default"])(b, props));
    };

    if (isSplit && !isViewportSynced) {
      var _mapState$splitMapVie;

      if ((_mapState$splitMapVie = mapState.splitMapViewports) !== null && _mapState$splitMapVie !== void 0 && _mapState$splitMapVie.some(function (s, i) {
        return hasChanged(s, viewStates[i]);
      })) {
        setViewStates(mapState.splitMapViewports);
      }
    } else {
      if (hasChanged(primaryState, mapState)) {
        setViewStates([(0, _reducers.pickViewportPropsFromMapState)(mapState)]);
      }
    } // Only update internalViewState when viewState changes
    // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [mapState]);
  var value = {
    getInternalViewState: function getInternalViewState() {
      var _viewStates$index;

      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return (_viewStates$index = viewStates[index]) !== null && _viewStates$index !== void 0 ? _viewStates$index : viewStates[0];
    },
    setInternalViewState: function setInternalViewState(newViewState) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      setViewStates(function (prevViewStates) {
        if (isSplit && !isViewportSynced) {
          var nextViewStates = (0, _toConsumableArray2["default"])(prevViewStates);
          nextViewStates[index] = newViewState;
          return nextViewStates;
        } else {
          return [newViewState];
        }
      });
    }
  };
  return /*#__PURE__*/_react["default"].createElement(MapViewStateContext.Provider, {
    value: value
  }, children);
};

exports.MapViewStateContextProvider = MapViewStateContextProvider;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYXAtdmlldy1zdGF0ZS1jb250ZXh0LnRzeCJdLCJuYW1lcyI6WyJNYXBWaWV3U3RhdGVDb250ZXh0IiwiZ2V0SW50ZXJuYWxWaWV3U3RhdGUiLCJpbmRleCIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInNldEludGVybmFsVmlld1N0YXRlIiwidmlld1N0YXRlIiwiTWFwVmlld1N0YXRlQ29udGV4dFByb3ZpZGVyIiwibWFwU3RhdGUiLCJjaGlsZHJlbiIsImlzU3BsaXQiLCJpc1ZpZXdwb3J0U3luY2VkIiwidmlld1N0YXRlcyIsInNldFZpZXdTdGF0ZXMiLCJwcmltYXJ5U3RhdGUiLCJwcm9wcyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJzdGFydHNXaXRoIiwiaGFzQ2hhbmdlZCIsImEiLCJiIiwic3BsaXRNYXBWaWV3cG9ydHMiLCJzb21lIiwicyIsImkiLCJ2YWx1ZSIsIm5ld1ZpZXdTdGF0ZSIsInByZXZWaWV3U3RhdGVzIiwibmV4dFZpZXdTdGF0ZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUdBOztBQUNBOztBQUNBOztBQUVBOztBQVBBO0FBQ0E7QUFlTyxJQUFNQSxtQkFBMkQsZ0JBQUcsMEJBQWM7QUFDdkZDLEVBQUFBLG9CQUFvQixFQUFFO0FBQUEsUUFBQ0MsS0FBRCx1RUFBUyxDQUFUO0FBQUEsV0FBZ0I7QUFBQ0MsTUFBQUEsUUFBUSxFQUFFLENBQVg7QUFBY0MsTUFBQUEsU0FBUyxFQUFFLENBQXpCO0FBQTRCQyxNQUFBQSxJQUFJLEVBQUU7QUFBbEMsS0FBaEI7QUFBQSxHQURpRTtBQUV2RkMsRUFBQUEsb0JBQW9CLEVBQUUsOEJBQUNDLFNBQUQsRUFBMEI7QUFBQSxRQUFkTCxLQUFjLHVFQUFOLENBQU07QUFBRTtBQUZxQyxDQUFkLENBQXBFO0FBS1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUVPLElBQU1NLDJCQUEyQixHQUFHLFNBQTlCQSwyQkFBOEIsT0FNckM7QUFBQSxNQUxKQyxRQUtJLFFBTEpBLFFBS0k7QUFBQSxNQUpKQyxRQUlJLFFBSkpBLFFBSUk7O0FBQUEsY0FDZ0NELFFBQVEsSUFBSSxFQUQ1QztBQUFBLE1BQ0dFLE9BREgsU0FDR0EsT0FESDtBQUFBLE1BQ1lDLGdCQURaLFNBQ1lBLGdCQURaLEVBR0o7OztBQUhJLGtCQUlnQyxxQkFBUyxDQUFDSCxRQUFELENBQVQsQ0FKaEM7QUFBQTtBQUFBLE1BSUdJLFVBSkg7QUFBQSxNQUllQyxhQUpmLGtCQU1KO0FBQ0E7OztBQUNBLHdCQUFVLFlBQU07QUFDZCxRQUFJLENBQUNMLFFBQUwsRUFBZTtBQUNmLFFBQU1NLFlBQVksR0FBR0YsVUFBVSxDQUFDLENBQUQsQ0FBL0I7QUFDQSxRQUFJRSxZQUFZLEtBQUtOLFFBQXJCLEVBQStCO0FBQy9CLFFBQU1PLEtBQUssR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVlILFlBQVosRUFBMEJJLE1BQTFCLENBQWlDLFVBQUFDLEdBQUc7QUFBQSxhQUFJLENBQUNBLEdBQUcsQ0FBQ0MsVUFBSixDQUFlLFlBQWYsQ0FBTDtBQUFBLEtBQXBDLENBQWQ7O0FBQ0EsUUFBTUMsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsYUFBVSxDQUFDLHdCQUFRLHlCQUFLRCxDQUFMLEVBQVFQLEtBQVIsQ0FBUixFQUF3Qix5QkFBS1EsQ0FBTCxFQUFRUixLQUFSLENBQXhCLENBQVg7QUFBQSxLQUFuQjs7QUFDQSxRQUFJTCxPQUFPLElBQUksQ0FBQ0MsZ0JBQWhCLEVBQWtDO0FBQUE7O0FBQ2hDLG1DQUFJSCxRQUFRLENBQUNnQixpQkFBYixrREFBSSxzQkFBNEJDLElBQTVCLENBQWlDLFVBQUNDLENBQUQsRUFBSUMsQ0FBSjtBQUFBLGVBQVVOLFVBQVUsQ0FBQ0ssQ0FBRCxFQUFJZCxVQUFVLENBQUNlLENBQUQsQ0FBZCxDQUFwQjtBQUFBLE9BQWpDLENBQUosRUFBOEU7QUFDNUVkLFFBQUFBLGFBQWEsQ0FBQ0wsUUFBUSxDQUFDZ0IsaUJBQVYsQ0FBYjtBQUNEO0FBQ0YsS0FKRCxNQUlPO0FBQ0wsVUFBSUgsVUFBVSxDQUFDUCxZQUFELEVBQWVOLFFBQWYsQ0FBZCxFQUF3QztBQUN0Q0ssUUFBQUEsYUFBYSxDQUFDLENBQUMsNkNBQThCTCxRQUE5QixDQUFELENBQUQsQ0FBYjtBQUNEO0FBQ0YsS0FkYSxDQWVkO0FBQ0E7O0FBQ0QsR0FqQkQsRUFpQkcsQ0FBQ0EsUUFBRCxDQWpCSDtBQW1CQSxNQUFNb0IsS0FBSyxHQUFHO0FBQ1o1QixJQUFBQSxvQkFBb0IsRUFBRTtBQUFBOztBQUFBLFVBQUNDLEtBQUQsdUVBQVMsQ0FBVDtBQUFBLGtDQUFlVyxVQUFVLENBQUNYLEtBQUQsQ0FBekIsaUVBQW9DVyxVQUFVLENBQUMsQ0FBRCxDQUE5QztBQUFBLEtBRFY7QUFFWlAsSUFBQUEsb0JBQW9CLEVBQUUsOEJBQUN3QixZQUFELEVBQTZCO0FBQUEsVUFBZDVCLEtBQWMsdUVBQU4sQ0FBTTtBQUNqRFksTUFBQUEsYUFBYSxDQUFDLFVBQUFpQixjQUFjLEVBQUk7QUFDOUIsWUFBSXBCLE9BQU8sSUFBSSxDQUFDQyxnQkFBaEIsRUFBa0M7QUFDaEMsY0FBTW9CLGNBQWMsdUNBQU9ELGNBQVAsQ0FBcEI7QUFDQUMsVUFBQUEsY0FBYyxDQUFDOUIsS0FBRCxDQUFkLEdBQXdCNEIsWUFBeEI7QUFDQSxpQkFBT0UsY0FBUDtBQUNELFNBSkQsTUFJTztBQUNMLGlCQUFPLENBQUNGLFlBQUQsQ0FBUDtBQUNEO0FBQ0YsT0FSWSxDQUFiO0FBU0Q7QUFaVyxHQUFkO0FBY0Esc0JBQU8sZ0NBQUMsbUJBQUQsQ0FBcUIsUUFBckI7QUFBOEIsSUFBQSxLQUFLLEVBQUVEO0FBQXJDLEtBQTZDbkIsUUFBN0MsQ0FBUDtBQUNELENBaERNIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IFJlYWN0LCB7dXNlU3RhdGUsIHVzZUVmZmVjdCwgY3JlYXRlQ29udGV4dH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSAnbG9kYXNoLmlzZXF1YWwnO1xuaW1wb3J0IHBpY2sgZnJvbSAnbG9kYXNoLnBpY2snO1xuaW1wb3J0IHtNYXBWaWV3U3RhdGV9IGZyb20gJ0BkZWNrLmdsL2NvcmUvdHlwZWQnO1xuaW1wb3J0IHtwaWNrVmlld3BvcnRQcm9wc0Zyb21NYXBTdGF0ZX0gZnJvbSAnQGtlcGxlci5nbC9yZWR1Y2Vycyc7XG5cbmltcG9ydCB7TWFwU3RhdGV9IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBNYXBWaWV3U3RhdGVDb250ZXh0VHlwZSA9IHtcbiAgZ2V0SW50ZXJuYWxWaWV3U3RhdGU6IChpbmRleD86IG51bWJlcikgPT4gTWFwVmlld1N0YXRlO1xuICBzZXRJbnRlcm5hbFZpZXdTdGF0ZTogKHZpZXdTdGF0ZTogTWFwVmlld1N0YXRlLCBpbmRleD86IG51bWJlcikgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBjb25zdCBNYXBWaWV3U3RhdGVDb250ZXh0OiBSZWFjdC5Db250ZXh0PE1hcFZpZXdTdGF0ZUNvbnRleHRUeXBlPiA9IGNyZWF0ZUNvbnRleHQoe1xuICBnZXRJbnRlcm5hbFZpZXdTdGF0ZTogKGluZGV4ID0gMCkgPT4gKHtsYXRpdHVkZTogMCwgbG9uZ2l0dWRlOiAwLCB6b29tOiAwfSksXG4gIHNldEludGVybmFsVmlld1N0YXRlOiAodmlld1N0YXRlLCBpbmRleCA9IDApID0+IHt9XG59KTtcblxuLyoqXG4gKiBUaGlzIGNvbnRleHQgcHJvdmlkZXIgaXMgdXNlZCB0byBsb2NhbGl6ZSB0aGUgbWFwIHZpZXcgc3RhdGUgc29cbiAqIHRoYXQgY2hhbmdlcyB0byB0aGUgbWFwIHZpZXcgc3RhdGUgZG8gbm90IGFmZmVjdCB0aGUgcmVzdCBvZiB0aGUgYXBwLFxuICogbWFpbmx5IHRvIHByZXZlbnQgaXNzdWVzIHdlIGV4cGVyaWVuY2VkIHdpdGggYmFzZW1hcC9kZWNrIHZpZXdwb3J0IHN5bmNpbmcuXG4gKi9cblxuZXhwb3J0IGNvbnN0IE1hcFZpZXdTdGF0ZUNvbnRleHRQcm92aWRlciA9ICh7XG4gIG1hcFN0YXRlLFxuICBjaGlsZHJlblxufToge1xuICBtYXBTdGF0ZTogTWFwU3RhdGU7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59KSA9PiB7XG4gIGNvbnN0IHtpc1NwbGl0LCBpc1ZpZXdwb3J0U3luY2VkfSA9IG1hcFN0YXRlIHx8IHt9O1xuXG4gIC8vIFN0b3JlIGxvY2FsbHkgbWFwIHZpZXcgc3RhdGVzIGJ5IG1hcEluZGV4XG4gIGNvbnN0IFt2aWV3U3RhdGVzLCBzZXRWaWV3U3RhdGVzXSA9IHVzZVN0YXRlKFttYXBTdGF0ZV0pO1xuXG4gIC8vIERldGVjdCBhbmQgYXBwbHkgb3V0c2lkZSB2aWV3cG9ydCBjaGFuZ2VzXG4gIC8vIChlLmcuIGZyb20gZ2VvY29kZXIgb3Igd2hlbiBzd2l0Y2hpbmcgdG8gM2QgbW9kZSlcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcFN0YXRlKSByZXR1cm47XG4gICAgY29uc3QgcHJpbWFyeVN0YXRlID0gdmlld1N0YXRlc1swXTtcbiAgICBpZiAocHJpbWFyeVN0YXRlID09PSBtYXBTdGF0ZSkgcmV0dXJuO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMocHJpbWFyeVN0YXRlKS5maWx0ZXIoa2V5ID0+ICFrZXkuc3RhcnRzV2l0aCgndHJhbnNpdGlvbicpKTtcbiAgICBjb25zdCBoYXNDaGFuZ2VkID0gKGEsIGIpID0+ICFpc0VxdWFsKHBpY2soYSwgcHJvcHMpLCBwaWNrKGIsIHByb3BzKSk7XG4gICAgaWYgKGlzU3BsaXQgJiYgIWlzVmlld3BvcnRTeW5jZWQpIHtcbiAgICAgIGlmIChtYXBTdGF0ZS5zcGxpdE1hcFZpZXdwb3J0cz8uc29tZSgocywgaSkgPT4gaGFzQ2hhbmdlZChzLCB2aWV3U3RhdGVzW2ldKSkpIHtcbiAgICAgICAgc2V0Vmlld1N0YXRlcyhtYXBTdGF0ZS5zcGxpdE1hcFZpZXdwb3J0cyBhcyBNYXBTdGF0ZVtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc0NoYW5nZWQocHJpbWFyeVN0YXRlLCBtYXBTdGF0ZSkpIHtcbiAgICAgICAgc2V0Vmlld1N0YXRlcyhbcGlja1ZpZXdwb3J0UHJvcHNGcm9tTWFwU3RhdGUobWFwU3RhdGUpXSBhcyBNYXBTdGF0ZVtdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT25seSB1cGRhdGUgaW50ZXJuYWxWaWV3U3RhdGUgd2hlbiB2aWV3U3RhdGUgY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW21hcFN0YXRlXSk7XG5cbiAgY29uc3QgdmFsdWUgPSB7XG4gICAgZ2V0SW50ZXJuYWxWaWV3U3RhdGU6IChpbmRleCA9IDApID0+IHZpZXdTdGF0ZXNbaW5kZXhdID8/IHZpZXdTdGF0ZXNbMF0sXG4gICAgc2V0SW50ZXJuYWxWaWV3U3RhdGU6IChuZXdWaWV3U3RhdGUsIGluZGV4ID0gMCkgPT4ge1xuICAgICAgc2V0Vmlld1N0YXRlcyhwcmV2Vmlld1N0YXRlcyA9PiB7XG4gICAgICAgIGlmIChpc1NwbGl0ICYmICFpc1ZpZXdwb3J0U3luY2VkKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFZpZXdTdGF0ZXMgPSBbLi4ucHJldlZpZXdTdGF0ZXNdO1xuICAgICAgICAgIG5leHRWaWV3U3RhdGVzW2luZGV4XSA9IG5ld1ZpZXdTdGF0ZSBhcyBNYXBTdGF0ZTtcbiAgICAgICAgICByZXR1cm4gbmV4dFZpZXdTdGF0ZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtuZXdWaWV3U3RhdGVdIGFzIE1hcFN0YXRlW107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBhcyBNYXBWaWV3U3RhdGVDb250ZXh0VHlwZTtcbiAgcmV0dXJuIDxNYXBWaWV3U3RhdGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+e2NoaWxkcmVufTwvTWFwVmlld1N0YXRlQ29udGV4dC5Qcm92aWRlcj47XG59O1xuIl19