"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.colorMaker = exports.layerColors = exports.OVERLAY_TYPE_CONST = exports.LAYER_ID_LENGTH = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _window = require("global/window");

var _keymirror = _interopRequireDefault(require("keymirror"));

var _extensions = require("@deck.gl/extensions");

var _core = require("@deck.gl/core");

var _layers = require("@deck.gl/layers");

var _defaultLayerIcon = _interopRequireDefault(require("./default-layer-icon"));

var _layerUpdate = require("./layer-update");

var _constants = require("@kepler.gl/constants");

var _utils = require("@kepler.gl/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _marked = /*#__PURE__*/_regenerator["default"].mark(generateColor);

/**
 * Approx. number of points to sample in a large data set
 */
var LAYER_ID_LENGTH = 6;
exports.LAYER_ID_LENGTH = LAYER_ID_LENGTH;
var MAX_SAMPLE_SIZE = 5000;
var defaultDomain = [0, 1];
var dataFilterExtension = new _extensions.DataFilterExtension({
  filterSize: _constants.MAX_GPU_FILTERS
});

var defaultDataAccessor = function defaultDataAccessor(dc) {
  return function (d) {
    return d;
  };
};

var defaultGetFieldValue = function defaultGetFieldValue(field, d) {
  return field.valueAccessor(d);
};

var OVERLAY_TYPE_CONST = (0, _keymirror["default"])({
  deckgl: null,
  mapboxgl: null
});
exports.OVERLAY_TYPE_CONST = OVERLAY_TYPE_CONST;
var layerColors = Object.values(_constants.DataVizColors).map(_utils.hexToRgb);
exports.layerColors = layerColors;

function generateColor() {
  var index;
  return _regenerator["default"].wrap(function generateColor$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          index = 0;

        case 1:
          if (!(index < layerColors.length + 1)) {
            _context.next = 7;
            break;
          }

          if (index === layerColors.length) {
            index = 0;
          }

          _context.next = 5;
          return layerColors[index++];

        case 5:
          _context.next = 1;
          break;

        case 7:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

var colorMaker = generateColor();
exports.colorMaker = colorMaker;

var Layer = /*#__PURE__*/function () {
  // TODO: define _oldDataUpdateTriggers
  function Layer(props) {
    (0, _classCallCheck2["default"])(this, Layer);
    (0, _defineProperty2["default"])(this, "id", void 0);
    (0, _defineProperty2["default"])(this, "meta", void 0);
    (0, _defineProperty2["default"])(this, "visConfigSettings", void 0);
    (0, _defineProperty2["default"])(this, "config", void 0);
    (0, _defineProperty2["default"])(this, "_oldDataUpdateTriggers", void 0);
    (0, _defineProperty2["default"])(this, "isValid", void 0);
    (0, _defineProperty2["default"])(this, "errorMessage", void 0);
    this.id = props.id || (0, _utils.generateHashId)(LAYER_ID_LENGTH); // meta

    this.meta = {}; // visConfigSettings

    this.visConfigSettings = {};
    this.config = this.getDefaultLayerConfig(_objectSpread({
      columns: this.getLayerColumns()
    }, props)); // false indicates that the layer caused an error, and was disabled

    this.isValid = true;
    this.errorMessage = null;
  }

  (0, _createClass2["default"])(Layer, [{
    key: "layerIcon",
    get: function get() {
      return _defaultLayerIcon["default"];
    }
  }, {
    key: "overlayType",
    get: function get() {
      return OVERLAY_TYPE_CONST.deckgl;
    }
  }, {
    key: "type",
    get: function get() {
      return null;
    }
  }, {
    key: "name",
    get: function get() {
      return this.type;
    }
  }, {
    key: "isAggregated",
    get: function get() {
      return false;
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return [];
    }
  }, {
    key: "optionalColumns",
    get: function get() {
      return [];
    }
  }, {
    key: "noneLayerDataAffectingProps",
    get: function get() {
      return ['label', 'opacity', 'thickness', 'isVisible', 'hidden'];
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return {
        color: {
          property: 'color',
          field: 'colorField',
          scale: 'colorScale',
          domain: 'colorDomain',
          range: 'colorRange',
          key: 'color',
          channelScaleType: _constants.CHANNEL_SCALES.color,
          nullValue: _constants.NO_VALUE_COLOR,
          defaultValue: function defaultValue(config) {
            return config.color;
          }
        },
        size: {
          property: 'size',
          field: 'sizeField',
          scale: 'sizeScale',
          domain: 'sizeDomain',
          range: 'sizeRange',
          key: 'size',
          channelScaleType: _constants.CHANNEL_SCALES.size,
          nullValue: 0,
          defaultValue: 1
        }
      };
    }
  }, {
    key: "columnValidators",
    get: function get() {
      return {};
    }
    /*
     * Column pairs maps layer column to a specific field pairs,
     * By default, it is set to null
     */

  }, {
    key: "columnPairs",
    get: function get() {
      return null;
    }
    /*
     * Default point column pairs, can be used for point based layers: point, icon etc.
     */

  }, {
    key: "defaultPointColumnPairs",
    get: function get() {
      return {
        lat: {
          pair: 'lng',
          fieldPairKey: 'lat'
        },
        lng: {
          pair: 'lat',
          fieldPairKey: 'lng'
        }
      };
    }
    /*
     * Default link column pairs, can be used for link based layers: arc, line etc
     */

  }, {
    key: "defaultLinkColumnPairs",
    get: function get() {
      return {
        lat0: {
          pair: 'lng0',
          fieldPairKey: 'lat'
        },
        lng0: {
          pair: 'lat0',
          fieldPairKey: 'lng'
        },
        lat1: {
          pair: 'lng1',
          fieldPairKey: 'lat'
        },
        lng1: {
          pair: 'lat1',
          fieldPairKey: 'lng'
        }
      };
    }
    /**
     * Return a React component for to render layer instructions in a modal
     * @returns {object} - an object
     * @example
     *  return {
     *    id: 'iconInfo',
     *    template: IconInfoModal,
     *    modalProps: {
     *      title: 'How to draw icons'
     *   };
     * }
     */

  }, {
    key: "layerInfoModal",
    get: function get() {
      return null;
    }
  }, {
    key: "supportedDatasetTypes",
    get: function get() {
      return null;
    }
    /*
     * Given a dataset, automatically find props to create layer based on it
     * and return the props and previous found layers.
     * By default, no layers will be found
     */

  }, {
    key: "getDefaultLayerConfig",
    value: function getDefaultLayerConfig(props) {
      return {
        dataId: props.dataId,
        label: props.label || _constants.DEFAULT_LAYER_LABEL,
        color: props.color || colorMaker.next().value,
        columns: props.columns || {},
        isVisible: props.isVisible || false,
        isConfigActive: props.isConfigActive || false,
        highlightColor: props.highlightColor || _constants.DEFAULT_HIGHLIGHT_COLOR,
        hidden: props.hidden || false,
        // TODO: refactor this into separate visual Channel config
        // color by field, domain is set by filters, field, scale type
        colorField: null,
        colorDomain: [0, 1],
        colorScale: _constants.SCALE_TYPES.quantile,
        // color by size, domain is set by filters, field, scale type
        sizeDomain: [0, 1],
        sizeScale: _constants.SCALE_TYPES.linear,
        sizeField: null,
        visConfig: {},
        textLabel: [_constants.DEFAULT_TEXT_LABEL],
        colorUI: {
          color: _constants.DEFAULT_COLOR_UI,
          colorRange: _constants.DEFAULT_COLOR_UI
        },
        animation: {
          enabled: false
        }
      };
    }
    /**
     * Get the description of a visualChannel config
     * @param key
     * @returns
     */

  }, {
    key: "getVisualChannelDescription",
    value: function getVisualChannelDescription(key) {
      // e.g. label: Color, measure: Vehicle Type
      var channel = this.visualChannels[key];
      if (!channel) return {
        label: '',
        measure: undefined
      };
      var rangeSettings = this.visConfigSettings[channel.range];
      var fieldSettings = this.config[channel.field];
      var label = rangeSettings === null || rangeSettings === void 0 ? void 0 : rangeSettings.label;
      return {
        label: typeof label === 'function' ? label(this.config) : label || '',
        measure: fieldSettings ? fieldSettings.displayName || fieldSettings.name : channel.defaultMeasure
      };
    }
    /**
     * Assign a field to layer column, return column config
     * @param key - Column Key
     * @param field - Selected field
     * @returns {{}} - Column config
     */

  }, {
    key: "assignColumn",
    value: function assignColumn(key, field) {
      // field value could be null for optional columns
      var update = field ? {
        value: field.name,
        fieldIdx: field.fieldIdx
      } : {
        value: null,
        fieldIdx: -1
      };
      return _objectSpread(_objectSpread({}, this.config.columns), {}, (0, _defineProperty2["default"])({}, key, _objectSpread(_objectSpread({}, this.config.columns[key]), update)));
    }
    /**
     * Assign a field pair to column config, return column config
     * @param key - Column Key
     * @param pair - field Pair
     * @returns {object} - Column config
     */

  }, {
    key: "assignColumnPairs",
    value: function assignColumnPairs(key, pair) {
      var _this$columnPairs, _this$columnPairs2, _this$columnPairs3, _objectSpread3;

      if (!this.columnPairs || !((_this$columnPairs = this.columnPairs) !== null && _this$columnPairs !== void 0 && _this$columnPairs[key])) {
        // should not end in this state
        return this.config.columns;
      }

      var _this$columnPairs$key = (_this$columnPairs2 = this.columnPairs) === null || _this$columnPairs2 === void 0 ? void 0 : _this$columnPairs2[key],
          partnerKey = _this$columnPairs$key.pair,
          fieldPairKey = _this$columnPairs$key.fieldPairKey;

      if (!pair[fieldPairKey]) {
        // do not allow `key: undefined` to creep into the `updatedColumn` object
        return this.config.columns;
      }

      var _this$columnPairs$par = (_this$columnPairs3 = this.columnPairs) === null || _this$columnPairs3 === void 0 ? void 0 : _this$columnPairs3[partnerKey],
          partnerFieldPairKey = _this$columnPairs$par.fieldPairKey;

      return _objectSpread(_objectSpread({}, this.config.columns), {}, (_objectSpread3 = {}, (0, _defineProperty2["default"])(_objectSpread3, key, pair[fieldPairKey]), (0, _defineProperty2["default"])(_objectSpread3, partnerKey, pair[partnerFieldPairKey]), _objectSpread3));
    }
    /**
     * Calculate a radius zoom multiplier to render points, so they are visible in all zoom level
     * @param {object} mapState
     * @param {number} mapState.zoom - actual zoom
     * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image
     * @returns {number}
     */

  }, {
    key: "getZoomFactor",
    value: function getZoomFactor(_ref) {
      var zoom = _ref.zoom,
          _ref$zoomOffset = _ref.zoomOffset,
          zoomOffset = _ref$zoomOffset === void 0 ? 0 : _ref$zoomOffset;
      return Math.pow(2, Math.max(14 - zoom + zoomOffset, 0));
    }
    /**
     * Calculate a elevation zoom multiplier to render points, so they are visible in all zoom level
     * @param {object} mapState
     * @param {number} mapState.zoom - actual zoom
     * @param {number=} mapState.zoomOffset - zoomOffset when render in the plot container for export image
     * @returns {number}
     */

  }, {
    key: "getElevationZoomFactor",
    value: function getElevationZoomFactor(_ref2) {
      var zoom = _ref2.zoom,
          _ref2$zoomOffset = _ref2.zoomOffset,
          zoomOffset = _ref2$zoomOffset === void 0 ? 0 : _ref2$zoomOffset;
      return this.config.visConfig.enableElevationZoomFactor ? Math.pow(2, Math.max(8 - zoom + zoomOffset, 0)) : 1;
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData) {
      return {};
    }
  }, {
    key: "renderLayer",
    value: function renderLayer() {
      return [];
    }
  }, {
    key: "getHoverData",
    value: function getHoverData(object, dataContainer, fields) {
      if (!object) {
        return null;
      } // By default, each entry of layerData should have an index of a row in the original data container.
      // Each layer can implement its own getHoverData method


      return dataContainer.row(object.index);
    }
    /**
     * When change layer type, try to copy over layer configs as much as possible
     * @param configToCopy - config to copy over
     * @param visConfigSettings - visConfig settings of config to copy
     */

  }, {
    key: "assignConfigToLayer",
    value: function assignConfigToLayer(configToCopy, visConfigSettings) {
      var _this = this;

      // don't deep merge visualChannel field
      // don't deep merge color range, reversed: is not a key by default
      var shallowCopy = ['colorRange', 'strokeColorRange'].concat(Object.values(this.visualChannels).map(function (v) {
        return v.field;
      })); // don't copy over domain and animation

      var notToCopy = ['animation'].concat(Object.values(this.visualChannels).map(function (v) {
        return v.domain;
      })); // if range is for the same property group copy it, otherwise, not to copy

      Object.values(this.visualChannels).forEach(function (v) {
        if (configToCopy.visConfig[v.range] && _this.visConfigSettings[v.range] && visConfigSettings[v.range].group !== _this.visConfigSettings[v.range].group) {
          notToCopy.push(v.range);
        }
      }); // don't copy over visualChannel range

      var currentConfig = this.config;
      var copied = this.copyLayerConfig(currentConfig, configToCopy, {
        shallowCopy: shallowCopy,
        notToCopy: notToCopy
      });
      this.updateLayerConfig(copied); // validate visualChannel field type and scale types

      Object.keys(this.visualChannels).forEach(function (channel) {
        _this.validateVisualChannel(channel);
      });
    }
    /*
     * Recursively copy config over to an empty layer
     * when received saved config, or copy config over from a different layer type
     * make sure to only copy over value to existing keys
     * @param {object} currentConfig - existing config to be override
     * @param {object} configToCopy - new Config to copy over
     * @param {string[]} shallowCopy - array of properties to not to be deep copied
     * @param {string[]} notToCopy - array of properties not to copy
     * @returns {object} - copied config
     */

  }, {
    key: "copyLayerConfig",
    value: function copyLayerConfig(currentConfig, configToCopy) {
      var _this2 = this;

      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref3$shallowCopy = _ref3.shallowCopy,
          shallowCopy = _ref3$shallowCopy === void 0 ? [] : _ref3$shallowCopy,
          _ref3$notToCopy = _ref3.notToCopy,
          notToCopy = _ref3$notToCopy === void 0 ? [] : _ref3$notToCopy;

      var copied = {};
      Object.keys(currentConfig).forEach(function (key) {
        if ((0, _utils.isPlainObject)(currentConfig[key]) && (0, _utils.isPlainObject)(configToCopy[key]) && !shallowCopy.includes(key) && !notToCopy.includes(key)) {
          // recursively assign object value
          copied[key] = _this2.copyLayerConfig(currentConfig[key], configToCopy[key], {
            shallowCopy: shallowCopy,
            notToCopy: notToCopy
          });
        } else if ((0, _utils.notNullorUndefined)(configToCopy[key]) && !notToCopy.includes(key)) {
          // copy
          copied[key] = configToCopy[key];
        } else {
          // keep existing
          copied[key] = currentConfig[key];
        }
      });
      return copied;
    }
  }, {
    key: "registerVisConfig",
    value: function registerVisConfig(layerVisConfigs) {
      var _this3 = this;

      Object.keys(layerVisConfigs).forEach(function (item) {
        var configItem = layerVisConfigs[item];

        if (typeof configItem === 'string' && _constants.LAYER_VIS_CONFIGS[configItem]) {
          // if assigned one of default LAYER_CONFIGS
          _this3.config.visConfig[item] = _constants.LAYER_VIS_CONFIGS[configItem].defaultValue;
          _this3.visConfigSettings[item] = _constants.LAYER_VIS_CONFIGS[configItem];
        } else if ((0, _typeof2["default"])(configItem) === 'object' && ['type', 'defaultValue'].every(function (p) {
          return configItem.hasOwnProperty(p);
        })) {
          // if provided customized visConfig, and has type && defaultValue
          // TODO: further check if customized visConfig is valid
          _this3.config.visConfig[item] = configItem.defaultValue;
          _this3.visConfigSettings[item] = configItem;
        }
      });
    }
  }, {
    key: "getLayerColumns",
    value: function getLayerColumns() {
      var columnValidators = this.columnValidators;
      var required = this.requiredLayerColumns.reduce(function (accu, key) {
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, columnValidators[key] ? {
          value: null,
          fieldIdx: -1,
          validator: columnValidators[key]
        } : {
          value: null,
          fieldIdx: -1
        }));
      }, {});
      var optional = this.optionalColumns.reduce(function (accu, key) {
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, {
          value: null,
          fieldIdx: -1,
          optional: true
        }));
      }, {});
      return _objectSpread(_objectSpread({}, required), optional);
    }
  }, {
    key: "updateLayerConfig",
    value: function updateLayerConfig(newConfig) {
      this.config = _objectSpread(_objectSpread({}, this.config), newConfig);
      return this;
    }
  }, {
    key: "updateLayerVisConfig",
    value: function updateLayerVisConfig(newVisConfig) {
      this.config.visConfig = _objectSpread(_objectSpread({}, this.config.visConfig), newVisConfig);
      return this;
    }
  }, {
    key: "updateLayerColorUI",
    value: function updateLayerColorUI(prop, newConfig) {
      var _this$config = this.config,
          previous = _this$config.colorUI,
          visConfig = _this$config.visConfig;

      if (!(0, _utils.isPlainObject)(newConfig) || typeof prop !== 'string') {
        return this;
      }

      var colorUIProp = Object.entries(newConfig).reduce(function (accu, _ref4) {
        var _ref5 = (0, _slicedToArray2["default"])(_ref4, 2),
            key = _ref5[0],
            value = _ref5[1];

        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, (0, _utils.isPlainObject)(accu[key]) && (0, _utils.isPlainObject)(value) ? _objectSpread(_objectSpread({}, accu[key]), value) : value));
      }, previous[prop] || _constants.DEFAULT_COLOR_UI);

      var colorUI = _objectSpread(_objectSpread({}, previous), {}, (0, _defineProperty2["default"])({}, prop, colorUIProp));

      this.updateLayerConfig({
        colorUI: colorUI
      }); // if colorUI[prop] is colorRange

      var isColorRange = visConfig[prop] && visConfig[prop].colors;

      if (isColorRange) {
        this.updateColorUIByColorRange(newConfig, prop);
        this.updateColorRangeByColorUI(newConfig, previous, prop);
        this.updateCustomPalette(newConfig, previous, prop);
      }

      return this;
    }
  }, {
    key: "updateCustomPalette",
    value: function updateCustomPalette(newConfig, previous, prop) {
      if (!newConfig.colorRangeConfig || !newConfig.colorRangeConfig.custom) {
        return;
      }

      var _this$config2 = this.config,
          colorUI = _this$config2.colorUI,
          visConfig = _this$config2.visConfig;
      if (!visConfig[prop]) return;
      var colors = visConfig[prop].colors;

      var customPalette = _objectSpread(_objectSpread({}, colorUI[prop].customPalette), {}, {
        name: 'Custom Palette',
        colors: (0, _toConsumableArray2["default"])(colors)
      });

      this.updateLayerConfig({
        colorUI: _objectSpread(_objectSpread({}, colorUI), {}, (0, _defineProperty2["default"])({}, prop, _objectSpread(_objectSpread({}, colorUI[prop]), {}, {
          customPalette: customPalette
        })))
      });
    }
    /**
     * if open dropdown and prop is color range
     * Automatically set colorRangeConfig's step and reversed
     * @param {*} newConfig
     * @param {*} prop
     */

  }, {
    key: "updateColorUIByColorRange",
    value: function updateColorUIByColorRange(newConfig, prop) {
      if (typeof newConfig.showDropdown !== 'number') return;
      var _this$config3 = this.config,
          colorUI = _this$config3.colorUI,
          visConfig = _this$config3.visConfig;
      this.updateLayerConfig({
        colorUI: _objectSpread(_objectSpread({}, colorUI), {}, (0, _defineProperty2["default"])({}, prop, _objectSpread(_objectSpread({}, colorUI[prop]), {}, {
          colorRangeConfig: _objectSpread(_objectSpread({}, colorUI[prop].colorRangeConfig), {}, {
            steps: visConfig[prop].colors.length,
            reversed: Boolean(visConfig[prop].reversed)
          })
        })))
      });
    }
  }, {
    key: "updateColorRangeByColorUI",
    value: function updateColorRangeByColorUI(newConfig, previous, prop) {
      // only update colorRange if changes in UI is made to 'reversed', 'steps' or steps
      var shouldUpdate = newConfig.colorRangeConfig && ['reversed', 'steps'].some(function (key) {
        return newConfig.colorRangeConfig.hasOwnProperty(key) && newConfig.colorRangeConfig[key] !== (previous[prop] || _constants.DEFAULT_COLOR_UI).colorRangeConfig[key];
      });
      if (!shouldUpdate) return;
      var _this$config4 = this.config,
          colorUI = _this$config4.colorUI,
          visConfig = _this$config4.visConfig;
      var _colorUI$prop$colorRa = colorUI[prop].colorRangeConfig,
          steps = _colorUI$prop$colorRa.steps,
          reversed = _colorUI$prop$colorRa.reversed;
      var colorRange = visConfig[prop]; // find based on step or reversed

      var update;

      if (newConfig.colorRangeConfig.hasOwnProperty('steps')) {
        var group = (0, _utils.getColorGroupByName)(colorRange);

        if (group) {
          var sameGroup = _constants.COLOR_RANGES.filter(function (cr) {
            return (0, _utils.getColorGroupByName)(cr) === group;
          });

          update = sameGroup.find(function (cr) {
            return cr.colors.length === steps;
          });

          if (update && colorRange.reversed) {
            update = (0, _utils.reverseColorRange)(true, update);
          }
        }
      }

      if (newConfig.colorRangeConfig.hasOwnProperty('reversed')) {
        update = (0, _utils.reverseColorRange)(reversed, update || colorRange);
      }

      if (update) {
        this.updateLayerVisConfig((0, _defineProperty2["default"])({}, prop, update));
      }
    }
    /**
     * Check whether layer has all columns
     * @returns yes or no
     */

  }, {
    key: "hasAllColumns",
    value: function hasAllColumns() {
      var columns = this.config.columns;
      return columns && Object.values(columns).every(function (column) {
        return Boolean(column && (column.optional || column.value && column.fieldIdx > -1));
      });
    }
    /**
     * Check whether layer has data
     *
     * @param {Array | Object} layerData
     * @returns {boolean} yes or no
     */

  }, {
    key: "hasLayerData",
    value: function hasLayerData(layerData) {
      if (!layerData) {
        return false;
      }

      return Boolean(layerData.data && layerData.data.length);
    }
  }, {
    key: "isValidToSave",
    value: function isValidToSave() {
      return Boolean(this.type && this.hasAllColumns());
    }
  }, {
    key: "shouldRenderLayer",
    value: function shouldRenderLayer(data) {
      return Boolean(this.type) && this.hasAllColumns() && this.hasLayerData(data) && typeof this.renderLayer === 'function';
    }
  }, {
    key: "getColorScale",
    value: function getColorScale(colorScale, colorDomain, colorRange) {
      if (Array.isArray(colorRange.colorMap)) {
        var cMap = new Map();
        colorRange.colorMap.forEach(function (_ref6) {
          var _ref7 = (0, _slicedToArray2["default"])(_ref6, 2),
              k = _ref7[0],
              v = _ref7[1];

          cMap.set(k, typeof v === 'string' ? (0, _utils.hexToRgb)(v) : v);
        });

        var scale = _constants.SCALE_FUNC[_constants.SCALE_TYPES.ordinal]().domain(cMap.keys()).range(cMap.values()).unknown(cMap.get(_constants.UNKNOWN_COLOR_KEY) || _constants.NO_VALUE_COLOR);

        return scale;
      }

      return this.getVisChannelScale(colorScale, colorDomain, colorRange.colors.map(_utils.hexToRgb));
    }
    /**
     * Mapping from visual channels to deck.gl accesors
     * @param {Object} param Parameters
     * @param {Function} param.dataAccessor Access kepler.gl layer data from deck.gl layer
     * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} param.dataContainer DataContainer to use use with dataAccessor
     * @return {Object} attributeAccessors - deck.gl layer attribute accessors
     */

  }, {
    key: "getAttributeAccessors",
    value: function getAttributeAccessors(_ref8) {
      var _this4 = this;

      var _ref8$dataAccessor = _ref8.dataAccessor,
          dataAccessor = _ref8$dataAccessor === void 0 ? defaultDataAccessor : _ref8$dataAccessor,
          dataContainer = _ref8.dataContainer;
      var attributeAccessors = {};
      Object.keys(this.visualChannels).forEach(function (channel) {
        var _this4$visualChannels = _this4.visualChannels[channel],
            field = _this4$visualChannels.field,
            fixed = _this4$visualChannels.fixed,
            scale = _this4$visualChannels.scale,
            domain = _this4$visualChannels.domain,
            range = _this4$visualChannels.range,
            accessor = _this4$visualChannels.accessor,
            defaultValue = _this4$visualChannels.defaultValue,
            getAttributeValue = _this4$visualChannels.getAttributeValue,
            nullValue = _this4$visualChannels.nullValue,
            channelScaleType = _this4$visualChannels.channelScaleType;

        if (accessor) {
          var shouldGetScale = _this4.config[field];

          if (shouldGetScale) {
            var isFixed = fixed && _this4.config.visConfig[fixed];
            var scaleFunction = channelScaleType === _constants.CHANNEL_SCALES.color ? _this4.getColorScale(_this4.config[scale], _this4.config[domain], _this4.config.visConfig[range]) : _this4.getVisChannelScale(_this4.config[scale], _this4.config[domain], _this4.config.visConfig[range], isFixed);

            attributeAccessors[accessor] = function (d) {
              return _this4.getEncodedChannelValue(scaleFunction, dataAccessor(dataContainer)(d), _this4.config[field], nullValue);
            };
          } else if (typeof getAttributeValue === 'function') {
            attributeAccessors[accessor] = getAttributeValue(_this4.config);
          } else {
            attributeAccessors[accessor] = typeof defaultValue === 'function' ? defaultValue(_this4.config) : defaultValue;
          }

          if (!attributeAccessors[accessor]) {
            _window.console.warn("Failed to provide accessor function for ".concat(accessor || channel));
          }
        }
      });
      return attributeAccessors;
    }
  }, {
    key: "getVisChannelScale",
    value: function getVisChannelScale(scale, domain, range, fixed) {
      return _constants.SCALE_FUNC[fixed ? 'linear' : scale]().domain(domain).range(fixed ? domain : range);
    }
    /**
     * Get longitude and latitude bounds of the data.
     * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} dataContainer DataContainer to calculate bounds for.
     * @param {(d: {index: number}, dc: import('utils/table-utils/data-container-interface').DataContainerInterface) => number[]} getPosition Access kepler.gl layer data from deck.gl layer
     * @return {number[]|null} bounds of the data.
     */

  }, {
    key: "getPointsBounds",
    value: function getPointsBounds(dataContainer, getPosition) {
      // no need to loop through the entire dataset
      // get a sample of data to calculate bounds
      var sampleData = dataContainer.numRows() > MAX_SAMPLE_SIZE ? (0, _utils.getSampleContainerData)(dataContainer, MAX_SAMPLE_SIZE) : dataContainer;
      var points = getPosition ? sampleData.mapIndex(getPosition) : [];
      var latBounds = (0, _utils.getLatLngBounds)(points, 1, [-90, 90]);
      var lngBounds = (0, _utils.getLatLngBounds)(points, 0, [-180, 180]);

      if (!latBounds || !lngBounds) {
        return null;
      }

      return [lngBounds[0], latBounds[0], lngBounds[1], latBounds[1]];
    }
  }, {
    key: "getChangedTriggers",
    value: function getChangedTriggers(dataUpdateTriggers) {
      var triggerChanged = (0, _layerUpdate.diffUpdateTriggers)(dataUpdateTriggers, this._oldDataUpdateTriggers);
      this._oldDataUpdateTriggers = dataUpdateTriggers;
      return triggerChanged;
    }
  }, {
    key: "getEncodedChannelValue",
    value: function getEncodedChannelValue(scale, data, field) {
      var nullValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _constants.NO_VALUE_COLOR;
      var getValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultGetFieldValue;
      // @ts-expect-error TODO: VisualChannelField better typing
      var type = field.type;
      var value = getValue(field, data);

      if (!(0, _utils.notNullorUndefined)(value)) {
        return nullValue;
      }

      var attributeValue;

      if (type === _constants.ALL_FIELD_TYPES.timestamp) {
        // shouldn't need to convert here
        // scale Function should take care of it
        attributeValue = scale(new Date(value));
      } else {
        attributeValue = scale(value);
      }

      if (!(0, _utils.notNullorUndefined)(attributeValue)) {
        attributeValue = nullValue;
      }

      return attributeValue;
    }
  }, {
    key: "updateMeta",
    value: function updateMeta(meta) {
      this.meta = _objectSpread(_objectSpread({}, this.meta), meta);
    }
  }, {
    key: "getDataUpdateTriggers",
    value: function getDataUpdateTriggers(_ref9) {
      var filteredIndex = _ref9.filteredIndex,
          id = _ref9.id,
          dataContainer = _ref9.dataContainer;
      var columns = this.config.columns;
      return _objectSpread({
        getData: {
          datasetId: id,
          dataContainer: dataContainer,
          columns: columns,
          filteredIndex: filteredIndex
        },
        getMeta: {
          datasetId: id,
          dataContainer: dataContainer,
          columns: columns
        }
      }, (this.config.textLabel || []).reduce(function (accu, tl, i) {
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, "getLabelCharacterSet-".concat(i), tl.field ? tl.field.name : null));
      }, {}));
    }
  }, {
    key: "updateData",
    value: function updateData(datasets, oldLayerData) {
      if (!this.config.dataId) {
        return {};
      }

      var layerDataset = datasets[this.config.dataId];
      var dataContainer = layerDataset.dataContainer;
      var getPosition = this.getPositionAccessor(dataContainer);
      var dataUpdateTriggers = this.getDataUpdateTriggers(layerDataset);
      var triggerChanged = this.getChangedTriggers(dataUpdateTriggers);

      if (triggerChanged && (triggerChanged.getMeta || triggerChanged.getData)) {
        this.updateLayerMeta(dataContainer, getPosition);
      }

      var data = [];

      if (!(triggerChanged && triggerChanged.getData) && oldLayerData && oldLayerData.data) {
        // same data
        data = oldLayerData.data;
      } else {
        data = this.calculateDataAttribute(layerDataset, getPosition);
      }

      return {
        data: data,
        triggerChanged: triggerChanged
      };
    }
    /**
     * helper function to update one layer domain when state.data changed
     * if state.data change is due ot update filter, newFiler will be passed
     * called by updateAllLayerDomainData
     * @param datasets
     * @param newFilter
     * @returns layer
     */

  }, {
    key: "updateLayerDomain",
    value: function updateLayerDomain(datasets, newFilter) {
      var _this5 = this;

      var table = this.getDataset(datasets);

      if (!table) {
        return this;
      }

      Object.values(this.visualChannels).forEach(function (channel) {
        var scale = channel.scale;
        var scaleType = _this5.config[scale]; // ordinal domain is based on dataContainer, if only filter changed
        // no need to update ordinal domain

        if (!newFilter || scaleType !== _constants.SCALE_TYPES.ordinal) {
          var domain = channel.domain;

          var updatedDomain = _this5.calculateLayerDomain(table, channel);

          _this5.updateLayerConfig((0, _defineProperty2["default"])({}, domain, updatedDomain));
        }
      });
      return this;
    }
  }, {
    key: "getDataset",
    value: function getDataset(datasets) {
      return this.config.dataId ? datasets[this.config.dataId] : null;
    }
    /**
     * Validate visual channel field and scales based on supported field & scale type
     * @param channel
     */

  }, {
    key: "validateVisualChannel",
    value: function validateVisualChannel(channel) {
      this.validateFieldType(channel);
      this.validateScale(channel);
    }
    /**
     * Validate field type based on channelScaleType
     */

  }, {
    key: "validateFieldType",
    value: function validateFieldType(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
          channelScaleType = visualChannel.channelScaleType,
          supportedFieldTypes = visualChannel.supportedFieldTypes;

      if (this.config[field]) {
        // if field is selected, check if field type is supported
        var channelSupportedFieldTypes = supportedFieldTypes || _constants.CHANNEL_SCALE_SUPPORTED_FIELDS[channelScaleType];

        if (!channelSupportedFieldTypes.includes(this.config[field].type)) {
          // field type is not supported, set it back to null
          // set scale back to default
          this.updateLayerConfig((0, _defineProperty2["default"])({}, field, null));
        }
      }
    }
    /**
     * Validate scale type based on aggregation
     */

  }, {
    key: "validateScale",
    value: function validateScale(channel) {
      var visualChannel = this.visualChannels[channel];
      var scale = visualChannel.scale;

      if (!scale) {
        // visualChannel doesn't have scale
        return;
      }

      var scaleOptions = this.getScaleOptions(channel); // check if current selected scale is
      // supported, if not, change to default

      if (!scaleOptions.includes(this.config[scale])) {
        this.updateLayerConfig((0, _defineProperty2["default"])({}, scale, scaleOptions[0]));
      }
    }
    /**
     * Get scale options based on current field
     * @param {string} channel
     * @returns {string[]}
     */

  }, {
    key: "getScaleOptions",
    value: function getScaleOptions(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
          scale = visualChannel.scale,
          channelScaleType = visualChannel.channelScaleType;
      return this.config[field] ? _constants.FIELD_OPTS[this.config[field].type].scale[channelScaleType] : [this.getDefaultLayerConfig({
        dataId: ''
      })[scale]];
    }
  }, {
    key: "updateLayerVisualChannel",
    value: function updateLayerVisualChannel(dataset, channel) {
      var visualChannel = this.visualChannels[channel];
      this.validateVisualChannel(channel); // calculate layer channel domain

      var updatedDomain = this.calculateLayerDomain(dataset, visualChannel);
      this.updateLayerConfig((0, _defineProperty2["default"])({}, visualChannel.domain, updatedDomain));
    }
  }, {
    key: "getVisualChannelUpdateTriggers",
    value: function getVisualChannelUpdateTriggers() {
      var _this6 = this;

      var updateTriggers = {};
      Object.values(this.visualChannels).forEach(function (visualChannel) {
        // field range scale domain
        var accessor = visualChannel.accessor,
            field = visualChannel.field,
            scale = visualChannel.scale,
            domain = visualChannel.domain,
            range = visualChannel.range,
            defaultValue = visualChannel.defaultValue,
            fixed = visualChannel.fixed;

        if (accessor) {
          var _objectSpread11;

          updateTriggers[accessor] = _objectSpread((_objectSpread11 = {}, (0, _defineProperty2["default"])(_objectSpread11, field, _this6.config[field]), (0, _defineProperty2["default"])(_objectSpread11, scale, _this6.config[scale]), (0, _defineProperty2["default"])(_objectSpread11, domain, _this6.config[domain]), (0, _defineProperty2["default"])(_objectSpread11, range, _this6.config.visConfig[range]), (0, _defineProperty2["default"])(_objectSpread11, "defaultValue", typeof defaultValue === 'function' ? defaultValue(_this6.config) : defaultValue), _objectSpread11), fixed ? (0, _defineProperty2["default"])({}, fixed, _this6.config.visConfig[fixed]) : {});
        }
      });
      return updateTriggers;
    }
  }, {
    key: "calculateLayerDomain",
    value: function calculateLayerDomain(dataset, visualChannel) {
      var scale = visualChannel.scale;
      var scaleType = this.config[scale];
      var field = this.config[visualChannel.field];

      if (!field) {
        // if colorField or sizeField were set back to null
        return defaultDomain;
      }

      return dataset.getColumnLayerDomain(field, scaleType) || defaultDomain;
    }
  }, {
    key: "hasHoveredObject",
    value: function hasHoveredObject(objectInfo) {
      return this.isLayerHovered(objectInfo) && objectInfo.object ? objectInfo.object : null;
    }
  }, {
    key: "isLayerHovered",
    value: function isLayerHovered(objectInfo) {
      var _objectInfo$layer, _objectInfo$layer$pro;

      return (objectInfo === null || objectInfo === void 0 ? void 0 : objectInfo.picked) && (objectInfo === null || objectInfo === void 0 ? void 0 : (_objectInfo$layer = objectInfo.layer) === null || _objectInfo$layer === void 0 ? void 0 : (_objectInfo$layer$pro = _objectInfo$layer.props) === null || _objectInfo$layer$pro === void 0 ? void 0 : _objectInfo$layer$pro.id) === this.id;
    }
  }, {
    key: "getRadiusScaleByZoom",
    value: function getRadiusScaleByZoom(mapState, fixedRadius) {
      var radiusChannel = Object.values(this.visualChannels).find(function (vc) {
        return vc.property === 'radius';
      });

      if (!radiusChannel) {
        return 1;
      }

      var field = radiusChannel.field;
      var fixed = fixedRadius === undefined ? this.config.visConfig.fixedRadius : fixedRadius;
      var radius = this.config.visConfig.radius;
      return fixed ? 1 : (this.config[field] ? 1 : radius) * this.getZoomFactor(mapState);
    }
  }, {
    key: "shouldCalculateLayerData",
    value: function shouldCalculateLayerData(props) {
      var _this7 = this;

      return props.some(function (p) {
        return !_this7.noneLayerDataAffectingProps.includes(p);
      });
    }
  }, {
    key: "getBrushingExtensionProps",
    value: function getBrushingExtensionProps(interactionConfig, brushingTarget) {
      var brush = interactionConfig.brush;
      return {
        // brushing
        autoHighlight: !brush.enabled,
        brushingRadius: brush.config.size * 1000,
        brushingTarget: brushingTarget || 'source',
        brushingEnabled: brush.enabled
      };
    }
  }, {
    key: "getDefaultDeckLayerProps",
    value: function getDefaultDeckLayerProps(_ref11) {
      var idx = _ref11.idx,
          gpuFilter = _ref11.gpuFilter,
          mapState = _ref11.mapState,
          visible = _ref11.visible;
      return {
        id: this.id,
        idx: idx,
        coordinateSystem: _core.COORDINATE_SYSTEM.LNGLAT,
        pickable: true,
        wrapLongitude: true,
        parameters: {
          depthTest: Boolean(mapState.dragRotate || this.config.visConfig.enable3d)
        },
        hidden: this.config.hidden,
        // visconfig
        opacity: this.config.visConfig.opacity,
        highlightColor: this.config.highlightColor,
        // data filtering
        extensions: [dataFilterExtension],
        filterRange: gpuFilter ? gpuFilter.filterRange : undefined,
        // layer should be visible and if splitMap, shown in to one of panel
        visible: this.config.isVisible && visible
      };
    }
  }, {
    key: "getDefaultHoverLayerProps",
    value: function getDefaultHoverLayerProps() {
      return {
        id: "".concat(this.id, "-hovered"),
        pickable: false,
        wrapLongitude: true,
        coordinateSystem: _core.COORDINATE_SYSTEM.LNGLAT
      };
    }
  }, {
    key: "renderTextLabelLayer",
    value: function renderTextLabelLayer(_ref12, renderOpts) {
      var _this8 = this;

      var getPosition = _ref12.getPosition,
          getPixelOffset = _ref12.getPixelOffset,
          backgroundProps = _ref12.backgroundProps,
          updateTriggers = _ref12.updateTriggers,
          sharedProps = _ref12.sharedProps;
      var data = renderOpts.data,
          mapState = renderOpts.mapState;
      var textLabel = this.config.textLabel;
      return data.textLabels.reduce(function (accu, d, i) {
        if (d.getText) {
          var _textLabel$i$field, _textLabel$i$field2;

          var background = textLabel[i].background || (backgroundProps === null || backgroundProps === void 0 ? void 0 : backgroundProps.background);
          accu.push(new _layers.TextLayer(_objectSpread(_objectSpread({}, sharedProps), {}, {
            id: "".concat(_this8.id, "-label-").concat((_textLabel$i$field = textLabel[i].field) === null || _textLabel$i$field === void 0 ? void 0 : _textLabel$i$field.name),
            data: data.data,
            visible: _this8.config.isVisible,
            getText: d.getText,
            getPosition: getPosition,
            characterSet: d.characterSet,
            getPixelOffset: getPixelOffset(textLabel[i]),
            getSize: _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER,
            sizeScale: textLabel[i].size,
            getTextAnchor: textLabel[i].anchor,
            getAlignmentBaseline: textLabel[i].alignment,
            getColor: textLabel[i].color,
            outlineWidth: textLabel[i].outlineWidth * _constants.TEXT_OUTLINE_MULTIPLIER,
            outlineColor: textLabel[i].outlineColor,
            background: background,
            getBackgroundColor: textLabel[i].backgroundColor,
            fontSettings: {
              sdf: textLabel[i].outlineWidth > 0
            },
            parameters: {
              // text will always show on top of all layers
              depthTest: false
            },
            getFilterValue: data.getFilterValue,
            updateTriggers: _objectSpread(_objectSpread({}, updateTriggers), {}, {
              getText: (_textLabel$i$field2 = textLabel[i].field) === null || _textLabel$i$field2 === void 0 ? void 0 : _textLabel$i$field2.name,
              getPixelOffset: _objectSpread(_objectSpread({}, updateTriggers.getRadius), {}, {
                mapState: mapState,
                anchor: textLabel[i].anchor,
                alignment: textLabel[i].alignment
              }),
              getTextAnchor: textLabel[i].anchor,
              getAlignmentBaseline: textLabel[i].alignment,
              getColor: textLabel[i].color
            }),
            _subLayerProps: _objectSpread({}, background ? {
              background: {
                parameters: {
                  cull: false
                }
              }
            } : null)
          })));
        }

        return accu;
      }, []);
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(keplerTable, getPosition) {
      // implemented in subclasses
      return [];
    }
  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataContainer, getPosition) {// implemented in subclasses
    }
  }, {
    key: "getPositionAccessor",
    value: function getPositionAccessor(dataContainer) {
      // implemented in subclasses
      return function () {
        return null;
      };
    }
  }], [{
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(dataset, foundLayers) {
      return {
        props: [],
        foundLayers: foundLayers
      };
    }
    /**
     * Given a array of preset required column names
     * found field that has the same name to set as layer column
     *
     * @param {object} defaultFields
     * @param {object[]} allFields
     * @returns {object[] | null} all possible required layer column pairs
     */

  }, {
    key: "findDefaultColumnField",
    value: function findDefaultColumnField(defaultFields, allFields) {
      // find all matched fields for each required col
      var requiredColumns = Object.keys(defaultFields).reduce(function (prev, key) {
        var requiredFields = allFields.filter(function (f) {
          return f.name === defaultFields[key] || defaultFields[key].includes(f.name);
        });
        prev[key] = requiredFields.length ? requiredFields.map(function (f) {
          return {
            value: f.name,
            fieldIdx: f.fieldIdx
          };
        }) : null;
        return prev;
      }, {});

      if (!Object.values(requiredColumns).every(Boolean)) {
        // if any field missing, return null
        return null;
      }

      return this.getAllPossibleColumnParis(requiredColumns);
    }
  }, {
    key: "getAllPossibleColumnParis",
    value: function getAllPossibleColumnParis(requiredColumns) {
      // for multiple matched field for one required column, return multiple
      // combinations, e. g. if column a has 2 matched, column b has 3 matched
      // 6 possible column pairs will be returned
      var allKeys = Object.keys(requiredColumns);
      var pointers = allKeys.map(function (k, i) {
        return i === allKeys.length - 1 ? -1 : 0;
      });
      var countPerKey = allKeys.map(function (k) {
        return requiredColumns[k].length;
      }); // TODO: Better typings

      var pairs = [];
      /* eslint-disable no-loop-func */

      while (incrementPointers(pointers, countPerKey, pointers.length - 1)) {
        var newPair = pointers.reduce(function (prev, cuur, i) {
          prev[allKeys[i]] = requiredColumns[allKeys[i]][cuur];
          return prev;
        }, {});
        pairs.push(newPair);
      }
      /* eslint-enable no-loop-func */
      // recursively increment pointers


      function incrementPointers(pts, counts, index) {
        if (index === 0 && pts[0] === counts[0] - 1) {
          // nothing to increment
          return false;
        }

        if (pts[index] + 1 < counts[index]) {
          pts[index] = pts[index] + 1;
          return true;
        }

        pts[index] = 0;
        return incrementPointers(pts, counts, index - 1);
      }

      return pairs;
    }
  }, {
    key: "hexToRgb",
    value: function hexToRgb(c) {
      return (0, _utils.hexToRgb)(c);
    }
  }]);
  return Layer;
}();

var _default = Layer;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9iYXNlLWxheWVyLnRzIl0sIm5hbWVzIjpbImdlbmVyYXRlQ29sb3IiLCJMQVlFUl9JRF9MRU5HVEgiLCJNQVhfU0FNUExFX1NJWkUiLCJkZWZhdWx0RG9tYWluIiwiZGF0YUZpbHRlckV4dGVuc2lvbiIsIkRhdGFGaWx0ZXJFeHRlbnNpb24iLCJmaWx0ZXJTaXplIiwiTUFYX0dQVV9GSUxURVJTIiwiZGVmYXVsdERhdGFBY2Nlc3NvciIsImRjIiwiZCIsImRlZmF1bHRHZXRGaWVsZFZhbHVlIiwiZmllbGQiLCJ2YWx1ZUFjY2Vzc29yIiwiT1ZFUkxBWV9UWVBFX0NPTlNUIiwiZGVja2dsIiwibWFwYm94Z2wiLCJsYXllckNvbG9ycyIsIk9iamVjdCIsInZhbHVlcyIsIkRhdGFWaXpDb2xvcnMiLCJtYXAiLCJoZXhUb1JnYiIsImluZGV4IiwibGVuZ3RoIiwiY29sb3JNYWtlciIsIkxheWVyIiwicHJvcHMiLCJpZCIsIm1ldGEiLCJ2aXNDb25maWdTZXR0aW5ncyIsImNvbmZpZyIsImdldERlZmF1bHRMYXllckNvbmZpZyIsImNvbHVtbnMiLCJnZXRMYXllckNvbHVtbnMiLCJpc1ZhbGlkIiwiZXJyb3JNZXNzYWdlIiwiRGVmYXVsdExheWVySWNvbiIsInR5cGUiLCJjb2xvciIsInByb3BlcnR5Iiwic2NhbGUiLCJkb21haW4iLCJyYW5nZSIsImtleSIsImNoYW5uZWxTY2FsZVR5cGUiLCJDSEFOTkVMX1NDQUxFUyIsIm51bGxWYWx1ZSIsIk5PX1ZBTFVFX0NPTE9SIiwiZGVmYXVsdFZhbHVlIiwic2l6ZSIsImxhdCIsInBhaXIiLCJmaWVsZFBhaXJLZXkiLCJsbmciLCJsYXQwIiwibG5nMCIsImxhdDEiLCJsbmcxIiwiZGF0YUlkIiwibGFiZWwiLCJERUZBVUxUX0xBWUVSX0xBQkVMIiwibmV4dCIsInZhbHVlIiwiaXNWaXNpYmxlIiwiaXNDb25maWdBY3RpdmUiLCJoaWdobGlnaHRDb2xvciIsIkRFRkFVTFRfSElHSExJR0hUX0NPTE9SIiwiaGlkZGVuIiwiY29sb3JGaWVsZCIsImNvbG9yRG9tYWluIiwiY29sb3JTY2FsZSIsIlNDQUxFX1RZUEVTIiwicXVhbnRpbGUiLCJzaXplRG9tYWluIiwic2l6ZVNjYWxlIiwibGluZWFyIiwic2l6ZUZpZWxkIiwidmlzQ29uZmlnIiwidGV4dExhYmVsIiwiREVGQVVMVF9URVhUX0xBQkVMIiwiY29sb3JVSSIsIkRFRkFVTFRfQ09MT1JfVUkiLCJjb2xvclJhbmdlIiwiYW5pbWF0aW9uIiwiZW5hYmxlZCIsImNoYW5uZWwiLCJ2aXN1YWxDaGFubmVscyIsIm1lYXN1cmUiLCJ1bmRlZmluZWQiLCJyYW5nZVNldHRpbmdzIiwiZmllbGRTZXR0aW5ncyIsImRpc3BsYXlOYW1lIiwibmFtZSIsImRlZmF1bHRNZWFzdXJlIiwidXBkYXRlIiwiZmllbGRJZHgiLCJjb2x1bW5QYWlycyIsInBhcnRuZXJLZXkiLCJwYXJ0bmVyRmllbGRQYWlyS2V5Iiwiem9vbSIsInpvb21PZmZzZXQiLCJNYXRoIiwicG93IiwibWF4IiwiZW5hYmxlRWxldmF0aW9uWm9vbUZhY3RvciIsImRhdGFzZXRzIiwib2xkTGF5ZXJEYXRhIiwib2JqZWN0IiwiZGF0YUNvbnRhaW5lciIsImZpZWxkcyIsInJvdyIsImNvbmZpZ1RvQ29weSIsInNoYWxsb3dDb3B5IiwiY29uY2F0IiwidiIsIm5vdFRvQ29weSIsImZvckVhY2giLCJncm91cCIsInB1c2giLCJjdXJyZW50Q29uZmlnIiwiY29waWVkIiwiY29weUxheWVyQ29uZmlnIiwidXBkYXRlTGF5ZXJDb25maWciLCJrZXlzIiwidmFsaWRhdGVWaXN1YWxDaGFubmVsIiwiaW5jbHVkZXMiLCJsYXllclZpc0NvbmZpZ3MiLCJpdGVtIiwiY29uZmlnSXRlbSIsIkxBWUVSX1ZJU19DT05GSUdTIiwiZXZlcnkiLCJwIiwiaGFzT3duUHJvcGVydHkiLCJjb2x1bW5WYWxpZGF0b3JzIiwicmVxdWlyZWQiLCJyZXF1aXJlZExheWVyQ29sdW1ucyIsInJlZHVjZSIsImFjY3UiLCJ2YWxpZGF0b3IiLCJvcHRpb25hbCIsIm9wdGlvbmFsQ29sdW1ucyIsIm5ld0NvbmZpZyIsIm5ld1Zpc0NvbmZpZyIsInByb3AiLCJwcmV2aW91cyIsImNvbG9yVUlQcm9wIiwiZW50cmllcyIsImlzQ29sb3JSYW5nZSIsImNvbG9ycyIsInVwZGF0ZUNvbG9yVUlCeUNvbG9yUmFuZ2UiLCJ1cGRhdGVDb2xvclJhbmdlQnlDb2xvclVJIiwidXBkYXRlQ3VzdG9tUGFsZXR0ZSIsImNvbG9yUmFuZ2VDb25maWciLCJjdXN0b20iLCJjdXN0b21QYWxldHRlIiwic2hvd0Ryb3Bkb3duIiwic3RlcHMiLCJyZXZlcnNlZCIsIkJvb2xlYW4iLCJzaG91bGRVcGRhdGUiLCJzb21lIiwic2FtZUdyb3VwIiwiQ09MT1JfUkFOR0VTIiwiZmlsdGVyIiwiY3IiLCJmaW5kIiwidXBkYXRlTGF5ZXJWaXNDb25maWciLCJjb2x1bW4iLCJsYXllckRhdGEiLCJkYXRhIiwiaGFzQWxsQ29sdW1ucyIsImhhc0xheWVyRGF0YSIsInJlbmRlckxheWVyIiwiQXJyYXkiLCJpc0FycmF5IiwiY29sb3JNYXAiLCJjTWFwIiwiTWFwIiwiayIsInNldCIsIlNDQUxFX0ZVTkMiLCJvcmRpbmFsIiwidW5rbm93biIsImdldCIsIlVOS05PV05fQ09MT1JfS0VZIiwiZ2V0VmlzQ2hhbm5lbFNjYWxlIiwiZGF0YUFjY2Vzc29yIiwiYXR0cmlidXRlQWNjZXNzb3JzIiwiZml4ZWQiLCJhY2Nlc3NvciIsImdldEF0dHJpYnV0ZVZhbHVlIiwic2hvdWxkR2V0U2NhbGUiLCJpc0ZpeGVkIiwic2NhbGVGdW5jdGlvbiIsImdldENvbG9yU2NhbGUiLCJnZXRFbmNvZGVkQ2hhbm5lbFZhbHVlIiwiQ29uc29sZSIsIndhcm4iLCJnZXRQb3NpdGlvbiIsInNhbXBsZURhdGEiLCJudW1Sb3dzIiwicG9pbnRzIiwibWFwSW5kZXgiLCJsYXRCb3VuZHMiLCJsbmdCb3VuZHMiLCJkYXRhVXBkYXRlVHJpZ2dlcnMiLCJ0cmlnZ2VyQ2hhbmdlZCIsIl9vbGREYXRhVXBkYXRlVHJpZ2dlcnMiLCJnZXRWYWx1ZSIsImF0dHJpYnV0ZVZhbHVlIiwiQUxMX0ZJRUxEX1RZUEVTIiwidGltZXN0YW1wIiwiRGF0ZSIsImZpbHRlcmVkSW5kZXgiLCJnZXREYXRhIiwiZGF0YXNldElkIiwiZ2V0TWV0YSIsInRsIiwiaSIsImxheWVyRGF0YXNldCIsImdldFBvc2l0aW9uQWNjZXNzb3IiLCJnZXREYXRhVXBkYXRlVHJpZ2dlcnMiLCJnZXRDaGFuZ2VkVHJpZ2dlcnMiLCJ1cGRhdGVMYXllck1ldGEiLCJjYWxjdWxhdGVEYXRhQXR0cmlidXRlIiwibmV3RmlsdGVyIiwidGFibGUiLCJnZXREYXRhc2V0Iiwic2NhbGVUeXBlIiwidXBkYXRlZERvbWFpbiIsImNhbGN1bGF0ZUxheWVyRG9tYWluIiwidmFsaWRhdGVGaWVsZFR5cGUiLCJ2YWxpZGF0ZVNjYWxlIiwidmlzdWFsQ2hhbm5lbCIsInN1cHBvcnRlZEZpZWxkVHlwZXMiLCJjaGFubmVsU3VwcG9ydGVkRmllbGRUeXBlcyIsIkNIQU5ORUxfU0NBTEVfU1VQUE9SVEVEX0ZJRUxEUyIsInNjYWxlT3B0aW9ucyIsImdldFNjYWxlT3B0aW9ucyIsIkZJRUxEX09QVFMiLCJkYXRhc2V0IiwidXBkYXRlVHJpZ2dlcnMiLCJnZXRDb2x1bW5MYXllckRvbWFpbiIsIm9iamVjdEluZm8iLCJpc0xheWVySG92ZXJlZCIsInBpY2tlZCIsImxheWVyIiwibWFwU3RhdGUiLCJmaXhlZFJhZGl1cyIsInJhZGl1c0NoYW5uZWwiLCJ2YyIsInJhZGl1cyIsImdldFpvb21GYWN0b3IiLCJub25lTGF5ZXJEYXRhQWZmZWN0aW5nUHJvcHMiLCJpbnRlcmFjdGlvbkNvbmZpZyIsImJydXNoaW5nVGFyZ2V0IiwiYnJ1c2giLCJhdXRvSGlnaGxpZ2h0IiwiYnJ1c2hpbmdSYWRpdXMiLCJicnVzaGluZ0VuYWJsZWQiLCJpZHgiLCJncHVGaWx0ZXIiLCJ2aXNpYmxlIiwiY29vcmRpbmF0ZVN5c3RlbSIsIkNPT1JESU5BVEVfU1lTVEVNIiwiTE5HTEFUIiwicGlja2FibGUiLCJ3cmFwTG9uZ2l0dWRlIiwicGFyYW1ldGVycyIsImRlcHRoVGVzdCIsImRyYWdSb3RhdGUiLCJlbmFibGUzZCIsIm9wYWNpdHkiLCJleHRlbnNpb25zIiwiZmlsdGVyUmFuZ2UiLCJyZW5kZXJPcHRzIiwiZ2V0UGl4ZWxPZmZzZXQiLCJiYWNrZ3JvdW5kUHJvcHMiLCJzaGFyZWRQcm9wcyIsInRleHRMYWJlbHMiLCJnZXRUZXh0IiwiYmFja2dyb3VuZCIsIlRleHRMYXllciIsImNoYXJhY3RlclNldCIsImdldFNpemUiLCJQUk9KRUNURURfUElYRUxfU0laRV9NVUxUSVBMSUVSIiwiZ2V0VGV4dEFuY2hvciIsImFuY2hvciIsImdldEFsaWdubWVudEJhc2VsaW5lIiwiYWxpZ25tZW50IiwiZ2V0Q29sb3IiLCJvdXRsaW5lV2lkdGgiLCJURVhUX09VVExJTkVfTVVMVElQTElFUiIsIm91dGxpbmVDb2xvciIsImdldEJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRDb2xvciIsImZvbnRTZXR0aW5ncyIsInNkZiIsImdldEZpbHRlclZhbHVlIiwiZ2V0UmFkaXVzIiwiX3N1YkxheWVyUHJvcHMiLCJjdWxsIiwia2VwbGVyVGFibGUiLCJmb3VuZExheWVycyIsImRlZmF1bHRGaWVsZHMiLCJhbGxGaWVsZHMiLCJyZXF1aXJlZENvbHVtbnMiLCJwcmV2IiwicmVxdWlyZWRGaWVsZHMiLCJmIiwiZ2V0QWxsUG9zc2libGVDb2x1bW5QYXJpcyIsImFsbEtleXMiLCJwb2ludGVycyIsImNvdW50UGVyS2V5IiwicGFpcnMiLCJpbmNyZW1lbnRQb2ludGVycyIsIm5ld1BhaXIiLCJjdXVyIiwicHRzIiwiY291bnRzIiwiYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFzQkE7Ozs7Ozt3REFvS1VBLGE7O0FBbEJWO0FBQ0E7QUFDQTtBQUNPLElBQU1DLGVBQWUsR0FBRyxDQUF4Qjs7QUFFUCxJQUFNQyxlQUFlLEdBQUcsSUFBeEI7QUFDQSxJQUFNQyxhQUErQixHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBeEM7QUFDQSxJQUFNQyxtQkFBbUIsR0FBRyxJQUFJQywrQkFBSixDQUF3QjtBQUFDQyxFQUFBQSxVQUFVLEVBQUVDO0FBQWIsQ0FBeEIsQ0FBNUI7O0FBRUEsSUFBTUMsbUJBQW1CLEdBQUcsU0FBdEJBLG1CQUFzQixDQUFBQyxFQUFFO0FBQUEsU0FBSSxVQUFBQyxDQUFDO0FBQUEsV0FBSUEsQ0FBSjtBQUFBLEdBQUw7QUFBQSxDQUE5Qjs7QUFDQSxJQUFNQyxvQkFBb0IsR0FBRyxTQUF2QkEsb0JBQXVCLENBQUNDLEtBQUQsRUFBUUYsQ0FBUjtBQUFBLFNBQWNFLEtBQUssQ0FBQ0MsYUFBTixDQUFvQkgsQ0FBcEIsQ0FBZDtBQUFBLENBQTdCOztBQUVPLElBQU1JLGtCQUFrQixHQUFHLDJCQUFVO0FBQzFDQyxFQUFBQSxNQUFNLEVBQUUsSUFEa0M7QUFFMUNDLEVBQUFBLFFBQVEsRUFBRTtBQUZnQyxDQUFWLENBQTNCOztBQUtBLElBQU1DLFdBQVcsR0FBR0MsTUFBTSxDQUFDQyxNQUFQLENBQWNDLHdCQUFkLEVBQTZCQyxHQUE3QixDQUFpQ0MsZUFBakMsQ0FBcEI7OztBQUNQLFNBQVV0QixhQUFWO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNNdUIsVUFBQUEsS0FETixHQUNjLENBRGQ7O0FBQUE7QUFBQSxnQkFFU0EsS0FBSyxHQUFHTixXQUFXLENBQUNPLE1BQVosR0FBcUIsQ0FGdEM7QUFBQTtBQUFBO0FBQUE7O0FBR0ksY0FBSUQsS0FBSyxLQUFLTixXQUFXLENBQUNPLE1BQTFCLEVBQWtDO0FBQ2hDRCxZQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNEOztBQUxMO0FBTUksaUJBQU1OLFdBQVcsQ0FBQ00sS0FBSyxFQUFOLENBQWpCOztBQU5KO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFVTyxJQUFNRSxVQUFVLEdBQUd6QixhQUFhLEVBQWhDOzs7SUFNRDBCLEs7QUFPSjtBQU1BLGlCQUFZQyxLQUFaLEVBQThDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUM1QyxTQUFLQyxFQUFMLEdBQVVELEtBQUssQ0FBQ0MsRUFBTixJQUFZLDJCQUFlM0IsZUFBZixDQUF0QixDQUQ0QyxDQUc1Qzs7QUFDQSxTQUFLNEIsSUFBTCxHQUFZLEVBQVosQ0FKNEMsQ0FNNUM7O0FBQ0EsU0FBS0MsaUJBQUwsR0FBeUIsRUFBekI7QUFFQSxTQUFLQyxNQUFMLEdBQWMsS0FBS0MscUJBQUw7QUFDWkMsTUFBQUEsT0FBTyxFQUFFLEtBQUtDLGVBQUw7QUFERyxPQUVUUCxLQUZTLEVBQWQsQ0FUNEMsQ0FjNUM7O0FBQ0EsU0FBS1EsT0FBTCxHQUFlLElBQWY7QUFDQSxTQUFLQyxZQUFMLEdBQW9CLElBQXBCO0FBQ0Q7Ozs7U0FFRCxlQUFtQztBQUNqQyxhQUFPQyw0QkFBUDtBQUNEOzs7U0FFRCxlQUFtRDtBQUNqRCxhQUFPdkIsa0JBQWtCLENBQUNDLE1BQTFCO0FBQ0Q7OztTQUVELGVBQTBCO0FBQ3hCLGFBQU8sSUFBUDtBQUNEOzs7U0FFRCxlQUFXO0FBQ1QsYUFBTyxLQUFLdUIsSUFBWjtBQUNEOzs7U0FFRCxlQUFtQjtBQUNqQixhQUFPLEtBQVA7QUFDRDs7O1NBRUQsZUFBcUM7QUFDbkMsYUFBTyxFQUFQO0FBQ0Q7OztTQUVELGVBQWdDO0FBQzlCLGFBQU8sRUFBUDtBQUNEOzs7U0FFRCxlQUFrQztBQUNoQyxhQUFPLENBQUMsT0FBRCxFQUFVLFNBQVYsRUFBcUIsV0FBckIsRUFBa0MsV0FBbEMsRUFBK0MsUUFBL0MsQ0FBUDtBQUNEOzs7U0FFRCxlQUFxQztBQUNuQyxhQUFPO0FBQ0xDLFFBQUFBLEtBQUssRUFBRTtBQUNMQyxVQUFBQSxRQUFRLEVBQUUsT0FETDtBQUVMNUIsVUFBQUEsS0FBSyxFQUFFLFlBRkY7QUFHTDZCLFVBQUFBLEtBQUssRUFBRSxZQUhGO0FBSUxDLFVBQUFBLE1BQU0sRUFBRSxhQUpIO0FBS0xDLFVBQUFBLEtBQUssRUFBRSxZQUxGO0FBTUxDLFVBQUFBLEdBQUcsRUFBRSxPQU5BO0FBT0xDLFVBQUFBLGdCQUFnQixFQUFFQywwQkFBZVAsS0FQNUI7QUFRTFEsVUFBQUEsU0FBUyxFQUFFQyx5QkFSTjtBQVNMQyxVQUFBQSxZQUFZLEVBQUUsc0JBQUFsQixNQUFNO0FBQUEsbUJBQUlBLE1BQU0sQ0FBQ1EsS0FBWDtBQUFBO0FBVGYsU0FERjtBQVlMVyxRQUFBQSxJQUFJLEVBQUU7QUFDSlYsVUFBQUEsUUFBUSxFQUFFLE1BRE47QUFFSjVCLFVBQUFBLEtBQUssRUFBRSxXQUZIO0FBR0o2QixVQUFBQSxLQUFLLEVBQUUsV0FISDtBQUlKQyxVQUFBQSxNQUFNLEVBQUUsWUFKSjtBQUtKQyxVQUFBQSxLQUFLLEVBQUUsV0FMSDtBQU1KQyxVQUFBQSxHQUFHLEVBQUUsTUFORDtBQU9KQyxVQUFBQSxnQkFBZ0IsRUFBRUMsMEJBQWVJLElBUDdCO0FBUUpILFVBQUFBLFNBQVMsRUFBRSxDQVJQO0FBU0pFLFVBQUFBLFlBQVksRUFBRTtBQVRWO0FBWkQsT0FBUDtBQXdCRDs7O1NBRUQsZUFBeUQ7QUFDdkQsYUFBTyxFQUFQO0FBQ0Q7QUFDRDtBQUNGO0FBQ0E7QUFDQTs7OztTQUNFLGVBQXNDO0FBQ3BDLGFBQU8sSUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7O1NBQ0UsZUFBMkM7QUFDekMsYUFBTztBQUNMRSxRQUFBQSxHQUFHLEVBQUU7QUFBQ0MsVUFBQUEsSUFBSSxFQUFFLEtBQVA7QUFBY0MsVUFBQUEsWUFBWSxFQUFFO0FBQTVCLFNBREE7QUFFTEMsUUFBQUEsR0FBRyxFQUFFO0FBQUNGLFVBQUFBLElBQUksRUFBRSxLQUFQO0FBQWNDLFVBQUFBLFlBQVksRUFBRTtBQUE1QjtBQUZBLE9BQVA7QUFJRDtBQUVEO0FBQ0Y7QUFDQTs7OztTQUNFLGVBQTBDO0FBQ3hDLGFBQU87QUFDTEUsUUFBQUEsSUFBSSxFQUFFO0FBQUNILFVBQUFBLElBQUksRUFBRSxNQUFQO0FBQWVDLFVBQUFBLFlBQVksRUFBRTtBQUE3QixTQUREO0FBRUxHLFFBQUFBLElBQUksRUFBRTtBQUFDSixVQUFBQSxJQUFJLEVBQUUsTUFBUDtBQUFlQyxVQUFBQSxZQUFZLEVBQUU7QUFBN0IsU0FGRDtBQUdMSSxRQUFBQSxJQUFJLEVBQUU7QUFBQ0wsVUFBQUEsSUFBSSxFQUFFLE1BQVA7QUFBZUMsVUFBQUEsWUFBWSxFQUFFO0FBQTdCLFNBSEQ7QUFJTEssUUFBQUEsSUFBSSxFQUFFO0FBQUNOLFVBQUFBLElBQUksRUFBRSxNQUFQO0FBQWVDLFVBQUFBLFlBQVksRUFBRTtBQUE3QjtBQUpELE9BQVA7QUFNRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztTQUNFLGVBQTBCO0FBQ3hCLGFBQU8sSUFBUDtBQUNEOzs7U0FFRCxlQUE2QztBQUMzQyxhQUFPLElBQVA7QUFDRDtBQUNEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FvRkUsK0JBQ0UxQixLQURGLEVBRWlFO0FBQy9ELGFBQU87QUFDTGdDLFFBQUFBLE1BQU0sRUFBRWhDLEtBQUssQ0FBQ2dDLE1BRFQ7QUFFTEMsUUFBQUEsS0FBSyxFQUFFakMsS0FBSyxDQUFDaUMsS0FBTixJQUFlQyw4QkFGakI7QUFHTHRCLFFBQUFBLEtBQUssRUFBRVosS0FBSyxDQUFDWSxLQUFOLElBQWVkLFVBQVUsQ0FBQ3FDLElBQVgsR0FBa0JDLEtBSG5DO0FBSUw5QixRQUFBQSxPQUFPLEVBQUVOLEtBQUssQ0FBQ00sT0FBTixJQUFpQixFQUpyQjtBQUtMK0IsUUFBQUEsU0FBUyxFQUFFckMsS0FBSyxDQUFDcUMsU0FBTixJQUFtQixLQUx6QjtBQU1MQyxRQUFBQSxjQUFjLEVBQUV0QyxLQUFLLENBQUNzQyxjQUFOLElBQXdCLEtBTm5DO0FBT0xDLFFBQUFBLGNBQWMsRUFBRXZDLEtBQUssQ0FBQ3VDLGNBQU4sSUFBd0JDLGtDQVBuQztBQVFMQyxRQUFBQSxNQUFNLEVBQUV6QyxLQUFLLENBQUN5QyxNQUFOLElBQWdCLEtBUm5CO0FBVUw7QUFDQTtBQUNBQyxRQUFBQSxVQUFVLEVBQUUsSUFaUDtBQWFMQyxRQUFBQSxXQUFXLEVBQUUsQ0FBQyxDQUFELEVBQUksQ0FBSixDQWJSO0FBY0xDLFFBQUFBLFVBQVUsRUFBRUMsdUJBQVlDLFFBZG5CO0FBZ0JMO0FBQ0FDLFFBQUFBLFVBQVUsRUFBRSxDQUFDLENBQUQsRUFBSSxDQUFKLENBakJQO0FBa0JMQyxRQUFBQSxTQUFTLEVBQUVILHVCQUFZSSxNQWxCbEI7QUFtQkxDLFFBQUFBLFNBQVMsRUFBRSxJQW5CTjtBQXFCTEMsUUFBQUEsU0FBUyxFQUFFLEVBckJOO0FBdUJMQyxRQUFBQSxTQUFTLEVBQUUsQ0FBQ0MsNkJBQUQsQ0F2Qk47QUF5QkxDLFFBQUFBLE9BQU8sRUFBRTtBQUNQMUMsVUFBQUEsS0FBSyxFQUFFMkMsMkJBREE7QUFFUEMsVUFBQUEsVUFBVSxFQUFFRDtBQUZMLFNBekJKO0FBNkJMRSxRQUFBQSxTQUFTLEVBQUU7QUFBQ0MsVUFBQUEsT0FBTyxFQUFFO0FBQVY7QUE3Qk4sT0FBUDtBQStCRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FDRSxxQ0FBNEJ6QyxHQUE1QixFQUFtRTtBQUNqRTtBQUNBLFVBQU0wQyxPQUFPLEdBQUcsS0FBS0MsY0FBTCxDQUFvQjNDLEdBQXBCLENBQWhCO0FBQ0EsVUFBSSxDQUFDMEMsT0FBTCxFQUFjLE9BQU87QUFBQzFCLFFBQUFBLEtBQUssRUFBRSxFQUFSO0FBQVk0QixRQUFBQSxPQUFPLEVBQUVDO0FBQXJCLE9BQVA7QUFDZCxVQUFNQyxhQUFhLEdBQUcsS0FBSzVELGlCQUFMLENBQXVCd0QsT0FBTyxDQUFDM0MsS0FBL0IsQ0FBdEI7QUFDQSxVQUFNZ0QsYUFBYSxHQUFHLEtBQUs1RCxNQUFMLENBQVl1RCxPQUFPLENBQUMxRSxLQUFwQixDQUF0QjtBQUNBLFVBQU1nRCxLQUFLLEdBQUc4QixhQUFILGFBQUdBLGFBQUgsdUJBQUdBLGFBQWEsQ0FBRTlCLEtBQTdCO0FBQ0EsYUFBTztBQUNMQSxRQUFBQSxLQUFLLEVBQUUsT0FBT0EsS0FBUCxLQUFpQixVQUFqQixHQUE4QkEsS0FBSyxDQUFDLEtBQUs3QixNQUFOLENBQW5DLEdBQW1ENkIsS0FBSyxJQUFJLEVBRDlEO0FBRUw0QixRQUFBQSxPQUFPLEVBQUVHLGFBQWEsR0FDbEJBLGFBQWEsQ0FBQ0MsV0FBZCxJQUE2QkQsYUFBYSxDQUFDRSxJQUR6QixHQUVsQlAsT0FBTyxDQUFDUTtBQUpQLE9BQVA7QUFNRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztXQUNFLHNCQUFhbEQsR0FBYixFQUEwQmhDLEtBQTFCLEVBQXNEO0FBQ3BEO0FBQ0EsVUFBTW1GLE1BQU0sR0FBR25GLEtBQUssR0FDaEI7QUFDRW1ELFFBQUFBLEtBQUssRUFBRW5ELEtBQUssQ0FBQ2lGLElBRGY7QUFFRUcsUUFBQUEsUUFBUSxFQUFFcEYsS0FBSyxDQUFDb0Y7QUFGbEIsT0FEZ0IsR0FLaEI7QUFBQ2pDLFFBQUFBLEtBQUssRUFBRSxJQUFSO0FBQWNpQyxRQUFBQSxRQUFRLEVBQUUsQ0FBQztBQUF6QixPQUxKO0FBT0EsNkNBQ0ssS0FBS2pFLE1BQUwsQ0FBWUUsT0FEakIsNENBRUdXLEdBRkgsa0NBR08sS0FBS2IsTUFBTCxDQUFZRSxPQUFaLENBQW9CVyxHQUFwQixDQUhQLEdBSU9tRCxNQUpQO0FBT0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FDRSwyQkFBa0JuRCxHQUFsQixFQUErQlEsSUFBL0IsRUFBMkQ7QUFBQTs7QUFDekQsVUFBSSxDQUFDLEtBQUs2QyxXQUFOLElBQXFCLHVCQUFDLEtBQUtBLFdBQU4sOENBQUMsa0JBQW1CckQsR0FBbkIsQ0FBRCxDQUF6QixFQUFtRDtBQUNqRDtBQUNBLGVBQU8sS0FBS2IsTUFBTCxDQUFZRSxPQUFuQjtBQUNEOztBQUp3RCx3REFNaEIsS0FBS2dFLFdBTlcsdURBTWhCLG1CQUFtQnJELEdBQW5CLENBTmdCO0FBQUEsVUFNNUNzRCxVQU40Qyx5QkFNbEQ5QyxJQU5rRDtBQUFBLFVBTWhDQyxZQU5nQyx5QkFNaENBLFlBTmdDOztBQVF6RCxVQUFJLENBQUNELElBQUksQ0FBQ0MsWUFBRCxDQUFULEVBQXlCO0FBQ3ZCO0FBQ0EsZUFBTyxLQUFLdEIsTUFBTCxDQUFZRSxPQUFuQjtBQUNEOztBQVh3RCx3REFhYixLQUFLZ0UsV0FiUSx1REFhYixtQkFBbUJDLFVBQW5CLENBYmE7QUFBQSxVQWFwQ0MsbUJBYm9DLHlCQWFsRDlDLFlBYmtEOztBQWV6RCw2Q0FDSyxLQUFLdEIsTUFBTCxDQUFZRSxPQURqQiw4RUFFR1csR0FGSCxFQUVTUSxJQUFJLENBQUNDLFlBQUQsQ0FGYixvREFHRzZDLFVBSEgsRUFHZ0I5QyxJQUFJLENBQUMrQyxtQkFBRCxDQUhwQjtBQUtEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FDRSw2QkFBc0M7QUFBQSxVQUF2QkMsSUFBdUIsUUFBdkJBLElBQXVCO0FBQUEsaUNBQWpCQyxVQUFpQjtBQUFBLFVBQWpCQSxVQUFpQixnQ0FBSixDQUFJO0FBQ3BDLGFBQU9DLElBQUksQ0FBQ0MsR0FBTCxDQUFTLENBQVQsRUFBWUQsSUFBSSxDQUFDRSxHQUFMLENBQVMsS0FBS0osSUFBTCxHQUFZQyxVQUFyQixFQUFpQyxDQUFqQyxDQUFaLENBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O1dBQ0UsdUNBQTRGO0FBQUEsVUFBcEVELElBQW9FLFNBQXBFQSxJQUFvRTtBQUFBLG1DQUE5REMsVUFBOEQ7QUFBQSxVQUE5REEsVUFBOEQsaUNBQWpELENBQWlEO0FBQzFGLGFBQU8sS0FBS3RFLE1BQUwsQ0FBWStDLFNBQVosQ0FBc0IyQix5QkFBdEIsR0FDSEgsSUFBSSxDQUFDQyxHQUFMLENBQVMsQ0FBVCxFQUFZRCxJQUFJLENBQUNFLEdBQUwsQ0FBUyxJQUFJSixJQUFKLEdBQVdDLFVBQXBCLEVBQWdDLENBQWhDLENBQVosQ0FERyxHQUVILENBRko7QUFHRDs7O1dBRUQseUJBQWdCSyxRQUFoQixFQUFvQ0MsWUFBcEMsRUFBd0Q7QUFDdEQsYUFBTyxFQUFQO0FBQ0Q7OztXQUVELHVCQUFtQztBQUNqQyxhQUFPLEVBQVA7QUFDRDs7O1dBRUQsc0JBQWFDLE1BQWIsRUFBcUJDLGFBQXJCLEVBQTREQyxNQUE1RCxFQUE2RTtBQUMzRSxVQUFJLENBQUNGLE1BQUwsRUFBYTtBQUNYLGVBQU8sSUFBUDtBQUNELE9BSDBFLENBSzNFO0FBQ0E7OztBQUNBLGFBQU9DLGFBQWEsQ0FBQ0UsR0FBZCxDQUFrQkgsTUFBTSxDQUFDckYsS0FBekIsQ0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OztXQUNFLDZCQUFvQnlGLFlBQXBCLEVBQWtDbEYsaUJBQWxDLEVBQXFEO0FBQUE7O0FBQ25EO0FBQ0E7QUFDQSxVQUFNbUYsV0FBVyxHQUFHLENBQUMsWUFBRCxFQUFlLGtCQUFmLEVBQW1DQyxNQUFuQyxDQUNsQmhHLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEtBQUtvRSxjQUFuQixFQUFtQ2xFLEdBQW5DLENBQXVDLFVBQUE4RixDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDdkcsS0FBTjtBQUFBLE9BQXhDLENBRGtCLENBQXBCLENBSG1ELENBT25EOztBQUNBLFVBQU13RyxTQUFTLEdBQUcsQ0FBQyxXQUFELEVBQWNGLE1BQWQsQ0FBcUJoRyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxLQUFLb0UsY0FBbkIsRUFBbUNsRSxHQUFuQyxDQUF1QyxVQUFBOEYsQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQ3pFLE1BQU47QUFBQSxPQUF4QyxDQUFyQixDQUFsQixDQVJtRCxDQVNuRDs7QUFDQXhCLE1BQUFBLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEtBQUtvRSxjQUFuQixFQUFtQzhCLE9BQW5DLENBQTJDLFVBQUFGLENBQUMsRUFBSTtBQUM5QyxZQUNFSCxZQUFZLENBQUNsQyxTQUFiLENBQXVCcUMsQ0FBQyxDQUFDeEUsS0FBekIsS0FDQSxLQUFJLENBQUNiLGlCQUFMLENBQXVCcUYsQ0FBQyxDQUFDeEUsS0FBekIsQ0FEQSxJQUVBYixpQkFBaUIsQ0FBQ3FGLENBQUMsQ0FBQ3hFLEtBQUgsQ0FBakIsQ0FBMkIyRSxLQUEzQixLQUFxQyxLQUFJLENBQUN4RixpQkFBTCxDQUF1QnFGLENBQUMsQ0FBQ3hFLEtBQXpCLEVBQWdDMkUsS0FIdkUsRUFJRTtBQUNBRixVQUFBQSxTQUFTLENBQUNHLElBQVYsQ0FBZUosQ0FBQyxDQUFDeEUsS0FBakI7QUFDRDtBQUNGLE9BUkQsRUFWbUQsQ0FvQm5EOztBQUNBLFVBQU02RSxhQUFhLEdBQUcsS0FBS3pGLE1BQTNCO0FBQ0EsVUFBTTBGLE1BQU0sR0FBRyxLQUFLQyxlQUFMLENBQXFCRixhQUFyQixFQUFvQ1IsWUFBcEMsRUFBa0Q7QUFDL0RDLFFBQUFBLFdBQVcsRUFBWEEsV0FEK0Q7QUFFL0RHLFFBQUFBLFNBQVMsRUFBVEE7QUFGK0QsT0FBbEQsQ0FBZjtBQUtBLFdBQUtPLGlCQUFMLENBQXVCRixNQUF2QixFQTNCbUQsQ0E0Qm5EOztBQUNBdkcsTUFBQUEsTUFBTSxDQUFDMEcsSUFBUCxDQUFZLEtBQUtyQyxjQUFqQixFQUFpQzhCLE9BQWpDLENBQXlDLFVBQUEvQixPQUFPLEVBQUk7QUFDbEQsUUFBQSxLQUFJLENBQUN1QyxxQkFBTCxDQUEyQnZDLE9BQTNCO0FBQ0QsT0FGRDtBQUdEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FDRSx5QkFDRWtDLGFBREYsRUFFRVIsWUFGRixFQUlFO0FBQUE7O0FBQUEsc0ZBRHFGLEVBQ3JGO0FBQUEsb0NBRENDLFdBQ0Q7QUFBQSxVQURDQSxXQUNELGtDQURlLEVBQ2Y7QUFBQSxrQ0FEbUJHLFNBQ25CO0FBQUEsVUFEbUJBLFNBQ25CLGdDQUQrQixFQUMvQjs7QUFDQSxVQUFNSyxNQUFNLEdBQUcsRUFBZjtBQUNBdkcsTUFBQUEsTUFBTSxDQUFDMEcsSUFBUCxDQUFZSixhQUFaLEVBQTJCSCxPQUEzQixDQUFtQyxVQUFBekUsR0FBRyxFQUFJO0FBQ3hDLFlBQ0UsMEJBQWM0RSxhQUFhLENBQUM1RSxHQUFELENBQTNCLEtBQ0EsMEJBQWNvRSxZQUFZLENBQUNwRSxHQUFELENBQTFCLENBREEsSUFFQSxDQUFDcUUsV0FBVyxDQUFDYSxRQUFaLENBQXFCbEYsR0FBckIsQ0FGRCxJQUdBLENBQUN3RSxTQUFTLENBQUNVLFFBQVYsQ0FBbUJsRixHQUFuQixDQUpILEVBS0U7QUFDQTtBQUNBNkUsVUFBQUEsTUFBTSxDQUFDN0UsR0FBRCxDQUFOLEdBQWMsTUFBSSxDQUFDOEUsZUFBTCxDQUFxQkYsYUFBYSxDQUFDNUUsR0FBRCxDQUFsQyxFQUF5Q29FLFlBQVksQ0FBQ3BFLEdBQUQsQ0FBckQsRUFBNEQ7QUFDeEVxRSxZQUFBQSxXQUFXLEVBQVhBLFdBRHdFO0FBRXhFRyxZQUFBQSxTQUFTLEVBQVRBO0FBRndFLFdBQTVELENBQWQ7QUFJRCxTQVhELE1BV08sSUFBSSwrQkFBbUJKLFlBQVksQ0FBQ3BFLEdBQUQsQ0FBL0IsS0FBeUMsQ0FBQ3dFLFNBQVMsQ0FBQ1UsUUFBVixDQUFtQmxGLEdBQW5CLENBQTlDLEVBQXVFO0FBQzVFO0FBQ0E2RSxVQUFBQSxNQUFNLENBQUM3RSxHQUFELENBQU4sR0FBY29FLFlBQVksQ0FBQ3BFLEdBQUQsQ0FBMUI7QUFDRCxTQUhNLE1BR0E7QUFDTDtBQUNBNkUsVUFBQUEsTUFBTSxDQUFDN0UsR0FBRCxDQUFOLEdBQWM0RSxhQUFhLENBQUM1RSxHQUFELENBQTNCO0FBQ0Q7QUFDRixPQW5CRDtBQXFCQSxhQUFPNkUsTUFBUDtBQUNEOzs7V0FFRCwyQkFBa0JNLGVBQWxCLEVBRUc7QUFBQTs7QUFDRDdHLE1BQUFBLE1BQU0sQ0FBQzBHLElBQVAsQ0FBWUcsZUFBWixFQUE2QlYsT0FBN0IsQ0FBcUMsVUFBQVcsSUFBSSxFQUFJO0FBQzNDLFlBQU1DLFVBQVUsR0FBR0YsZUFBZSxDQUFDQyxJQUFELENBQWxDOztBQUNBLFlBQUksT0FBT0MsVUFBUCxLQUFzQixRQUF0QixJQUFrQ0MsNkJBQWtCRCxVQUFsQixDQUF0QyxFQUFxRTtBQUNuRTtBQUNBLFVBQUEsTUFBSSxDQUFDbEcsTUFBTCxDQUFZK0MsU0FBWixDQUFzQmtELElBQXRCLElBQThCRSw2QkFBa0JELFVBQWxCLEVBQThCaEYsWUFBNUQ7QUFDQSxVQUFBLE1BQUksQ0FBQ25CLGlCQUFMLENBQXVCa0csSUFBdkIsSUFBK0JFLDZCQUFrQkQsVUFBbEIsQ0FBL0I7QUFDRCxTQUpELE1BSU8sSUFDTCx5QkFBT0EsVUFBUCxNQUFzQixRQUF0QixJQUNBLENBQUMsTUFBRCxFQUFTLGNBQVQsRUFBeUJFLEtBQXpCLENBQStCLFVBQUFDLENBQUM7QUFBQSxpQkFBSUgsVUFBVSxDQUFDSSxjQUFYLENBQTBCRCxDQUExQixDQUFKO0FBQUEsU0FBaEMsQ0FGSyxFQUdMO0FBQ0E7QUFDQTtBQUNBLFVBQUEsTUFBSSxDQUFDckcsTUFBTCxDQUFZK0MsU0FBWixDQUFzQmtELElBQXRCLElBQThCQyxVQUFVLENBQUNoRixZQUF6QztBQUNBLFVBQUEsTUFBSSxDQUFDbkIsaUJBQUwsQ0FBdUJrRyxJQUF2QixJQUErQkMsVUFBL0I7QUFDRDtBQUNGLE9BZkQ7QUFnQkQ7OztXQUVELDJCQUFrQjtBQUNoQixVQUFNSyxnQkFBZ0IsR0FBRyxLQUFLQSxnQkFBOUI7QUFDQSxVQUFNQyxRQUFRLEdBQUcsS0FBS0Msb0JBQUwsQ0FBMEJDLE1BQTFCLENBQ2YsVUFBQ0MsSUFBRCxFQUFPOUYsR0FBUDtBQUFBLCtDQUNLOEYsSUFETCw0Q0FFRzlGLEdBRkgsRUFFUzBGLGdCQUFnQixDQUFDMUYsR0FBRCxDQUFoQixHQUNIO0FBQUNtQixVQUFBQSxLQUFLLEVBQUUsSUFBUjtBQUFjaUMsVUFBQUEsUUFBUSxFQUFFLENBQUMsQ0FBekI7QUFBNEIyQyxVQUFBQSxTQUFTLEVBQUVMLGdCQUFnQixDQUFDMUYsR0FBRDtBQUF2RCxTQURHLEdBRUg7QUFBQ21CLFVBQUFBLEtBQUssRUFBRSxJQUFSO0FBQWNpQyxVQUFBQSxRQUFRLEVBQUUsQ0FBQztBQUF6QixTQUpOO0FBQUEsT0FEZSxFQU9mLEVBUGUsQ0FBakI7QUFTQSxVQUFNNEMsUUFBUSxHQUFHLEtBQUtDLGVBQUwsQ0FBcUJKLE1BQXJCLENBQ2YsVUFBQ0MsSUFBRCxFQUFPOUYsR0FBUDtBQUFBLCtDQUNLOEYsSUFETCw0Q0FFRzlGLEdBRkgsRUFFUztBQUFDbUIsVUFBQUEsS0FBSyxFQUFFLElBQVI7QUFBY2lDLFVBQUFBLFFBQVEsRUFBRSxDQUFDLENBQXpCO0FBQTRCNEMsVUFBQUEsUUFBUSxFQUFFO0FBQXRDLFNBRlQ7QUFBQSxPQURlLEVBS2YsRUFMZSxDQUFqQjtBQVFBLDZDQUFXTCxRQUFYLEdBQXdCSyxRQUF4QjtBQUNEOzs7V0FFRCwyQkFDRUUsU0FERixFQUVTO0FBQ1AsV0FBSy9HLE1BQUwsbUNBQWtCLEtBQUtBLE1BQXZCLEdBQWtDK0csU0FBbEM7QUFDQSxhQUFPLElBQVA7QUFDRDs7O1dBRUQsOEJBQXFCQyxZQUFyQixFQUFtQztBQUNqQyxXQUFLaEgsTUFBTCxDQUFZK0MsU0FBWixtQ0FBNEIsS0FBSy9DLE1BQUwsQ0FBWStDLFNBQXhDLEdBQXNEaUUsWUFBdEQ7QUFDQSxhQUFPLElBQVA7QUFDRDs7O1dBRUQsNEJBQW1CQyxJQUFuQixFQUFpQ0YsU0FBakMsRUFBMkU7QUFBQSx5QkFDbEMsS0FBSy9HLE1BRDZCO0FBQUEsVUFDekRrSCxRQUR5RCxnQkFDbEVoRSxPQURrRTtBQUFBLFVBQy9DSCxTQUQrQyxnQkFDL0NBLFNBRCtDOztBQUd6RSxVQUFJLENBQUMsMEJBQWNnRSxTQUFkLENBQUQsSUFBNkIsT0FBT0UsSUFBUCxLQUFnQixRQUFqRCxFQUEyRDtBQUN6RCxlQUFPLElBQVA7QUFDRDs7QUFFRCxVQUFNRSxXQUFXLEdBQUdoSSxNQUFNLENBQUNpSSxPQUFQLENBQWVMLFNBQWYsRUFBMEJMLE1BQTFCLENBQWlDLFVBQUNDLElBQUQsU0FBd0I7QUFBQTtBQUFBLFlBQWhCOUYsR0FBZ0I7QUFBQSxZQUFYbUIsS0FBVzs7QUFDM0UsK0NBQ0syRSxJQURMLDRDQUVHOUYsR0FGSCxFQUVTLDBCQUFjOEYsSUFBSSxDQUFDOUYsR0FBRCxDQUFsQixLQUE0QiwwQkFBY21CLEtBQWQsQ0FBNUIsbUNBQXVEMkUsSUFBSSxDQUFDOUYsR0FBRCxDQUEzRCxHQUFxRW1CLEtBQXJFLElBQThFQSxLQUZ2RjtBQUlELE9BTG1CLEVBS2pCa0YsUUFBUSxDQUFDRCxJQUFELENBQVIsSUFBa0I5RCwyQkFMRCxDQUFwQjs7QUFPQSxVQUFNRCxPQUFPLG1DQUNSZ0UsUUFEUSw0Q0FFVkQsSUFGVSxFQUVIRSxXQUZHLEVBQWI7O0FBS0EsV0FBS3ZCLGlCQUFMLENBQXVCO0FBQUMxQyxRQUFBQSxPQUFPLEVBQVBBO0FBQUQsT0FBdkIsRUFuQnlFLENBb0J6RTs7QUFDQSxVQUFNbUUsWUFBWSxHQUFHdEUsU0FBUyxDQUFDa0UsSUFBRCxDQUFULElBQW1CbEUsU0FBUyxDQUFDa0UsSUFBRCxDQUFULENBQWdCSyxNQUF4RDs7QUFFQSxVQUFJRCxZQUFKLEVBQWtCO0FBQ2hCLGFBQUtFLHlCQUFMLENBQStCUixTQUEvQixFQUEwQ0UsSUFBMUM7QUFDQSxhQUFLTyx5QkFBTCxDQUErQlQsU0FBL0IsRUFBMENHLFFBQTFDLEVBQW9ERCxJQUFwRDtBQUNBLGFBQUtRLG1CQUFMLENBQXlCVixTQUF6QixFQUFvQ0csUUFBcEMsRUFBOENELElBQTlDO0FBQ0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0Q7OztXQUVELDZCQUFvQkYsU0FBcEIsRUFBK0JHLFFBQS9CLEVBQXlDRCxJQUF6QyxFQUErQztBQUM3QyxVQUFJLENBQUNGLFNBQVMsQ0FBQ1csZ0JBQVgsSUFBK0IsQ0FBQ1gsU0FBUyxDQUFDVyxnQkFBVixDQUEyQkMsTUFBL0QsRUFBdUU7QUFDckU7QUFDRDs7QUFINEMsMEJBS2hCLEtBQUszSCxNQUxXO0FBQUEsVUFLdENrRCxPQUxzQyxpQkFLdENBLE9BTHNDO0FBQUEsVUFLN0JILFNBTDZCLGlCQUs3QkEsU0FMNkI7QUFPN0MsVUFBSSxDQUFDQSxTQUFTLENBQUNrRSxJQUFELENBQWQsRUFBc0I7QUFQdUIsVUFRdENLLE1BUnNDLEdBUTVCdkUsU0FBUyxDQUFDa0UsSUFBRCxDQVJtQixDQVF0Q0ssTUFSc0M7O0FBUzdDLFVBQU1NLGFBQWEsbUNBQ2QxRSxPQUFPLENBQUMrRCxJQUFELENBQVAsQ0FBY1csYUFEQTtBQUVqQjlELFFBQUFBLElBQUksRUFBRSxnQkFGVztBQUdqQndELFFBQUFBLE1BQU0sc0NBQU1BLE1BQU47QUFIVyxRQUFuQjs7QUFLQSxXQUFLMUIsaUJBQUwsQ0FBdUI7QUFDckIxQyxRQUFBQSxPQUFPLGtDQUNGQSxPQURFLDRDQUVKK0QsSUFGSSxrQ0FHQS9ELE9BQU8sQ0FBQytELElBQUQsQ0FIUDtBQUlIVyxVQUFBQSxhQUFhLEVBQWJBO0FBSkc7QUFEYyxPQUF2QjtBQVNEO0FBQ0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O1dBQ0UsbUNBQTBCYixTQUExQixFQUFxQ0UsSUFBckMsRUFBMkM7QUFDekMsVUFBSSxPQUFPRixTQUFTLENBQUNjLFlBQWpCLEtBQWtDLFFBQXRDLEVBQWdEO0FBRFAsMEJBR1osS0FBSzdILE1BSE87QUFBQSxVQUdsQ2tELE9BSGtDLGlCQUdsQ0EsT0FIa0M7QUFBQSxVQUd6QkgsU0FIeUIsaUJBR3pCQSxTQUh5QjtBQUl6QyxXQUFLNkMsaUJBQUwsQ0FBdUI7QUFDckIxQyxRQUFBQSxPQUFPLGtDQUNGQSxPQURFLDRDQUVKK0QsSUFGSSxrQ0FHQS9ELE9BQU8sQ0FBQytELElBQUQsQ0FIUDtBQUlIUyxVQUFBQSxnQkFBZ0Isa0NBQ1h4RSxPQUFPLENBQUMrRCxJQUFELENBQVAsQ0FBY1MsZ0JBREg7QUFFZEksWUFBQUEsS0FBSyxFQUFFL0UsU0FBUyxDQUFDa0UsSUFBRCxDQUFULENBQWdCSyxNQUFoQixDQUF1QjdILE1BRmhCO0FBR2RzSSxZQUFBQSxRQUFRLEVBQUVDLE9BQU8sQ0FBQ2pGLFNBQVMsQ0FBQ2tFLElBQUQsQ0FBVCxDQUFnQmMsUUFBakI7QUFISDtBQUpiO0FBRGMsT0FBdkI7QUFhRDs7O1dBRUQsbUNBQTBCaEIsU0FBMUIsRUFBcUNHLFFBQXJDLEVBQStDRCxJQUEvQyxFQUFxRDtBQUNuRDtBQUNBLFVBQU1nQixZQUFZLEdBQ2hCbEIsU0FBUyxDQUFDVyxnQkFBVixJQUNBLENBQUMsVUFBRCxFQUFhLE9BQWIsRUFBc0JRLElBQXRCLENBQ0UsVUFBQXJILEdBQUc7QUFBQSxlQUNEa0csU0FBUyxDQUFDVyxnQkFBVixDQUEyQnBCLGNBQTNCLENBQTBDekYsR0FBMUMsS0FDQWtHLFNBQVMsQ0FBQ1csZ0JBQVYsQ0FBMkI3RyxHQUEzQixNQUNFLENBQUNxRyxRQUFRLENBQUNELElBQUQsQ0FBUixJQUFrQjlELDJCQUFuQixFQUFxQ3VFLGdCQUFyQyxDQUFzRDdHLEdBQXRELENBSEQ7QUFBQSxPQURMLENBRkY7QUFRQSxVQUFJLENBQUNvSCxZQUFMLEVBQW1CO0FBVmdDLDBCQVl0QixLQUFLakksTUFaaUI7QUFBQSxVQVk1Q2tELE9BWjRDLGlCQVk1Q0EsT0FaNEM7QUFBQSxVQVluQ0gsU0FabUMsaUJBWW5DQSxTQVptQztBQUFBLGtDQWF6QkcsT0FBTyxDQUFDK0QsSUFBRCxDQUFQLENBQWNTLGdCQWJXO0FBQUEsVUFhNUNJLEtBYjRDLHlCQWE1Q0EsS0FiNEM7QUFBQSxVQWFyQ0MsUUFicUMseUJBYXJDQSxRQWJxQztBQWNuRCxVQUFNM0UsVUFBVSxHQUFHTCxTQUFTLENBQUNrRSxJQUFELENBQTVCLENBZG1ELENBZW5EOztBQUNBLFVBQUlqRCxNQUFKOztBQUNBLFVBQUkrQyxTQUFTLENBQUNXLGdCQUFWLENBQTJCcEIsY0FBM0IsQ0FBMEMsT0FBMUMsQ0FBSixFQUF3RDtBQUN0RCxZQUFNZixLQUFLLEdBQUcsZ0NBQW9CbkMsVUFBcEIsQ0FBZDs7QUFFQSxZQUFJbUMsS0FBSixFQUFXO0FBQ1QsY0FBTTRDLFNBQVMsR0FBR0Msd0JBQWFDLE1BQWIsQ0FBb0IsVUFBQUMsRUFBRTtBQUFBLG1CQUFJLGdDQUFvQkEsRUFBcEIsTUFBNEIvQyxLQUFoQztBQUFBLFdBQXRCLENBQWxCOztBQUVBdkIsVUFBQUEsTUFBTSxHQUFHbUUsU0FBUyxDQUFDSSxJQUFWLENBQWUsVUFBQUQsRUFBRTtBQUFBLG1CQUFJQSxFQUFFLENBQUNoQixNQUFILENBQVU3SCxNQUFWLEtBQXFCcUksS0FBekI7QUFBQSxXQUFqQixDQUFUOztBQUVBLGNBQUk5RCxNQUFNLElBQUlaLFVBQVUsQ0FBQzJFLFFBQXpCLEVBQW1DO0FBQ2pDL0QsWUFBQUEsTUFBTSxHQUFHLDhCQUFrQixJQUFsQixFQUF3QkEsTUFBeEIsQ0FBVDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxVQUFJK0MsU0FBUyxDQUFDVyxnQkFBVixDQUEyQnBCLGNBQTNCLENBQTBDLFVBQTFDLENBQUosRUFBMkQ7QUFDekR0QyxRQUFBQSxNQUFNLEdBQUcsOEJBQWtCK0QsUUFBbEIsRUFBNEIvRCxNQUFNLElBQUlaLFVBQXRDLENBQVQ7QUFDRDs7QUFFRCxVQUFJWSxNQUFKLEVBQVk7QUFDVixhQUFLd0Usb0JBQUwsc0NBQTRCdkIsSUFBNUIsRUFBbUNqRCxNQUFuQztBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTs7OztXQUNFLHlCQUF5QjtBQUFBLFVBQ2hCOUQsT0FEZ0IsR0FDTCxLQUFLRixNQURBLENBQ2hCRSxPQURnQjtBQUV2QixhQUNFQSxPQUFPLElBQ1BmLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjYyxPQUFkLEVBQXVCa0csS0FBdkIsQ0FBNkIsVUFBQXFDLE1BQU0sRUFBSTtBQUNyQyxlQUFPVCxPQUFPLENBQUNTLE1BQU0sS0FBS0EsTUFBTSxDQUFDNUIsUUFBUCxJQUFvQjRCLE1BQU0sQ0FBQ3pHLEtBQVAsSUFBZ0J5RyxNQUFNLENBQUN4RSxRQUFQLEdBQWtCLENBQUMsQ0FBNUQsQ0FBUCxDQUFkO0FBQ0QsT0FGRCxDQUZGO0FBTUQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FDRSxzQkFBYXlFLFNBQWIsRUFBd0I7QUFDdEIsVUFBSSxDQUFDQSxTQUFMLEVBQWdCO0FBQ2QsZUFBTyxLQUFQO0FBQ0Q7O0FBQ0QsYUFBT1YsT0FBTyxDQUFDVSxTQUFTLENBQUNDLElBQVYsSUFBa0JELFNBQVMsQ0FBQ0MsSUFBVixDQUFlbEosTUFBbEMsQ0FBZDtBQUNEOzs7V0FFRCx5QkFBeUI7QUFDdkIsYUFBT3VJLE9BQU8sQ0FBQyxLQUFLekgsSUFBTCxJQUFhLEtBQUtxSSxhQUFMLEVBQWQsQ0FBZDtBQUNEOzs7V0FFRCwyQkFBa0JELElBQWxCLEVBQWlDO0FBQy9CLGFBQ0VYLE9BQU8sQ0FBQyxLQUFLekgsSUFBTixDQUFQLElBQ0EsS0FBS3FJLGFBQUwsRUFEQSxJQUVBLEtBQUtDLFlBQUwsQ0FBa0JGLElBQWxCLENBRkEsSUFHQSxPQUFPLEtBQUtHLFdBQVosS0FBNEIsVUFKOUI7QUFNRDs7O1dBRUQsdUJBQWN0RyxVQUFkLEVBQWtDRCxXQUFsQyxFQUFvRWEsVUFBcEUsRUFBNEY7QUFDMUYsVUFBSTJGLEtBQUssQ0FBQ0MsT0FBTixDQUFjNUYsVUFBVSxDQUFDNkYsUUFBekIsQ0FBSixFQUF3QztBQUN0QyxZQUFNQyxJQUFJLEdBQUcsSUFBSUMsR0FBSixFQUFiO0FBQ0EvRixRQUFBQSxVQUFVLENBQUM2RixRQUFYLENBQW9CM0QsT0FBcEIsQ0FBNEIsaUJBQVk7QUFBQTtBQUFBLGNBQVY4RCxDQUFVO0FBQUEsY0FBUGhFLENBQU87O0FBQ3RDOEQsVUFBQUEsSUFBSSxDQUFDRyxHQUFMLENBQVNELENBQVQsRUFBWSxPQUFPaEUsQ0FBUCxLQUFhLFFBQWIsR0FBd0IscUJBQVNBLENBQVQsQ0FBeEIsR0FBc0NBLENBQWxEO0FBQ0QsU0FGRDs7QUFJQSxZQUFNMUUsS0FBSyxHQUFHNEksc0JBQVc3Ryx1QkFBWThHLE9BQXZCLElBQ1g1SSxNQURXLENBQ0p1SSxJQUFJLENBQUNyRCxJQUFMLEVBREksRUFFWGpGLEtBRlcsQ0FFTHNJLElBQUksQ0FBQzlKLE1BQUwsRUFGSyxFQUdYb0ssT0FIVyxDQUdITixJQUFJLENBQUNPLEdBQUwsQ0FBU0MsNEJBQVQsS0FBK0J6SSx5QkFINUIsQ0FBZDs7QUFJQSxlQUFPUCxLQUFQO0FBQ0Q7O0FBQ0QsYUFBTyxLQUFLaUosa0JBQUwsQ0FBd0JuSCxVQUF4QixFQUFvQ0QsV0FBcEMsRUFBaURhLFVBQVUsQ0FBQ2tFLE1BQVgsQ0FBa0JoSSxHQUFsQixDQUFzQkMsZUFBdEIsQ0FBakQsQ0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FDRSxzQ0FNRztBQUFBOztBQUFBLHFDQUxEcUssWUFLQztBQUFBLFVBTERBLFlBS0MsbUNBTGNuTCxtQkFLZDtBQUFBLFVBSkRxRyxhQUlDLFNBSkRBLGFBSUM7QUFDRCxVQUFNK0Usa0JBQXdDLEdBQUcsRUFBakQ7QUFFQTFLLE1BQUFBLE1BQU0sQ0FBQzBHLElBQVAsQ0FBWSxLQUFLckMsY0FBakIsRUFBaUM4QixPQUFqQyxDQUF5QyxVQUFBL0IsT0FBTyxFQUFJO0FBQUEsb0NBWTlDLE1BQUksQ0FBQ0MsY0FBTCxDQUFvQkQsT0FBcEIsQ0FaOEM7QUFBQSxZQUVoRDFFLEtBRmdELHlCQUVoREEsS0FGZ0Q7QUFBQSxZQUdoRGlMLEtBSGdELHlCQUdoREEsS0FIZ0Q7QUFBQSxZQUloRHBKLEtBSmdELHlCQUloREEsS0FKZ0Q7QUFBQSxZQUtoREMsTUFMZ0QseUJBS2hEQSxNQUxnRDtBQUFBLFlBTWhEQyxLQU5nRCx5QkFNaERBLEtBTmdEO0FBQUEsWUFPaERtSixRQVBnRCx5QkFPaERBLFFBUGdEO0FBQUEsWUFRaEQ3SSxZQVJnRCx5QkFRaERBLFlBUmdEO0FBQUEsWUFTaEQ4SSxpQkFUZ0QseUJBU2hEQSxpQkFUZ0Q7QUFBQSxZQVVoRGhKLFNBVmdELHlCQVVoREEsU0FWZ0Q7QUFBQSxZQVdoREYsZ0JBWGdELHlCQVdoREEsZ0JBWGdEOztBQWNsRCxZQUFJaUosUUFBSixFQUFjO0FBQ1osY0FBTUUsY0FBYyxHQUFHLE1BQUksQ0FBQ2pLLE1BQUwsQ0FBWW5CLEtBQVosQ0FBdkI7O0FBRUEsY0FBSW9MLGNBQUosRUFBb0I7QUFDbEIsZ0JBQU1DLE9BQU8sR0FBR0osS0FBSyxJQUFJLE1BQUksQ0FBQzlKLE1BQUwsQ0FBWStDLFNBQVosQ0FBc0IrRyxLQUF0QixDQUF6QjtBQUVBLGdCQUFNSyxhQUFhLEdBQ2pCckosZ0JBQWdCLEtBQUtDLDBCQUFlUCxLQUFwQyxHQUNJLE1BQUksQ0FBQzRKLGFBQUwsQ0FDRSxNQUFJLENBQUNwSyxNQUFMLENBQVlVLEtBQVosQ0FERixFQUVFLE1BQUksQ0FBQ1YsTUFBTCxDQUFZVyxNQUFaLENBRkYsRUFHRSxNQUFJLENBQUNYLE1BQUwsQ0FBWStDLFNBQVosQ0FBc0JuQyxLQUF0QixDQUhGLENBREosR0FNSSxNQUFJLENBQUMrSSxrQkFBTCxDQUNFLE1BQUksQ0FBQzNKLE1BQUwsQ0FBWVUsS0FBWixDQURGLEVBRUUsTUFBSSxDQUFDVixNQUFMLENBQVlXLE1BQVosQ0FGRixFQUdFLE1BQUksQ0FBQ1gsTUFBTCxDQUFZK0MsU0FBWixDQUFzQm5DLEtBQXRCLENBSEYsRUFJRXNKLE9BSkYsQ0FQTjs7QUFjQUwsWUFBQUEsa0JBQWtCLENBQUNFLFFBQUQsQ0FBbEIsR0FBK0IsVUFBQXBMLENBQUM7QUFBQSxxQkFDOUIsTUFBSSxDQUFDMEwsc0JBQUwsQ0FDRUYsYUFERixFQUVFUCxZQUFZLENBQUM5RSxhQUFELENBQVosQ0FBNEJuRyxDQUE1QixDQUZGLEVBR0UsTUFBSSxDQUFDcUIsTUFBTCxDQUFZbkIsS0FBWixDQUhGLEVBSUVtQyxTQUpGLENBRDhCO0FBQUEsYUFBaEM7QUFPRCxXQXhCRCxNQXdCTyxJQUFJLE9BQU9nSixpQkFBUCxLQUE2QixVQUFqQyxFQUE2QztBQUNsREgsWUFBQUEsa0JBQWtCLENBQUNFLFFBQUQsQ0FBbEIsR0FBK0JDLGlCQUFpQixDQUFDLE1BQUksQ0FBQ2hLLE1BQU4sQ0FBaEQ7QUFDRCxXQUZNLE1BRUE7QUFDTDZKLFlBQUFBLGtCQUFrQixDQUFDRSxRQUFELENBQWxCLEdBQ0UsT0FBTzdJLFlBQVAsS0FBd0IsVUFBeEIsR0FBcUNBLFlBQVksQ0FBQyxNQUFJLENBQUNsQixNQUFOLENBQWpELEdBQWlFa0IsWUFEbkU7QUFFRDs7QUFFRCxjQUFJLENBQUMySSxrQkFBa0IsQ0FBQ0UsUUFBRCxDQUF2QixFQUFtQztBQUNqQ08sNEJBQVFDLElBQVIsbURBQXdEUixRQUFRLElBQUl4RyxPQUFwRTtBQUNEO0FBQ0Y7QUFDRixPQXBERDtBQXNEQSxhQUFPc0csa0JBQVA7QUFDRDs7O1dBRUQsNEJBQ0VuSixLQURGLEVBRUVDLE1BRkYsRUFHRUMsS0FIRixFQUlFa0osS0FKRixFQUtvQjtBQUNsQixhQUFPUixzQkFBV1EsS0FBSyxHQUFHLFFBQUgsR0FBY3BKLEtBQTlCLElBQ0pDLE1BREksQ0FDR0EsTUFESCxFQUVKQyxLQUZJLENBRUVrSixLQUFLLEdBQUduSixNQUFILEdBQVlDLEtBRm5CLENBQVA7QUFHRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztXQUNFLHlCQUNFa0UsYUFERixFQUVFMEYsV0FGRixFQUdtQjtBQUNqQjtBQUNBO0FBQ0EsVUFBTUMsVUFBVSxHQUNkM0YsYUFBYSxDQUFDNEYsT0FBZCxLQUEwQnZNLGVBQTFCLEdBQ0ksbUNBQXVCMkcsYUFBdkIsRUFBc0MzRyxlQUF0QyxDQURKLEdBRUkyRyxhQUhOO0FBS0EsVUFBTTZGLE1BQU0sR0FBR0gsV0FBVyxHQUFHQyxVQUFVLENBQUNHLFFBQVgsQ0FBb0JKLFdBQXBCLENBQUgsR0FBc0MsRUFBaEU7QUFFQSxVQUFNSyxTQUFTLEdBQUcsNEJBQWdCRixNQUFoQixFQUF3QixDQUF4QixFQUEyQixDQUFDLENBQUMsRUFBRixFQUFNLEVBQU4sQ0FBM0IsQ0FBbEI7QUFDQSxVQUFNRyxTQUFTLEdBQUcsNEJBQWdCSCxNQUFoQixFQUF3QixDQUF4QixFQUEyQixDQUFDLENBQUMsR0FBRixFQUFPLEdBQVAsQ0FBM0IsQ0FBbEI7O0FBRUEsVUFBSSxDQUFDRSxTQUFELElBQWMsQ0FBQ0MsU0FBbkIsRUFBOEI7QUFDNUIsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQsYUFBTyxDQUFDQSxTQUFTLENBQUMsQ0FBRCxDQUFWLEVBQWVELFNBQVMsQ0FBQyxDQUFELENBQXhCLEVBQTZCQyxTQUFTLENBQUMsQ0FBRCxDQUF0QyxFQUEyQ0QsU0FBUyxDQUFDLENBQUQsQ0FBcEQsQ0FBUDtBQUNEOzs7V0FFRCw0QkFBbUJFLGtCQUFuQixFQUF1QztBQUNyQyxVQUFNQyxjQUFjLEdBQUcscUNBQW1CRCxrQkFBbkIsRUFBdUMsS0FBS0Usc0JBQTVDLENBQXZCO0FBQ0EsV0FBS0Esc0JBQUwsR0FBOEJGLGtCQUE5QjtBQUVBLGFBQU9DLGNBQVA7QUFDRDs7O1dBRUQsZ0NBQ0V0SyxLQURGLEVBRUVpSSxJQUZGLEVBR0U5SixLQUhGLEVBTUU7QUFBQSxVQUZBbUMsU0FFQSx1RUFGWUMseUJBRVo7QUFBQSxVQURBaUssUUFDQSx1RUFEV3RNLG9CQUNYO0FBQ0E7QUFEQSxVQUVPMkIsSUFGUCxHQUVlMUIsS0FGZixDQUVPMEIsSUFGUDtBQUdBLFVBQU15QixLQUFLLEdBQUdrSixRQUFRLENBQUNyTSxLQUFELEVBQVE4SixJQUFSLENBQXRCOztBQUVBLFVBQUksQ0FBQywrQkFBbUIzRyxLQUFuQixDQUFMLEVBQWdDO0FBQzlCLGVBQU9oQixTQUFQO0FBQ0Q7O0FBRUQsVUFBSW1LLGNBQUo7O0FBQ0EsVUFBSTVLLElBQUksS0FBSzZLLDJCQUFnQkMsU0FBN0IsRUFBd0M7QUFDdEM7QUFDQTtBQUNBRixRQUFBQSxjQUFjLEdBQUd6SyxLQUFLLENBQUMsSUFBSTRLLElBQUosQ0FBU3RKLEtBQVQsQ0FBRCxDQUF0QjtBQUNELE9BSkQsTUFJTztBQUNMbUosUUFBQUEsY0FBYyxHQUFHekssS0FBSyxDQUFDc0IsS0FBRCxDQUF0QjtBQUNEOztBQUVELFVBQUksQ0FBQywrQkFBbUJtSixjQUFuQixDQUFMLEVBQXlDO0FBQ3ZDQSxRQUFBQSxjQUFjLEdBQUduSyxTQUFqQjtBQUNEOztBQUVELGFBQU9tSyxjQUFQO0FBQ0Q7OztXQUVELG9CQUFXckwsSUFBWCxFQUFnQztBQUM5QixXQUFLQSxJQUFMLG1DQUFnQixLQUFLQSxJQUFyQixHQUE4QkEsSUFBOUI7QUFDRDs7O1dBRUQsc0NBQTRFO0FBQUEsVUFBckR5TCxhQUFxRCxTQUFyREEsYUFBcUQ7QUFBQSxVQUF0QzFMLEVBQXNDLFNBQXRDQSxFQUFzQztBQUFBLFVBQWxDaUYsYUFBa0MsU0FBbENBLGFBQWtDO0FBQUEsVUFDbkU1RSxPQURtRSxHQUN4RCxLQUFLRixNQURtRCxDQUNuRUUsT0FEbUU7QUFHMUU7QUFDRXNMLFFBQUFBLE9BQU8sRUFBRTtBQUFDQyxVQUFBQSxTQUFTLEVBQUU1TCxFQUFaO0FBQWdCaUYsVUFBQUEsYUFBYSxFQUFiQSxhQUFoQjtBQUErQjVFLFVBQUFBLE9BQU8sRUFBUEEsT0FBL0I7QUFBd0NxTCxVQUFBQSxhQUFhLEVBQWJBO0FBQXhDLFNBRFg7QUFFRUcsUUFBQUEsT0FBTyxFQUFFO0FBQUNELFVBQUFBLFNBQVMsRUFBRTVMLEVBQVo7QUFBZ0JpRixVQUFBQSxhQUFhLEVBQWJBLGFBQWhCO0FBQStCNUUsVUFBQUEsT0FBTyxFQUFQQTtBQUEvQjtBQUZYLFNBR0ssQ0FBQyxLQUFLRixNQUFMLENBQVlnRCxTQUFaLElBQXlCLEVBQTFCLEVBQThCMEQsTUFBOUIsQ0FDRCxVQUFDQyxJQUFELEVBQU9nRixFQUFQLEVBQVdDLENBQVg7QUFBQSwrQ0FDS2pGLElBREwsMkVBRTJCaUYsQ0FGM0IsR0FFaUNELEVBQUUsQ0FBQzlNLEtBQUgsR0FBVzhNLEVBQUUsQ0FBQzlNLEtBQUgsQ0FBU2lGLElBQXBCLEdBQTJCLElBRjVEO0FBQUEsT0FEQyxFQUtELEVBTEMsQ0FITDtBQVdEOzs7V0FFRCxvQkFBV2EsUUFBWCxFQUErQkMsWUFBL0IsRUFBa0Q7QUFDaEQsVUFBSSxDQUFDLEtBQUs1RSxNQUFMLENBQVk0QixNQUFqQixFQUF5QjtBQUN2QixlQUFPLEVBQVA7QUFDRDs7QUFDRCxVQUFNaUssWUFBWSxHQUFHbEgsUUFBUSxDQUFDLEtBQUszRSxNQUFMLENBQVk0QixNQUFiLENBQTdCO0FBSmdELFVBS3pDa0QsYUFMeUMsR0FLeEIrRyxZQUx3QixDQUt6Qy9HLGFBTHlDO0FBT2hELFVBQU0wRixXQUFXLEdBQUcsS0FBS3NCLG1CQUFMLENBQXlCaEgsYUFBekIsQ0FBcEI7QUFDQSxVQUFNaUcsa0JBQWtCLEdBQUcsS0FBS2dCLHFCQUFMLENBQTJCRixZQUEzQixDQUEzQjtBQUNBLFVBQU1iLGNBQWMsR0FBRyxLQUFLZ0Isa0JBQUwsQ0FBd0JqQixrQkFBeEIsQ0FBdkI7O0FBRUEsVUFBSUMsY0FBYyxLQUFLQSxjQUFjLENBQUNVLE9BQWYsSUFBMEJWLGNBQWMsQ0FBQ1EsT0FBOUMsQ0FBbEIsRUFBMEU7QUFDeEUsYUFBS1MsZUFBTCxDQUFxQm5ILGFBQXJCLEVBQW9DMEYsV0FBcEM7QUFDRDs7QUFFRCxVQUFJN0IsSUFBSSxHQUFHLEVBQVg7O0FBRUEsVUFBSSxFQUFFcUMsY0FBYyxJQUFJQSxjQUFjLENBQUNRLE9BQW5DLEtBQStDNUcsWUFBL0MsSUFBK0RBLFlBQVksQ0FBQytELElBQWhGLEVBQXNGO0FBQ3BGO0FBQ0FBLFFBQUFBLElBQUksR0FBRy9ELFlBQVksQ0FBQytELElBQXBCO0FBQ0QsT0FIRCxNQUdPO0FBQ0xBLFFBQUFBLElBQUksR0FBRyxLQUFLdUQsc0JBQUwsQ0FBNEJMLFlBQTVCLEVBQTBDckIsV0FBMUMsQ0FBUDtBQUNEOztBQUVELGFBQU87QUFBQzdCLFFBQUFBLElBQUksRUFBSkEsSUFBRDtBQUFPcUMsUUFBQUEsY0FBYyxFQUFkQTtBQUFQLE9BQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FDRSwyQkFBa0JyRyxRQUFsQixFQUFzQ3dILFNBQXRDLEVBQWlFO0FBQUE7O0FBQy9ELFVBQU1DLEtBQUssR0FBRyxLQUFLQyxVQUFMLENBQWdCMUgsUUFBaEIsQ0FBZDs7QUFDQSxVQUFJLENBQUN5SCxLQUFMLEVBQVk7QUFDVixlQUFPLElBQVA7QUFDRDs7QUFDRGpOLE1BQUFBLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEtBQUtvRSxjQUFuQixFQUFtQzhCLE9BQW5DLENBQTJDLFVBQUEvQixPQUFPLEVBQUk7QUFBQSxZQUM3QzdDLEtBRDZDLEdBQ3BDNkMsT0FEb0MsQ0FDN0M3QyxLQUQ2QztBQUVwRCxZQUFNNEwsU0FBUyxHQUFHLE1BQUksQ0FBQ3RNLE1BQUwsQ0FBWVUsS0FBWixDQUFsQixDQUZvRCxDQUdwRDtBQUNBOztBQUNBLFlBQUksQ0FBQ3lMLFNBQUQsSUFBY0csU0FBUyxLQUFLN0osdUJBQVk4RyxPQUE1QyxFQUFxRDtBQUFBLGNBQzVDNUksTUFENEMsR0FDbEM0QyxPQURrQyxDQUM1QzVDLE1BRDRDOztBQUVuRCxjQUFNNEwsYUFBYSxHQUFHLE1BQUksQ0FBQ0Msb0JBQUwsQ0FBMEJKLEtBQTFCLEVBQWlDN0ksT0FBakMsQ0FBdEI7O0FBQ0EsVUFBQSxNQUFJLENBQUNxQyxpQkFBTCxzQ0FBeUJqRixNQUF6QixFQUFrQzRMLGFBQWxDO0FBQ0Q7QUFDRixPQVZEO0FBWUEsYUFBTyxJQUFQO0FBQ0Q7OztXQUVELG9CQUFXNUgsUUFBWCxFQUFxQjtBQUNuQixhQUFPLEtBQUszRSxNQUFMLENBQVk0QixNQUFaLEdBQXFCK0MsUUFBUSxDQUFDLEtBQUszRSxNQUFMLENBQVk0QixNQUFiLENBQTdCLEdBQW9ELElBQTNEO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTs7OztXQUNFLCtCQUFzQjJCLE9BQXRCLEVBQXVDO0FBQ3JDLFdBQUtrSixpQkFBTCxDQUF1QmxKLE9BQXZCO0FBQ0EsV0FBS21KLGFBQUwsQ0FBbUJuSixPQUFuQjtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7O1dBQ0UsMkJBQWtCQSxPQUFsQixFQUFtQztBQUNqQyxVQUFNb0osYUFBYSxHQUFHLEtBQUtuSixjQUFMLENBQW9CRCxPQUFwQixDQUF0QjtBQURpQyxVQUUxQjFFLEtBRjBCLEdBRXNCOE4sYUFGdEIsQ0FFMUI5TixLQUYwQjtBQUFBLFVBRW5CaUMsZ0JBRm1CLEdBRXNCNkwsYUFGdEIsQ0FFbkI3TCxnQkFGbUI7QUFBQSxVQUVEOEwsbUJBRkMsR0FFc0JELGFBRnRCLENBRURDLG1CQUZDOztBQUlqQyxVQUFJLEtBQUs1TSxNQUFMLENBQVluQixLQUFaLENBQUosRUFBd0I7QUFDdEI7QUFDQSxZQUFNZ08sMEJBQTBCLEdBQzlCRCxtQkFBbUIsSUFBSUUsMENBQStCaE0sZ0JBQS9CLENBRHpCOztBQUdBLFlBQUksQ0FBQytMLDBCQUEwQixDQUFDOUcsUUFBM0IsQ0FBb0MsS0FBSy9GLE1BQUwsQ0FBWW5CLEtBQVosRUFBbUIwQixJQUF2RCxDQUFMLEVBQW1FO0FBQ2pFO0FBQ0E7QUFDQSxlQUFLcUYsaUJBQUwsc0NBQXlCL0csS0FBekIsRUFBaUMsSUFBakM7QUFDRDtBQUNGO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7Ozs7V0FDRSx1QkFBYzBFLE9BQWQsRUFBdUI7QUFDckIsVUFBTW9KLGFBQWEsR0FBRyxLQUFLbkosY0FBTCxDQUFvQkQsT0FBcEIsQ0FBdEI7QUFEcUIsVUFFZDdDLEtBRmMsR0FFTGlNLGFBRkssQ0FFZGpNLEtBRmM7O0FBR3JCLFVBQUksQ0FBQ0EsS0FBTCxFQUFZO0FBQ1Y7QUFDQTtBQUNEOztBQUNELFVBQU1xTSxZQUFZLEdBQUcsS0FBS0MsZUFBTCxDQUFxQnpKLE9BQXJCLENBQXJCLENBUHFCLENBUXJCO0FBQ0E7O0FBQ0EsVUFBSSxDQUFDd0osWUFBWSxDQUFDaEgsUUFBYixDQUFzQixLQUFLL0YsTUFBTCxDQUFZVSxLQUFaLENBQXRCLENBQUwsRUFBZ0Q7QUFDOUMsYUFBS2tGLGlCQUFMLHNDQUF5QmxGLEtBQXpCLEVBQWlDcU0sWUFBWSxDQUFDLENBQUQsQ0FBN0M7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OztXQUNFLHlCQUFnQnhKLE9BQWhCLEVBQXlCO0FBQ3ZCLFVBQU1vSixhQUFhLEdBQUcsS0FBS25KLGNBQUwsQ0FBb0JELE9BQXBCLENBQXRCO0FBRHVCLFVBRWhCMUUsS0FGZ0IsR0FFa0I4TixhQUZsQixDQUVoQjlOLEtBRmdCO0FBQUEsVUFFVDZCLEtBRlMsR0FFa0JpTSxhQUZsQixDQUVUak0sS0FGUztBQUFBLFVBRUZJLGdCQUZFLEdBRWtCNkwsYUFGbEIsQ0FFRjdMLGdCQUZFO0FBSXZCLGFBQU8sS0FBS2QsTUFBTCxDQUFZbkIsS0FBWixJQUNIb08sc0JBQVcsS0FBS2pOLE1BQUwsQ0FBWW5CLEtBQVosRUFBbUIwQixJQUE5QixFQUFvQ0csS0FBcEMsQ0FBMENJLGdCQUExQyxDQURHLEdBRUgsQ0FBQyxLQUFLYixxQkFBTCxDQUEyQjtBQUFDMkIsUUFBQUEsTUFBTSxFQUFFO0FBQVQsT0FBM0IsRUFBeUNsQixLQUF6QyxDQUFELENBRko7QUFHRDs7O1dBRUQsa0NBQXlCd00sT0FBekIsRUFBK0MzSixPQUEvQyxFQUFnRTtBQUM5RCxVQUFNb0osYUFBYSxHQUFHLEtBQUtuSixjQUFMLENBQW9CRCxPQUFwQixDQUF0QjtBQUNBLFdBQUt1QyxxQkFBTCxDQUEyQnZDLE9BQTNCLEVBRjhELENBRzlEOztBQUNBLFVBQU1nSixhQUFhLEdBQUcsS0FBS0Msb0JBQUwsQ0FBMEJVLE9BQTFCLEVBQW1DUCxhQUFuQyxDQUF0QjtBQUNBLFdBQUsvRyxpQkFBTCxzQ0FBeUIrRyxhQUFhLENBQUNoTSxNQUF2QyxFQUFnRDRMLGFBQWhEO0FBQ0Q7OztXQUVELDBDQUFpRDtBQUFBOztBQUMvQyxVQUFNWSxjQUE4QixHQUFHLEVBQXZDO0FBQ0FoTyxNQUFBQSxNQUFNLENBQUNDLE1BQVAsQ0FBYyxLQUFLb0UsY0FBbkIsRUFBbUM4QixPQUFuQyxDQUEyQyxVQUFBcUgsYUFBYSxFQUFJO0FBQzFEO0FBRDBELFlBRW5ENUMsUUFGbUQsR0FFVzRDLGFBRlgsQ0FFbkQ1QyxRQUZtRDtBQUFBLFlBRXpDbEwsS0FGeUMsR0FFVzhOLGFBRlgsQ0FFekM5TixLQUZ5QztBQUFBLFlBRWxDNkIsS0FGa0MsR0FFV2lNLGFBRlgsQ0FFbENqTSxLQUZrQztBQUFBLFlBRTNCQyxNQUYyQixHQUVXZ00sYUFGWCxDQUUzQmhNLE1BRjJCO0FBQUEsWUFFbkJDLEtBRm1CLEdBRVcrTCxhQUZYLENBRW5CL0wsS0FGbUI7QUFBQSxZQUVaTSxZQUZZLEdBRVd5TCxhQUZYLENBRVp6TCxZQUZZO0FBQUEsWUFFRTRJLEtBRkYsR0FFVzZDLGFBRlgsQ0FFRTdDLEtBRkY7O0FBSTFELFlBQUlDLFFBQUosRUFBYztBQUFBOztBQUNab0QsVUFBQUEsY0FBYyxDQUFDcEQsUUFBRCxDQUFkLDBGQUNHbEwsS0FESCxFQUNXLE1BQUksQ0FBQ21CLE1BQUwsQ0FBWW5CLEtBQVosQ0FEWCxxREFFRzZCLEtBRkgsRUFFVyxNQUFJLENBQUNWLE1BQUwsQ0FBWVUsS0FBWixDQUZYLHFEQUdHQyxNQUhILEVBR1ksTUFBSSxDQUFDWCxNQUFMLENBQVlXLE1BQVosQ0FIWixxREFJR0MsS0FKSCxFQUlXLE1BQUksQ0FBQ1osTUFBTCxDQUFZK0MsU0FBWixDQUFzQm5DLEtBQXRCLENBSlgscUVBTUksT0FBT00sWUFBUCxLQUF3QixVQUF4QixHQUFxQ0EsWUFBWSxDQUFDLE1BQUksQ0FBQ2xCLE1BQU4sQ0FBakQsR0FBaUVrQixZQU5yRSxxQkFPTTRJLEtBQUssd0NBQUtBLEtBQUwsRUFBYSxNQUFJLENBQUM5SixNQUFMLENBQVkrQyxTQUFaLENBQXNCK0csS0FBdEIsQ0FBYixJQUE2QyxFQVB4RDtBQVNEO0FBQ0YsT0FmRDtBQWdCQSxhQUFPcUQsY0FBUDtBQUNEOzs7V0FFRCw4QkFBcUJELE9BQXJCLEVBQThCUCxhQUE5QixFQUE2QztBQUFBLFVBQ3BDak0sS0FEb0MsR0FDM0JpTSxhQUQyQixDQUNwQ2pNLEtBRG9DO0FBRTNDLFVBQU00TCxTQUFTLEdBQUcsS0FBS3RNLE1BQUwsQ0FBWVUsS0FBWixDQUFsQjtBQUVBLFVBQU03QixLQUFLLEdBQUcsS0FBS21CLE1BQUwsQ0FBWTJNLGFBQWEsQ0FBQzlOLEtBQTFCLENBQWQ7O0FBQ0EsVUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDVjtBQUNBLGVBQU9ULGFBQVA7QUFDRDs7QUFFRCxhQUFPOE8sT0FBTyxDQUFDRSxvQkFBUixDQUE2QnZPLEtBQTdCLEVBQW9DeU4sU0FBcEMsS0FBa0RsTyxhQUF6RDtBQUNEOzs7V0FFRCwwQkFBaUJpUCxVQUFqQixFQUE2QjtBQUMzQixhQUFPLEtBQUtDLGNBQUwsQ0FBb0JELFVBQXBCLEtBQW1DQSxVQUFVLENBQUN4SSxNQUE5QyxHQUF1RHdJLFVBQVUsQ0FBQ3hJLE1BQWxFLEdBQTJFLElBQWxGO0FBQ0Q7OztXQUVELHdCQUFld0ksVUFBZixFQUFvQztBQUFBOztBQUNsQyxhQUFPLENBQUFBLFVBQVUsU0FBVixJQUFBQSxVQUFVLFdBQVYsWUFBQUEsVUFBVSxDQUFFRSxNQUFaLEtBQXNCLENBQUFGLFVBQVUsU0FBVixJQUFBQSxVQUFVLFdBQVYsaUNBQUFBLFVBQVUsQ0FBRUcsS0FBWixpR0FBbUI1TixLQUFuQixnRkFBMEJDLEVBQTFCLE1BQWlDLEtBQUtBLEVBQW5FO0FBQ0Q7OztXQUVELDhCQUFxQjROLFFBQXJCLEVBQXlDQyxXQUF6QyxFQUFnRTtBQUM5RCxVQUFNQyxhQUFhLEdBQUd4TyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxLQUFLb0UsY0FBbkIsRUFBbUMrRSxJQUFuQyxDQUF3QyxVQUFBcUYsRUFBRTtBQUFBLGVBQUlBLEVBQUUsQ0FBQ25OLFFBQUgsS0FBZ0IsUUFBcEI7QUFBQSxPQUExQyxDQUF0Qjs7QUFFQSxVQUFJLENBQUNrTixhQUFMLEVBQW9CO0FBQ2xCLGVBQU8sQ0FBUDtBQUNEOztBQUVELFVBQU05TyxLQUFLLEdBQUc4TyxhQUFhLENBQUM5TyxLQUE1QjtBQUNBLFVBQU1pTCxLQUFLLEdBQUc0RCxXQUFXLEtBQUtoSyxTQUFoQixHQUE0QixLQUFLMUQsTUFBTCxDQUFZK0MsU0FBWixDQUFzQjJLLFdBQWxELEdBQWdFQSxXQUE5RTtBQVI4RCxVQVN2REcsTUFUdUQsR0FTN0MsS0FBSzdOLE1BQUwsQ0FBWStDLFNBVGlDLENBU3ZEOEssTUFUdUQ7QUFXOUQsYUFBTy9ELEtBQUssR0FBRyxDQUFILEdBQU8sQ0FBQyxLQUFLOUosTUFBTCxDQUFZbkIsS0FBWixJQUFxQixDQUFyQixHQUF5QmdQLE1BQTFCLElBQW9DLEtBQUtDLGFBQUwsQ0FBbUJMLFFBQW5CLENBQXZEO0FBQ0Q7OztXQUVELGtDQUF5QjdOLEtBQXpCLEVBQTBDO0FBQUE7O0FBQ3hDLGFBQU9BLEtBQUssQ0FBQ3NJLElBQU4sQ0FBVyxVQUFBN0IsQ0FBQztBQUFBLGVBQUksQ0FBQyxNQUFJLENBQUMwSCwyQkFBTCxDQUFpQ2hJLFFBQWpDLENBQTBDTSxDQUExQyxDQUFMO0FBQUEsT0FBWixDQUFQO0FBQ0Q7OztXQUVELG1DQUEwQjJILGlCQUExQixFQUE2Q0MsY0FBN0MsRUFBOEQ7QUFBQSxVQUNyREMsS0FEcUQsR0FDNUNGLGlCQUQ0QyxDQUNyREUsS0FEcUQ7QUFHNUQsYUFBTztBQUNMO0FBQ0FDLFFBQUFBLGFBQWEsRUFBRSxDQUFDRCxLQUFLLENBQUM1SyxPQUZqQjtBQUdMOEssUUFBQUEsY0FBYyxFQUFFRixLQUFLLENBQUNsTyxNQUFOLENBQWFtQixJQUFiLEdBQW9CLElBSC9CO0FBSUw4TSxRQUFBQSxjQUFjLEVBQUVBLGNBQWMsSUFBSSxRQUo3QjtBQUtMSSxRQUFBQSxlQUFlLEVBQUVILEtBQUssQ0FBQzVLO0FBTGxCLE9BQVA7QUFPRDs7O1dBRUQsMENBVUc7QUFBQSxVQVREZ0wsR0FTQyxVQVREQSxHQVNDO0FBQUEsVUFSREMsU0FRQyxVQVJEQSxTQVFDO0FBQUEsVUFQRGQsUUFPQyxVQVBEQSxRQU9DO0FBQUEsVUFORGUsT0FNQyxVQU5EQSxPQU1DO0FBQ0QsYUFBTztBQUNMM08sUUFBQUEsRUFBRSxFQUFFLEtBQUtBLEVBREo7QUFFTHlPLFFBQUFBLEdBQUcsRUFBSEEsR0FGSztBQUdMRyxRQUFBQSxnQkFBZ0IsRUFBRUMsd0JBQWtCQyxNQUgvQjtBQUlMQyxRQUFBQSxRQUFRLEVBQUUsSUFKTDtBQUtMQyxRQUFBQSxhQUFhLEVBQUUsSUFMVjtBQU1MQyxRQUFBQSxVQUFVLEVBQUU7QUFBQ0MsVUFBQUEsU0FBUyxFQUFFL0csT0FBTyxDQUFDeUYsUUFBUSxDQUFDdUIsVUFBVCxJQUF1QixLQUFLaFAsTUFBTCxDQUFZK0MsU0FBWixDQUFzQmtNLFFBQTlDO0FBQW5CLFNBTlA7QUFPTDVNLFFBQUFBLE1BQU0sRUFBRSxLQUFLckMsTUFBTCxDQUFZcUMsTUFQZjtBQVFMO0FBQ0E2TSxRQUFBQSxPQUFPLEVBQUUsS0FBS2xQLE1BQUwsQ0FBWStDLFNBQVosQ0FBc0JtTSxPQVQxQjtBQVVML00sUUFBQUEsY0FBYyxFQUFFLEtBQUtuQyxNQUFMLENBQVltQyxjQVZ2QjtBQVdMO0FBQ0FnTixRQUFBQSxVQUFVLEVBQUUsQ0FBQzlRLG1CQUFELENBWlA7QUFhTCtRLFFBQUFBLFdBQVcsRUFBRWIsU0FBUyxHQUFHQSxTQUFTLENBQUNhLFdBQWIsR0FBMkIxTCxTQWI1QztBQWVMO0FBQ0E4SyxRQUFBQSxPQUFPLEVBQUUsS0FBS3hPLE1BQUwsQ0FBWWlDLFNBQVosSUFBeUJ1TTtBQWhCN0IsT0FBUDtBQWtCRDs7O1dBRUQscUNBQTRCO0FBQzFCLGFBQU87QUFDTDNPLFFBQUFBLEVBQUUsWUFBSyxLQUFLQSxFQUFWLGFBREc7QUFFTCtPLFFBQUFBLFFBQVEsRUFBRSxLQUZMO0FBR0xDLFFBQUFBLGFBQWEsRUFBRSxJQUhWO0FBSUxKLFFBQUFBLGdCQUFnQixFQUFFQyx3QkFBa0JDO0FBSi9CLE9BQVA7QUFNRDs7O1dBRUQsc0NBY0VVLFVBZEYsRUFlRTtBQUFBOztBQUFBLFVBYkU3RSxXQWFGLFVBYkVBLFdBYUY7QUFBQSxVQVpFOEUsY0FZRixVQVpFQSxjQVlGO0FBQUEsVUFYRUMsZUFXRixVQVhFQSxlQVdGO0FBQUEsVUFWRXBDLGNBVUYsVUFWRUEsY0FVRjtBQUFBLFVBVEVxQyxXQVNGLFVBVEVBLFdBU0Y7QUFBQSxVQUNPN0csSUFEUCxHQUN5QjBHLFVBRHpCLENBQ08xRyxJQURQO0FBQUEsVUFDYThFLFFBRGIsR0FDeUI0QixVQUR6QixDQUNhNUIsUUFEYjtBQUFBLFVBRU96SyxTQUZQLEdBRW9CLEtBQUtoRCxNQUZ6QixDQUVPZ0QsU0FGUDtBQUlBLGFBQU8yRixJQUFJLENBQUM4RyxVQUFMLENBQWdCL0ksTUFBaEIsQ0FBdUIsVUFBQ0MsSUFBRCxFQUFPaEksQ0FBUCxFQUFVaU4sQ0FBVixFQUFnQjtBQUM1QyxZQUFJak4sQ0FBQyxDQUFDK1EsT0FBTixFQUFlO0FBQUE7O0FBQ2IsY0FBTUMsVUFBVSxHQUFHM00sU0FBUyxDQUFDNEksQ0FBRCxDQUFULENBQWErRCxVQUFiLEtBQTJCSixlQUEzQixhQUEyQkEsZUFBM0IsdUJBQTJCQSxlQUFlLENBQUVJLFVBQTVDLENBQW5CO0FBRUFoSixVQUFBQSxJQUFJLENBQUNuQixJQUFMLENBQ0UsSUFBSW9LLGlCQUFKLGlDQUNLSixXQURMO0FBRUUzUCxZQUFBQSxFQUFFLFlBQUssTUFBSSxDQUFDQSxFQUFWLDBDQUFzQm1ELFNBQVMsQ0FBQzRJLENBQUQsQ0FBVCxDQUFhL00sS0FBbkMsdURBQXNCLG1CQUFvQmlGLElBQTFDLENBRko7QUFHRTZFLFlBQUFBLElBQUksRUFBRUEsSUFBSSxDQUFDQSxJQUhiO0FBSUU2RixZQUFBQSxPQUFPLEVBQUUsTUFBSSxDQUFDeE8sTUFBTCxDQUFZaUMsU0FKdkI7QUFLRXlOLFlBQUFBLE9BQU8sRUFBRS9RLENBQUMsQ0FBQytRLE9BTGI7QUFNRWxGLFlBQUFBLFdBQVcsRUFBWEEsV0FORjtBQU9FcUYsWUFBQUEsWUFBWSxFQUFFbFIsQ0FBQyxDQUFDa1IsWUFQbEI7QUFRRVAsWUFBQUEsY0FBYyxFQUFFQSxjQUFjLENBQUN0TSxTQUFTLENBQUM0SSxDQUFELENBQVYsQ0FSaEM7QUFTRWtFLFlBQUFBLE9BQU8sRUFBRUMsMENBVFg7QUFVRW5OLFlBQUFBLFNBQVMsRUFBRUksU0FBUyxDQUFDNEksQ0FBRCxDQUFULENBQWF6SyxJQVYxQjtBQVdFNk8sWUFBQUEsYUFBYSxFQUFFaE4sU0FBUyxDQUFDNEksQ0FBRCxDQUFULENBQWFxRSxNQVg5QjtBQVlFQyxZQUFBQSxvQkFBb0IsRUFBRWxOLFNBQVMsQ0FBQzRJLENBQUQsQ0FBVCxDQUFhdUUsU0FackM7QUFhRUMsWUFBQUEsUUFBUSxFQUFFcE4sU0FBUyxDQUFDNEksQ0FBRCxDQUFULENBQWFwTCxLQWJ6QjtBQWNFNlAsWUFBQUEsWUFBWSxFQUFFck4sU0FBUyxDQUFDNEksQ0FBRCxDQUFULENBQWF5RSxZQUFiLEdBQTRCQyxrQ0FkNUM7QUFlRUMsWUFBQUEsWUFBWSxFQUFFdk4sU0FBUyxDQUFDNEksQ0FBRCxDQUFULENBQWEyRSxZQWY3QjtBQWdCRVosWUFBQUEsVUFBVSxFQUFWQSxVQWhCRjtBQWlCRWEsWUFBQUEsa0JBQWtCLEVBQUV4TixTQUFTLENBQUM0SSxDQUFELENBQVQsQ0FBYTZFLGVBakJuQztBQWtCRUMsWUFBQUEsWUFBWSxFQUFFO0FBQ1pDLGNBQUFBLEdBQUcsRUFBRTNOLFNBQVMsQ0FBQzRJLENBQUQsQ0FBVCxDQUFheUUsWUFBYixHQUE0QjtBQURyQixhQWxCaEI7QUFxQkV2QixZQUFBQSxVQUFVLEVBQUU7QUFDVjtBQUNBQyxjQUFBQSxTQUFTLEVBQUU7QUFGRCxhQXJCZDtBQTBCRTZCLFlBQUFBLGNBQWMsRUFBRWpJLElBQUksQ0FBQ2lJLGNBMUJ2QjtBQTJCRXpELFlBQUFBLGNBQWMsa0NBQ1RBLGNBRFM7QUFFWnVDLGNBQUFBLE9BQU8seUJBQUUxTSxTQUFTLENBQUM0SSxDQUFELENBQVQsQ0FBYS9NLEtBQWYsd0RBQUUsb0JBQW9CaUYsSUFGakI7QUFHWndMLGNBQUFBLGNBQWMsa0NBQ1RuQyxjQUFjLENBQUMwRCxTQUROO0FBRVpwRCxnQkFBQUEsUUFBUSxFQUFSQSxRQUZZO0FBR1p3QyxnQkFBQUEsTUFBTSxFQUFFak4sU0FBUyxDQUFDNEksQ0FBRCxDQUFULENBQWFxRSxNQUhUO0FBSVpFLGdCQUFBQSxTQUFTLEVBQUVuTixTQUFTLENBQUM0SSxDQUFELENBQVQsQ0FBYXVFO0FBSlosZ0JBSEY7QUFTWkgsY0FBQUEsYUFBYSxFQUFFaE4sU0FBUyxDQUFDNEksQ0FBRCxDQUFULENBQWFxRSxNQVRoQjtBQVVaQyxjQUFBQSxvQkFBb0IsRUFBRWxOLFNBQVMsQ0FBQzRJLENBQUQsQ0FBVCxDQUFhdUUsU0FWdkI7QUFXWkMsY0FBQUEsUUFBUSxFQUFFcE4sU0FBUyxDQUFDNEksQ0FBRCxDQUFULENBQWFwTDtBQVhYLGNBM0JoQjtBQXdDRXNRLFlBQUFBLGNBQWMsb0JBQ1JuQixVQUFVLEdBQ1Y7QUFDRUEsY0FBQUEsVUFBVSxFQUFFO0FBQ1ZiLGdCQUFBQSxVQUFVLEVBQUU7QUFDVmlDLGtCQUFBQSxJQUFJLEVBQUU7QUFESTtBQURGO0FBRGQsYUFEVSxHQVFWLElBVFE7QUF4Q2hCLGFBREY7QUFzREQ7O0FBQ0QsZUFBT3BLLElBQVA7QUFDRCxPQTVETSxFQTRESixFQTVESSxDQUFQO0FBNkREOzs7V0FFRCxnQ0FBdUJxSyxXQUF2QixFQUFpRHhHLFdBQWpELEVBQW1FO0FBQ2pFO0FBQ0EsYUFBTyxFQUFQO0FBQ0Q7OztXQUVELHlCQUFnQjFGLGFBQWhCLEVBQXVEMEYsV0FBdkQsRUFBb0UsQ0FDbEU7QUFDRDs7O1dBRUQsNkJBQW9CMUYsYUFBcEIsRUFBcUY7QUFDbkY7QUFDQSxhQUFPO0FBQUEsZUFBTSxJQUFOO0FBQUEsT0FBUDtBQUNEOzs7V0F6aENELCtCQUNFb0ksT0FERixFQUVFK0QsV0FGRixFQUdvQztBQUNsQyxhQUFPO0FBQUNyUixRQUFBQSxLQUFLLEVBQUUsRUFBUjtBQUFZcVIsUUFBQUEsV0FBVyxFQUFYQTtBQUFaLE9BQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FDRSxnQ0FBOEJDLGFBQTlCLEVBQTZDQyxTQUE3QyxFQUF3RDtBQUN0RDtBQUNBLFVBQU1DLGVBQWUsR0FBR2pTLE1BQU0sQ0FBQzBHLElBQVAsQ0FBWXFMLGFBQVosRUFBMkJ4SyxNQUEzQixDQUFrQyxVQUFDMkssSUFBRCxFQUFPeFEsR0FBUCxFQUFlO0FBQ3ZFLFlBQU15USxjQUFjLEdBQUdILFNBQVMsQ0FBQzlJLE1BQVYsQ0FDckIsVUFBQWtKLENBQUM7QUFBQSxpQkFBSUEsQ0FBQyxDQUFDek4sSUFBRixLQUFXb04sYUFBYSxDQUFDclEsR0FBRCxDQUF4QixJQUFpQ3FRLGFBQWEsQ0FBQ3JRLEdBQUQsQ0FBYixDQUFtQmtGLFFBQW5CLENBQTRCd0wsQ0FBQyxDQUFDek4sSUFBOUIsQ0FBckM7QUFBQSxTQURvQixDQUF2QjtBQUlBdU4sUUFBQUEsSUFBSSxDQUFDeFEsR0FBRCxDQUFKLEdBQVl5USxjQUFjLENBQUM3UixNQUFmLEdBQ1I2UixjQUFjLENBQUNoUyxHQUFmLENBQW1CLFVBQUFpUyxDQUFDO0FBQUEsaUJBQUs7QUFDdkJ2UCxZQUFBQSxLQUFLLEVBQUV1UCxDQUFDLENBQUN6TixJQURjO0FBRXZCRyxZQUFBQSxRQUFRLEVBQUVzTixDQUFDLENBQUN0TjtBQUZXLFdBQUw7QUFBQSxTQUFwQixDQURRLEdBS1IsSUFMSjtBQU1BLGVBQU9vTixJQUFQO0FBQ0QsT0FadUIsRUFZckIsRUFacUIsQ0FBeEI7O0FBY0EsVUFBSSxDQUFDbFMsTUFBTSxDQUFDQyxNQUFQLENBQWNnUyxlQUFkLEVBQStCaEwsS0FBL0IsQ0FBcUM0QixPQUFyQyxDQUFMLEVBQW9EO0FBQ2xEO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQsYUFBTyxLQUFLd0oseUJBQUwsQ0FBK0JKLGVBQS9CLENBQVA7QUFDRDs7O1dBRUQsbUNBQWlDQSxlQUFqQyxFQUFrRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxVQUFNSyxPQUFPLEdBQUd0UyxNQUFNLENBQUMwRyxJQUFQLENBQVl1TCxlQUFaLENBQWhCO0FBQ0EsVUFBTU0sUUFBUSxHQUFHRCxPQUFPLENBQUNuUyxHQUFSLENBQVksVUFBQzhKLENBQUQsRUFBSXdDLENBQUo7QUFBQSxlQUFXQSxDQUFDLEtBQUs2RixPQUFPLENBQUNoUyxNQUFSLEdBQWlCLENBQXZCLEdBQTJCLENBQUMsQ0FBNUIsR0FBZ0MsQ0FBM0M7QUFBQSxPQUFaLENBQWpCO0FBQ0EsVUFBTWtTLFdBQVcsR0FBR0YsT0FBTyxDQUFDblMsR0FBUixDQUFZLFVBQUE4SixDQUFDO0FBQUEsZUFBSWdJLGVBQWUsQ0FBQ2hJLENBQUQsQ0FBZixDQUFtQjNKLE1BQXZCO0FBQUEsT0FBYixDQUFwQixDQU5nRCxDQU9oRDs7QUFDQSxVQUFNbVMsS0FBWSxHQUFHLEVBQXJCO0FBRUE7O0FBQ0EsYUFBT0MsaUJBQWlCLENBQUNILFFBQUQsRUFBV0MsV0FBWCxFQUF3QkQsUUFBUSxDQUFDalMsTUFBVCxHQUFrQixDQUExQyxDQUF4QixFQUFzRTtBQUNwRSxZQUFNcVMsT0FBTyxHQUFHSixRQUFRLENBQUNoTCxNQUFULENBQWdCLFVBQUMySyxJQUFELEVBQU9VLElBQVAsRUFBYW5HLENBQWIsRUFBbUI7QUFDakR5RixVQUFBQSxJQUFJLENBQUNJLE9BQU8sQ0FBQzdGLENBQUQsQ0FBUixDQUFKLEdBQW1Cd0YsZUFBZSxDQUFDSyxPQUFPLENBQUM3RixDQUFELENBQVIsQ0FBZixDQUE0Qm1HLElBQTVCLENBQW5CO0FBQ0EsaUJBQU9WLElBQVA7QUFDRCxTQUhlLEVBR2IsRUFIYSxDQUFoQjtBQUtBTyxRQUFBQSxLQUFLLENBQUNwTSxJQUFOLENBQVdzTSxPQUFYO0FBQ0Q7QUFDRDtBQUVBOzs7QUFDQSxlQUFTRCxpQkFBVCxDQUEyQkcsR0FBM0IsRUFBZ0NDLE1BQWhDLEVBQXdDelMsS0FBeEMsRUFBK0M7QUFDN0MsWUFBSUEsS0FBSyxLQUFLLENBQVYsSUFBZXdTLEdBQUcsQ0FBQyxDQUFELENBQUgsS0FBV0MsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZLENBQTFDLEVBQTZDO0FBQzNDO0FBQ0EsaUJBQU8sS0FBUDtBQUNEOztBQUVELFlBQUlELEdBQUcsQ0FBQ3hTLEtBQUQsQ0FBSCxHQUFhLENBQWIsR0FBaUJ5UyxNQUFNLENBQUN6UyxLQUFELENBQTNCLEVBQW9DO0FBQ2xDd1MsVUFBQUEsR0FBRyxDQUFDeFMsS0FBRCxDQUFILEdBQWF3UyxHQUFHLENBQUN4UyxLQUFELENBQUgsR0FBYSxDQUExQjtBQUNBLGlCQUFPLElBQVA7QUFDRDs7QUFFRHdTLFFBQUFBLEdBQUcsQ0FBQ3hTLEtBQUQsQ0FBSCxHQUFhLENBQWI7QUFDQSxlQUFPcVMsaUJBQWlCLENBQUNHLEdBQUQsRUFBTUMsTUFBTixFQUFjelMsS0FBSyxHQUFHLENBQXRCLENBQXhCO0FBQ0Q7O0FBRUQsYUFBT29TLEtBQVA7QUFDRDs7O1dBRUQsa0JBQWdCTSxDQUFoQixFQUFtQjtBQUNqQixhQUFPLHFCQUFTQSxDQUFULENBQVA7QUFDRDs7Ozs7ZUEyOEJZdlMsSyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge2NvbnNvbGUgYXMgQ29uc29sZX0gZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5pbXBvcnQga2V5bWlycm9yIGZyb20gJ2tleW1pcnJvcic7XG5pbXBvcnQge0RhdGFGaWx0ZXJFeHRlbnNpb259IGZyb20gJ0BkZWNrLmdsL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQge1RleHRMYXllcn0gZnJvbSAnQGRlY2suZ2wvbGF5ZXJzJztcblxuaW1wb3J0IERlZmF1bHRMYXllckljb24gZnJvbSAnLi9kZWZhdWx0LWxheWVyLWljb24nO1xuaW1wb3J0IHtkaWZmVXBkYXRlVHJpZ2dlcnN9IGZyb20gJy4vbGF5ZXItdXBkYXRlJztcblxuaW1wb3J0IHtcbiAgQUxMX0ZJRUxEX1RZUEVTLFxuICBOT19WQUxVRV9DT0xPUixcbiAgU0NBTEVfVFlQRVMsXG4gIENIQU5ORUxfU0NBTEVTLFxuICBGSUVMRF9PUFRTLFxuICBTQ0FMRV9GVU5DLFxuICBDSEFOTkVMX1NDQUxFX1NVUFBPUlRFRF9GSUVMRFMsXG4gIE1BWF9HUFVfRklMVEVSUyxcbiAgQ29sb3JSYW5nZSxcbiAgQ09MT1JfUkFOR0VTLFxuICBEYXRhVml6Q29sb3JzLFxuICBMQVlFUl9WSVNfQ09ORklHUyxcbiAgREVGQVVMVF9URVhUX0xBQkVMLFxuICBERUZBVUxUX0NPTE9SX1VJLFxuICBVTktOT1dOX0NPTE9SX0tFWSxcbiAgREVGQVVMVF9ISUdITElHSFRfQ09MT1IsXG4gIERFRkFVTFRfTEFZRVJfTEFCRUwsXG4gIFBST0pFQ1RFRF9QSVhFTF9TSVpFX01VTFRJUExJRVIsXG4gIFRFWFRfT1VUTElORV9NVUxUSVBMSUVSXG59IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcblxuaW1wb3J0IHtcbiAgZ2VuZXJhdGVIYXNoSWQsXG4gIGdldENvbG9yR3JvdXBCeU5hbWUsXG4gIHJldmVyc2VDb2xvclJhbmdlLFxuICBoZXhUb1JnYixcbiAgZ2V0TGF0TG5nQm91bmRzLFxuICBpc1BsYWluT2JqZWN0LFxuICBub3ROdWxsb3JVbmRlZmluZWQsXG4gIERhdGFDb250YWluZXJJbnRlcmZhY2UsXG4gIGdldFNhbXBsZUNvbnRhaW5lckRhdGFcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5cbmltcG9ydCB7XG4gIFJHQkNvbG9yLFxuICBSR0JBQ29sb3IsXG4gIFZhbHVlT2YsXG4gIE5lc3RlZFBhcnRpYWwsXG4gIExheWVyVGV4dExhYmVsLFxuICBDb2xvclVJLFxuICBMYXllclZpc0NvbmZpZyxcbiAgTGF5ZXJWaXNDb25maWdTZXR0aW5ncyxcbiAgRmllbGQsXG4gIE1hcFN0YXRlLFxuICBGaWx0ZXJcbn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0tlcGxlclRhYmxlLCBEYXRhc2V0cywgR3B1RmlsdGVyfSBmcm9tICdAa2VwbGVyLmdsL3RhYmxlJztcblxuZXhwb3J0IHR5cGUgTGF5ZXJDb2x1bW4gPSB7dmFsdWU6IHN0cmluZyB8IG51bGw7IGZpZWxkSWR4OiBudW1iZXI7IG9wdGlvbmFsPzogYm9vbGVhbn07XG5cbmV4cG9ydCB0eXBlIExheWVyQ29sdW1ucyA9IHtcbiAgW2tleTogc3RyaW5nXTogTGF5ZXJDb2x1bW47XG59O1xuZXhwb3J0IHR5cGUgVmlzdWFsQ2hhbm5lbERvbWFpbiA9IG51bWJlcltdIHwgc3RyaW5nW107XG5leHBvcnQgdHlwZSBWaXN1YWxDaGFubmVsRmllbGQgPSBGaWVsZCB8IG51bGw7XG5leHBvcnQgdHlwZSBWaXN1YWxDaGFubmVsU2NhbGUgPSBrZXlvZiB0eXBlb2YgU0NBTEVfVFlQRVM7XG5cbmV4cG9ydCB0eXBlIExheWVyQmFzZUNvbmZpZyA9IHtcbiAgZGF0YUlkOiBzdHJpbmc7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIGNvbG9yOiBSR0JDb2xvcjtcblxuICBjb2x1bW5zOiBMYXllckNvbHVtbnM7XG4gIGlzVmlzaWJsZTogYm9vbGVhbjtcbiAgaXNDb25maWdBY3RpdmU6IGJvb2xlYW47XG4gIGhpZ2hsaWdodENvbG9yOiBSR0JDb2xvciB8IFJHQkFDb2xvcjtcbiAgaGlkZGVuOiBib29sZWFuO1xuXG4gIHZpc0NvbmZpZzogTGF5ZXJWaXNDb25maWc7XG4gIHRleHRMYWJlbDogTGF5ZXJUZXh0TGFiZWxbXTtcblxuICBjb2xvclVJOiB7XG4gICAgY29sb3I6IENvbG9yVUk7XG4gICAgY29sb3JSYW5nZTogQ29sb3JVSTtcbiAgfTtcbiAgYW5pbWF0aW9uOiB7XG4gICAgZW5hYmxlZDogYm9vbGVhbjtcbiAgICBkb21haW4/OiBudWxsO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgTGF5ZXJCYXNlQ29uZmlnUGFydGlhbCA9IHtkYXRhSWQ6IExheWVyQmFzZUNvbmZpZ1snZGF0YUlkJ119ICYgUGFydGlhbDxMYXllckJhc2VDb25maWc+O1xuXG5leHBvcnQgdHlwZSBMYXllckNvbG9yQ29uZmlnID0ge1xuICBjb2xvckZpZWxkOiBWaXN1YWxDaGFubmVsRmllbGQ7XG4gIGNvbG9yRG9tYWluOiBWaXN1YWxDaGFubmVsRG9tYWluO1xuICBjb2xvclNjYWxlOiBWaXN1YWxDaGFubmVsU2NhbGU7XG59O1xuZXhwb3J0IHR5cGUgTGF5ZXJTaXplQ29uZmlnID0ge1xuICAvLyBjb2xvciBieSBzaXplLCBkb21haW4gaXMgc2V0IGJ5IGZpbHRlcnMsIGZpZWxkLCBzY2FsZSB0eXBlXG4gIHNpemVEb21haW46IFZpc3VhbENoYW5uZWxEb21haW47XG4gIHNpemVTY2FsZTogVmlzdWFsQ2hhbm5lbFNjYWxlO1xuICBzaXplRmllbGQ6IFZpc3VhbENoYW5uZWxGaWVsZDtcbn07XG5leHBvcnQgdHlwZSBMYXllckhlaWdodENvbmZpZyA9IHtcbiAgaGVpZ2h0RmllbGQ6IFZpc3VhbENoYW5uZWxGaWVsZDtcbiAgaGVpZ2h0RG9tYWluOiBWaXN1YWxDaGFubmVsRG9tYWluO1xuICBoZWlnaHRTY2FsZTogVmlzdWFsQ2hhbm5lbFNjYWxlO1xufTtcbmV4cG9ydCB0eXBlIExheWVyU3Ryb2tlQ29sb3JDb25maWcgPSB7XG4gIHN0cm9rZUNvbG9yRmllbGQ6IFZpc3VhbENoYW5uZWxGaWVsZDtcbiAgc3Ryb2tlQ29sb3JEb21haW46IFZpc3VhbENoYW5uZWxEb21haW47XG4gIHN0cm9rZUNvbG9yU2NhbGU6IFZpc3VhbENoYW5uZWxTY2FsZTtcbn07XG5leHBvcnQgdHlwZSBMYXllckNvdmVyYWdlQ29uZmlnID0ge1xuICBjb3ZlcmFnZUZpZWxkOiBWaXN1YWxDaGFubmVsRmllbGQ7XG4gIGNvdmVyYWdlRG9tYWluOiBWaXN1YWxDaGFubmVsRG9tYWluO1xuICBjb3ZlcmFnZVNjYWxlOiBWaXN1YWxDaGFubmVsU2NhbGU7XG59O1xuZXhwb3J0IHR5cGUgTGF5ZXJSYWRpdXNDb25maWcgPSB7XG4gIHJhZGl1c0ZpZWxkOiBWaXN1YWxDaGFubmVsRmllbGQ7XG4gIHJhZGl1c0RvbWFpbjogVmlzdWFsQ2hhbm5lbERvbWFpbjtcbiAgcmFkaXVzU2NhbGU6IFZpc3VhbENoYW5uZWxTY2FsZTtcbn07XG5leHBvcnQgdHlwZSBMYXllcldlaWdodENvbmZpZyA9IHtcbiAgd2VpZ2h0RmllbGQ6IFZpc3VhbENoYW5uZWxGaWVsZDtcbn07XG5cbmV4cG9ydCB0eXBlIFZpc3VhbENoYW5uZWxzID0ge1trZXk6IHN0cmluZ106IFZpc3VhbENoYW5uZWx9O1xuXG5leHBvcnQgdHlwZSBWaXN1YWxDaGFubmVsQWdncmVnYXRpb24gPSAnY29sb3JBZ2dyZWdhdGlvbicgfCAnc2l6ZUFnZ3JlZ2F0aW9uJztcblxuZXhwb3J0IHR5cGUgVmlzdWFsQ2hhbm5lbCA9IHtcbiAgcHJvcGVydHk6IHN0cmluZztcbiAgZmllbGQ6IHN0cmluZztcbiAgc2NhbGU6IHN0cmluZztcbiAgZG9tYWluOiBzdHJpbmc7XG4gIHJhbmdlOiBzdHJpbmc7XG4gIGtleTogc3RyaW5nO1xuICBjaGFubmVsU2NhbGVUeXBlOiBzdHJpbmc7XG4gIG51bGxWYWx1ZT86IGFueTtcbiAgZGVmYXVsdE1lYXN1cmU/OiBhbnk7XG4gIGFjY2Vzc29yPzogc3RyaW5nO1xuICBjb25kaXRpb24/OiAoY29uZmlnOiBhbnkpID0+IGJvb2xlYW47XG4gIGRlZmF1bHRWYWx1ZT86ICgoY29uZmlnOiBhbnkpID0+IGFueSkgfCBhbnk7XG4gIGdldEF0dHJpYnV0ZVZhbHVlPzogKGNvbmZpZzogYW55KSA9PiAoZDogYW55KSA9PiBhbnk7XG5cbiAgLy8gVE9ETzogZGVmaW5lIGZpeGVkXG4gIGZpeGVkPzogYW55O1xuXG4gIHN1cHBvcnRlZEZpZWxkVHlwZXM/OiBBcnJheTxrZXlvZiB0eXBlb2YgQUxMX0ZJRUxEX1RZUEVTPjtcblxuICBhZ2dyZWdhdGlvbj86IFZpc3VhbENoYW5uZWxBZ2dyZWdhdGlvbjtcbn07XG5cbmV4cG9ydCB0eXBlIFZpc3VhbENoYW5uZWxEZXNjcmlwdGlvbiA9IHtcbiAgbGFiZWw6IHN0cmluZztcbiAgbWVhc3VyZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IHR5cGUgQ29sdW1uUGFpciA9IHtcbiAgcGFpcjogc3RyaW5nO1xuICBmaWVsZFBhaXJLZXk6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIENvbHVtblBhaXJzID0ge1trZXk6IHN0cmluZ106IENvbHVtblBhaXJ9O1xuXG50eXBlIENvbHVtblZhbGlkYXRvciA9IChjb2x1bW46IExheWVyQ29sdW1uLCBjb2x1bW5zOiBMYXllckNvbHVtbnMsIGFsbEZpZWxkczogRmllbGRbXSkgPT4gYm9vbGVhbjtcblxuZXhwb3J0IHR5cGUgVXBkYXRlVHJpZ2dlcnMgPSB7XG4gIFtrZXk6IHN0cmluZ106IFVwZGF0ZVRyaWdnZXI7XG59O1xuZXhwb3J0IHR5cGUgVXBkYXRlVHJpZ2dlciA9IHtcbiAgW2tleTogc3RyaW5nXToge307XG59O1xuZXhwb3J0IHR5cGUgTGF5ZXJCb3VuZHMgPSBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbmV4cG9ydCB0eXBlIEZpbmREZWZhdWx0TGF5ZXJQcm9wc1JldHVyblZhbHVlID0ge3Byb3BzOiBhbnlbXTsgZm91bmRMYXllcnM/OiBhbnlbXX07XG4vKipcbiAqIEFwcHJveC4gbnVtYmVyIG9mIHBvaW50cyB0byBzYW1wbGUgaW4gYSBsYXJnZSBkYXRhIHNldFxuICovXG5leHBvcnQgY29uc3QgTEFZRVJfSURfTEVOR1RIID0gNjtcblxuY29uc3QgTUFYX1NBTVBMRV9TSVpFID0gNTAwMDtcbmNvbnN0IGRlZmF1bHREb21haW46IFtudW1iZXIsIG51bWJlcl0gPSBbMCwgMV07XG5jb25zdCBkYXRhRmlsdGVyRXh0ZW5zaW9uID0gbmV3IERhdGFGaWx0ZXJFeHRlbnNpb24oe2ZpbHRlclNpemU6IE1BWF9HUFVfRklMVEVSU30pO1xuXG5jb25zdCBkZWZhdWx0RGF0YUFjY2Vzc29yID0gZGMgPT4gZCA9PiBkO1xuY29uc3QgZGVmYXVsdEdldEZpZWxkVmFsdWUgPSAoZmllbGQsIGQpID0+IGZpZWxkLnZhbHVlQWNjZXNzb3IoZCk7XG5cbmV4cG9ydCBjb25zdCBPVkVSTEFZX1RZUEVfQ09OU1QgPSBrZXltaXJyb3Ioe1xuICBkZWNrZ2w6IG51bGwsXG4gIG1hcGJveGdsOiBudWxsXG59KTtcblxuZXhwb3J0IGNvbnN0IGxheWVyQ29sb3JzID0gT2JqZWN0LnZhbHVlcyhEYXRhVml6Q29sb3JzKS5tYXAoaGV4VG9SZ2IpO1xuZnVuY3Rpb24qIGdlbmVyYXRlQ29sb3IoKTogR2VuZXJhdG9yPFJHQkNvbG9yPiB7XG4gIGxldCBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IGxheWVyQ29sb3JzLmxlbmd0aCArIDEpIHtcbiAgICBpZiAoaW5kZXggPT09IGxheWVyQ29sb3JzLmxlbmd0aCkge1xuICAgICAgaW5kZXggPSAwO1xuICAgIH1cbiAgICB5aWVsZCBsYXllckNvbG9yc1tpbmRleCsrXTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY29sb3JNYWtlciA9IGdlbmVyYXRlQ29sb3IoKTtcblxuZXhwb3J0IHR5cGUgQmFzZUxheWVyQ29uc3RydWN0b3JQcm9wcyA9IHtcbiAgaWQ/OiBzdHJpbmc7XG59ICYgTGF5ZXJCYXNlQ29uZmlnUGFydGlhbDtcblxuY2xhc3MgTGF5ZXIge1xuICBpZDogc3RyaW5nO1xuICBtZXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICB2aXNDb25maWdTZXR0aW5nczoge1xuICAgIFtrZXk6IHN0cmluZ106IFZhbHVlT2Y8TGF5ZXJWaXNDb25maWdTZXR0aW5ncz47XG4gIH07XG4gIGNvbmZpZzogTGF5ZXJCYXNlQ29uZmlnO1xuICAvLyBUT0RPOiBkZWZpbmUgX29sZERhdGFVcGRhdGVUcmlnZ2Vyc1xuICBfb2xkRGF0YVVwZGF0ZVRyaWdnZXJzOiBhbnk7XG5cbiAgaXNWYWxpZDogYm9vbGVhbjtcbiAgZXJyb3JNZXNzYWdlOiBzdHJpbmcgfCBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBCYXNlTGF5ZXJDb25zdHJ1Y3RvclByb3BzKSB7XG4gICAgdGhpcy5pZCA9IHByb3BzLmlkIHx8IGdlbmVyYXRlSGFzaElkKExBWUVSX0lEX0xFTkdUSCk7XG5cbiAgICAvLyBtZXRhXG4gICAgdGhpcy5tZXRhID0ge307XG5cbiAgICAvLyB2aXNDb25maWdTZXR0aW5nc1xuICAgIHRoaXMudmlzQ29uZmlnU2V0dGluZ3MgPSB7fTtcblxuICAgIHRoaXMuY29uZmlnID0gdGhpcy5nZXREZWZhdWx0TGF5ZXJDb25maWcoe1xuICAgICAgY29sdW1uczogdGhpcy5nZXRMYXllckNvbHVtbnMoKSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG5cbiAgICAvLyBmYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbGF5ZXIgY2F1c2VkIGFuIGVycm9yLCBhbmQgd2FzIGRpc2FibGVkXG4gICAgdGhpcy5pc1ZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLmVycm9yTWVzc2FnZSA9IG51bGw7XG4gIH1cblxuICBnZXQgbGF5ZXJJY29uKCk6IFJlYWN0LkVsZW1lbnRUeXBlIHtcbiAgICByZXR1cm4gRGVmYXVsdExheWVySWNvbjtcbiAgfVxuXG4gIGdldCBvdmVybGF5VHlwZSgpOiBrZXlvZiB0eXBlb2YgT1ZFUkxBWV9UWVBFX0NPTlNUIHtcbiAgICByZXR1cm4gT1ZFUkxBWV9UWVBFX0NPTlNULmRlY2tnbDtcbiAgfVxuXG4gIGdldCB0eXBlKCk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldCBpc0FnZ3JlZ2F0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0IHJlcXVpcmVkTGF5ZXJDb2x1bW5zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBnZXQgb3B0aW9uYWxDb2x1bW5zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBnZXQgbm9uZUxheWVyRGF0YUFmZmVjdGluZ1Byb3BzKCkge1xuICAgIHJldHVybiBbJ2xhYmVsJywgJ29wYWNpdHknLCAndGhpY2tuZXNzJywgJ2lzVmlzaWJsZScsICdoaWRkZW4nXTtcbiAgfVxuXG4gIGdldCB2aXN1YWxDaGFubmVscygpOiBWaXN1YWxDaGFubmVscyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHByb3BlcnR5OiAnY29sb3InLFxuICAgICAgICBmaWVsZDogJ2NvbG9yRmllbGQnLFxuICAgICAgICBzY2FsZTogJ2NvbG9yU2NhbGUnLFxuICAgICAgICBkb21haW46ICdjb2xvckRvbWFpbicsXG4gICAgICAgIHJhbmdlOiAnY29sb3JSYW5nZScsXG4gICAgICAgIGtleTogJ2NvbG9yJyxcbiAgICAgICAgY2hhbm5lbFNjYWxlVHlwZTogQ0hBTk5FTF9TQ0FMRVMuY29sb3IsXG4gICAgICAgIG51bGxWYWx1ZTogTk9fVkFMVUVfQ09MT1IsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogY29uZmlnID0+IGNvbmZpZy5jb2xvclxuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgcHJvcGVydHk6ICdzaXplJyxcbiAgICAgICAgZmllbGQ6ICdzaXplRmllbGQnLFxuICAgICAgICBzY2FsZTogJ3NpemVTY2FsZScsXG4gICAgICAgIGRvbWFpbjogJ3NpemVEb21haW4nLFxuICAgICAgICByYW5nZTogJ3NpemVSYW5nZScsXG4gICAgICAgIGtleTogJ3NpemUnLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlOiBDSEFOTkVMX1NDQUxFUy5zaXplLFxuICAgICAgICBudWxsVmFsdWU6IDAsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogMVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBnZXQgY29sdW1uVmFsaWRhdG9ycygpOiB7W2tleTogc3RyaW5nXTogQ29sdW1uVmFsaWRhdG9yfSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIC8qXG4gICAqIENvbHVtbiBwYWlycyBtYXBzIGxheWVyIGNvbHVtbiB0byBhIHNwZWNpZmljIGZpZWxkIHBhaXJzLFxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbnVsbFxuICAgKi9cbiAgZ2V0IGNvbHVtblBhaXJzKCk6IENvbHVtblBhaXJzIHwgbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKlxuICAgKiBEZWZhdWx0IHBvaW50IGNvbHVtbiBwYWlycywgY2FuIGJlIHVzZWQgZm9yIHBvaW50IGJhc2VkIGxheWVyczogcG9pbnQsIGljb24gZXRjLlxuICAgKi9cbiAgZ2V0IGRlZmF1bHRQb2ludENvbHVtblBhaXJzKCk6IENvbHVtblBhaXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGF0OiB7cGFpcjogJ2xuZycsIGZpZWxkUGFpcktleTogJ2xhdCd9LFxuICAgICAgbG5nOiB7cGFpcjogJ2xhdCcsIGZpZWxkUGFpcktleTogJ2xuZyd9XG4gICAgfTtcbiAgfVxuXG4gIC8qXG4gICAqIERlZmF1bHQgbGluayBjb2x1bW4gcGFpcnMsIGNhbiBiZSB1c2VkIGZvciBsaW5rIGJhc2VkIGxheWVyczogYXJjLCBsaW5lIGV0Y1xuICAgKi9cbiAgZ2V0IGRlZmF1bHRMaW5rQ29sdW1uUGFpcnMoKTogQ29sdW1uUGFpcnMge1xuICAgIHJldHVybiB7XG4gICAgICBsYXQwOiB7cGFpcjogJ2xuZzAnLCBmaWVsZFBhaXJLZXk6ICdsYXQnfSxcbiAgICAgIGxuZzA6IHtwYWlyOiAnbGF0MCcsIGZpZWxkUGFpcktleTogJ2xuZyd9LFxuICAgICAgbGF0MToge3BhaXI6ICdsbmcxJywgZmllbGRQYWlyS2V5OiAnbGF0J30sXG4gICAgICBsbmcxOiB7cGFpcjogJ2xhdDEnLCBmaWVsZFBhaXJLZXk6ICdsbmcnfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgUmVhY3QgY29tcG9uZW50IGZvciB0byByZW5kZXIgbGF5ZXIgaW5zdHJ1Y3Rpb25zIGluIGEgbW9kYWxcbiAgICogQHJldHVybnMge29iamVjdH0gLSBhbiBvYmplY3RcbiAgICogQGV4YW1wbGVcbiAgICogIHJldHVybiB7XG4gICAqICAgIGlkOiAnaWNvbkluZm8nLFxuICAgKiAgICB0ZW1wbGF0ZTogSWNvbkluZm9Nb2RhbCxcbiAgICogICAgbW9kYWxQcm9wczoge1xuICAgKiAgICAgIHRpdGxlOiAnSG93IHRvIGRyYXcgaWNvbnMnXG4gICAqICAgfTtcbiAgICogfVxuICAgKi9cbiAgZ2V0IGxheWVySW5mb01vZGFsKCk6IGFueSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgc3VwcG9ydGVkRGF0YXNldFR5cGVzKCk6IHN0cmluZ1tdIHwgbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLypcbiAgICogR2l2ZW4gYSBkYXRhc2V0LCBhdXRvbWF0aWNhbGx5IGZpbmQgcHJvcHMgdG8gY3JlYXRlIGxheWVyIGJhc2VkIG9uIGl0XG4gICAqIGFuZCByZXR1cm4gdGhlIHByb3BzIGFuZCBwcmV2aW91cyBmb3VuZCBsYXllcnMuXG4gICAqIEJ5IGRlZmF1bHQsIG5vIGxheWVycyB3aWxsIGJlIGZvdW5kXG4gICAqL1xuICBzdGF0aWMgZmluZERlZmF1bHRMYXllclByb3BzKFxuICAgIGRhdGFzZXQ6IEtlcGxlclRhYmxlLFxuICAgIGZvdW5kTGF5ZXJzPzogYW55W11cbiAgKTogRmluZERlZmF1bHRMYXllclByb3BzUmV0dXJuVmFsdWUge1xuICAgIHJldHVybiB7cHJvcHM6IFtdLCBmb3VuZExheWVyc307XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBhcnJheSBvZiBwcmVzZXQgcmVxdWlyZWQgY29sdW1uIG5hbWVzXG4gICAqIGZvdW5kIGZpZWxkIHRoYXQgaGFzIHRoZSBzYW1lIG5hbWUgdG8gc2V0IGFzIGxheWVyIGNvbHVtblxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdEZpZWxkc1xuICAgKiBAcGFyYW0ge29iamVjdFtdfSBhbGxGaWVsZHNcbiAgICogQHJldHVybnMge29iamVjdFtdIHwgbnVsbH0gYWxsIHBvc3NpYmxlIHJlcXVpcmVkIGxheWVyIGNvbHVtbiBwYWlyc1xuICAgKi9cbiAgc3RhdGljIGZpbmREZWZhdWx0Q29sdW1uRmllbGQoZGVmYXVsdEZpZWxkcywgYWxsRmllbGRzKSB7XG4gICAgLy8gZmluZCBhbGwgbWF0Y2hlZCBmaWVsZHMgZm9yIGVhY2ggcmVxdWlyZWQgY29sXG4gICAgY29uc3QgcmVxdWlyZWRDb2x1bW5zID0gT2JqZWN0LmtleXMoZGVmYXVsdEZpZWxkcykucmVkdWNlKChwcmV2LCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gYWxsRmllbGRzLmZpbHRlcihcbiAgICAgICAgZiA9PiBmLm5hbWUgPT09IGRlZmF1bHRGaWVsZHNba2V5XSB8fCBkZWZhdWx0RmllbGRzW2tleV0uaW5jbHVkZXMoZi5uYW1lKVxuICAgICAgKTtcblxuICAgICAgcHJldltrZXldID0gcmVxdWlyZWRGaWVsZHMubGVuZ3RoXG4gICAgICAgID8gcmVxdWlyZWRGaWVsZHMubWFwKGYgPT4gKHtcbiAgICAgICAgICAgIHZhbHVlOiBmLm5hbWUsXG4gICAgICAgICAgICBmaWVsZElkeDogZi5maWVsZElkeFxuICAgICAgICAgIH0pKVxuICAgICAgICA6IG51bGw7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9LCB7fSk7XG5cbiAgICBpZiAoIU9iamVjdC52YWx1ZXMocmVxdWlyZWRDb2x1bW5zKS5ldmVyeShCb29sZWFuKSkge1xuICAgICAgLy8gaWYgYW55IGZpZWxkIG1pc3NpbmcsIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRBbGxQb3NzaWJsZUNvbHVtblBhcmlzKHJlcXVpcmVkQ29sdW1ucyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0QWxsUG9zc2libGVDb2x1bW5QYXJpcyhyZXF1aXJlZENvbHVtbnMpIHtcbiAgICAvLyBmb3IgbXVsdGlwbGUgbWF0Y2hlZCBmaWVsZCBmb3Igb25lIHJlcXVpcmVkIGNvbHVtbiwgcmV0dXJuIG11bHRpcGxlXG4gICAgLy8gY29tYmluYXRpb25zLCBlLiBnLiBpZiBjb2x1bW4gYSBoYXMgMiBtYXRjaGVkLCBjb2x1bW4gYiBoYXMgMyBtYXRjaGVkXG4gICAgLy8gNiBwb3NzaWJsZSBjb2x1bW4gcGFpcnMgd2lsbCBiZSByZXR1cm5lZFxuICAgIGNvbnN0IGFsbEtleXMgPSBPYmplY3Qua2V5cyhyZXF1aXJlZENvbHVtbnMpO1xuICAgIGNvbnN0IHBvaW50ZXJzID0gYWxsS2V5cy5tYXAoKGssIGkpID0+IChpID09PSBhbGxLZXlzLmxlbmd0aCAtIDEgPyAtMSA6IDApKTtcbiAgICBjb25zdCBjb3VudFBlcktleSA9IGFsbEtleXMubWFwKGsgPT4gcmVxdWlyZWRDb2x1bW5zW2tdLmxlbmd0aCk7XG4gICAgLy8gVE9ETzogQmV0dGVyIHR5cGluZ3NcbiAgICBjb25zdCBwYWlyczogYW55W10gPSBbXTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuICAgIHdoaWxlIChpbmNyZW1lbnRQb2ludGVycyhwb2ludGVycywgY291bnRQZXJLZXksIHBvaW50ZXJzLmxlbmd0aCAtIDEpKSB7XG4gICAgICBjb25zdCBuZXdQYWlyID0gcG9pbnRlcnMucmVkdWNlKChwcmV2LCBjdXVyLCBpKSA9PiB7XG4gICAgICAgIHByZXZbYWxsS2V5c1tpXV0gPSByZXF1aXJlZENvbHVtbnNbYWxsS2V5c1tpXV1bY3V1cl07XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfSwge30pO1xuXG4gICAgICBwYWlycy5wdXNoKG5ld1BhaXIpO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG4gICAgLy8gcmVjdXJzaXZlbHkgaW5jcmVtZW50IHBvaW50ZXJzXG4gICAgZnVuY3Rpb24gaW5jcmVtZW50UG9pbnRlcnMocHRzLCBjb3VudHMsIGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IDAgJiYgcHRzWzBdID09PSBjb3VudHNbMF0gLSAxKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gaW5jcmVtZW50XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHB0c1tpbmRleF0gKyAxIDwgY291bnRzW2luZGV4XSkge1xuICAgICAgICBwdHNbaW5kZXhdID0gcHRzW2luZGV4XSArIDE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwdHNbaW5kZXhdID0gMDtcbiAgICAgIHJldHVybiBpbmNyZW1lbnRQb2ludGVycyhwdHMsIGNvdW50cywgaW5kZXggLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFpcnM7XG4gIH1cblxuICBzdGF0aWMgaGV4VG9SZ2IoYykge1xuICAgIHJldHVybiBoZXhUb1JnYihjKTtcbiAgfVxuXG4gIGdldERlZmF1bHRMYXllckNvbmZpZyhcbiAgICBwcm9wczogTGF5ZXJCYXNlQ29uZmlnUGFydGlhbFxuICApOiBMYXllckJhc2VDb25maWcgJiBQYXJ0aWFsPExheWVyQ29sb3JDb25maWcgJiBMYXllclNpemVDb25maWc+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YUlkOiBwcm9wcy5kYXRhSWQsXG4gICAgICBsYWJlbDogcHJvcHMubGFiZWwgfHwgREVGQVVMVF9MQVlFUl9MQUJFTCxcbiAgICAgIGNvbG9yOiBwcm9wcy5jb2xvciB8fCBjb2xvck1ha2VyLm5leHQoKS52YWx1ZSxcbiAgICAgIGNvbHVtbnM6IHByb3BzLmNvbHVtbnMgfHwge30sXG4gICAgICBpc1Zpc2libGU6IHByb3BzLmlzVmlzaWJsZSB8fCBmYWxzZSxcbiAgICAgIGlzQ29uZmlnQWN0aXZlOiBwcm9wcy5pc0NvbmZpZ0FjdGl2ZSB8fCBmYWxzZSxcbiAgICAgIGhpZ2hsaWdodENvbG9yOiBwcm9wcy5oaWdobGlnaHRDb2xvciB8fCBERUZBVUxUX0hJR0hMSUdIVF9DT0xPUixcbiAgICAgIGhpZGRlbjogcHJvcHMuaGlkZGVuIHx8IGZhbHNlLFxuXG4gICAgICAvLyBUT0RPOiByZWZhY3RvciB0aGlzIGludG8gc2VwYXJhdGUgdmlzdWFsIENoYW5uZWwgY29uZmlnXG4gICAgICAvLyBjb2xvciBieSBmaWVsZCwgZG9tYWluIGlzIHNldCBieSBmaWx0ZXJzLCBmaWVsZCwgc2NhbGUgdHlwZVxuICAgICAgY29sb3JGaWVsZDogbnVsbCxcbiAgICAgIGNvbG9yRG9tYWluOiBbMCwgMV0sXG4gICAgICBjb2xvclNjYWxlOiBTQ0FMRV9UWVBFUy5xdWFudGlsZSxcblxuICAgICAgLy8gY29sb3IgYnkgc2l6ZSwgZG9tYWluIGlzIHNldCBieSBmaWx0ZXJzLCBmaWVsZCwgc2NhbGUgdHlwZVxuICAgICAgc2l6ZURvbWFpbjogWzAsIDFdLFxuICAgICAgc2l6ZVNjYWxlOiBTQ0FMRV9UWVBFUy5saW5lYXIsXG4gICAgICBzaXplRmllbGQ6IG51bGwsXG5cbiAgICAgIHZpc0NvbmZpZzoge30sXG5cbiAgICAgIHRleHRMYWJlbDogW0RFRkFVTFRfVEVYVF9MQUJFTF0sXG5cbiAgICAgIGNvbG9yVUk6IHtcbiAgICAgICAgY29sb3I6IERFRkFVTFRfQ09MT1JfVUksXG4gICAgICAgIGNvbG9yUmFuZ2U6IERFRkFVTFRfQ09MT1JfVUlcbiAgICAgIH0sXG4gICAgICBhbmltYXRpb246IHtlbmFibGVkOiBmYWxzZX1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVzY3JpcHRpb24gb2YgYSB2aXN1YWxDaGFubmVsIGNvbmZpZ1xuICAgKiBAcGFyYW0ga2V5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRWaXN1YWxDaGFubmVsRGVzY3JpcHRpb24oa2V5OiBzdHJpbmcpOiBWaXN1YWxDaGFubmVsRGVzY3JpcHRpb24ge1xuICAgIC8vIGUuZy4gbGFiZWw6IENvbG9yLCBtZWFzdXJlOiBWZWhpY2xlIFR5cGVcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy52aXN1YWxDaGFubmVsc1trZXldO1xuICAgIGlmICghY2hhbm5lbCkgcmV0dXJuIHtsYWJlbDogJycsIG1lYXN1cmU6IHVuZGVmaW5lZH07XG4gICAgY29uc3QgcmFuZ2VTZXR0aW5ncyA9IHRoaXMudmlzQ29uZmlnU2V0dGluZ3NbY2hhbm5lbC5yYW5nZV07XG4gICAgY29uc3QgZmllbGRTZXR0aW5ncyA9IHRoaXMuY29uZmlnW2NoYW5uZWwuZmllbGRdO1xuICAgIGNvbnN0IGxhYmVsID0gcmFuZ2VTZXR0aW5ncz8ubGFiZWw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiB0eXBlb2YgbGFiZWwgPT09ICdmdW5jdGlvbicgPyBsYWJlbCh0aGlzLmNvbmZpZykgOiBsYWJlbCB8fCAnJyxcbiAgICAgIG1lYXN1cmU6IGZpZWxkU2V0dGluZ3NcbiAgICAgICAgPyBmaWVsZFNldHRpbmdzLmRpc3BsYXlOYW1lIHx8IGZpZWxkU2V0dGluZ3MubmFtZVxuICAgICAgICA6IGNoYW5uZWwuZGVmYXVsdE1lYXN1cmVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbiBhIGZpZWxkIHRvIGxheWVyIGNvbHVtbiwgcmV0dXJuIGNvbHVtbiBjb25maWdcbiAgICogQHBhcmFtIGtleSAtIENvbHVtbiBLZXlcbiAgICogQHBhcmFtIGZpZWxkIC0gU2VsZWN0ZWQgZmllbGRcbiAgICogQHJldHVybnMge3t9fSAtIENvbHVtbiBjb25maWdcbiAgICovXG4gIGFzc2lnbkNvbHVtbihrZXk6IHN0cmluZywgZmllbGQ6IEZpZWxkKTogTGF5ZXJDb2x1bW5zIHtcbiAgICAvLyBmaWVsZCB2YWx1ZSBjb3VsZCBiZSBudWxsIGZvciBvcHRpb25hbCBjb2x1bW5zXG4gICAgY29uc3QgdXBkYXRlID0gZmllbGRcbiAgICAgID8ge1xuICAgICAgICAgIHZhbHVlOiBmaWVsZC5uYW1lLFxuICAgICAgICAgIGZpZWxkSWR4OiBmaWVsZC5maWVsZElkeFxuICAgICAgICB9XG4gICAgICA6IHt2YWx1ZTogbnVsbCwgZmllbGRJZHg6IC0xfTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmNvbmZpZy5jb2x1bW5zLFxuICAgICAgW2tleV06IHtcbiAgICAgICAgLi4udGhpcy5jb25maWcuY29sdW1uc1trZXldLFxuICAgICAgICAuLi51cGRhdGVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbiBhIGZpZWxkIHBhaXIgdG8gY29sdW1uIGNvbmZpZywgcmV0dXJuIGNvbHVtbiBjb25maWdcbiAgICogQHBhcmFtIGtleSAtIENvbHVtbiBLZXlcbiAgICogQHBhcmFtIHBhaXIgLSBmaWVsZCBQYWlyXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IC0gQ29sdW1uIGNvbmZpZ1xuICAgKi9cbiAgYXNzaWduQ29sdW1uUGFpcnMoa2V5OiBzdHJpbmcsIHBhaXI6IHN0cmluZyk6IExheWVyQ29sdW1ucyB7XG4gICAgaWYgKCF0aGlzLmNvbHVtblBhaXJzIHx8ICF0aGlzLmNvbHVtblBhaXJzPy5ba2V5XSkge1xuICAgICAgLy8gc2hvdWxkIG5vdCBlbmQgaW4gdGhpcyBzdGF0ZVxuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNvbHVtbnM7XG4gICAgfVxuXG4gICAgY29uc3Qge3BhaXI6IHBhcnRuZXJLZXksIGZpZWxkUGFpcktleX0gPSB0aGlzLmNvbHVtblBhaXJzPy5ba2V5XTtcblxuICAgIGlmICghcGFpcltmaWVsZFBhaXJLZXldKSB7XG4gICAgICAvLyBkbyBub3QgYWxsb3cgYGtleTogdW5kZWZpbmVkYCB0byBjcmVlcCBpbnRvIHRoZSBgdXBkYXRlZENvbHVtbmAgb2JqZWN0XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcuY29sdW1ucztcbiAgICB9XG5cbiAgICBjb25zdCB7ZmllbGRQYWlyS2V5OiBwYXJ0bmVyRmllbGRQYWlyS2V5fSA9IHRoaXMuY29sdW1uUGFpcnM/LltwYXJ0bmVyS2V5XTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmNvbmZpZy5jb2x1bW5zLFxuICAgICAgW2tleV06IHBhaXJbZmllbGRQYWlyS2V5XSxcbiAgICAgIFtwYXJ0bmVyS2V5XTogcGFpcltwYXJ0bmVyRmllbGRQYWlyS2V5XVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGEgcmFkaXVzIHpvb20gbXVsdGlwbGllciB0byByZW5kZXIgcG9pbnRzLCBzbyB0aGV5IGFyZSB2aXNpYmxlIGluIGFsbCB6b29tIGxldmVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYXBTdGF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbWFwU3RhdGUuem9vbSAtIGFjdHVhbCB6b29tXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdm9pZH0gbWFwU3RhdGUuem9vbU9mZnNldCAtIHpvb21PZmZzZXQgd2hlbiByZW5kZXIgaW4gdGhlIHBsb3QgY29udGFpbmVyIGZvciBleHBvcnQgaW1hZ2VcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldFpvb21GYWN0b3Ioe3pvb20sIHpvb21PZmZzZXQgPSAwfSkge1xuICAgIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLm1heCgxNCAtIHpvb20gKyB6b29tT2Zmc2V0LCAwKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGEgZWxldmF0aW9uIHpvb20gbXVsdGlwbGllciB0byByZW5kZXIgcG9pbnRzLCBzbyB0aGV5IGFyZSB2aXNpYmxlIGluIGFsbCB6b29tIGxldmVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYXBTdGF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbWFwU3RhdGUuem9vbSAtIGFjdHVhbCB6b29tXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gbWFwU3RhdGUuem9vbU9mZnNldCAtIHpvb21PZmZzZXQgd2hlbiByZW5kZXIgaW4gdGhlIHBsb3QgY29udGFpbmVyIGZvciBleHBvcnQgaW1hZ2VcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldEVsZXZhdGlvblpvb21GYWN0b3Ioe3pvb20sIHpvb21PZmZzZXQgPSAwfToge3pvb206IG51bWJlcjsgem9vbU9mZnNldD86IG51bWJlcn0pOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy52aXNDb25maWcuZW5hYmxlRWxldmF0aW9uWm9vbUZhY3RvclxuICAgICAgPyBNYXRoLnBvdygyLCBNYXRoLm1heCg4IC0gem9vbSArIHpvb21PZmZzZXQsIDApKVxuICAgICAgOiAxO1xuICB9XG5cbiAgZm9ybWF0TGF5ZXJEYXRhKGRhdGFzZXRzOiBEYXRhc2V0cywgb2xkTGF5ZXJEYXRhPzogYW55KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcmVuZGVyTGF5ZXIoLi4uYXJnczogYW55W10pOiBhbnlbXSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZ2V0SG92ZXJEYXRhKG9iamVjdCwgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZSwgZmllbGRzOiBGaWVsZFtdKSB7XG4gICAgaWYgKCFvYmplY3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIGVhY2ggZW50cnkgb2YgbGF5ZXJEYXRhIHNob3VsZCBoYXZlIGFuIGluZGV4IG9mIGEgcm93IGluIHRoZSBvcmlnaW5hbCBkYXRhIGNvbnRhaW5lci5cbiAgICAvLyBFYWNoIGxheWVyIGNhbiBpbXBsZW1lbnQgaXRzIG93biBnZXRIb3ZlckRhdGEgbWV0aG9kXG4gICAgcmV0dXJuIGRhdGFDb250YWluZXIucm93KG9iamVjdC5pbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBjaGFuZ2UgbGF5ZXIgdHlwZSwgdHJ5IHRvIGNvcHkgb3ZlciBsYXllciBjb25maWdzIGFzIG11Y2ggYXMgcG9zc2libGVcbiAgICogQHBhcmFtIGNvbmZpZ1RvQ29weSAtIGNvbmZpZyB0byBjb3B5IG92ZXJcbiAgICogQHBhcmFtIHZpc0NvbmZpZ1NldHRpbmdzIC0gdmlzQ29uZmlnIHNldHRpbmdzIG9mIGNvbmZpZyB0byBjb3B5XG4gICAqL1xuICBhc3NpZ25Db25maWdUb0xheWVyKGNvbmZpZ1RvQ29weSwgdmlzQ29uZmlnU2V0dGluZ3MpIHtcbiAgICAvLyBkb24ndCBkZWVwIG1lcmdlIHZpc3VhbENoYW5uZWwgZmllbGRcbiAgICAvLyBkb24ndCBkZWVwIG1lcmdlIGNvbG9yIHJhbmdlLCByZXZlcnNlZDogaXMgbm90IGEga2V5IGJ5IGRlZmF1bHRcbiAgICBjb25zdCBzaGFsbG93Q29weSA9IFsnY29sb3JSYW5nZScsICdzdHJva2VDb2xvclJhbmdlJ10uY29uY2F0KFxuICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLnZpc3VhbENoYW5uZWxzKS5tYXAodiA9PiB2LmZpZWxkKVxuICAgICk7XG5cbiAgICAvLyBkb24ndCBjb3B5IG92ZXIgZG9tYWluIGFuZCBhbmltYXRpb25cbiAgICBjb25zdCBub3RUb0NvcHkgPSBbJ2FuaW1hdGlvbiddLmNvbmNhdChPYmplY3QudmFsdWVzKHRoaXMudmlzdWFsQ2hhbm5lbHMpLm1hcCh2ID0+IHYuZG9tYWluKSk7XG4gICAgLy8gaWYgcmFuZ2UgaXMgZm9yIHRoZSBzYW1lIHByb3BlcnR5IGdyb3VwIGNvcHkgaXQsIG90aGVyd2lzZSwgbm90IHRvIGNvcHlcbiAgICBPYmplY3QudmFsdWVzKHRoaXMudmlzdWFsQ2hhbm5lbHMpLmZvckVhY2godiA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGNvbmZpZ1RvQ29weS52aXNDb25maWdbdi5yYW5nZV0gJiZcbiAgICAgICAgdGhpcy52aXNDb25maWdTZXR0aW5nc1t2LnJhbmdlXSAmJlxuICAgICAgICB2aXNDb25maWdTZXR0aW5nc1t2LnJhbmdlXS5ncm91cCAhPT0gdGhpcy52aXNDb25maWdTZXR0aW5nc1t2LnJhbmdlXS5ncm91cFxuICAgICAgKSB7XG4gICAgICAgIG5vdFRvQ29weS5wdXNoKHYucmFuZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZG9uJ3QgY29weSBvdmVyIHZpc3VhbENoYW5uZWwgcmFuZ2VcbiAgICBjb25zdCBjdXJyZW50Q29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgY29waWVkID0gdGhpcy5jb3B5TGF5ZXJDb25maWcoY3VycmVudENvbmZpZywgY29uZmlnVG9Db3B5LCB7XG4gICAgICBzaGFsbG93Q29weSxcbiAgICAgIG5vdFRvQ29weVxuICAgIH0pO1xuXG4gICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyhjb3BpZWQpO1xuICAgIC8vIHZhbGlkYXRlIHZpc3VhbENoYW5uZWwgZmllbGQgdHlwZSBhbmQgc2NhbGUgdHlwZXNcbiAgICBPYmplY3Qua2V5cyh0aGlzLnZpc3VhbENoYW5uZWxzKS5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgdGhpcy52YWxpZGF0ZVZpc3VhbENoYW5uZWwoY2hhbm5lbCk7XG4gICAgfSk7XG4gIH1cblxuICAvKlxuICAgKiBSZWN1cnNpdmVseSBjb3B5IGNvbmZpZyBvdmVyIHRvIGFuIGVtcHR5IGxheWVyXG4gICAqIHdoZW4gcmVjZWl2ZWQgc2F2ZWQgY29uZmlnLCBvciBjb3B5IGNvbmZpZyBvdmVyIGZyb20gYSBkaWZmZXJlbnQgbGF5ZXIgdHlwZVxuICAgKiBtYWtlIHN1cmUgdG8gb25seSBjb3B5IG92ZXIgdmFsdWUgdG8gZXhpc3Rpbmcga2V5c1xuICAgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudENvbmZpZyAtIGV4aXN0aW5nIGNvbmZpZyB0byBiZSBvdmVycmlkZVxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnVG9Db3B5IC0gbmV3IENvbmZpZyB0byBjb3B5IG92ZXJcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gc2hhbGxvd0NvcHkgLSBhcnJheSBvZiBwcm9wZXJ0aWVzIHRvIG5vdCB0byBiZSBkZWVwIGNvcGllZFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBub3RUb0NvcHkgLSBhcnJheSBvZiBwcm9wZXJ0aWVzIG5vdCB0byBjb3B5XG4gICAqIEByZXR1cm5zIHtvYmplY3R9IC0gY29waWVkIGNvbmZpZ1xuICAgKi9cbiAgY29weUxheWVyQ29uZmlnKFxuICAgIGN1cnJlbnRDb25maWcsXG4gICAgY29uZmlnVG9Db3B5LFxuICAgIHtzaGFsbG93Q29weSA9IFtdLCBub3RUb0NvcHkgPSBbXX06IHtzaGFsbG93Q29weT86IHN0cmluZ1tdOyBub3RUb0NvcHk/OiBzdHJpbmdbXX0gPSB7fVxuICApIHtcbiAgICBjb25zdCBjb3BpZWQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjdXJyZW50Q29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGlzUGxhaW5PYmplY3QoY3VycmVudENvbmZpZ1trZXldKSAmJlxuICAgICAgICBpc1BsYWluT2JqZWN0KGNvbmZpZ1RvQ29weVtrZXldKSAmJlxuICAgICAgICAhc2hhbGxvd0NvcHkuaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAhbm90VG9Db3B5LmluY2x1ZGVzKGtleSlcbiAgICAgICkge1xuICAgICAgICAvLyByZWN1cnNpdmVseSBhc3NpZ24gb2JqZWN0IHZhbHVlXG4gICAgICAgIGNvcGllZFtrZXldID0gdGhpcy5jb3B5TGF5ZXJDb25maWcoY3VycmVudENvbmZpZ1trZXldLCBjb25maWdUb0NvcHlba2V5XSwge1xuICAgICAgICAgIHNoYWxsb3dDb3B5LFxuICAgICAgICAgIG5vdFRvQ29weVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAobm90TnVsbG9yVW5kZWZpbmVkKGNvbmZpZ1RvQ29weVtrZXldKSAmJiAhbm90VG9Db3B5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgLy8gY29weVxuICAgICAgICBjb3BpZWRba2V5XSA9IGNvbmZpZ1RvQ29weVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8ga2VlcCBleGlzdGluZ1xuICAgICAgICBjb3BpZWRba2V5XSA9IGN1cnJlbnRDb25maWdba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjb3BpZWQ7XG4gIH1cblxuICByZWdpc3RlclZpc0NvbmZpZyhsYXllclZpc0NvbmZpZ3M6IHtcbiAgICBba2V5OiBzdHJpbmddOiBrZXlvZiBMYXllclZpc0NvbmZpZ1NldHRpbmdzIHwgVmFsdWVPZjxMYXllclZpc0NvbmZpZ1NldHRpbmdzPjtcbiAgfSkge1xuICAgIE9iamVjdC5rZXlzKGxheWVyVmlzQ29uZmlncykuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZ0l0ZW0gPSBsYXllclZpc0NvbmZpZ3NbaXRlbV07XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZ0l0ZW0gPT09ICdzdHJpbmcnICYmIExBWUVSX1ZJU19DT05GSUdTW2NvbmZpZ0l0ZW1dKSB7XG4gICAgICAgIC8vIGlmIGFzc2lnbmVkIG9uZSBvZiBkZWZhdWx0IExBWUVSX0NPTkZJR1NcbiAgICAgICAgdGhpcy5jb25maWcudmlzQ29uZmlnW2l0ZW1dID0gTEFZRVJfVklTX0NPTkZJR1NbY29uZmlnSXRlbV0uZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLnZpc0NvbmZpZ1NldHRpbmdzW2l0ZW1dID0gTEFZRVJfVklTX0NPTkZJR1NbY29uZmlnSXRlbV07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2YgY29uZmlnSXRlbSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgWyd0eXBlJywgJ2RlZmF1bHRWYWx1ZSddLmV2ZXJ5KHAgPT4gY29uZmlnSXRlbS5oYXNPd25Qcm9wZXJ0eShwKSlcbiAgICAgICkge1xuICAgICAgICAvLyBpZiBwcm92aWRlZCBjdXN0b21pemVkIHZpc0NvbmZpZywgYW5kIGhhcyB0eXBlICYmIGRlZmF1bHRWYWx1ZVxuICAgICAgICAvLyBUT0RPOiBmdXJ0aGVyIGNoZWNrIGlmIGN1c3RvbWl6ZWQgdmlzQ29uZmlnIGlzIHZhbGlkXG4gICAgICAgIHRoaXMuY29uZmlnLnZpc0NvbmZpZ1tpdGVtXSA9IGNvbmZpZ0l0ZW0uZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLnZpc0NvbmZpZ1NldHRpbmdzW2l0ZW1dID0gY29uZmlnSXRlbTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldExheWVyQ29sdW1ucygpIHtcbiAgICBjb25zdCBjb2x1bW5WYWxpZGF0b3JzID0gdGhpcy5jb2x1bW5WYWxpZGF0b3JzO1xuICAgIGNvbnN0IHJlcXVpcmVkID0gdGhpcy5yZXF1aXJlZExheWVyQ29sdW1ucy5yZWR1Y2UoXG4gICAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICBba2V5XTogY29sdW1uVmFsaWRhdG9yc1trZXldXG4gICAgICAgICAgPyB7dmFsdWU6IG51bGwsIGZpZWxkSWR4OiAtMSwgdmFsaWRhdG9yOiBjb2x1bW5WYWxpZGF0b3JzW2tleV19XG4gICAgICAgICAgOiB7dmFsdWU6IG51bGwsIGZpZWxkSWR4OiAtMX1cbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICAgIGNvbnN0IG9wdGlvbmFsID0gdGhpcy5vcHRpb25hbENvbHVtbnMucmVkdWNlKFxuICAgICAgKGFjY3UsIGtleSkgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgW2tleV06IHt2YWx1ZTogbnVsbCwgZmllbGRJZHg6IC0xLCBvcHRpb25hbDogdHJ1ZX1cbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuXG4gICAgcmV0dXJuIHsuLi5yZXF1aXJlZCwgLi4ub3B0aW9uYWx9O1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJDb25maWc8TGF5ZXJDb25maWcgZXh0ZW5kcyBMYXllckJhc2VDb25maWcgPSBMYXllckJhc2VDb25maWc+KFxuICAgIG5ld0NvbmZpZzogUGFydGlhbDxMYXllckNvbmZpZz5cbiAgKTogTGF5ZXIge1xuICAgIHRoaXMuY29uZmlnID0gey4uLnRoaXMuY29uZmlnLCAuLi5uZXdDb25maWd9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJWaXNDb25maWcobmV3VmlzQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcudmlzQ29uZmlnID0gey4uLnRoaXMuY29uZmlnLnZpc0NvbmZpZywgLi4ubmV3VmlzQ29uZmlnfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVwZGF0ZUxheWVyQ29sb3JVSShwcm9wOiBzdHJpbmcsIG5ld0NvbmZpZzogTmVzdGVkUGFydGlhbDxDb2xvclVJPik6IExheWVyIHtcbiAgICBjb25zdCB7Y29sb3JVSTogcHJldmlvdXMsIHZpc0NvbmZpZ30gPSB0aGlzLmNvbmZpZztcblxuICAgIGlmICghaXNQbGFpbk9iamVjdChuZXdDb25maWcpIHx8IHR5cGVvZiBwcm9wICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgY29sb3JVSVByb3AgPSBPYmplY3QuZW50cmllcyhuZXdDb25maWcpLnJlZHVjZSgoYWNjdSwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICBba2V5XTogaXNQbGFpbk9iamVjdChhY2N1W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsdWUpID8gey4uLmFjY3Vba2V5XSwgLi4udmFsdWV9IDogdmFsdWVcbiAgICAgIH07XG4gICAgfSwgcHJldmlvdXNbcHJvcF0gfHwgREVGQVVMVF9DT0xPUl9VSSk7XG5cbiAgICBjb25zdCBjb2xvclVJID0ge1xuICAgICAgLi4ucHJldmlvdXMsXG4gICAgICBbcHJvcF06IGNvbG9yVUlQcm9wXG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlTGF5ZXJDb25maWcoe2NvbG9yVUl9KTtcbiAgICAvLyBpZiBjb2xvclVJW3Byb3BdIGlzIGNvbG9yUmFuZ2VcbiAgICBjb25zdCBpc0NvbG9yUmFuZ2UgPSB2aXNDb25maWdbcHJvcF0gJiYgdmlzQ29uZmlnW3Byb3BdLmNvbG9ycztcblxuICAgIGlmIChpc0NvbG9yUmFuZ2UpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29sb3JVSUJ5Q29sb3JSYW5nZShuZXdDb25maWcsIHByb3ApO1xuICAgICAgdGhpcy51cGRhdGVDb2xvclJhbmdlQnlDb2xvclVJKG5ld0NvbmZpZywgcHJldmlvdXMsIHByb3ApO1xuICAgICAgdGhpcy51cGRhdGVDdXN0b21QYWxldHRlKG5ld0NvbmZpZywgcHJldmlvdXMsIHByb3ApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdXBkYXRlQ3VzdG9tUGFsZXR0ZShuZXdDb25maWcsIHByZXZpb3VzLCBwcm9wKSB7XG4gICAgaWYgKCFuZXdDb25maWcuY29sb3JSYW5nZUNvbmZpZyB8fCAhbmV3Q29uZmlnLmNvbG9yUmFuZ2VDb25maWcuY3VzdG9tKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge2NvbG9yVUksIHZpc0NvbmZpZ30gPSB0aGlzLmNvbmZpZztcblxuICAgIGlmICghdmlzQ29uZmlnW3Byb3BdKSByZXR1cm47XG4gICAgY29uc3Qge2NvbG9yc30gPSB2aXNDb25maWdbcHJvcF07XG4gICAgY29uc3QgY3VzdG9tUGFsZXR0ZSA9IHtcbiAgICAgIC4uLmNvbG9yVUlbcHJvcF0uY3VzdG9tUGFsZXR0ZSxcbiAgICAgIG5hbWU6ICdDdXN0b20gUGFsZXR0ZScsXG4gICAgICBjb2xvcnM6IFsuLi5jb2xvcnNdXG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICAgIGNvbG9yVUk6IHtcbiAgICAgICAgLi4uY29sb3JVSSxcbiAgICAgICAgW3Byb3BdOiB7XG4gICAgICAgICAgLi4uY29sb3JVSVtwcm9wXSxcbiAgICAgICAgICBjdXN0b21QYWxldHRlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogaWYgb3BlbiBkcm9wZG93biBhbmQgcHJvcCBpcyBjb2xvciByYW5nZVxuICAgKiBBdXRvbWF0aWNhbGx5IHNldCBjb2xvclJhbmdlQ29uZmlnJ3Mgc3RlcCBhbmQgcmV2ZXJzZWRcbiAgICogQHBhcmFtIHsqfSBuZXdDb25maWdcbiAgICogQHBhcmFtIHsqfSBwcm9wXG4gICAqL1xuICB1cGRhdGVDb2xvclVJQnlDb2xvclJhbmdlKG5ld0NvbmZpZywgcHJvcCkge1xuICAgIGlmICh0eXBlb2YgbmV3Q29uZmlnLnNob3dEcm9wZG93biAhPT0gJ251bWJlcicpIHJldHVybjtcblxuICAgIGNvbnN0IHtjb2xvclVJLCB2aXNDb25maWd9ID0gdGhpcy5jb25maWc7XG4gICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgICBjb2xvclVJOiB7XG4gICAgICAgIC4uLmNvbG9yVUksXG4gICAgICAgIFtwcm9wXToge1xuICAgICAgICAgIC4uLmNvbG9yVUlbcHJvcF0sXG4gICAgICAgICAgY29sb3JSYW5nZUNvbmZpZzoge1xuICAgICAgICAgICAgLi4uY29sb3JVSVtwcm9wXS5jb2xvclJhbmdlQ29uZmlnLFxuICAgICAgICAgICAgc3RlcHM6IHZpc0NvbmZpZ1twcm9wXS5jb2xvcnMubGVuZ3RoLFxuICAgICAgICAgICAgcmV2ZXJzZWQ6IEJvb2xlYW4odmlzQ29uZmlnW3Byb3BdLnJldmVyc2VkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlQ29sb3JSYW5nZUJ5Q29sb3JVSShuZXdDb25maWcsIHByZXZpb3VzLCBwcm9wKSB7XG4gICAgLy8gb25seSB1cGRhdGUgY29sb3JSYW5nZSBpZiBjaGFuZ2VzIGluIFVJIGlzIG1hZGUgdG8gJ3JldmVyc2VkJywgJ3N0ZXBzJyBvciBzdGVwc1xuICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9XG4gICAgICBuZXdDb25maWcuY29sb3JSYW5nZUNvbmZpZyAmJlxuICAgICAgWydyZXZlcnNlZCcsICdzdGVwcyddLnNvbWUoXG4gICAgICAgIGtleSA9PlxuICAgICAgICAgIG5ld0NvbmZpZy5jb2xvclJhbmdlQ29uZmlnLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgICAgICBuZXdDb25maWcuY29sb3JSYW5nZUNvbmZpZ1trZXldICE9PVxuICAgICAgICAgICAgKHByZXZpb3VzW3Byb3BdIHx8IERFRkFVTFRfQ09MT1JfVUkpLmNvbG9yUmFuZ2VDb25maWdba2V5XVxuICAgICAgKTtcbiAgICBpZiAoIXNob3VsZFVwZGF0ZSkgcmV0dXJuO1xuXG4gICAgY29uc3Qge2NvbG9yVUksIHZpc0NvbmZpZ30gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCB7c3RlcHMsIHJldmVyc2VkfSA9IGNvbG9yVUlbcHJvcF0uY29sb3JSYW5nZUNvbmZpZztcbiAgICBjb25zdCBjb2xvclJhbmdlID0gdmlzQ29uZmlnW3Byb3BdO1xuICAgIC8vIGZpbmQgYmFzZWQgb24gc3RlcCBvciByZXZlcnNlZFxuICAgIGxldCB1cGRhdGU7XG4gICAgaWYgKG5ld0NvbmZpZy5jb2xvclJhbmdlQ29uZmlnLmhhc093blByb3BlcnR5KCdzdGVwcycpKSB7XG4gICAgICBjb25zdCBncm91cCA9IGdldENvbG9yR3JvdXBCeU5hbWUoY29sb3JSYW5nZSk7XG5cbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICBjb25zdCBzYW1lR3JvdXAgPSBDT0xPUl9SQU5HRVMuZmlsdGVyKGNyID0+IGdldENvbG9yR3JvdXBCeU5hbWUoY3IpID09PSBncm91cCk7XG5cbiAgICAgICAgdXBkYXRlID0gc2FtZUdyb3VwLmZpbmQoY3IgPT4gY3IuY29sb3JzLmxlbmd0aCA9PT0gc3RlcHMpO1xuXG4gICAgICAgIGlmICh1cGRhdGUgJiYgY29sb3JSYW5nZS5yZXZlcnNlZCkge1xuICAgICAgICAgIHVwZGF0ZSA9IHJldmVyc2VDb2xvclJhbmdlKHRydWUsIHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV3Q29uZmlnLmNvbG9yUmFuZ2VDb25maWcuaGFzT3duUHJvcGVydHkoJ3JldmVyc2VkJykpIHtcbiAgICAgIHVwZGF0ZSA9IHJldmVyc2VDb2xvclJhbmdlKHJldmVyc2VkLCB1cGRhdGUgfHwgY29sb3JSYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVMYXllclZpc0NvbmZpZyh7W3Byb3BdOiB1cGRhdGV9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBsYXllciBoYXMgYWxsIGNvbHVtbnNcbiAgICogQHJldHVybnMgeWVzIG9yIG5vXG4gICAqL1xuICBoYXNBbGxDb2x1bW5zKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHtjb2x1bW5zfSA9IHRoaXMuY29uZmlnO1xuICAgIHJldHVybiAoXG4gICAgICBjb2x1bW5zICYmXG4gICAgICBPYmplY3QudmFsdWVzKGNvbHVtbnMpLmV2ZXJ5KGNvbHVtbiA9PiB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGNvbHVtbiAmJiAoY29sdW1uLm9wdGlvbmFsIHx8IChjb2x1bW4udmFsdWUgJiYgY29sdW1uLmZpZWxkSWR4ID4gLTEpKSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBsYXllciBoYXMgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5IHwgT2JqZWN0fSBsYXllckRhdGFcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHllcyBvciBub1xuICAgKi9cbiAgaGFzTGF5ZXJEYXRhKGxheWVyRGF0YSkge1xuICAgIGlmICghbGF5ZXJEYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBCb29sZWFuKGxheWVyRGF0YS5kYXRhICYmIGxheWVyRGF0YS5kYXRhLmxlbmd0aCk7XG4gIH1cblxuICBpc1ZhbGlkVG9TYXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMudHlwZSAmJiB0aGlzLmhhc0FsbENvbHVtbnMoKSk7XG4gIH1cblxuICBzaG91bGRSZW5kZXJMYXllcihkYXRhKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIEJvb2xlYW4odGhpcy50eXBlKSAmJlxuICAgICAgdGhpcy5oYXNBbGxDb2x1bW5zKCkgJiZcbiAgICAgIHRoaXMuaGFzTGF5ZXJEYXRhKGRhdGEpICYmXG4gICAgICB0eXBlb2YgdGhpcy5yZW5kZXJMYXllciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICk7XG4gIH1cblxuICBnZXRDb2xvclNjYWxlKGNvbG9yU2NhbGU6IHN0cmluZywgY29sb3JEb21haW46IFZpc3VhbENoYW5uZWxEb21haW4sIGNvbG9yUmFuZ2U6IENvbG9yUmFuZ2UpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvclJhbmdlLmNvbG9yTWFwKSkge1xuICAgICAgY29uc3QgY01hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbG9yUmFuZ2UuY29sb3JNYXAuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgIGNNYXAuc2V0KGssIHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IGhleFRvUmdiKHYpIDogdik7XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2NhbGUgPSBTQ0FMRV9GVU5DW1NDQUxFX1RZUEVTLm9yZGluYWxdKClcbiAgICAgICAgLmRvbWFpbihjTWFwLmtleXMoKSlcbiAgICAgICAgLnJhbmdlKGNNYXAudmFsdWVzKCkpXG4gICAgICAgIC51bmtub3duKGNNYXAuZ2V0KFVOS05PV05fQ09MT1JfS0VZKSB8fCBOT19WQUxVRV9DT0xPUik7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFZpc0NoYW5uZWxTY2FsZShjb2xvclNjYWxlLCBjb2xvckRvbWFpbiwgY29sb3JSYW5nZS5jb2xvcnMubWFwKGhleFRvUmdiKSk7XG4gIH1cblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHZpc3VhbCBjaGFubmVscyB0byBkZWNrLmdsIGFjY2Vzb3JzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBQYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtLmRhdGFBY2Nlc3NvciBBY2Nlc3Mga2VwbGVyLmdsIGxheWVyIGRhdGEgZnJvbSBkZWNrLmdsIGxheWVyXG4gICAqIEBwYXJhbSB7aW1wb3J0KCd1dGlscy90YWJsZS11dGlscy9kYXRhLWNvbnRhaW5lci1pbnRlcmZhY2UnKS5EYXRhQ29udGFpbmVySW50ZXJmYWNlfSBwYXJhbS5kYXRhQ29udGFpbmVyIERhdGFDb250YWluZXIgdG8gdXNlIHVzZSB3aXRoIGRhdGFBY2Nlc3NvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGF0dHJpYnV0ZUFjY2Vzc29ycyAtIGRlY2suZ2wgbGF5ZXIgYXR0cmlidXRlIGFjY2Vzc29yc1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlQWNjZXNzb3JzKHtcbiAgICBkYXRhQWNjZXNzb3IgPSBkZWZhdWx0RGF0YUFjY2Vzc29yLFxuICAgIGRhdGFDb250YWluZXJcbiAgfToge1xuICAgIGRhdGFBY2Nlc3Nvcj86IHR5cGVvZiBkZWZhdWx0RGF0YUFjY2Vzc29yO1xuICAgIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2U7XG4gIH0pIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVBY2Nlc3NvcnM6IHtba2V5OiBzdHJpbmddOiBhbnl9ID0ge307XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLnZpc3VhbENoYW5uZWxzKS5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWVsZCxcbiAgICAgICAgZml4ZWQsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBkb21haW4sXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBhY2Nlc3NvcixcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVWYWx1ZSxcbiAgICAgICAgbnVsbFZhbHVlLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlXG4gICAgICB9ID0gdGhpcy52aXN1YWxDaGFubmVsc1tjaGFubmVsXTtcblxuICAgICAgaWYgKGFjY2Vzc29yKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZEdldFNjYWxlID0gdGhpcy5jb25maWdbZmllbGRdO1xuXG4gICAgICAgIGlmIChzaG91bGRHZXRTY2FsZSkge1xuICAgICAgICAgIGNvbnN0IGlzRml4ZWQgPSBmaXhlZCAmJiB0aGlzLmNvbmZpZy52aXNDb25maWdbZml4ZWRdO1xuXG4gICAgICAgICAgY29uc3Qgc2NhbGVGdW5jdGlvbiA9XG4gICAgICAgICAgICBjaGFubmVsU2NhbGVUeXBlID09PSBDSEFOTkVMX1NDQUxFUy5jb2xvclxuICAgICAgICAgICAgICA/IHRoaXMuZ2V0Q29sb3JTY2FsZShcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnW3NjYWxlXSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnW2RvbWFpbl0sXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy52aXNDb25maWdbcmFuZ2VdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHRoaXMuZ2V0VmlzQ2hhbm5lbFNjYWxlKFxuICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWdbc2NhbGVdLFxuICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWdbZG9tYWluXSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnZpc0NvbmZpZ1tyYW5nZV0sXG4gICAgICAgICAgICAgICAgICBpc0ZpeGVkXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgIGF0dHJpYnV0ZUFjY2Vzc29yc1thY2Nlc3Nvcl0gPSBkID0+XG4gICAgICAgICAgICB0aGlzLmdldEVuY29kZWRDaGFubmVsVmFsdWUoXG4gICAgICAgICAgICAgIHNjYWxlRnVuY3Rpb24sXG4gICAgICAgICAgICAgIGRhdGFBY2Nlc3NvcihkYXRhQ29udGFpbmVyKShkKSxcbiAgICAgICAgICAgICAgdGhpcy5jb25maWdbZmllbGRdLFxuICAgICAgICAgICAgICBudWxsVmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGdldEF0dHJpYnV0ZVZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYXR0cmlidXRlQWNjZXNzb3JzW2FjY2Vzc29yXSA9IGdldEF0dHJpYnV0ZVZhbHVlKHRoaXMuY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyaWJ1dGVBY2Nlc3NvcnNbYWNjZXNzb3JdID1cbiAgICAgICAgICAgIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicgPyBkZWZhdWx0VmFsdWUodGhpcy5jb25maWcpIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVBY2Nlc3NvcnNbYWNjZXNzb3JdKSB7XG4gICAgICAgICAgQ29uc29sZS53YXJuKGBGYWlsZWQgdG8gcHJvdmlkZSBhY2Nlc3NvciBmdW5jdGlvbiBmb3IgJHthY2Nlc3NvciB8fCBjaGFubmVsfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXR0cmlidXRlQWNjZXNzb3JzO1xuICB9XG5cbiAgZ2V0VmlzQ2hhbm5lbFNjYWxlKFxuICAgIHNjYWxlOiBzdHJpbmcsXG4gICAgZG9tYWluOiBWaXN1YWxDaGFubmVsRG9tYWluLFxuICAgIHJhbmdlOiBhbnksXG4gICAgZml4ZWQ/OiBib29sZWFuXG4gICk6ICgpID0+IGFueSB8IG51bGwge1xuICAgIHJldHVybiBTQ0FMRV9GVU5DW2ZpeGVkID8gJ2xpbmVhcicgOiBzY2FsZV0oKVxuICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAucmFuZ2UoZml4ZWQgPyBkb21haW4gOiByYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgYm91bmRzIG9mIHRoZSBkYXRhLlxuICAgKiBAcGFyYW0ge2ltcG9ydCgndXRpbHMvdGFibGUtdXRpbHMvZGF0YS1jb250YWluZXItaW50ZXJmYWNlJykuRGF0YUNvbnRhaW5lckludGVyZmFjZX0gZGF0YUNvbnRhaW5lciBEYXRhQ29udGFpbmVyIHRvIGNhbGN1bGF0ZSBib3VuZHMgZm9yLlxuICAgKiBAcGFyYW0geyhkOiB7aW5kZXg6IG51bWJlcn0sIGRjOiBpbXBvcnQoJ3V0aWxzL3RhYmxlLXV0aWxzL2RhdGEtY29udGFpbmVyLWludGVyZmFjZScpLkRhdGFDb250YWluZXJJbnRlcmZhY2UpID0+IG51bWJlcltdfSBnZXRQb3NpdGlvbiBBY2Nlc3Mga2VwbGVyLmdsIGxheWVyIGRhdGEgZnJvbSBkZWNrLmdsIGxheWVyXG4gICAqIEByZXR1cm4ge251bWJlcltdfG51bGx9IGJvdW5kcyBvZiB0aGUgZGF0YS5cbiAgICovXG4gIGdldFBvaW50c0JvdW5kcyhcbiAgICBkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlLFxuICAgIGdldFBvc2l0aW9uPzogKHg6IGFueSwgZGM6IERhdGFDb250YWluZXJJbnRlcmZhY2UpID0+IG51bWJlcltdXG4gICk6IG51bWJlcltdIHwgbnVsbCB7XG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHRocm91Z2ggdGhlIGVudGlyZSBkYXRhc2V0XG4gICAgLy8gZ2V0IGEgc2FtcGxlIG9mIGRhdGEgdG8gY2FsY3VsYXRlIGJvdW5kc1xuICAgIGNvbnN0IHNhbXBsZURhdGEgPVxuICAgICAgZGF0YUNvbnRhaW5lci5udW1Sb3dzKCkgPiBNQVhfU0FNUExFX1NJWkVcbiAgICAgICAgPyBnZXRTYW1wbGVDb250YWluZXJEYXRhKGRhdGFDb250YWluZXIsIE1BWF9TQU1QTEVfU0laRSlcbiAgICAgICAgOiBkYXRhQ29udGFpbmVyO1xuXG4gICAgY29uc3QgcG9pbnRzID0gZ2V0UG9zaXRpb24gPyBzYW1wbGVEYXRhLm1hcEluZGV4KGdldFBvc2l0aW9uKSA6IFtdO1xuXG4gICAgY29uc3QgbGF0Qm91bmRzID0gZ2V0TGF0TG5nQm91bmRzKHBvaW50cywgMSwgWy05MCwgOTBdKTtcbiAgICBjb25zdCBsbmdCb3VuZHMgPSBnZXRMYXRMbmdCb3VuZHMocG9pbnRzLCAwLCBbLTE4MCwgMTgwXSk7XG5cbiAgICBpZiAoIWxhdEJvdW5kcyB8fCAhbG5nQm91bmRzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gW2xuZ0JvdW5kc1swXSwgbGF0Qm91bmRzWzBdLCBsbmdCb3VuZHNbMV0sIGxhdEJvdW5kc1sxXV07XG4gIH1cblxuICBnZXRDaGFuZ2VkVHJpZ2dlcnMoZGF0YVVwZGF0ZVRyaWdnZXJzKSB7XG4gICAgY29uc3QgdHJpZ2dlckNoYW5nZWQgPSBkaWZmVXBkYXRlVHJpZ2dlcnMoZGF0YVVwZGF0ZVRyaWdnZXJzLCB0aGlzLl9vbGREYXRhVXBkYXRlVHJpZ2dlcnMpO1xuICAgIHRoaXMuX29sZERhdGFVcGRhdGVUcmlnZ2VycyA9IGRhdGFVcGRhdGVUcmlnZ2VycztcblxuICAgIHJldHVybiB0cmlnZ2VyQ2hhbmdlZDtcbiAgfVxuXG4gIGdldEVuY29kZWRDaGFubmVsVmFsdWUoXG4gICAgc2NhbGU6ICh2YWx1ZSkgPT4gYW55LFxuICAgIGRhdGE6IGFueVtdLFxuICAgIGZpZWxkOiBWaXN1YWxDaGFubmVsRmllbGQsXG4gICAgbnVsbFZhbHVlID0gTk9fVkFMVUVfQ09MT1IsXG4gICAgZ2V0VmFsdWUgPSBkZWZhdWx0R2V0RmllbGRWYWx1ZVxuICApIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IFZpc3VhbENoYW5uZWxGaWVsZCBiZXR0ZXIgdHlwaW5nXG4gICAgY29uc3Qge3R5cGV9ID0gZmllbGQ7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZShmaWVsZCwgZGF0YSk7XG5cbiAgICBpZiAoIW5vdE51bGxvclVuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsVmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IGF0dHJpYnV0ZVZhbHVlO1xuICAgIGlmICh0eXBlID09PSBBTExfRklFTERfVFlQRVMudGltZXN0YW1wKSB7XG4gICAgICAvLyBzaG91bGRuJ3QgbmVlZCB0byBjb252ZXJ0IGhlcmVcbiAgICAgIC8vIHNjYWxlIEZ1bmN0aW9uIHNob3VsZCB0YWtlIGNhcmUgb2YgaXRcbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gc2NhbGUobmV3IERhdGUodmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRlVmFsdWUgPSBzY2FsZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCFub3ROdWxsb3JVbmRlZmluZWQoYXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICBhdHRyaWJ1dGVWYWx1ZSA9IG51bGxWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XG4gIH1cblxuICB1cGRhdGVNZXRhKG1ldGE6IExheWVyWydtZXRhJ10pIHtcbiAgICB0aGlzLm1ldGEgPSB7Li4udGhpcy5tZXRhLCAuLi5tZXRhfTtcbiAgfVxuXG4gIGdldERhdGFVcGRhdGVUcmlnZ2Vycyh7ZmlsdGVyZWRJbmRleCwgaWQsIGRhdGFDb250YWluZXJ9OiBLZXBsZXJUYWJsZSk6IGFueSB7XG4gICAgY29uc3Qge2NvbHVtbnN9ID0gdGhpcy5jb25maWc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0RGF0YToge2RhdGFzZXRJZDogaWQsIGRhdGFDb250YWluZXIsIGNvbHVtbnMsIGZpbHRlcmVkSW5kZXh9LFxuICAgICAgZ2V0TWV0YToge2RhdGFzZXRJZDogaWQsIGRhdGFDb250YWluZXIsIGNvbHVtbnN9LFxuICAgICAgLi4uKHRoaXMuY29uZmlnLnRleHRMYWJlbCB8fCBbXSkucmVkdWNlKFxuICAgICAgICAoYWNjdSwgdGwsIGkpID0+ICh7XG4gICAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgICBbYGdldExhYmVsQ2hhcmFjdGVyU2V0LSR7aX1gXTogdGwuZmllbGQgPyB0bC5maWVsZC5uYW1lIDogbnVsbFxuICAgICAgICB9KSxcbiAgICAgICAge31cbiAgICAgIClcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlRGF0YShkYXRhc2V0czogRGF0YXNldHMsIG9sZExheWVyRGF0YTogYW55KSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5kYXRhSWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXJEYXRhc2V0ID0gZGF0YXNldHNbdGhpcy5jb25maWcuZGF0YUlkXTtcbiAgICBjb25zdCB7ZGF0YUNvbnRhaW5lcn0gPSBsYXllckRhdGFzZXQ7XG5cbiAgICBjb25zdCBnZXRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb25BY2Nlc3NvcihkYXRhQ29udGFpbmVyKTtcbiAgICBjb25zdCBkYXRhVXBkYXRlVHJpZ2dlcnMgPSB0aGlzLmdldERhdGFVcGRhdGVUcmlnZ2VycyhsYXllckRhdGFzZXQpO1xuICAgIGNvbnN0IHRyaWdnZXJDaGFuZ2VkID0gdGhpcy5nZXRDaGFuZ2VkVHJpZ2dlcnMoZGF0YVVwZGF0ZVRyaWdnZXJzKTtcblxuICAgIGlmICh0cmlnZ2VyQ2hhbmdlZCAmJiAodHJpZ2dlckNoYW5nZWQuZ2V0TWV0YSB8fCB0cmlnZ2VyQ2hhbmdlZC5nZXREYXRhKSkge1xuICAgICAgdGhpcy51cGRhdGVMYXllck1ldGEoZGF0YUNvbnRhaW5lciwgZ2V0UG9zaXRpb24pO1xuICAgIH1cblxuICAgIGxldCBkYXRhID0gW107XG5cbiAgICBpZiAoISh0cmlnZ2VyQ2hhbmdlZCAmJiB0cmlnZ2VyQ2hhbmdlZC5nZXREYXRhKSAmJiBvbGRMYXllckRhdGEgJiYgb2xkTGF5ZXJEYXRhLmRhdGEpIHtcbiAgICAgIC8vIHNhbWUgZGF0YVxuICAgICAgZGF0YSA9IG9sZExheWVyRGF0YS5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdGhpcy5jYWxjdWxhdGVEYXRhQXR0cmlidXRlKGxheWVyRGF0YXNldCwgZ2V0UG9zaXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB7ZGF0YSwgdHJpZ2dlckNoYW5nZWR9O1xuICB9XG5cbiAgLyoqXG4gICAqIGhlbHBlciBmdW5jdGlvbiB0byB1cGRhdGUgb25lIGxheWVyIGRvbWFpbiB3aGVuIHN0YXRlLmRhdGEgY2hhbmdlZFxuICAgKiBpZiBzdGF0ZS5kYXRhIGNoYW5nZSBpcyBkdWUgb3QgdXBkYXRlIGZpbHRlciwgbmV3RmlsZXIgd2lsbCBiZSBwYXNzZWRcbiAgICogY2FsbGVkIGJ5IHVwZGF0ZUFsbExheWVyRG9tYWluRGF0YVxuICAgKiBAcGFyYW0gZGF0YXNldHNcbiAgICogQHBhcmFtIG5ld0ZpbHRlclxuICAgKiBAcmV0dXJucyBsYXllclxuICAgKi9cbiAgdXBkYXRlTGF5ZXJEb21haW4oZGF0YXNldHM6IERhdGFzZXRzLCBuZXdGaWx0ZXI/OiBGaWx0ZXIpOiBMYXllciB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLmdldERhdGFzZXQoZGF0YXNldHMpO1xuICAgIGlmICghdGFibGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QudmFsdWVzKHRoaXMudmlzdWFsQ2hhbm5lbHMpLmZvckVhY2goY2hhbm5lbCA9PiB7XG4gICAgICBjb25zdCB7c2NhbGV9ID0gY2hhbm5lbDtcbiAgICAgIGNvbnN0IHNjYWxlVHlwZSA9IHRoaXMuY29uZmlnW3NjYWxlXTtcbiAgICAgIC8vIG9yZGluYWwgZG9tYWluIGlzIGJhc2VkIG9uIGRhdGFDb250YWluZXIsIGlmIG9ubHkgZmlsdGVyIGNoYW5nZWRcbiAgICAgIC8vIG5vIG5lZWQgdG8gdXBkYXRlIG9yZGluYWwgZG9tYWluXG4gICAgICBpZiAoIW5ld0ZpbHRlciB8fCBzY2FsZVR5cGUgIT09IFNDQUxFX1RZUEVTLm9yZGluYWwpIHtcbiAgICAgICAgY29uc3Qge2RvbWFpbn0gPSBjaGFubmVsO1xuICAgICAgICBjb25zdCB1cGRhdGVkRG9tYWluID0gdGhpcy5jYWxjdWxhdGVMYXllckRvbWFpbih0YWJsZSwgY2hhbm5lbCk7XG4gICAgICAgIHRoaXMudXBkYXRlTGF5ZXJDb25maWcoe1tkb21haW5dOiB1cGRhdGVkRG9tYWlufSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldERhdGFzZXQoZGF0YXNldHMpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YUlkID8gZGF0YXNldHNbdGhpcy5jb25maWcuZGF0YUlkXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdmlzdWFsIGNoYW5uZWwgZmllbGQgYW5kIHNjYWxlcyBiYXNlZCBvbiBzdXBwb3J0ZWQgZmllbGQgJiBzY2FsZSB0eXBlXG4gICAqIEBwYXJhbSBjaGFubmVsXG4gICAqL1xuICB2YWxpZGF0ZVZpc3VhbENoYW5uZWwoY2hhbm5lbDogc3RyaW5nKSB7XG4gICAgdGhpcy52YWxpZGF0ZUZpZWxkVHlwZShjaGFubmVsKTtcbiAgICB0aGlzLnZhbGlkYXRlU2NhbGUoY2hhbm5lbCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgZmllbGQgdHlwZSBiYXNlZCBvbiBjaGFubmVsU2NhbGVUeXBlXG4gICAqL1xuICB2YWxpZGF0ZUZpZWxkVHlwZShjaGFubmVsOiBzdHJpbmcpIHtcbiAgICBjb25zdCB2aXN1YWxDaGFubmVsID0gdGhpcy52aXN1YWxDaGFubmVsc1tjaGFubmVsXTtcbiAgICBjb25zdCB7ZmllbGQsIGNoYW5uZWxTY2FsZVR5cGUsIHN1cHBvcnRlZEZpZWxkVHlwZXN9ID0gdmlzdWFsQ2hhbm5lbDtcblxuICAgIGlmICh0aGlzLmNvbmZpZ1tmaWVsZF0pIHtcbiAgICAgIC8vIGlmIGZpZWxkIGlzIHNlbGVjdGVkLCBjaGVjayBpZiBmaWVsZCB0eXBlIGlzIHN1cHBvcnRlZFxuICAgICAgY29uc3QgY2hhbm5lbFN1cHBvcnRlZEZpZWxkVHlwZXMgPVxuICAgICAgICBzdXBwb3J0ZWRGaWVsZFR5cGVzIHx8IENIQU5ORUxfU0NBTEVfU1VQUE9SVEVEX0ZJRUxEU1tjaGFubmVsU2NhbGVUeXBlXTtcblxuICAgICAgaWYgKCFjaGFubmVsU3VwcG9ydGVkRmllbGRUeXBlcy5pbmNsdWRlcyh0aGlzLmNvbmZpZ1tmaWVsZF0udHlwZSkpIHtcbiAgICAgICAgLy8gZmllbGQgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLCBzZXQgaXQgYmFjayB0byBudWxsXG4gICAgICAgIC8vIHNldCBzY2FsZSBiYWNrIHRvIGRlZmF1bHRcbiAgICAgICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyh7W2ZpZWxkXTogbnVsbH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBzY2FsZSB0eXBlIGJhc2VkIG9uIGFnZ3JlZ2F0aW9uXG4gICAqL1xuICB2YWxpZGF0ZVNjYWxlKGNoYW5uZWwpIHtcbiAgICBjb25zdCB2aXN1YWxDaGFubmVsID0gdGhpcy52aXN1YWxDaGFubmVsc1tjaGFubmVsXTtcbiAgICBjb25zdCB7c2NhbGV9ID0gdmlzdWFsQ2hhbm5lbDtcbiAgICBpZiAoIXNjYWxlKSB7XG4gICAgICAvLyB2aXN1YWxDaGFubmVsIGRvZXNuJ3QgaGF2ZSBzY2FsZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSB0aGlzLmdldFNjYWxlT3B0aW9ucyhjaGFubmVsKTtcbiAgICAvLyBjaGVjayBpZiBjdXJyZW50IHNlbGVjdGVkIHNjYWxlIGlzXG4gICAgLy8gc3VwcG9ydGVkLCBpZiBub3QsIGNoYW5nZSB0byBkZWZhdWx0XG4gICAgaWYgKCFzY2FsZU9wdGlvbnMuaW5jbHVkZXModGhpcy5jb25maWdbc2NhbGVdKSkge1xuICAgICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyh7W3NjYWxlXTogc2NhbGVPcHRpb25zWzBdfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzY2FsZSBvcHRpb25zIGJhc2VkIG9uIGN1cnJlbnQgZmllbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxcbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgZ2V0U2NhbGVPcHRpb25zKGNoYW5uZWwpIHtcbiAgICBjb25zdCB2aXN1YWxDaGFubmVsID0gdGhpcy52aXN1YWxDaGFubmVsc1tjaGFubmVsXTtcbiAgICBjb25zdCB7ZmllbGQsIHNjYWxlLCBjaGFubmVsU2NhbGVUeXBlfSA9IHZpc3VhbENoYW5uZWw7XG5cbiAgICByZXR1cm4gdGhpcy5jb25maWdbZmllbGRdXG4gICAgICA/IEZJRUxEX09QVFNbdGhpcy5jb25maWdbZmllbGRdLnR5cGVdLnNjYWxlW2NoYW5uZWxTY2FsZVR5cGVdXG4gICAgICA6IFt0aGlzLmdldERlZmF1bHRMYXllckNvbmZpZyh7ZGF0YUlkOiAnJ30pW3NjYWxlXV07XG4gIH1cblxuICB1cGRhdGVMYXllclZpc3VhbENoYW5uZWwoZGF0YXNldDogS2VwbGVyVGFibGUsIGNoYW5uZWw6IHN0cmluZykge1xuICAgIGNvbnN0IHZpc3VhbENoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxdO1xuICAgIHRoaXMudmFsaWRhdGVWaXN1YWxDaGFubmVsKGNoYW5uZWwpO1xuICAgIC8vIGNhbGN1bGF0ZSBsYXllciBjaGFubmVsIGRvbWFpblxuICAgIGNvbnN0IHVwZGF0ZWREb21haW4gPSB0aGlzLmNhbGN1bGF0ZUxheWVyRG9tYWluKGRhdGFzZXQsIHZpc3VhbENoYW5uZWwpO1xuICAgIHRoaXMudXBkYXRlTGF5ZXJDb25maWcoe1t2aXN1YWxDaGFubmVsLmRvbWFpbl06IHVwZGF0ZWREb21haW59KTtcbiAgfVxuXG4gIGdldFZpc3VhbENoYW5uZWxVcGRhdGVUcmlnZ2VycygpOiBVcGRhdGVUcmlnZ2VycyB7XG4gICAgY29uc3QgdXBkYXRlVHJpZ2dlcnM6IFVwZGF0ZVRyaWdnZXJzID0ge307XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLnZpc3VhbENoYW5uZWxzKS5mb3JFYWNoKHZpc3VhbENoYW5uZWwgPT4ge1xuICAgICAgLy8gZmllbGQgcmFuZ2Ugc2NhbGUgZG9tYWluXG4gICAgICBjb25zdCB7YWNjZXNzb3IsIGZpZWxkLCBzY2FsZSwgZG9tYWluLCByYW5nZSwgZGVmYXVsdFZhbHVlLCBmaXhlZH0gPSB2aXN1YWxDaGFubmVsO1xuXG4gICAgICBpZiAoYWNjZXNzb3IpIHtcbiAgICAgICAgdXBkYXRlVHJpZ2dlcnNbYWNjZXNzb3JdID0ge1xuICAgICAgICAgIFtmaWVsZF06IHRoaXMuY29uZmlnW2ZpZWxkXSxcbiAgICAgICAgICBbc2NhbGVdOiB0aGlzLmNvbmZpZ1tzY2FsZV0sXG4gICAgICAgICAgW2RvbWFpbl06IHRoaXMuY29uZmlnW2RvbWFpbl0sXG4gICAgICAgICAgW3JhbmdlXTogdGhpcy5jb25maWcudmlzQ29uZmlnW3JhbmdlXSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6XG4gICAgICAgICAgICB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nID8gZGVmYXVsdFZhbHVlKHRoaXMuY29uZmlnKSA6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAuLi4oZml4ZWQgPyB7W2ZpeGVkXTogdGhpcy5jb25maWcudmlzQ29uZmlnW2ZpeGVkXX0gOiB7fSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdXBkYXRlVHJpZ2dlcnM7XG4gIH1cblxuICBjYWxjdWxhdGVMYXllckRvbWFpbihkYXRhc2V0LCB2aXN1YWxDaGFubmVsKSB7XG4gICAgY29uc3Qge3NjYWxlfSA9IHZpc3VhbENoYW5uZWw7XG4gICAgY29uc3Qgc2NhbGVUeXBlID0gdGhpcy5jb25maWdbc2NhbGVdO1xuXG4gICAgY29uc3QgZmllbGQgPSB0aGlzLmNvbmZpZ1t2aXN1YWxDaGFubmVsLmZpZWxkXTtcbiAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAvLyBpZiBjb2xvckZpZWxkIG9yIHNpemVGaWVsZCB3ZXJlIHNldCBiYWNrIHRvIG51bGxcbiAgICAgIHJldHVybiBkZWZhdWx0RG9tYWluO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhc2V0LmdldENvbHVtbkxheWVyRG9tYWluKGZpZWxkLCBzY2FsZVR5cGUpIHx8IGRlZmF1bHREb21haW47XG4gIH1cblxuICBoYXNIb3ZlcmVkT2JqZWN0KG9iamVjdEluZm8pIHtcbiAgICByZXR1cm4gdGhpcy5pc0xheWVySG92ZXJlZChvYmplY3RJbmZvKSAmJiBvYmplY3RJbmZvLm9iamVjdCA/IG9iamVjdEluZm8ub2JqZWN0IDogbnVsbDtcbiAgfVxuXG4gIGlzTGF5ZXJIb3ZlcmVkKG9iamVjdEluZm8pOiBib29sZWFuIHtcbiAgICByZXR1cm4gb2JqZWN0SW5mbz8ucGlja2VkICYmIG9iamVjdEluZm8/LmxheWVyPy5wcm9wcz8uaWQgPT09IHRoaXMuaWQ7XG4gIH1cblxuICBnZXRSYWRpdXNTY2FsZUJ5Wm9vbShtYXBTdGF0ZTogTWFwU3RhdGUsIGZpeGVkUmFkaXVzPzogYm9vbGVhbikge1xuICAgIGNvbnN0IHJhZGl1c0NoYW5uZWwgPSBPYmplY3QudmFsdWVzKHRoaXMudmlzdWFsQ2hhbm5lbHMpLmZpbmQodmMgPT4gdmMucHJvcGVydHkgPT09ICdyYWRpdXMnKTtcblxuICAgIGlmICghcmFkaXVzQ2hhbm5lbCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgY29uc3QgZmllbGQgPSByYWRpdXNDaGFubmVsLmZpZWxkO1xuICAgIGNvbnN0IGZpeGVkID0gZml4ZWRSYWRpdXMgPT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5maXhlZFJhZGl1cyA6IGZpeGVkUmFkaXVzO1xuICAgIGNvbnN0IHtyYWRpdXN9ID0gdGhpcy5jb25maWcudmlzQ29uZmlnO1xuXG4gICAgcmV0dXJuIGZpeGVkID8gMSA6ICh0aGlzLmNvbmZpZ1tmaWVsZF0gPyAxIDogcmFkaXVzKSAqIHRoaXMuZ2V0Wm9vbUZhY3RvcihtYXBTdGF0ZSk7XG4gIH1cblxuICBzaG91bGRDYWxjdWxhdGVMYXllckRhdGEocHJvcHM6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIHByb3BzLnNvbWUocCA9PiAhdGhpcy5ub25lTGF5ZXJEYXRhQWZmZWN0aW5nUHJvcHMuaW5jbHVkZXMocCkpO1xuICB9XG5cbiAgZ2V0QnJ1c2hpbmdFeHRlbnNpb25Qcm9wcyhpbnRlcmFjdGlvbkNvbmZpZywgYnJ1c2hpbmdUYXJnZXQ/KSB7XG4gICAgY29uc3Qge2JydXNofSA9IGludGVyYWN0aW9uQ29uZmlnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGJydXNoaW5nXG4gICAgICBhdXRvSGlnaGxpZ2h0OiAhYnJ1c2guZW5hYmxlZCxcbiAgICAgIGJydXNoaW5nUmFkaXVzOiBicnVzaC5jb25maWcuc2l6ZSAqIDEwMDAsXG4gICAgICBicnVzaGluZ1RhcmdldDogYnJ1c2hpbmdUYXJnZXQgfHwgJ3NvdXJjZScsXG4gICAgICBicnVzaGluZ0VuYWJsZWQ6IGJydXNoLmVuYWJsZWRcbiAgICB9O1xuICB9XG5cbiAgZ2V0RGVmYXVsdERlY2tMYXllclByb3BzKHtcbiAgICBpZHgsXG4gICAgZ3B1RmlsdGVyLFxuICAgIG1hcFN0YXRlLFxuICAgIHZpc2libGVcbiAgfToge1xuICAgIGlkeDogbnVtYmVyO1xuICAgIGdwdUZpbHRlcjogR3B1RmlsdGVyO1xuICAgIG1hcFN0YXRlOiBNYXBTdGF0ZTtcbiAgICB2aXNpYmxlOiBib29sZWFuO1xuICB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgaWR4LFxuICAgICAgY29vcmRpbmF0ZVN5c3RlbTogQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICAgICAgcGlja2FibGU6IHRydWUsXG4gICAgICB3cmFwTG9uZ2l0dWRlOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczoge2RlcHRoVGVzdDogQm9vbGVhbihtYXBTdGF0ZS5kcmFnUm90YXRlIHx8IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5lbmFibGUzZCl9LFxuICAgICAgaGlkZGVuOiB0aGlzLmNvbmZpZy5oaWRkZW4sXG4gICAgICAvLyB2aXNjb25maWdcbiAgICAgIG9wYWNpdHk6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5vcGFjaXR5LFxuICAgICAgaGlnaGxpZ2h0Q29sb3I6IHRoaXMuY29uZmlnLmhpZ2hsaWdodENvbG9yLFxuICAgICAgLy8gZGF0YSBmaWx0ZXJpbmdcbiAgICAgIGV4dGVuc2lvbnM6IFtkYXRhRmlsdGVyRXh0ZW5zaW9uXSxcbiAgICAgIGZpbHRlclJhbmdlOiBncHVGaWx0ZXIgPyBncHVGaWx0ZXIuZmlsdGVyUmFuZ2UgOiB1bmRlZmluZWQsXG5cbiAgICAgIC8vIGxheWVyIHNob3VsZCBiZSB2aXNpYmxlIGFuZCBpZiBzcGxpdE1hcCwgc2hvd24gaW4gdG8gb25lIG9mIHBhbmVsXG4gICAgICB2aXNpYmxlOiB0aGlzLmNvbmZpZy5pc1Zpc2libGUgJiYgdmlzaWJsZVxuICAgIH07XG4gIH1cblxuICBnZXREZWZhdWx0SG92ZXJMYXllclByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogYCR7dGhpcy5pZH0taG92ZXJlZGAsXG4gICAgICBwaWNrYWJsZTogZmFsc2UsXG4gICAgICB3cmFwTG9uZ2l0dWRlOiB0cnVlLFxuICAgICAgY29vcmRpbmF0ZVN5c3RlbTogQ09PUkRJTkFURV9TWVNURU0uTE5HTEFUXG4gICAgfTtcbiAgfVxuXG4gIHJlbmRlclRleHRMYWJlbExheWVyKFxuICAgIHtcbiAgICAgIGdldFBvc2l0aW9uLFxuICAgICAgZ2V0UGl4ZWxPZmZzZXQsXG4gICAgICBiYWNrZ3JvdW5kUHJvcHMsXG4gICAgICB1cGRhdGVUcmlnZ2VycyxcbiAgICAgIHNoYXJlZFByb3BzXG4gICAgfToge1xuICAgICAgZ2V0UG9zaXRpb246IGFueTtcbiAgICAgIGdldFBpeGVsT2Zmc2V0OiBhbnk7XG4gICAgICBiYWNrZ3JvdW5kUHJvcHM/OiBhbnk7XG4gICAgICB1cGRhdGVUcmlnZ2VyczogYW55O1xuICAgICAgc2hhcmVkUHJvcHM6IGFueTtcbiAgICB9LFxuICAgIHJlbmRlck9wdHNcbiAgKSB7XG4gICAgY29uc3Qge2RhdGEsIG1hcFN0YXRlfSA9IHJlbmRlck9wdHM7XG4gICAgY29uc3Qge3RleHRMYWJlbH0gPSB0aGlzLmNvbmZpZztcblxuICAgIHJldHVybiBkYXRhLnRleHRMYWJlbHMucmVkdWNlKChhY2N1LCBkLCBpKSA9PiB7XG4gICAgICBpZiAoZC5nZXRUZXh0KSB7XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmQgPSB0ZXh0TGFiZWxbaV0uYmFja2dyb3VuZCB8fCBiYWNrZ3JvdW5kUHJvcHM/LmJhY2tncm91bmQ7XG5cbiAgICAgICAgYWNjdS5wdXNoKFxuICAgICAgICAgIG5ldyBUZXh0TGF5ZXIoe1xuICAgICAgICAgICAgLi4uc2hhcmVkUHJvcHMsXG4gICAgICAgICAgICBpZDogYCR7dGhpcy5pZH0tbGFiZWwtJHt0ZXh0TGFiZWxbaV0uZmllbGQ/Lm5hbWV9YCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEuZGF0YSxcbiAgICAgICAgICAgIHZpc2libGU6IHRoaXMuY29uZmlnLmlzVmlzaWJsZSxcbiAgICAgICAgICAgIGdldFRleHQ6IGQuZ2V0VGV4dCxcbiAgICAgICAgICAgIGdldFBvc2l0aW9uLFxuICAgICAgICAgICAgY2hhcmFjdGVyU2V0OiBkLmNoYXJhY3RlclNldCxcbiAgICAgICAgICAgIGdldFBpeGVsT2Zmc2V0OiBnZXRQaXhlbE9mZnNldCh0ZXh0TGFiZWxbaV0pLFxuICAgICAgICAgICAgZ2V0U2l6ZTogUFJPSkVDVEVEX1BJWEVMX1NJWkVfTVVMVElQTElFUixcbiAgICAgICAgICAgIHNpemVTY2FsZTogdGV4dExhYmVsW2ldLnNpemUsXG4gICAgICAgICAgICBnZXRUZXh0QW5jaG9yOiB0ZXh0TGFiZWxbaV0uYW5jaG9yLFxuICAgICAgICAgICAgZ2V0QWxpZ25tZW50QmFzZWxpbmU6IHRleHRMYWJlbFtpXS5hbGlnbm1lbnQsXG4gICAgICAgICAgICBnZXRDb2xvcjogdGV4dExhYmVsW2ldLmNvbG9yLFxuICAgICAgICAgICAgb3V0bGluZVdpZHRoOiB0ZXh0TGFiZWxbaV0ub3V0bGluZVdpZHRoICogVEVYVF9PVVRMSU5FX01VTFRJUExJRVIsXG4gICAgICAgICAgICBvdXRsaW5lQ29sb3I6IHRleHRMYWJlbFtpXS5vdXRsaW5lQ29sb3IsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLFxuICAgICAgICAgICAgZ2V0QmFja2dyb3VuZENvbG9yOiB0ZXh0TGFiZWxbaV0uYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udFNldHRpbmdzOiB7XG4gICAgICAgICAgICAgIHNkZjogdGV4dExhYmVsW2ldLm91dGxpbmVXaWR0aCA+IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgIC8vIHRleHQgd2lsbCBhbHdheXMgc2hvdyBvbiB0b3Agb2YgYWxsIGxheWVyc1xuICAgICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRGaWx0ZXJWYWx1ZTogZGF0YS5nZXRGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgICAgIC4uLnVwZGF0ZVRyaWdnZXJzLFxuICAgICAgICAgICAgICBnZXRUZXh0OiB0ZXh0TGFiZWxbaV0uZmllbGQ/Lm5hbWUsXG4gICAgICAgICAgICAgIGdldFBpeGVsT2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgLi4udXBkYXRlVHJpZ2dlcnMuZ2V0UmFkaXVzLFxuICAgICAgICAgICAgICAgIG1hcFN0YXRlLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogdGV4dExhYmVsW2ldLmFuY2hvcixcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IHRleHRMYWJlbFtpXS5hbGlnbm1lbnRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2V0VGV4dEFuY2hvcjogdGV4dExhYmVsW2ldLmFuY2hvcixcbiAgICAgICAgICAgICAgZ2V0QWxpZ25tZW50QmFzZWxpbmU6IHRleHRMYWJlbFtpXS5hbGlnbm1lbnQsXG4gICAgICAgICAgICAgIGdldENvbG9yOiB0ZXh0TGFiZWxbaV0uY29sb3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc3ViTGF5ZXJQcm9wczoge1xuICAgICAgICAgICAgICAuLi4oYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VsbDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IG51bGwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1O1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZURhdGFBdHRyaWJ1dGUoa2VwbGVyVGFibGU6IEtlcGxlclRhYmxlLCBnZXRQb3NpdGlvbik6IGFueSB7XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHVwZGF0ZUxheWVyTWV0YShkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlLCBnZXRQb3NpdGlvbikge1xuICAgIC8vIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcbiAgfVxuXG4gIGdldFBvc2l0aW9uQWNjZXNzb3IoZGF0YUNvbnRhaW5lcj86IERhdGFDb250YWluZXJJbnRlcmZhY2UpOiAoLi4uYXJnczogYW55W10pID0+IGFueSB7XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xuICAgIHJldHVybiAoKSA9PiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyO1xuIl19