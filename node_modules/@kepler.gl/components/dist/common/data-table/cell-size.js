"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderedSize = renderedSize;
exports.adjustCellsToContainer = adjustCellsToContainer;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _document = _interopRequireDefault(require("global/document"));

var _utils = require("@kepler.gl/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var MIN_GHOST_CELL_SIZE = 200;
var MIN_CELL_SIZE = 45; // first column have padding on the left

var EDGE_COLUMN_PADDING = 10; // in case cell content is small, column name is big, we allow max empty space to
// be added to min cell width in order to show column name

var MAX_EMPTY_COLUMN_SPACE = 60;

/**
 * Measure rows and column content to determine min width for each column
 * @param {RenderSizeParam} param0
 */
function renderedSize(_ref) {
  var _ref$text = _ref.text,
      dataContainer = _ref$text.dataContainer,
      column = _ref$text.column,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'string' : _ref$type,
      colIdx = _ref.colIdx,
      _ref$numRowsToCalcula = _ref.numRowsToCalculate,
      numRowsToCalculate = _ref$numRowsToCalcula === void 0 ? 10 : _ref$numRowsToCalcula,
      _ref$fontSize = _ref.fontSize,
      fontSize = _ref$fontSize === void 0 ? 12 : _ref$fontSize,
      _ref$font = _ref.font,
      font = _ref$font === void 0 ? 'Lato' : _ref$font,
      _ref$cellPadding = _ref.cellPadding,
      cellPadding = _ref$cellPadding === void 0 ? 40 : _ref$cellPadding,
      _ref$maxCellSize = _ref.maxCellSize,
      maxCellSize = _ref$maxCellSize === void 0 ? 500 : _ref$maxCellSize,
      _ref$maxHeaderSize = _ref.maxHeaderSize,
      maxHeaderSize = _ref$maxHeaderSize === void 0 ? 500 : _ref$maxHeaderSize,
      _ref$minCellSize = _ref.minCellSize,
      minCellSize = _ref$minCellSize === void 0 ? MIN_CELL_SIZE : _ref$minCellSize,
      _ref$optionsButton = _ref.optionsButton,
      optionsButton = _ref$optionsButton === void 0 ? 44 : _ref$optionsButton;

  if (!_document["default"]) {
    return {
      row: 0,
      header: 0
    };
  }

  var textCanvas = _document["default"].createElement('canvas');

  _document["default"].body.appendChild(textCanvas);

  var context = textCanvas.getContext('2d');
  context.font = [fontSize, font].join('px ');
  var rowsToSample = (0, _toConsumableArray2["default"])(Array(numRowsToCalculate)).map(function () {
    return Math.floor(Math.random() * (dataContainer.numRows() - 1));
  }); // If we have less than 10 rows, lets measure all of them

  if (dataContainer.numRows() <= numRowsToCalculate) {
    rowsToSample = Array.from(Array(dataContainer.numRows()).keys());
  }

  var rowWidth = Math.max.apply(Math, (0, _toConsumableArray2["default"])(rowsToSample.map(function (rowIdx) {
    var value = (0, _utils.parseFieldValue)(dataContainer.valueAt(rowIdx, colIdx), type); // measuring large text cause slow performance

    if (value.length > maxCellSize) {
      return maxCellSize;
    }

    var textWidth = context.measureText(value).width;
    return Math.ceil(textWidth) + cellPadding;
  }))); // header cell only has left padding

  var headerWidth = Math.ceil(context.measureText(column).width) + cellPadding / 2 + optionsButton; // min row width is measured by cell content

  var minRowWidth = minCellSize + cellPadding; // min header width is measured by cell

  var minHeaderWidth = minCellSize + cellPadding / 2 + optionsButton;
  var clampedRowWidth = clamp(minRowWidth, maxCellSize, rowWidth);
  var clampedHeaderWidth = clamp(minHeaderWidth, maxHeaderSize, headerWidth); // cleanup

  textCanvas.parentElement.removeChild(textCanvas);
  return {
    row: clampedRowWidth,
    header: clampedHeaderWidth
  };
}

function clamp(min, max, value) {
  return Math.max(Math.min(max, value), min);
}

function getColumnOrder() {
  var pinnedColumns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var unpinnedColumns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return [].concat((0, _toConsumableArray2["default"])(pinnedColumns), (0, _toConsumableArray2["default"])(unpinnedColumns));
} // If total min cell size is bigger than containerWidth adjust column


function getMinCellSize(cellSizeCache) {
  return Object.keys(cellSizeCache).reduce(function (accu, col) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, col, cellSizeCache[col].row > cellSizeCache[col].header ? cellSizeCache[col].row : // if row is smaller than header, use the smaller of MAX_EMPTY_COLUMN_SPACE + row width and header
    Math.min(cellSizeCache[col].header, cellSizeCache[col].row + MAX_EMPTY_COLUMN_SPACE)));
  }, {});
}

function getSizeSum(sizeCache, key) {
  return Object.keys(sizeCache).reduce(function (acc, val) {
    return acc + (key ? sizeCache[val][key] : sizeCache[val]);
  }, 0);
}
/**
 * Expand cell to fit both row and header, if there is still room left,
 * expand last cell to fit the entire width of the container
 * @param {CellSizeCache} cellSizeCache
 * @param {string[]} columnOrder
 * @param {number} containerWidth
 * @param {number} roomToFill
 */


function expandCellSize(cellSizeCache, columnOrder, containerWidth, roomToFill) {
  var remaining = roomToFill;
  var expandedCellSize = columnOrder.reduce(function (accu, col) {
    var size = cellSizeCache[col].row;

    if (cellSizeCache[col].row < cellSizeCache[col].header && remaining > 0) {
      // if we are cutting off the header, expand to fit it
      size = cellSizeCache[col].header - cellSizeCache[col].row < remaining ? cellSizeCache[col].header : cellSizeCache[col].row + remaining;
      remaining -= size - cellSizeCache[col].row;
    }

    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, col, size));
  }, {});
  var ghost = null;

  if (remaining > 0 && remaining < MIN_GHOST_CELL_SIZE) {
    // expand last cell
    var lastCell = columnOrder[columnOrder.length - 1];
    expandedCellSize[lastCell] += remaining;
  } else if (remaining >= MIN_GHOST_CELL_SIZE) {
    // if too much left add a ghost cell
    ghost = remaining;
  }

  return {
    cellSizeCache: expandedCellSize,
    ghost: ghost
  };
}

function addPaddingToFirstColumn(cellSizeCache) {
  var columnOrder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var firstCol = columnOrder[0];

  if (firstCol && cellSizeCache[firstCol]) {
    return _objectSpread(_objectSpread({}, cellSizeCache), {}, (0, _defineProperty2["default"])({}, firstCol, {
      header: cellSizeCache[firstCol].header + EDGE_COLUMN_PADDING,
      row: cellSizeCache[firstCol].row + EDGE_COLUMN_PADDING
    }));
  }

  return cellSizeCache;
}
/**
 * Adjust cell size based on container width
 * @param {number} containerWidth
 * @param {CellSizeCache} cellSizeCache
 * @param {string[]} pinnedColumns
 * @param {string[]} unpinnedColumns
 */


function adjustCellsToContainer(containerWidth, cellSizeCache, pinnedColumns, unpinnedColumns) {
  var columnOrder = getColumnOrder(pinnedColumns, unpinnedColumns);
  var paddedCellSize = addPaddingToFirstColumn(cellSizeCache, columnOrder);
  var minRowSum = getSizeSum(paddedCellSize, 'row');

  if (minRowSum >= containerWidth) {
    // we apply the min Width to all cells
    return {
      cellSizeCache: getMinCellSize(paddedCellSize)
    };
  } // if we have some room to expand


  return expandCellSize(paddedCellSize, columnOrder, containerWidth, containerWidth - minRowSum);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vZGF0YS10YWJsZS9jZWxsLXNpemUudHMiXSwibmFtZXMiOlsiTUlOX0dIT1NUX0NFTExfU0laRSIsIk1JTl9DRUxMX1NJWkUiLCJFREdFX0NPTFVNTl9QQURESU5HIiwiTUFYX0VNUFRZX0NPTFVNTl9TUEFDRSIsInJlbmRlcmVkU2l6ZSIsInRleHQiLCJkYXRhQ29udGFpbmVyIiwiY29sdW1uIiwidHlwZSIsImNvbElkeCIsIm51bVJvd3NUb0NhbGN1bGF0ZSIsImZvbnRTaXplIiwiZm9udCIsImNlbGxQYWRkaW5nIiwibWF4Q2VsbFNpemUiLCJtYXhIZWFkZXJTaXplIiwibWluQ2VsbFNpemUiLCJvcHRpb25zQnV0dG9uIiwiZG9jdW1lbnQiLCJyb3ciLCJoZWFkZXIiLCJ0ZXh0Q2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNvbnRleHQiLCJnZXRDb250ZXh0Iiwiam9pbiIsInJvd3NUb1NhbXBsZSIsIkFycmF5IiwibWFwIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibnVtUm93cyIsImZyb20iLCJrZXlzIiwicm93V2lkdGgiLCJtYXgiLCJyb3dJZHgiLCJ2YWx1ZSIsInZhbHVlQXQiLCJsZW5ndGgiLCJ0ZXh0V2lkdGgiLCJtZWFzdXJlVGV4dCIsIndpZHRoIiwiY2VpbCIsImhlYWRlcldpZHRoIiwibWluUm93V2lkdGgiLCJtaW5IZWFkZXJXaWR0aCIsImNsYW1wZWRSb3dXaWR0aCIsImNsYW1wIiwiY2xhbXBlZEhlYWRlcldpZHRoIiwicGFyZW50RWxlbWVudCIsInJlbW92ZUNoaWxkIiwibWluIiwiZ2V0Q29sdW1uT3JkZXIiLCJwaW5uZWRDb2x1bW5zIiwidW5waW5uZWRDb2x1bW5zIiwiZ2V0TWluQ2VsbFNpemUiLCJjZWxsU2l6ZUNhY2hlIiwiT2JqZWN0IiwicmVkdWNlIiwiYWNjdSIsImNvbCIsImdldFNpemVTdW0iLCJzaXplQ2FjaGUiLCJrZXkiLCJhY2MiLCJ2YWwiLCJleHBhbmRDZWxsU2l6ZSIsImNvbHVtbk9yZGVyIiwiY29udGFpbmVyV2lkdGgiLCJyb29tVG9GaWxsIiwicmVtYWluaW5nIiwiZXhwYW5kZWRDZWxsU2l6ZSIsInNpemUiLCJnaG9zdCIsImxhc3RDZWxsIiwiYWRkUGFkZGluZ1RvRmlyc3RDb2x1bW4iLCJmaXJzdENvbCIsImFkanVzdENlbGxzVG9Db250YWluZXIiLCJwYWRkZWRDZWxsU2l6ZSIsIm1pblJvd1N1bSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsbUJBQTJCLEdBQUcsR0FBcEM7QUFDQSxJQUFNQyxhQUFhLEdBQUcsRUFBdEIsQyxDQUNBOztBQUNBLElBQU1DLG1CQUFtQixHQUFHLEVBQTVCLEMsQ0FFQTtBQUNBOztBQUNBLElBQU1DLHNCQUFzQixHQUFHLEVBQS9COztBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNDLFlBQVQsT0FZNEM7QUFBQSx1QkFYakRDLElBV2lEO0FBQUEsTUFYMUNDLGFBVzBDLGFBWDFDQSxhQVcwQztBQUFBLE1BWDNCQyxNQVcyQixhQVgzQkEsTUFXMkI7QUFBQSx1QkFWakRDLElBVWlEO0FBQUEsTUFWakRBLElBVWlELDBCQVYxQyxRQVUwQztBQUFBLE1BVGpEQyxNQVNpRCxRQVRqREEsTUFTaUQ7QUFBQSxtQ0FSakRDLGtCQVFpRDtBQUFBLE1BUmpEQSxrQkFRaUQsc0NBUjVCLEVBUTRCO0FBQUEsMkJBUGpEQyxRQU9pRDtBQUFBLE1BUGpEQSxRQU9pRCw4QkFQdEMsRUFPc0M7QUFBQSx1QkFOakRDLElBTWlEO0FBQUEsTUFOakRBLElBTWlELDBCQU4xQyxNQU0wQztBQUFBLDhCQUxqREMsV0FLaUQ7QUFBQSxNQUxqREEsV0FLaUQsaUNBTG5DLEVBS21DO0FBQUEsOEJBSmpEQyxXQUlpRDtBQUFBLE1BSmpEQSxXQUlpRCxpQ0FKbkMsR0FJbUM7QUFBQSxnQ0FIakRDLGFBR2lEO0FBQUEsTUFIakRBLGFBR2lELG1DQUhqQyxHQUdpQztB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QUNuQixhQUFELEVBQWdCVyxXQUFoQixDQUE5QztBQUNBLE1BQU1ZLFNBQVMsR0FBR2xCLFVBQVUsQ0FBQ2lCLGNBQUQsRUFBaUIsS0FBakIsQ0FBNUI7O0FBRUEsTUFBSUMsU0FBUyxJQUFJWCxjQUFqQixFQUFpQztBQUMvQjtBQUNBLFdBQU87QUFBQ1osTUFBQUEsYUFBYSxFQUFFRCxjQUFjLENBQUN1QixjQUFEO0FBQTlCLEtBQVA7QUFDRCxHQVJELENBU0E7OztBQUNBLFNBQU9aLGNBQWMsQ0FBQ1ksY0FBRCxFQUFpQlgsV0FBakIsRUFBOEJDLGNBQTlCLEVBQThDQSxjQUFjLEdBQUdXLFNBQS9ELENBQXJCO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcbmltcG9ydCB7RGF0YUNvbnRhaW5lckludGVyZmFjZSwgcGFyc2VGaWVsZFZhbHVlfSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcblxuY29uc3QgTUlOX0dIT1NUX0NFTExfU0laRTogbnVtYmVyID0gMjAwO1xuY29uc3QgTUlOX0NFTExfU0laRSA9IDQ1O1xuLy8gZmlyc3QgY29sdW1uIGhhdmUgcGFkZGluZyBvbiB0aGUgbGVmdFxuY29uc3QgRURHRV9DT0xVTU5fUEFERElORyA9IDEwO1xuXG4vLyBpbiBjYXNlIGNlbGwgY29udGVudCBpcyBzbWFsbCwgY29sdW1uIG5hbWUgaXMgYmlnLCB3ZSBhbGxvdyBtYXggZW1wdHkgc3BhY2UgdG9cbi8vIGJlIGFkZGVkIHRvIG1pbiBjZWxsIHdpZHRoIGluIG9yZGVyIHRvIHNob3cgY29sdW1uIG5hbWVcbmNvbnN0IE1BWF9FTVBUWV9DT0xVTU5fU1BBQ0UgPSA2MDtcblxudHlwZSBSZW5kZXJTaXplUGFyYW0gPSB7XG4gIHRleHQ6IHtkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlOyBjb2x1bW46IHN0cmluZ307XG4gIHR5cGU/OiBzdHJpbmc7XG4gIGNvbElkeDogbnVtYmVyO1xuICBudW1Sb3dzVG9DYWxjdWxhdGU/OiBudW1iZXI7XG4gIGZvbnRTaXplPzogbnVtYmVyO1xuICBmb250Pzogc3RyaW5nO1xuICBjZWxsUGFkZGluZz86IG51bWJlcjtcbiAgbWF4Q2VsbFNpemU/OiBudW1iZXI7XG4gIG1heEhlYWRlclNpemU/OiBudW1iZXI7XG4gIG1pbkNlbGxTaXplPzogbnVtYmVyO1xuICBvcHRpb25zQnV0dG9uPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgQ2VsbFNpemVDYWNoZSA9IHtcbiAgW2tleTogc3RyaW5nXToge1xuICAgIHJvdzogbnVtYmVyO1xuICAgIGhlYWRlcjogbnVtYmVyO1xuICB9O1xufTtcblxuLyoqXG4gKiBNZWFzdXJlIHJvd3MgYW5kIGNvbHVtbiBjb250ZW50IHRvIGRldGVybWluZSBtaW4gd2lkdGggZm9yIGVhY2ggY29sdW1uXG4gKiBAcGFyYW0ge1JlbmRlclNpemVQYXJhbX0gcGFyYW0wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJlZFNpemUoe1xuICB0ZXh0OiB7ZGF0YUNvbnRhaW5lciwgY29sdW1ufSxcbiAgdHlwZSA9ICdzdHJpbmcnLFxuICBjb2xJZHgsXG4gIG51bVJvd3NUb0NhbGN1bGF0ZSA9IDEwLFxuICBmb250U2l6ZSA9IDEyLFxuICBmb250ID0gJ0xhdG8nLFxuICBjZWxsUGFkZGluZyA9IDQwLFxuICBtYXhDZWxsU2l6ZSA9IDUwMCxcbiAgbWF4SGVhZGVyU2l6ZSA9IDUwMCxcbiAgbWluQ2VsbFNpemUgPSBNSU5fQ0VMTF9TSVpFLFxuICBvcHRpb25zQnV0dG9uID0gNDRcbn06IFJlbmRlclNpemVQYXJhbSk6IHtyb3c6IG51bWJlcjsgaGVhZGVyOiBudW1iZXJ9IHtcbiAgaWYgKCFkb2N1bWVudCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3c6IDAsXG4gICAgICBoZWFkZXI6IDBcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgdGV4dENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRleHRDYW52YXMpO1xuICBjb25zdCBjb250ZXh0ID0gdGV4dENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjb250ZXh0LmZvbnQgPSBbZm9udFNpemUsIGZvbnRdLmpvaW4oJ3B4ICcpO1xuXG4gIGxldCByb3dzVG9TYW1wbGUgPSBbLi4uQXJyYXkobnVtUm93c1RvQ2FsY3VsYXRlKV0ubWFwKCgpID0+XG4gICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGRhdGFDb250YWluZXIubnVtUm93cygpIC0gMSkpXG4gICk7XG5cbiAgLy8gSWYgd2UgaGF2ZSBsZXNzIHRoYW4gMTAgcm93cywgbGV0cyBtZWFzdXJlIGFsbCBvZiB0aGVtXG4gIGlmIChkYXRhQ29udGFpbmVyLm51bVJvd3MoKSA8PSBudW1Sb3dzVG9DYWxjdWxhdGUpIHtcbiAgICByb3dzVG9TYW1wbGUgPSBBcnJheS5mcm9tKEFycmF5KGRhdGFDb250YWluZXIubnVtUm93cygpKS5rZXlzKCkpO1xuICB9XG4gIGNvbnN0IHJvd1dpZHRoID0gTWF0aC5tYXgoXG4gICAgLi4ucm93c1RvU2FtcGxlLm1hcChyb3dJZHggPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUZpZWxkVmFsdWUoZGF0YUNvbnRhaW5lci52YWx1ZUF0KHJvd0lkeCwgY29sSWR4KSwgdHlwZSk7XG4gICAgICAvLyBtZWFzdXJpbmcgbGFyZ2UgdGV4dCBjYXVzZSBzbG93IHBlcmZvcm1hbmNlXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gbWF4Q2VsbFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG1heENlbGxTaXplO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dFdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dCh2YWx1ZSkud2lkdGg7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHRleHRXaWR0aCkgKyBjZWxsUGFkZGluZztcbiAgICB9KVxuICApO1xuICAvLyBoZWFkZXIgY2VsbCBvbmx5IGhhcyBsZWZ0IHBhZGRpbmdcbiAgY29uc3QgaGVhZGVyV2lkdGggPVxuICAgIE1hdGguY2VpbChjb250ZXh0Lm1lYXN1cmVUZXh0KGNvbHVtbikud2lkdGgpICsgY2VsbFBhZGRpbmcgLyAyICsgb3B0aW9uc0J1dHRvbjtcblxuICAvLyBtaW4gcm93IHdpZHRoIGlzIG1lYXN1cmVkIGJ5IGNlbGwgY29udGVudFxuICBjb25zdCBtaW5Sb3dXaWR0aCA9IG1pbkNlbGxTaXplICsgY2VsbFBhZGRpbmc7XG4gIC8vIG1pbiBoZWFkZXIgd2lkdGggaXMgbWVhc3VyZWQgYnkgY2VsbFxuICBjb25zdCBtaW5IZWFkZXJXaWR0aCA9IG1pbkNlbGxTaXplICsgY2VsbFBhZGRpbmcgLyAyICsgb3B0aW9uc0J1dHRvbjtcblxuICBjb25zdCBjbGFtcGVkUm93V2lkdGggPSBjbGFtcChtaW5Sb3dXaWR0aCwgbWF4Q2VsbFNpemUsIHJvd1dpZHRoKTtcbiAgY29uc3QgY2xhbXBlZEhlYWRlcldpZHRoID0gY2xhbXAobWluSGVhZGVyV2lkdGgsIG1heEhlYWRlclNpemUsIGhlYWRlcldpZHRoKTtcblxuICAvLyBjbGVhbnVwXG4gIHRleHRDYW52YXMucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0ZXh0Q2FudmFzKTtcblxuICByZXR1cm4ge1xuICAgIHJvdzogY2xhbXBlZFJvd1dpZHRoLFxuICAgIGhlYWRlcjogY2xhbXBlZEhlYWRlcldpZHRoXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obWF4LCB2YWx1ZSksIG1pbik7XG59XG5cbmZ1bmN0aW9uIGdldENvbHVtbk9yZGVyKHBpbm5lZENvbHVtbnM6IHN0cmluZ1tdID0gW10sIHVucGlubmVkQ29sdW1uczogc3RyaW5nW10gPSBbXSkge1xuICByZXR1cm4gWy4uLnBpbm5lZENvbHVtbnMsIC4uLnVucGlubmVkQ29sdW1uc107XG59XG5cbi8vIElmIHRvdGFsIG1pbiBjZWxsIHNpemUgaXMgYmlnZ2VyIHRoYW4gY29udGFpbmVyV2lkdGggYWRqdXN0IGNvbHVtblxuZnVuY3Rpb24gZ2V0TWluQ2VsbFNpemUoY2VsbFNpemVDYWNoZTogQ2VsbFNpemVDYWNoZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoY2VsbFNpemVDYWNoZSkucmVkdWNlKFxuICAgIChhY2N1LCBjb2wpID0+ICh7XG4gICAgICAuLi5hY2N1LFxuICAgICAgLy8gaWYgcm93IGlzIGxhcmdlciB0aGFuIGhlYWRlciwgdXNlIHJvd1xuICAgICAgW2NvbF06XG4gICAgICAgIGNlbGxTaXplQ2FjaGVbY29sXS5yb3cgPiBjZWxsU2l6ZUNhY2hlW2NvbF0uaGVhZGVyXG4gICAgICAgICAgPyBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93XG4gICAgICAgICAgOiAvLyBpZiByb3cgaXMgc21hbGxlciB0aGFuIGhlYWRlciwgdXNlIHRoZSBzbWFsbGVyIG9mIE1BWF9FTVBUWV9DT0xVTU5fU1BBQ0UgKyByb3cgd2lkdGggYW5kIGhlYWRlclxuICAgICAgICAgICAgTWF0aC5taW4oY2VsbFNpemVDYWNoZVtjb2xdLmhlYWRlciwgY2VsbFNpemVDYWNoZVtjb2xdLnJvdyArIE1BWF9FTVBUWV9DT0xVTU5fU1BBQ0UpXG4gICAgfSksXG4gICAge31cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZVN1bShzaXplQ2FjaGUsIGtleSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoc2l6ZUNhY2hlKS5yZWR1Y2UoXG4gICAgKGFjYywgdmFsKSA9PiBhY2MgKyAoa2V5ID8gc2l6ZUNhY2hlW3ZhbF1ba2V5XSA6IHNpemVDYWNoZVt2YWxdKSxcbiAgICAwXG4gICk7XG59XG5cbi8qKlxuICogRXhwYW5kIGNlbGwgdG8gZml0IGJvdGggcm93IGFuZCBoZWFkZXIsIGlmIHRoZXJlIGlzIHN0aWxsIHJvb20gbGVmdCxcbiAqIGV4cGFuZCBsYXN0IGNlbGwgdG8gZml0IHRoZSBlbnRpcmUgd2lkdGggb2YgdGhlIGNvbnRhaW5lclxuICogQHBhcmFtIHtDZWxsU2l6ZUNhY2hlfSBjZWxsU2l6ZUNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBjb2x1bW5PcmRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbnRhaW5lcldpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gcm9vbVRvRmlsbFxuICovXG5mdW5jdGlvbiBleHBhbmRDZWxsU2l6ZShcbiAgY2VsbFNpemVDYWNoZTogQ2VsbFNpemVDYWNoZSxcbiAgY29sdW1uT3JkZXI6IHN0cmluZ1tdLFxuICBjb250YWluZXJXaWR0aDogbnVtYmVyLFxuICByb29tVG9GaWxsOiBudW1iZXJcbik6IHtcbiAgY2VsbFNpemVDYWNoZTogQ2VsbFNpemVDYWNoZTtcbiAgZ2hvc3Q6IG51bWJlciB8IG51bGw7XG59IHtcbiAgbGV0IHJlbWFpbmluZyA9IHJvb21Ub0ZpbGw7XG5cbiAgY29uc3QgZXhwYW5kZWRDZWxsU2l6ZSA9IGNvbHVtbk9yZGVyLnJlZHVjZSgoYWNjdSwgY29sKSA9PiB7XG4gICAgbGV0IHNpemUgPSBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93O1xuICAgIGlmIChjZWxsU2l6ZUNhY2hlW2NvbF0ucm93IDwgY2VsbFNpemVDYWNoZVtjb2xdLmhlYWRlciAmJiByZW1haW5pbmcgPiAwKSB7XG4gICAgICAvLyBpZiB3ZSBhcmUgY3V0dGluZyBvZmYgdGhlIGhlYWRlciwgZXhwYW5kIHRvIGZpdCBpdFxuICAgICAgc2l6ZSA9XG4gICAgICAgIGNlbGxTaXplQ2FjaGVbY29sXS5oZWFkZXIgLSBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93IDwgcmVtYWluaW5nXG4gICAgICAgICAgPyBjZWxsU2l6ZUNhY2hlW2NvbF0uaGVhZGVyXG4gICAgICAgICAgOiBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93ICsgcmVtYWluaW5nO1xuICAgICAgcmVtYWluaW5nIC09IHNpemUgLSBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2N1LFxuICAgICAgW2NvbF06IHNpemVcbiAgICB9O1xuICB9LCB7fSk7XG5cbiAgbGV0IGdob3N0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgaWYgKHJlbWFpbmluZyA+IDAgJiYgcmVtYWluaW5nIDwgTUlOX0dIT1NUX0NFTExfU0laRSkge1xuICAgIC8vIGV4cGFuZCBsYXN0IGNlbGxcbiAgICBjb25zdCBsYXN0Q2VsbCA9IGNvbHVtbk9yZGVyW2NvbHVtbk9yZGVyLmxlbmd0aCAtIDFdO1xuICAgIGV4cGFuZGVkQ2VsbFNpemVbbGFzdENlbGxdICs9IHJlbWFpbmluZztcbiAgfSBlbHNlIGlmIChyZW1haW5pbmcgPj0gTUlOX0dIT1NUX0NFTExfU0laRSkge1xuICAgIC8vIGlmIHRvbyBtdWNoIGxlZnQgYWRkIGEgZ2hvc3QgY2VsbFxuICAgIGdob3N0ID0gcmVtYWluaW5nO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjZWxsU2l6ZUNhY2hlOiBleHBhbmRlZENlbGxTaXplLFxuICAgIGdob3N0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZFBhZGRpbmdUb0ZpcnN0Q29sdW1uKFxuICBjZWxsU2l6ZUNhY2hlOiBDZWxsU2l6ZUNhY2hlLFxuICBjb2x1bW5PcmRlcjogc3RyaW5nW10gPSBbXVxuKTogQ2VsbFNpemVDYWNoZSB7XG4gIGNvbnN0IGZpcnN0Q29sID0gY29sdW1uT3JkZXJbMF07XG5cbiAgaWYgKGZpcnN0Q29sICYmIGNlbGxTaXplQ2FjaGVbZmlyc3RDb2xdKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNlbGxTaXplQ2FjaGUsXG4gICAgICBbZmlyc3RDb2xdOiB7XG4gICAgICAgIGhlYWRlcjogY2VsbFNpemVDYWNoZVtmaXJzdENvbF0uaGVhZGVyICsgRURHRV9DT0xVTU5fUEFERElORyxcbiAgICAgICAgcm93OiBjZWxsU2l6ZUNhY2hlW2ZpcnN0Q29sXS5yb3cgKyBFREdFX0NPTFVNTl9QQURESU5HXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY2VsbFNpemVDYWNoZTtcbn1cblxuLyoqXG4gKiBBZGp1c3QgY2VsbCBzaXplIGJhc2VkIG9uIGNvbnRhaW5lciB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IGNvbnRhaW5lcldpZHRoXG4gKiBAcGFyYW0ge0NlbGxTaXplQ2FjaGV9IGNlbGxTaXplQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBpbm5lZENvbHVtbnNcbiAqIEBwYXJhbSB7c3RyaW5nW119IHVucGlubmVkQ29sdW1uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0Q2VsbHNUb0NvbnRhaW5lcihcbiAgY29udGFpbmVyV2lkdGg6IG51bWJlcixcbiAgY2VsbFNpemVDYWNoZTogQ2VsbFNpemVDYWNoZSxcbiAgcGlubmVkQ29sdW1uczogc3RyaW5nW10sXG4gIHVucGlubmVkQ29sdW1uczogc3RyaW5nW11cbik6IHtcbiAgY2VsbFNpemVDYWNoZTogQ2VsbFNpemVDYWNoZTtcbiAgZ2hvc3Q/OiBudW1iZXIgfCBudWxsO1xufSB7XG4gIGNvbnN0IGNvbHVtbk9yZGVyID0gZ2V0Q29sdW1uT3JkZXIocGlubmVkQ29sdW1ucywgdW5waW5uZWRDb2x1bW5zKTtcbiAgY29uc3QgcGFkZGVkQ2VsbFNpemUgPSBhZGRQYWRkaW5nVG9GaXJzdENvbHVtbihjZWxsU2l6ZUNhY2hlLCBjb2x1bW5PcmRlcik7XG4gIGNvbnN0IG1pblJvd1N1bSA9IGdldFNpemVTdW0ocGFkZGVkQ2VsbFNpemUsICdyb3cnKTtcblxuICBpZiAobWluUm93U3VtID49IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgLy8gd2UgYXBwbHkgdGhlIG1pbiBXaWR0aCB0byBhbGwgY2VsbHNcbiAgICByZXR1cm4ge2NlbGxTaXplQ2FjaGU6IGdldE1pbkNlbGxTaXplKHBhZGRlZENlbGxTaXplKX07XG4gIH1cbiAgLy8gaWYgd2UgaGF2ZSBzb21lIHJvb20gdG8gZXhwYW5kXG4gIHJldHVybiBleHBhbmRDZWxsU2l6ZShwYWRkZWRDZWxsU2l6ZSwgY29sdW1uT3JkZXIsIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJXaWR0aCAtIG1pblJvd1N1bSk7XG59XG4iXX0=