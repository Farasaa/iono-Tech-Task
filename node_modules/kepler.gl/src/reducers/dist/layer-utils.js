"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findDefaultLayer = findDefaultLayer;
exports.calculateLayerData = calculateLayerData;
exports.getLayerHoverProp = getLayerHoverProp;
exports.renderDeckGlLayer = renderDeckGlLayer;
exports.isLayerRenderable = isLayerRenderable;
exports.isLayerVisible = isLayerVisible;
exports.prepareLayersForDeck = prepareLayersForDeck;
exports.prepareLayersToRender = prepareLayersToRender;
exports.getCustomDeckLayers = getCustomDeckLayers;
exports.bindLayerCallbacks = bindLayerCallbacks;
exports.computeDeckLayers = computeDeckLayers;
exports.getLayerOrderFromLayers = getLayerOrderFromLayers;
exports.reorderLayerOrder = reorderLayerOrder;
exports.addLayerToLayerOrder = addLayerToLayerOrder;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _sortable = require("@dnd-kit/sortable");

var _constants = require("@kepler.gl/constants");

var _layers = require("@kepler.gl/layers");

var _utils = require("@kepler.gl/utils");

var _deckglLayers = require("@kepler.gl/deckgl-layers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Find default layers from fields
 */
function findDefaultLayer(dataset, layerClasses) {
  if (!dataset) {
    return [];
  }

  var layerProps = Object.keys(layerClasses).reduce(function (previous, lc) {
    var result = typeof layerClasses[lc].findDefaultLayerProps === 'function' ? layerClasses[lc].findDefaultLayerProps(dataset, previous) : {
      props: []
    };
    var props = Array.isArray(result) ? result : result.props || [];
    var foundLayers = result.foundLayers || previous;
    return foundLayers.concat(props.map(function (p) {
      return _objectSpread(_objectSpread({}, p), {}, {
        type: lc,
        dataId: dataset.id
      });
    }));
  }, []); // go through all layerProps to create layer

  return layerProps.map(function (props) {
    // @ts-expect-error TODO: checking props.type !== null
    var layer = new layerClasses[props.type](props);
    return typeof layer.setInitialLayerConfig === 'function' && dataset.dataContainer ? layer.setInitialLayerConfig(dataset) : layer;
  });
}

/**
 * Calculate layer data based on layer type, col Config,
 * return updated layer if colorDomain, dataMap has changed.
 * Also, returns updated layer in case the input layer was in invalid state.
 * Adds an error message to the layer in case of an exception.
 */
function calculateLayerData(layer, state, oldLayerData) {
  var layerData;

  try {
    // Make sure the layer updates data after an error
    if (!layer.isValid) {
      layer._oldDataUpdateTriggers = undefined;
    }

    if (!layer.type || !layer.hasAllColumns() || !layer.config.dataId) {
      return {
        layer: layer,
        layerData: {}
      };
    }

    layerData = layer.formatLayerData(state.datasets, oldLayerData); // At this point the data for the layer is updated without errors

    if (!layer.isValid) {
      // Switch to visible after an error
      layer = layer.updateLayerConfig({
        isVisible: true
      });
    }

    layer.isValid = true;
    layer.errorMessage = null;
  } catch (err) {
    layer = layer.updateLayerConfig({
      isVisible: false
    });
    layer.isValid = false;
    layer.errorMessage = err instanceof Error && err.message ? err.message.substring(0, 100) : 'Unknown error';
    layerData = {};
  }

  return {
    layer: layer,
    layerData: layerData
  };
}
/**
 * Calculate props passed to LayerHoverInfo
 * @type {typeof import('./layer-utils').getLayerHoverProp}
 */


function getLayerHoverProp(_ref) {
  var interactionConfig = _ref.interactionConfig,
      hoverInfo = _ref.hoverInfo,
      layers = _ref.layers,
      layersToRender = _ref.layersToRender,
      datasets = _ref.datasets;

  if (interactionConfig.tooltip.enabled && hoverInfo && hoverInfo.picked) {
    // if anything hovered
    var object = hoverInfo.object,
        overlay = hoverInfo.layer; // deckgl layer to kepler-gl layer

    var layer = layers[overlay.props.idx]; // NOTE: for binary format GeojsonLayer, deck will return object=null but hoverInfo.index >= 0

    if ((object || hoverInfo.index >= 0) && layer && layer.getHoverData && layersToRender[layer.id]) {
      // if layer is visible and have hovered data
      var dataId = layer.config.dataId;

      if (!dataId) {
        return null;
      }

      var _datasets$dataId = datasets[dataId],
          dataContainer = _datasets$dataId.dataContainer,
          fields = _datasets$dataId.fields;
      var data = layer.getHoverData(object || hoverInfo.index, dataContainer, fields);

      if (!data) {
        return null;
      }

      var fieldsToShow = interactionConfig.tooltip.config.fieldsToShow[dataId];
      return {
        data: data,
        fields: fields,
        fieldsToShow: fieldsToShow,
        layer: layer
      };
    }
  }

  return null;
}

function renderDeckGlLayer(props, layerCallbacks) {
  var datasets = props.datasets,
      layer = props.layer,
      layerIndex = props.layerIndex,
      data = props.data,
      hoverInfo = props.hoverInfo,
      clicked = props.clicked,
      mapState = props.mapState,
      interactionConfig = props.interactionConfig,
      animationConfig = props.animationConfig,
      mapLayers = props.mapLayers;
  var dataset = datasets[layer.config.dataId];

  var _ref2 = dataset || {},
      gpuFilter = _ref2.gpuFilter;

  var objectHovered = clicked || hoverInfo;
  var visible = !mapLayers || mapLayers && mapLayers[layer.id]; // Layer is Layer class

  return layer.renderLayer({
    data: data,
    gpuFilter: gpuFilter,
    idx: layerIndex,
    interactionConfig: interactionConfig,
    layerCallbacks: layerCallbacks,
    mapState: mapState,
    animationConfig: animationConfig,
    objectHovered: objectHovered,
    visible: visible
  });
}

function isLayerRenderable(layer, layerData) {
  return layer.id !== _constants.GEOCODER_LAYER_ID && layer.shouldRenderLayer(layerData);
}

function isLayerVisible(layer, mapLayers) {
  return layer.config.isVisible && ( // if layer.id is not in mapLayers, don't render it
  !mapLayers || mapLayers && mapLayers[layer.id]);
} // Prepare a dict of layers rendered by the deck.gl
// Note, isVisible: false layer is passed to deck.gl here
// return {[id]: true \ false}


function prepareLayersForDeck(layers, layerData) {
  return layers.reduce(function (accu, layer, idx) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, layer.id, isLayerRenderable(layer, layerData[idx]) && layer.overlayType === _layers.OVERLAY_TYPE_CONST.deckgl));
  }, {});
} // Prepare a dict of rendered layers rendered in the map
// This includes only the visibile layers for single map view and split map view
// return {[id]: true \ false}


function prepareLayersToRender(layers, layerData, mapLayers) {
  return layers.reduce(function (accu, layer, idx) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, layer.id, isLayerRenderable(layer, layerData[idx]) && isLayerVisible(layer, mapLayers)));
  }, {});
}

function getCustomDeckLayers(deckGlProps) {
  var bottomDeckLayers = Array.isArray(deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.layers) ? deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.layers : (0, _utils.isFunction)(deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.layers) ? deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.layers() : [];
  var topDeckLayers = Array.isArray(deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.topLayers) ? deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.topLayers : (0, _utils.isFunction)(deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.topLayers) ? deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.topLayers() : [];
  return [bottomDeckLayers, topDeckLayers];
}

function bindLayerCallbacks() {
  var layerCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var idx = arguments.length > 1 ? arguments[1] : undefined;
  return Object.keys(layerCallbacks).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, function (val) {
      return layerCallbacks[key](idx, val);
    }));
  }, {});
}

// eslint-disable-next-line complexity
function computeDeckLayers(_ref3, options, layerCallbacks, deckGlProps) {
  var visState = _ref3.visState,
      mapState = _ref3.mapState,
      mapStyle = _ref3.mapStyle;
  var datasets = visState.datasets,
      layers = visState.layers,
      layerOrder = visState.layerOrder,
      layerData = visState.layerData,
      hoverInfo = visState.hoverInfo,
      clicked = visState.clicked,
      interactionConfig = visState.interactionConfig,
      animationConfig = visState.animationConfig,
      splitMaps = visState.splitMaps;

  var _ref4 = options || {},
      mapIndex = _ref4.mapIndex,
      mapboxApiAccessToken = _ref4.mapboxApiAccessToken,
      mapboxApiUrl = _ref4.mapboxApiUrl,
      primaryMap = _ref4.primaryMap,
      layersForDeck = _ref4.layersForDeck,
      editorInfo = _ref4.editorInfo;

  var dataLayers = [];

  if (layerData && layerData.length) {
    var mapLayers = (0, _utils.getMapLayersFromSplitMaps)(splitMaps, mapIndex || 0);
    var currentLayersForDeck = layersForDeck || prepareLayersForDeck(layers, layerData);
    dataLayers = layerOrder.slice().reverse().filter(function (id) {
      return currentLayersForDeck[id];
    }).reduce(function (overlays, layerId) {
      var layerIndex = layers.findIndex(function (_ref5) {
        var id = _ref5.id;
        return id === layerId;
      });
      var bindedLayerCallbacks = layerCallbacks ? bindLayerCallbacks(layerCallbacks, layerIndex) : {};
      var layer = layers[layerIndex];
      var data = layerData[layerIndex];
      var layerOverlay = renderDeckGlLayer({
        datasets: datasets,
        layer: layer,
        layerIndex: layerIndex,
        data: data,
        hoverInfo: hoverInfo,
        clicked: clicked,
        mapState: mapState,
        interactionConfig: interactionConfig,
        animationConfig: animationConfig,
        mapLayers: mapLayers
      }, bindedLayerCallbacks);
      return overlays.concat(layerOverlay || []);
    }, []);
  }

  if (!primaryMap) {
    return dataLayers;
  }

  if (mapStyle !== null && mapStyle !== void 0 && mapStyle.visibleLayerGroups['3d building'] && primaryMap && mapboxApiAccessToken && mapboxApiUrl) {
    dataLayers.push(new _deckglLayers.ThreeDBuildingLayer({
      id: '_keplergl_3d-building',
      mapboxApiAccessToken: mapboxApiAccessToken,
      mapboxApiUrl: mapboxApiUrl,
      threeDBuildingColor: mapStyle.threeDBuildingColor,
      updateTriggers: {
        getFillColor: mapStyle.threeDBuildingColor
      }
    }));
  }

  var _getCustomDeckLayers = getCustomDeckLayers(deckGlProps),
      _getCustomDeckLayers2 = (0, _slicedToArray2["default"])(_getCustomDeckLayers, 2),
      customBottomDeckLayers = _getCustomDeckLayers2[0],
      customTopDeckLayers = _getCustomDeckLayers2[1];

  var editorLayer = [];

  if (editorInfo) {
    editorLayer.push((0, _layers.getEditorLayer)(_objectSpread({}, editorInfo)));
  }

  return [].concat((0, _toConsumableArray2["default"])(customBottomDeckLayers), (0, _toConsumableArray2["default"])(dataLayers), (0, _toConsumableArray2["default"])(customTopDeckLayers), editorLayer);
}

function getLayerOrderFromLayers(layers) {
  return layers.map(function (_ref6) {
    var id = _ref6.id;
    return id;
  });
}

function reorderLayerOrder(layerOrder, originLayerId, destinationLayerId) {
  var activeIndex = layerOrder.indexOf(originLayerId);
  var overIndex = layerOrder.indexOf(destinationLayerId);
  return (0, _sortable.arrayMove)(layerOrder, activeIndex, overIndex);
}

function addLayerToLayerOrder(layerOrder, layerId) {
  return [layerId].concat((0, _toConsumableArray2["default"])(layerOrder));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9sYXllci11dGlscy50cyJdLCJuYW1lcyI6WyJmaW5kRGVmYXVsdExheWVyIiwiZGF0YXNldCIsImxheWVyQ2xhc3NlcyIsImxheWVyUHJvcHMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwicHJldmlvdXMiLCJsYyIsInJlc3VsdCIsImZpbmREZWZhdWx0TGF5ZXJQcm9wcyIsInByb3BzIiwiQXJyYXkiLCJpc0FycmF5IiwiZm91bmRMYXllcnMiLCJjb25jYXQiLCJtYXAiLCJwIiwidHlwZSIsImRhdGFJZCIsImlkIiwibGF5ZXIiLCJzZXRJbml0aWFsTGF5ZXJDb25maWciLCJkYXRhQ29udGFpbmVyIiwiY2FsY3VsYXRlTGF5ZXJEYXRhIiwic3RhdGUiLCJvbGRMYXllckRhdGEiLCJsYXllckRhdGEiLCJpc1ZhbGlkIiwiX29sZERhdGFVcGRhdGVUcmlnZ2VycyIsInVuZGVmaW5lZCIsImhhc0FsbENvbHVtbnMiLCJjb25maWciLCJmb3JtYXRMYXllckRhdGEiLCJkYXRhc2V0cyIsInVwZGF0ZUxheWVyQ29uZmlnIiwiaXNWaXNpYmxlIiwiZXJyb3JNZXNzYWdlIiwiZXJyIiwiRXJyb3IiLCJtZXNzYWdlIiwic3Vic3RyaW5nIiwiZ2V0TGF5ZXJIb3ZlclByb3AiLCJpbnRlcmFjdGlvbkNvbmZpZyIsImhvdmVySW5mbyIsImxheWVycyIsImxheWVyc1RvUmVuZGVyIiwidG9vbHRpcCIsImVuYWJsZWQiLCJwaWNrZWQiLCJvYmplY3QiLCJvdmVybGF5IiwiaWR4IiwiaW5kZXgiLCJnZXRIb3ZlckRhdGEiLCJmaWVsZHMiLCJkYXRhIiwiZmllbGRzVG9TaG93IiwicmVuZGVyRGVja0dsTGF5ZXIiLCJsYXllckNhbGxiYWNrcyIsImxheWVySW5kZXgiLCJjbGlja2VkIiwibWFwU3RhdGUiLCJhbmltYXRpb25Db25maWciLCJtYXBMYXllcnMiLCJncHVGaWx0ZXIiLCJvYmplY3RIb3ZlcmVkIiwidmlzaWJsZSIsInJlbmRlckxheWVyIiwiaXNMYXllclJlbmRlcmFibGUiLCJHRU9DT0RFUl9MQVlFUl9JRCIsInNob3VsZFJlbmRlckxheWVyIiwiaXNMYXllclZpc2libGUiLCJwcmVwYXJlTGF5ZXJzRm9yRGVjayIsImFjY3UiLCJvdmVybGF5VHlwZSIsIk9WRVJMQVlfVFlQRV9DT05TVCIsImRlY2tnbCIsInByZXBhcmVMYXllcnNUb1JlbmRlciIsImdldEN1c3RvbURlY2tMYXllcnMiLCJkZWNrR2xQcm9wcyIsImJvdHRvbURlY2tMYXllcnMiLCJ0b3BEZWNrTGF5ZXJzIiwidG9wTGF5ZXJzIiwiYmluZExheWVyQ2FsbGJhY2tzIiwia2V5IiwidmFsIiwiY29tcHV0ZURlY2tMYXllcnMiLCJvcHRpb25zIiwidmlzU3RhdGUiLCJtYXBTdHlsZSIsImxheWVyT3JkZXIiLCJzcGxpdE1hcHMiLCJtYXBJbmRleCIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwibWFwYm94QXBpVXJsIiwicHJpbWFyeU1hcCIsImxheWVyc0ZvckRlY2siLCJlZGl0b3JJbmZvIiwiZGF0YUxheWVycyIsImxlbmd0aCIsImN1cnJlbnRMYXllcnNGb3JEZWNrIiwic2xpY2UiLCJyZXZlcnNlIiwiZmlsdGVyIiwib3ZlcmxheXMiLCJsYXllcklkIiwiZmluZEluZGV4IiwiYmluZGVkTGF5ZXJDYWxsYmFja3MiLCJsYXllck92ZXJsYXkiLCJ2aXNpYmxlTGF5ZXJHcm91cHMiLCJwdXNoIiwiVGhyZWVEQnVpbGRpbmdMYXllciIsInRocmVlREJ1aWxkaW5nQ29sb3IiLCJ1cGRhdGVUcmlnZ2VycyIsImdldEZpbGxDb2xvciIsImN1c3RvbUJvdHRvbURlY2tMYXllcnMiLCJjdXN0b21Ub3BEZWNrTGF5ZXJzIiwiZWRpdG9yTGF5ZXIiLCJnZXRMYXllck9yZGVyRnJvbUxheWVycyIsInJlb3JkZXJMYXllck9yZGVyIiwib3JpZ2luTGF5ZXJJZCIsImRlc3RpbmF0aW9uTGF5ZXJJZCIsImFjdGl2ZUluZGV4IiwiaW5kZXhPZiIsIm92ZXJJbmRleCIsImFkZExheWVyVG9MYXllck9y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QUFTQyx1QkFBVCxDQUF5RDFFLE1BQXpELEVBQWdGO0FBQ3JGLFNBQU9BLE1BQU0sQ0FBQzdCLEdBQVAsQ0FBVztBQUFBLFFBQUVJLEVBQUYsU0FBRUEsRUFBRjtBQUFBLFdBQVVBLEVBQVY7QUFBQSxHQUFYLENBQVA7QUFDRDs7QUFFTSxTQUFTb0csaUJBQVQsQ0FDTDdCLFVBREssRUFFTDhCLGFBRkssRUFHTEMsa0JBSEssRUFJbUI7QUFDeEIsTUFBTUMsV0FBVyxHQUFHaEMsVUFBVSxDQUFDaUMsT0FBWCxDQUFtQkgsYUFBbkIsQ0FBcEI7QUFDQSxNQUFNSSxTQUFTLEdBQUdsQyxVQUFVLENBQUNpQyxPQUFYLENBQW1CRixrQkFBbkIsQ0FBbEI7QUFFQSxTQUFPLHlCQUFVL0IsVUFBVixFQUFzQmdDLFdBQXRCLEVBQW1DRSxTQUFuQyxDQUFQO0FBQ0Q7O0FBRU0sU0FBU0Msb0JBQVQsQ0FDTG5DLFVBREssRUFFTGUsT0FGSyxFQUdLO0FBQ1YsVUFBUUEsT0FBUiw2Q0FBb0JmLFVBQXBCO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQge2FycmF5TW92ZX0gZnJvbSAnQGRuZC1raXQvc29ydGFibGUnO1xuaW1wb3J0IHtHRU9DT0RFUl9MQVlFUl9JRH0gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtMYXllciBhcyBEZWNrTGF5ZXIsIExheWVyUHJvcHMgYXMgRGVja0xheWVyUHJvcHN9IGZyb20gJ0BkZWNrLmdsL2NvcmUvdHlwZWQnO1xuaW1wb3J0IHtcbiAgRmllbGQsXG4gIFRvb2x0aXBGaWVsZCxcbiAgQ29tcGFyZVR5cGUsXG4gIFNwbGl0TWFwTGF5ZXJzLFxuICBJbnRlcmFjdGlvbkNvbmZpZyxcbiAgRWRpdG9yLFxuICBGZWF0dXJlLFxuICBGZWF0dXJlU2VsZWN0aW9uQ29udGV4dCxcbiAgVmlld3BvcnRcbn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge1xuICBGaW5kRGVmYXVsdExheWVyUHJvcHNSZXR1cm5WYWx1ZSxcbiAgTGF5ZXIsXG4gIExheWVyQ2xhc3Nlc1R5cGUsXG4gIE9WRVJMQVlfVFlQRV9DT05TVCxcbiAgZ2V0RWRpdG9yTGF5ZXJcbn0gZnJvbSAnQGtlcGxlci5nbC9sYXllcnMnO1xuXG5pbXBvcnQgS2VwbGVyVGFibGUsIHtEYXRhc2V0c30gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5pbXBvcnQge1Zpc1N0YXRlfSBmcm9tICdAa2VwbGVyLmdsL3NjaGVtYXMnO1xuaW1wb3J0IHtpc0Z1bmN0aW9uLCBnZXRNYXBMYXllcnNGcm9tU3BsaXRNYXBzLCBEYXRhUm93fSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7VGhyZWVEQnVpbGRpbmdMYXllcn0gZnJvbSAnQGtlcGxlci5nbC9kZWNrZ2wtbGF5ZXJzJztcblxuZXhwb3J0IHR5cGUgTGF5ZXJzVG9SZW5kZXIgPSB7XG4gIFtsYXllcklkOiBzdHJpbmddOiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgQWdncmVnYXRpb25MYXllckhvdmVyRGF0YSA9IHtwb2ludHM6IGFueVtdOyBjb2xvclZhbHVlPzogYW55OyBlbGV2YXRpb25WYWx1ZT86IGFueX07XG5cbmV4cG9ydCB0eXBlIExheWVySG92ZXJQcm9wID0ge1xuICBkYXRhOiBEYXRhUm93IHwgQWdncmVnYXRpb25MYXllckhvdmVyRGF0YSB8IG51bGw7XG4gIGZpZWxkczogRmllbGRbXTtcbiAgZmllbGRzVG9TaG93OiBUb29sdGlwRmllbGRbXTtcbiAgbGF5ZXI6IExheWVyO1xuICBwcmltYXJ5RGF0YT86IERhdGFSb3cgfCBBZ2dyZWdhdGlvbkxheWVySG92ZXJEYXRhIHwgbnVsbDtcbiAgY29tcGFyZVR5cGU/OiBDb21wYXJlVHlwZTtcbn07XG5cbi8qKlxuICogRmluZCBkZWZhdWx0IGxheWVycyBmcm9tIGZpZWxkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZERlZmF1bHRMYXllcihkYXRhc2V0OiBLZXBsZXJUYWJsZSwgbGF5ZXJDbGFzc2VzOiBMYXllckNsYXNzZXNUeXBlKTogTGF5ZXJbXSB7XG4gIGlmICghZGF0YXNldCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBsYXllclByb3BzID0gKE9iamVjdC5rZXlzKGxheWVyQ2xhc3NlcykgYXMgQXJyYXk8a2V5b2YgTGF5ZXJDbGFzc2VzVHlwZT4pLnJlZHVjZShcbiAgICAocHJldmlvdXMsIGxjKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQ6IEZpbmREZWZhdWx0TGF5ZXJQcm9wc1JldHVyblZhbHVlID1cbiAgICAgICAgdHlwZW9mIGxheWVyQ2xhc3Nlc1tsY10uZmluZERlZmF1bHRMYXllclByb3BzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBsYXllckNsYXNzZXNbbGNdLmZpbmREZWZhdWx0TGF5ZXJQcm9wcyhkYXRhc2V0LCBwcmV2aW91cylcbiAgICAgICAgICA6IHtwcm9wczogW119O1xuXG4gICAgICBjb25zdCBwcm9wcyA9IEFycmF5LmlzQXJyYXkocmVzdWx0KSA/IHJlc3VsdCA6IHJlc3VsdC5wcm9wcyB8fCBbXTtcbiAgICAgIGNvbnN0IGZvdW5kTGF5ZXJzID0gcmVzdWx0LmZvdW5kTGF5ZXJzIHx8IHByZXZpb3VzO1xuXG4gICAgICByZXR1cm4gZm91bmRMYXllcnMuY29uY2F0KFxuICAgICAgICBwcm9wcy5tYXAocCA9PiAoe1xuICAgICAgICAgIC4uLnAsXG4gICAgICAgICAgdHlwZTogbGMsXG4gICAgICAgICAgZGF0YUlkOiBkYXRhc2V0LmlkXG4gICAgICAgIH0pKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtdIGFzIExheWVyQ2xhc3Nlc1R5cGVba2V5b2YgTGF5ZXJDbGFzc2VzVHlwZV1bXVxuICApO1xuXG4gIC8vIGdvIHRocm91Z2ggYWxsIGxheWVyUHJvcHMgdG8gY3JlYXRlIGxheWVyXG4gIHJldHVybiBsYXllclByb3BzLm1hcChwcm9wcyA9PiB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBjaGVja2luZyBwcm9wcy50eXBlICE9PSBudWxsXG4gICAgY29uc3QgbGF5ZXIgPSBuZXcgbGF5ZXJDbGFzc2VzW3Byb3BzLnR5cGVdKHByb3BzKTtcbiAgICByZXR1cm4gdHlwZW9mIGxheWVyLnNldEluaXRpYWxMYXllckNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyAmJiBkYXRhc2V0LmRhdGFDb250YWluZXJcbiAgICAgID8gbGF5ZXIuc2V0SW5pdGlhbExheWVyQ29uZmlnKGRhdGFzZXQpXG4gICAgICA6IGxheWVyO1xuICB9KTtcbn1cblxudHlwZSBNaW5WaXNTdGF0ZUZvckxheWVyRGF0YSA9IHtcbiAgZGF0YXNldHM6IFZpc1N0YXRlWydkYXRhc2V0cyddO1xuICBhbmltYXRpb25Db25maWc6IFZpc1N0YXRlWydhbmltYXRpb25Db25maWcnXTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIGxheWVyIGRhdGEgYmFzZWQgb24gbGF5ZXIgdHlwZSwgY29sIENvbmZpZyxcbiAqIHJldHVybiB1cGRhdGVkIGxheWVyIGlmIGNvbG9yRG9tYWluLCBkYXRhTWFwIGhhcyBjaGFuZ2VkLlxuICogQWxzbywgcmV0dXJucyB1cGRhdGVkIGxheWVyIGluIGNhc2UgdGhlIGlucHV0IGxheWVyIHdhcyBpbiBpbnZhbGlkIHN0YXRlLlxuICogQWRkcyBhbiBlcnJvciBtZXNzYWdlIHRvIHRoZSBsYXllciBpbiBjYXNlIG9mIGFuIGV4Y2VwdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUxheWVyRGF0YTxTIGV4dGVuZHMgTWluVmlzU3RhdGVGb3JMYXllckRhdGE+KFxuICBsYXllcjogTGF5ZXIsXG4gIHN0YXRlOiBTLFxuICBvbGRMYXllckRhdGE/OiBhbnlcbik6IHtcbiAgbGF5ZXJEYXRhOiBhbnk7XG4gIGxheWVyOiBMYXllcjtcbn0ge1xuICBsZXQgbGF5ZXJEYXRhO1xuICB0cnkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXIgdXBkYXRlcyBkYXRhIGFmdGVyIGFuIGVycm9yXG4gICAgaWYgKCFsYXllci5pc1ZhbGlkKSB7XG4gICAgICBsYXllci5fb2xkRGF0YVVwZGF0ZVRyaWdnZXJzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICghbGF5ZXIudHlwZSB8fCAhbGF5ZXIuaGFzQWxsQ29sdW1ucygpIHx8ICFsYXllci5jb25maWcuZGF0YUlkKSB7XG4gICAgICByZXR1cm4ge2xheWVyLCBsYXllckRhdGE6IHt9fTtcbiAgICB9XG5cbiAgICBsYXllckRhdGEgPSBsYXllci5mb3JtYXRMYXllckRhdGEoc3RhdGUuZGF0YXNldHMsIG9sZExheWVyRGF0YSk7XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBkYXRhIGZvciB0aGUgbGF5ZXIgaXMgdXBkYXRlZCB3aXRob3V0IGVycm9yc1xuICAgIGlmICghbGF5ZXIuaXNWYWxpZCkge1xuICAgICAgLy8gU3dpdGNoIHRvIHZpc2libGUgYWZ0ZXIgYW4gZXJyb3JcbiAgICAgIGxheWVyID0gbGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgICAgICBpc1Zpc2libGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsYXllci5pc1ZhbGlkID0gdHJ1ZTtcbiAgICBsYXllci5lcnJvck1lc3NhZ2UgPSBudWxsO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsYXllciA9IGxheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICAgIGlzVmlzaWJsZTogZmFsc2VcbiAgICB9KTtcbiAgICBsYXllci5pc1ZhbGlkID0gZmFsc2U7XG5cbiAgICBsYXllci5lcnJvck1lc3NhZ2UgPVxuICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLm1lc3NhZ2UgPyBlcnIubWVzc2FnZS5zdWJzdHJpbmcoMCwgMTAwKSA6ICdVbmtub3duIGVycm9yJztcblxuICAgIGxheWVyRGF0YSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsYXllcixcbiAgICBsYXllckRhdGFcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgcHJvcHMgcGFzc2VkIHRvIExheWVySG92ZXJJbmZvXG4gKiBAdHlwZSB7dHlwZW9mIGltcG9ydCgnLi9sYXllci11dGlscycpLmdldExheWVySG92ZXJQcm9wfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF5ZXJIb3ZlclByb3Aoe1xuICBpbnRlcmFjdGlvbkNvbmZpZyxcbiAgaG92ZXJJbmZvLFxuICBsYXllcnMsXG4gIGxheWVyc1RvUmVuZGVyLFxuICBkYXRhc2V0c1xufToge1xuICBpbnRlcmFjdGlvbkNvbmZpZzogSW50ZXJhY3Rpb25Db25maWc7XG4gIGhvdmVySW5mbzogYW55O1xuICBsYXllcnM6IExheWVyW107XG4gIGxheWVyc1RvUmVuZGVyOiBMYXllcnNUb1JlbmRlcjtcbiAgZGF0YXNldHM6IERhdGFzZXRzO1xufSk6IExheWVySG92ZXJQcm9wIHwgbnVsbCB7XG4gIGlmIChpbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLmVuYWJsZWQgJiYgaG92ZXJJbmZvICYmIGhvdmVySW5mby5waWNrZWQpIHtcbiAgICAvLyBpZiBhbnl0aGluZyBob3ZlcmVkXG4gICAgY29uc3Qge29iamVjdCwgbGF5ZXI6IG92ZXJsYXl9ID0gaG92ZXJJbmZvO1xuXG4gICAgLy8gZGVja2dsIGxheWVyIHRvIGtlcGxlci1nbCBsYXllclxuICAgIGNvbnN0IGxheWVyID0gbGF5ZXJzW292ZXJsYXkucHJvcHMuaWR4XTtcblxuICAgIC8vIE5PVEU6IGZvciBiaW5hcnkgZm9ybWF0IEdlb2pzb25MYXllciwgZGVjayB3aWxsIHJldHVybiBvYmplY3Q9bnVsbCBidXQgaG92ZXJJbmZvLmluZGV4ID49IDBcbiAgICBpZiAoXG4gICAgICAob2JqZWN0IHx8IGhvdmVySW5mby5pbmRleCA+PSAwKSAmJlxuICAgICAgbGF5ZXIgJiZcbiAgICAgIGxheWVyLmdldEhvdmVyRGF0YSAmJlxuICAgICAgbGF5ZXJzVG9SZW5kZXJbbGF5ZXIuaWRdXG4gICAgKSB7XG4gICAgICAvLyBpZiBsYXllciBpcyB2aXNpYmxlIGFuZCBoYXZlIGhvdmVyZWQgZGF0YVxuICAgICAgY29uc3Qge1xuICAgICAgICBjb25maWc6IHtkYXRhSWR9XG4gICAgICB9ID0gbGF5ZXI7XG4gICAgICBpZiAoIWRhdGFJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtkYXRhQ29udGFpbmVyLCBmaWVsZHN9ID0gZGF0YXNldHNbZGF0YUlkXTtcbiAgICAgIGNvbnN0IGRhdGE6IERhdGFSb3cgfCBudWxsID0gbGF5ZXIuZ2V0SG92ZXJEYXRhKFxuICAgICAgICBvYmplY3QgfHwgaG92ZXJJbmZvLmluZGV4LFxuICAgICAgICBkYXRhQ29udGFpbmVyLFxuICAgICAgICBmaWVsZHNcbiAgICAgICk7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBmaWVsZHNUb1Nob3cgPSBpbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLmNvbmZpZy5maWVsZHNUb1Nob3dbZGF0YUlkXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZmllbGRzLFxuICAgICAgICBmaWVsZHNUb1Nob3csXG4gICAgICAgIGxheWVyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyRGVja0dsTGF5ZXIocHJvcHM6IGFueSwgbGF5ZXJDYWxsYmFja3M6IHtba2V5OiBzdHJpbmddOiBhbnl9KSB7XG4gIGNvbnN0IHtcbiAgICBkYXRhc2V0cyxcbiAgICBsYXllcixcbiAgICBsYXllckluZGV4LFxuICAgIGRhdGEsXG4gICAgaG92ZXJJbmZvLFxuICAgIGNsaWNrZWQsXG4gICAgbWFwU3RhdGUsXG4gICAgaW50ZXJhY3Rpb25Db25maWcsXG4gICAgYW5pbWF0aW9uQ29uZmlnLFxuICAgIG1hcExheWVyc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tsYXllci5jb25maWcuZGF0YUlkXTtcbiAgY29uc3Qge2dwdUZpbHRlcn0gPSBkYXRhc2V0IHx8IHt9O1xuICBjb25zdCBvYmplY3RIb3ZlcmVkID0gY2xpY2tlZCB8fCBob3ZlckluZm87XG4gIGNvbnN0IHZpc2libGUgPSAhbWFwTGF5ZXJzIHx8IChtYXBMYXllcnMgJiYgbWFwTGF5ZXJzW2xheWVyLmlkXSk7XG4gIC8vIExheWVyIGlzIExheWVyIGNsYXNzXG4gIHJldHVybiBsYXllci5yZW5kZXJMYXllcih7XG4gICAgZGF0YSxcbiAgICBncHVGaWx0ZXIsXG4gICAgaWR4OiBsYXllckluZGV4LFxuICAgIGludGVyYWN0aW9uQ29uZmlnLFxuICAgIGxheWVyQ2FsbGJhY2tzLFxuICAgIG1hcFN0YXRlLFxuICAgIGFuaW1hdGlvbkNvbmZpZyxcbiAgICBvYmplY3RIb3ZlcmVkLFxuICAgIHZpc2libGVcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xheWVyUmVuZGVyYWJsZShsYXllcjogTGF5ZXIsIGxheWVyRGF0YSkge1xuICByZXR1cm4gbGF5ZXIuaWQgIT09IEdFT0NPREVSX0xBWUVSX0lEICYmIGxheWVyLnNob3VsZFJlbmRlckxheWVyKGxheWVyRGF0YSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xheWVyVmlzaWJsZShsYXllciwgbWFwTGF5ZXJzKSB7XG4gIHJldHVybiAoXG4gICAgbGF5ZXIuY29uZmlnLmlzVmlzaWJsZSAmJlxuICAgIC8vIGlmIGxheWVyLmlkIGlzIG5vdCBpbiBtYXBMYXllcnMsIGRvbid0IHJlbmRlciBpdFxuICAgICghbWFwTGF5ZXJzIHx8IChtYXBMYXllcnMgJiYgbWFwTGF5ZXJzW2xheWVyLmlkXSkpXG4gICk7XG59XG5cbi8vIFByZXBhcmUgYSBkaWN0IG9mIGxheWVycyByZW5kZXJlZCBieSB0aGUgZGVjay5nbFxuLy8gTm90ZSwgaXNWaXNpYmxlOiBmYWxzZSBsYXllciBpcyBwYXNzZWQgdG8gZGVjay5nbCBoZXJlXG4vLyByZXR1cm4ge1tpZF06IHRydWUgXFwgZmFsc2V9XG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUxheWVyc0ZvckRlY2soXG4gIGxheWVyczogTGF5ZXJbXSxcbiAgbGF5ZXJEYXRhOiBWaXNTdGF0ZVsnbGF5ZXJEYXRhJ11cbik6IHtcbiAgW2tleTogc3RyaW5nXTogYm9vbGVhbjtcbn0ge1xuICByZXR1cm4gbGF5ZXJzLnJlZHVjZShcbiAgICAoYWNjdSwgbGF5ZXIsIGlkeCkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICBbbGF5ZXIuaWRdOlxuICAgICAgICBpc0xheWVyUmVuZGVyYWJsZShsYXllciwgbGF5ZXJEYXRhW2lkeF0pICYmIGxheWVyLm92ZXJsYXlUeXBlID09PSBPVkVSTEFZX1RZUEVfQ09OU1QuZGVja2dsXG4gICAgfSksXG4gICAge31cbiAgKTtcbn1cblxuLy8gUHJlcGFyZSBhIGRpY3Qgb2YgcmVuZGVyZWQgbGF5ZXJzIHJlbmRlcmVkIGluIHRoZSBtYXBcbi8vIFRoaXMgaW5jbHVkZXMgb25seSB0aGUgdmlzaWJpbGUgbGF5ZXJzIGZvciBzaW5nbGUgbWFwIHZpZXcgYW5kIHNwbGl0IG1hcCB2aWV3XG4vLyByZXR1cm4ge1tpZF06IHRydWUgXFwgZmFsc2V9XG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUxheWVyc1RvUmVuZGVyKFxuICBsYXllcnM6IExheWVyW10sXG4gIGxheWVyRGF0YTogVmlzU3RhdGVbJ2xheWVyRGF0YSddLFxuICBtYXBMYXllcnM/OiBTcGxpdE1hcExheWVycyB8IHVuZGVmaW5lZCB8IG51bGxcbik6IExheWVyc1RvUmVuZGVyIHtcbiAgcmV0dXJuIGxheWVycy5yZWR1Y2UoXG4gICAgKGFjY3UsIGxheWVyLCBpZHgpID0+ICh7XG4gICAgICAuLi5hY2N1LFxuICAgICAgW2xheWVyLmlkXTogaXNMYXllclJlbmRlcmFibGUobGF5ZXIsIGxheWVyRGF0YVtpZHhdKSAmJiBpc0xheWVyVmlzaWJsZShsYXllciwgbWFwTGF5ZXJzKVxuICAgIH0pLFxuICAgIHt9XG4gICk7XG59XG5cbnR5cGUgQ3VzdG9tRGVja0xheWVyID0gRGVja0xheWVyPERlY2tMYXllclByb3BzPjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1c3RvbURlY2tMYXllcnMoZGVja0dsUHJvcHM/OiBhbnkpOiBbQ3VzdG9tRGVja0xheWVyW10sIEN1c3RvbURlY2tMYXllcltdXSB7XG4gIGNvbnN0IGJvdHRvbURlY2tMYXllcnMgPSBBcnJheS5pc0FycmF5KGRlY2tHbFByb3BzPy5sYXllcnMpXG4gICAgPyBkZWNrR2xQcm9wcz8ubGF5ZXJzXG4gICAgOiBpc0Z1bmN0aW9uKGRlY2tHbFByb3BzPy5sYXllcnMpXG4gICAgPyBkZWNrR2xQcm9wcz8ubGF5ZXJzKClcbiAgICA6IFtdO1xuICBjb25zdCB0b3BEZWNrTGF5ZXJzID0gQXJyYXkuaXNBcnJheShkZWNrR2xQcm9wcz8udG9wTGF5ZXJzKVxuICAgID8gZGVja0dsUHJvcHM/LnRvcExheWVyc1xuICAgIDogaXNGdW5jdGlvbihkZWNrR2xQcm9wcz8udG9wTGF5ZXJzKVxuICAgID8gZGVja0dsUHJvcHM/LnRvcExheWVycygpXG4gICAgOiBbXTtcblxuICByZXR1cm4gW2JvdHRvbURlY2tMYXllcnMsIHRvcERlY2tMYXllcnNdO1xufVxuXG5leHBvcnQgdHlwZSBDb21wdXRlRGVja0xheWVyc1Byb3BzID0ge1xuICBtYXBJbmRleD86IG51bWJlcjtcbiAgbWFwYm94QXBpQWNjZXNzVG9rZW4/OiBzdHJpbmc7XG4gIG1hcGJveEFwaVVybD86IHN0cmluZztcbiAgcHJpbWFyeU1hcD86IGJvb2xlYW47XG4gIGxheWVyc0ZvckRlY2s/OiB7W2tleTogc3RyaW5nXTogYm9vbGVhbn07XG4gIGVkaXRvckluZm8/OiB7XG4gICAgZWRpdG9yOiBFZGl0b3I7XG4gICAgZWRpdG9yTWVudUFjdGl2ZTogYm9vbGVhbjtcbiAgICBvblNldEZlYXR1cmVzOiAoZmVhdHVyZXM6IEZlYXR1cmVbXSkgPT4gYW55O1xuICAgIHNldFNlbGVjdGVkRmVhdHVyZTogKFxuICAgICAgZmVhdHVyZTogRmVhdHVyZSB8IG51bGwsXG4gICAgICBzZWxlY3Rpb25Db250ZXh0PzogRmVhdHVyZVNlbGVjdGlvbkNvbnRleHRcbiAgICApID0+IGFueTtcbiAgICBmZWF0dXJlQ29sbGVjdGlvbjoge1xuICAgICAgdHlwZTogc3RyaW5nO1xuICAgICAgZmVhdHVyZXM6IEZlYXR1cmVbXTtcbiAgICB9O1xuICAgIHNlbGVjdGVkRmVhdHVyZUluZGV4ZXM6IG51bWJlcltdO1xuICAgIHZpZXdwb3J0OiBWaWV3cG9ydDtcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5kTGF5ZXJDYWxsYmFja3MobGF5ZXJDYWxsYmFja3M6IExheWVyQ2FsbGJhY2tzID0ge30sIGlkeDogbnVtYmVyKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhsYXllckNhbGxiYWNrcykucmVkdWNlKFxuICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2N1LFxuICAgICAgW2tleV06IHZhbCA9PiBsYXllckNhbGxiYWNrc1trZXldKGlkeCwgdmFsKVxuICAgIH0pLFxuICAgIHt9IGFzIFJlY29yZDxzdHJpbmcsIChfaWR4OiBudW1iZXIsIHZhbDogYW55KSA9PiB2b2lkPlxuICApO1xufVxuXG5leHBvcnQgdHlwZSBMYXllckNhbGxiYWNrcyA9IHtcbiAgb25MYXllckhvdmVyPzogKGlkeDogbnVtYmVyLCB2YWx1ZTogYW55KSA9PiB2b2lkO1xuICBvblNldExheWVyRG9tYWluPzogKGlkeDogbnVtYmVyLCB2YWx1ZTogYW55KSA9PiB2b2lkO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRGVja0xheWVycyhcbiAge3Zpc1N0YXRlLCBtYXBTdGF0ZSwgbWFwU3R5bGV9OiBhbnksXG4gIG9wdGlvbnM/OiBDb21wdXRlRGVja0xheWVyc1Byb3BzLFxuICBsYXllckNhbGxiYWNrcz86IExheWVyQ2FsbGJhY2tzLFxuICBkZWNrR2xQcm9wcz86IGFueVxuKTogTGF5ZXJbXSB7XG4gIGNvbnN0IHtcbiAgICBkYXRhc2V0cyxcbiAgICBsYXllcnMsXG4gICAgbGF5ZXJPcmRlcixcbiAgICBsYXllckRhdGEsXG4gICAgaG92ZXJJbmZvLFxuICAgIGNsaWNrZWQsXG4gICAgaW50ZXJhY3Rpb25Db25maWcsXG4gICAgYW5pbWF0aW9uQ29uZmlnLFxuICAgIHNwbGl0TWFwc1xuICB9ID0gdmlzU3RhdGU7XG5cbiAgY29uc3Qge21hcEluZGV4LCBtYXBib3hBcGlBY2Nlc3NUb2tlbiwgbWFwYm94QXBpVXJsLCBwcmltYXJ5TWFwLCBsYXllcnNGb3JEZWNrLCBlZGl0b3JJbmZvfSA9XG4gICAgb3B0aW9ucyB8fCB7fTtcblxuICBsZXQgZGF0YUxheWVyczogYW55W10gPSBbXTtcblxuICBpZiAobGF5ZXJEYXRhICYmIGxheWVyRGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBtYXBMYXllcnMgPSBnZXRNYXBMYXllcnNGcm9tU3BsaXRNYXBzKHNwbGl0TWFwcywgbWFwSW5kZXggfHwgMCk7XG5cbiAgICBjb25zdCBjdXJyZW50TGF5ZXJzRm9yRGVjayA9IGxheWVyc0ZvckRlY2sgfHwgcHJlcGFyZUxheWVyc0ZvckRlY2sobGF5ZXJzLCBsYXllckRhdGEpO1xuXG4gICAgZGF0YUxheWVycyA9IGxheWVyT3JkZXJcbiAgICAgIC5zbGljZSgpXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmlsdGVyKGlkID0+IGN1cnJlbnRMYXllcnNGb3JEZWNrW2lkXSlcbiAgICAgIC5yZWR1Y2UoKG92ZXJsYXlzLCBsYXllcklkKSA9PiB7XG4gICAgICAgIGNvbnN0IGxheWVySW5kZXggPSBsYXllcnMuZmluZEluZGV4KCh7aWR9KSA9PiBpZCA9PT0gbGF5ZXJJZCk7XG4gICAgICAgIGNvbnN0IGJpbmRlZExheWVyQ2FsbGJhY2tzID0gbGF5ZXJDYWxsYmFja3NcbiAgICAgICAgICA/IGJpbmRMYXllckNhbGxiYWNrcyhsYXllckNhbGxiYWNrcywgbGF5ZXJJbmRleClcbiAgICAgICAgICA6IHt9O1xuICAgICAgICBjb25zdCBsYXllciA9IGxheWVyc1tsYXllckluZGV4XTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGxheWVyRGF0YVtsYXllckluZGV4XTtcbiAgICAgICAgY29uc3QgbGF5ZXJPdmVybGF5ID0gcmVuZGVyRGVja0dsTGF5ZXIoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGF0YXNldHMsXG4gICAgICAgICAgICBsYXllcixcbiAgICAgICAgICAgIGxheWVySW5kZXgsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaG92ZXJJbmZvLFxuICAgICAgICAgICAgY2xpY2tlZCxcbiAgICAgICAgICAgIG1hcFN0YXRlLFxuICAgICAgICAgICAgaW50ZXJhY3Rpb25Db25maWcsXG4gICAgICAgICAgICBhbmltYXRpb25Db25maWcsXG4gICAgICAgICAgICBtYXBMYXllcnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJpbmRlZExheWVyQ2FsbGJhY2tzXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBvdmVybGF5cy5jb25jYXQobGF5ZXJPdmVybGF5IHx8IFtdKTtcbiAgICAgIH0sIFtdKTtcbiAgfVxuXG4gIGlmICghcHJpbWFyeU1hcCkge1xuICAgIHJldHVybiBkYXRhTGF5ZXJzO1xuICB9XG5cbiAgaWYgKFxuICAgIG1hcFN0eWxlPy52aXNpYmxlTGF5ZXJHcm91cHNbJzNkIGJ1aWxkaW5nJ10gJiZcbiAgICBwcmltYXJ5TWFwICYmXG4gICAgbWFwYm94QXBpQWNjZXNzVG9rZW4gJiZcbiAgICBtYXBib3hBcGlVcmxcbiAgKSB7XG4gICAgZGF0YUxheWVycy5wdXNoKFxuICAgICAgbmV3IFRocmVlREJ1aWxkaW5nTGF5ZXIoe1xuICAgICAgICBpZDogJ19rZXBsZXJnbF8zZC1idWlsZGluZycsXG4gICAgICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgICAgICBtYXBib3hBcGlVcmwsXG4gICAgICAgIHRocmVlREJ1aWxkaW5nQ29sb3I6IG1hcFN0eWxlLnRocmVlREJ1aWxkaW5nQ29sb3IsXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgZ2V0RmlsbENvbG9yOiBtYXBTdHlsZS50aHJlZURCdWlsZGluZ0NvbG9yXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IFtjdXN0b21Cb3R0b21EZWNrTGF5ZXJzLCBjdXN0b21Ub3BEZWNrTGF5ZXJzXSA9IGdldEN1c3RvbURlY2tMYXllcnMoZGVja0dsUHJvcHMpO1xuXG4gIGNvbnN0IGVkaXRvckxheWVyOiBhbnlbXSA9IFtdO1xuICBpZiAoZWRpdG9ySW5mbykge1xuICAgIGVkaXRvckxheWVyLnB1c2goXG4gICAgICBnZXRFZGl0b3JMYXllcih7XG4gICAgICAgIC4uLmVkaXRvckluZm9cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBbLi4uY3VzdG9tQm90dG9tRGVja0xheWVycywgLi4uZGF0YUxheWVycywgLi4uY3VzdG9tVG9wRGVja0xheWVycywgLi4uZWRpdG9yTGF5ZXJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF5ZXJPcmRlckZyb21MYXllcnM8VCBleHRlbmRzIHtpZDogc3RyaW5nfT4obGF5ZXJzOiBUW10pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBsYXllcnMubWFwKCh7aWR9KSA9PiBpZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW9yZGVyTGF5ZXJPcmRlcihcbiAgbGF5ZXJPcmRlcjogVmlzU3RhdGVbJ2xheWVyT3JkZXInXSxcbiAgb3JpZ2luTGF5ZXJJZDogc3RyaW5nLFxuICBkZXN0aW5hdGlvbkxheWVySWQ6IHN0cmluZ1xuKTogVmlzU3RhdGVbJ2xheWVyT3JkZXInXSB7XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gbGF5ZXJPcmRlci5pbmRleE9mKG9yaWdpbkxheWVySWQpO1xuICBjb25zdCBvdmVySW5kZXggPSBsYXllck9yZGVyLmluZGV4T2YoZGVzdGluYXRpb25MYXllcklkKTtcblxuICByZXR1cm4gYXJyYXlNb3ZlKGxheWVyT3JkZXIsIGFjdGl2ZUluZGV4LCBvdmVySW5kZXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTGF5ZXJUb0xheWVyT3JkZXIoXG4gIGxheWVyT3JkZXI6IFZpc1N0YXRlWydsYXllck9yZGVyJ10sXG4gIGxheWVySWQ6IHN0cmluZ1xuKTogc3RyaW5nW10ge1xuICByZXR1cm4gW2xheWVySWQsIC4uLmxheWVyT3JkZXJdO1xufVxuIl19