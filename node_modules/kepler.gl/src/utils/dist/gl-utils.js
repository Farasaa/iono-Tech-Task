"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setLayerBlending = setLayerBlending;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _core = require("@luma.gl/core");

var _constants = require("@kepler.gl/constants");

var _constants2 = _interopRequireDefault(require("@luma.gl/constants"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var getGlConst = function getGlConst(d) {
  return _constants2["default"][d];
};

function setLayerBlending(gl, layerBlending) {
  var blending = _constants.LAYER_BLENDINGS[layerBlending];
  var blendFunc = blending.blendFunc,
      blendEquation = blending.blendEquation;
  (0, _core.setParameters)(gl, _objectSpread((0, _defineProperty2["default"])({}, _constants2["default"].BLEND, true), blendFunc ? {
    blendFunc: blendFunc.map(getGlConst),
    blendEquation: Array.isArray(blendEquation) ? blendEquation.map(getGlConst) : getGlConst(blendEquation)
  } : {}));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9nbC11dGlscy50cyJdLCJuYW1lcyI6WyJnZXRHbENvbnN0IiwiZCIsIkdMIiwic2V0TGF5ZXJCbGVuZGluZyIsImdsIiwibGF5ZXJCbGVuZGluZyIsImJsZW5kaW5nIiwiTEFZRVJfQkxFTkRJTkdTIiwiYmxlbmRGdW5jIiwiYmxlbmRFcXVhdGlvbiIsIkJMRU5EIiwibWFwIiwiQXJyYXkiLCJpc0FycmF5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUdBOztBQUNBOztBQUNBOzs7Ozs7QUFFQSxJQUFNQSxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFBQyxDQUFDO0FBQUEsU0FBSUMsdUJBQUdELENBQUgsQ0FBSjtBQUFBLENBQXBCOztBQUVPLFNBQVNFLGdCQUFULENBQTBCQyxFQUExQixFQUE4QkMsYUFBOUIsRUFBNkM7QUFDbEQsTUFBTUMsUUFBUSxHQUFHQywyQkFBZ0JGLGFBQWhCLENBQWpCO0FBRGtELE1BRTNDRyxTQUYyQyxHQUVmRixRQUZlLENBRTNDRSxTQUYyQztBQUFBLE1BRWhDQyxhQUZnQyxHQUVmSCxRQUZlLENBRWhDRyxhQUZnQztBQUlsRCwyQkFBY0wsRUFBZCxxREFDR0YsdUJBQUdRLEtBRE4sRUFDYyxJQURkLEdBRU1GLFNBQVMsR0FDVDtBQUNFQSxJQUFBQSxTQUFTLEVBQUVBLFNBQVMsQ0FBQ0csR0FBVixDQUFjWCxVQUFkLENBRGI7QUFFRVMsSUFBQUEsYUFBYSxFQUFFRyxLQUFLLENBQUNDLE9BQU4sQ0FBY0osYUFBZCxJQUNYQSxhQUFhLENBQUNFLEdBQWQsQ0FBa0JYLFVBQWxCLENBRFcsR0FFWEEsVUFBVSxDQUFDUyxhQUFEO0FBSmhCLEdBRFMsR0FPVCxFQVROO0FBV0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQge3NldFBhcmFtZXRlcnN9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xuaW1wb3J0IHtMQVlFUl9CTEVORElOR1N9IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCBHTCBmcm9tICdAbHVtYS5nbC9jb25zdGFudHMnO1xuXG5jb25zdCBnZXRHbENvbnN0ID0gZCA9PiBHTFtkXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldExheWVyQmxlbmRpbmcoZ2wsIGxheWVyQmxlbmRpbmcpIHtcbiAgY29uc3QgYmxlbmRpbmcgPSBMQVlFUl9CTEVORElOR1NbbGF5ZXJCbGVuZGluZ107XG4gIGNvbnN0IHtibGVuZEZ1bmMsIGJsZW5kRXF1YXRpb259ID0gYmxlbmRpbmc7XG5cbiAgc2V0UGFyYW1ldGVycyhnbCwge1xuICAgIFtHTC5CTEVORF06IHRydWUsXG4gICAgLi4uKGJsZW5kRnVuY1xuICAgICAgPyB7XG4gICAgICAgICAgYmxlbmRGdW5jOiBibGVuZEZ1bmMubWFwKGdldEdsQ29uc3QpLFxuICAgICAgICAgIGJsZW5kRXF1YXRpb246IEFycmF5LmlzQXJyYXkoYmxlbmRFcXVhdGlvbilcbiAgICAgICAgICAgID8gYmxlbmRFcXVhdGlvbi5tYXAoZ2V0R2xDb25zdClcbiAgICAgICAgICAgIDogZ2V0R2xDb25zdChibGVuZEVxdWF0aW9uKVxuICAgICAgICB9XG4gICAgICA6IHt9KVxuICB9KTtcbn1cbiJdfQ==