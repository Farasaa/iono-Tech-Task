"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.arcVisConfigs = exports.arcColumnLabels = exports.arcRequiredColumns = exports.arcPosAccessor = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _baseLayer = _interopRequireDefault(require("../base-layer"));

var _extensions = require("@deck.gl/extensions");

var _layers = require("@deck.gl/layers");

var _utils = require("@kepler.gl/utils");

var _arcLayerIcon = _interopRequireDefault(require("./arc-layer-icon"));

var _constants = require("@kepler.gl/constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var arcPosAccessor = function arcPosAccessor(_ref) {
  var lat0 = _ref.lat0,
      lng0 = _ref.lng0,
      lat1 = _ref.lat1,
      lng1 = _ref.lng1;
  return function (dc) {
    return function (d) {
      return [dc.valueAt(d.index, lng0.fieldIdx), dc.valueAt(d.index, lat0.fieldIdx), 0, dc.valueAt(d.index, lng1.fieldIdx), dc.valueAt(d.index, lat1.fieldIdx), 0];
    };
  };
};

exports.arcPosAccessor = arcPosAccessor;
var arcRequiredColumns = ['lat0', 'lng0', 'lat1', 'lng1'];
exports.arcRequiredColumns = arcRequiredColumns;
var arcColumnLabels = {
  lat0: 'arc.lat0',
  lng0: 'arc.lng0',
  lat1: 'arc.lat1',
  lng1: 'arc.lng1'
};
exports.arcColumnLabels = arcColumnLabels;
var arcVisConfigs = {
  opacity: 'opacity',
  thickness: 'thickness',
  colorRange: 'colorRange',
  sizeRange: 'strokeWidthRange',
  targetColor: 'targetColor'
};
exports.arcVisConfigs = arcVisConfigs;

var ArcLayer = /*#__PURE__*/function (_Layer) {
  (0, _inherits2["default"])(ArcLayer, _Layer);

  var _super = _createSuper(ArcLayer);

  function ArcLayer(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, ArcLayer);
    _this = _super.call(this, props);

    _this.registerVisConfig(arcVisConfigs);

    _this.getPositionAccessor = function (dataContainer) {
      return arcPosAccessor(_this.config.columns)(dataContainer);
    };

    return _this;
  }

  (0, _createClass2["default"])(ArcLayer, [{
    key: "type",
    get: function get() {
      return 'arc';
    }
  }, {
    key: "isAggregated",
    get: function get() {
      return false;
    }
  }, {
    key: "layerIcon",
    get: function get() {
      return _arcLayerIcon["default"];
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return arcRequiredColumns;
    }
  }, {
    key: "columnLabels",
    get: function get() {
      return arcColumnLabels;
    }
  }, {
    key: "columnPairs",
    get: function get() {
      return this.defaultLinkColumnPairs;
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return {
        sourceColor: _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(ArcLayer.prototype), "visualChannels", this).color), {}, {
          property: 'color',
          key: 'sourceColor',
          accessor: 'getSourceColor',
          defaultValue: function defaultValue(config) {
            return config.color;
          }
        }),
        targetColor: _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(ArcLayer.prototype), "visualChannels", this).color), {}, {
          property: 'targetColor',
          key: 'targetColor',
          accessor: 'getTargetColor',
          defaultValue: function defaultValue(config) {
            return config.visConfig.targetColor || config.color;
          }
        }),
        size: _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(ArcLayer.prototype), "visualChannels", this).size), {}, {
          accessor: 'getWidth',
          property: 'stroke'
        })
      };
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(_ref2, getPosition) {
      var dataContainer = _ref2.dataContainer,
          filteredIndex = _ref2.filteredIndex;
      var data = [];

      for (var i = 0; i < filteredIndex.length; i++) {
        var index = filteredIndex[i];
        var pos = getPosition({
          index: index
        }); // if doesn't have point lat or lng, do not add the point
        // deck.gl can't handle position = null

        if (pos.every(Number.isFinite)) {
          data.push({
            index: index,
            sourcePosition: [pos[0], pos[1], pos[2]],
            targetPosition: [pos[3], pos[4], pos[5]]
          });
        }
      }

      return data;
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData) {
      if (this.config.dataId === null) {
        return {};
      }

      var _datasets$this$config = datasets[this.config.dataId],
          gpuFilter = _datasets$this$config.gpuFilter,
          dataContainer = _datasets$this$config.dataContainer;

      var _this$updateData = this.updateData(datasets, oldLayerData),
          data = _this$updateData.data;

      var accessors = this.getAttributeAccessors({
        dataContainer: dataContainer
      });
      return _objectSpread({
        data: data,
        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)()
      }, accessors);
    }
    /* eslint-enable complexity */

  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataContainer) {
      // get bounds from arcs
      var getPosition = this.getPositionAccessor(dataContainer);
      var sBounds = this.getPointsBounds(dataContainer, function (d) {
        var pos = getPosition(d);
        return [pos[0], pos[1]];
      });
      var tBounds = this.getPointsBounds(dataContainer, function (d) {
        var pos = getPosition(d);
        return [pos[3], pos[4]];
      });
      var bounds = tBounds && sBounds ? [Math.min(sBounds[0], tBounds[0]), Math.min(sBounds[1], tBounds[1]), Math.max(sBounds[2], tBounds[2]), Math.max(sBounds[3], tBounds[3])] : sBounds || tBounds;
      this.updateMeta({
        bounds: bounds
      });
    }
  }, {
    key: "renderLayer",
    value: function renderLayer(opts) {
      var data = opts.data,
          gpuFilter = opts.gpuFilter,
          objectHovered = opts.objectHovered,
          interactionConfig = opts.interactionConfig;

      var updateTriggers = _objectSpread({
        getPosition: this.config.columns,
        getFilterValue: gpuFilter.filterValueUpdateTriggers
      }, this.getVisualChannelUpdateTriggers());

      var widthScale = this.config.visConfig.thickness * _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER;
      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);
      var hoveredObject = this.hasHoveredObject(objectHovered);
      return [new _layers.ArcLayer(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), this.getBrushingExtensionProps(interactionConfig, 'source_target')), data), {}, {
        widthScale: widthScale,
        updateTriggers: updateTriggers,
        extensions: [].concat((0, _toConsumableArray2["default"])(defaultLayerProps.extensions), [new _extensions.BrushingExtension()])
      }))].concat((0, _toConsumableArray2["default"])(hoveredObject ? [new _layers.ArcLayer(_objectSpread(_objectSpread({}, this.getDefaultHoverLayerProps()), {}, {
        visible: defaultLayerProps.visible,
        data: [hoveredObject],
        widthScale: widthScale,
        getSourceColor: this.config.highlightColor,
        getTargetColor: this.config.highlightColor,
        getWidth: data.getWidth
      }))] : []));
    }
  }], [{
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(_ref3) {
      var _ref3$fieldPairs = _ref3.fieldPairs,
          fieldPairs = _ref3$fieldPairs === void 0 ? [] : _ref3$fieldPairs;

      if (fieldPairs.length < 2) {
        return {
          props: []
        };
      }

      var props = {
        color: (0, _utils.hexToRgb)(_constants.DEFAULT_LAYER_COLOR.tripArc),
        // connect the first two point layer with arc
        columns: {
          lat0: fieldPairs[0].pair.lat,
          lng0: fieldPairs[0].pair.lng,
          lat1: fieldPairs[1].pair.lat,
          lng1: fieldPairs[1].pair.lng
        },
        label: "".concat(fieldPairs[0].defaultName, " -> ").concat(fieldPairs[1].defaultName, " arc")
      };
      return {
        props: [props]
      };
    }
  }]);
  return ArcLayer;
}(_baseLayer["default"]);

exports["default"] = ArcLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcmMtbGF5ZXIvYXJjLWxheWVyLnRzIl0sIm5hbWVzIjpbImFyY1Bvc0FjY2Vzc29yIiwibGF0MCIsImxuZzAiLCJsYXQxIiwibG5nMSIsImRjIiwiZCIsInZhbHVlQXQiLCJpbmRleCIsImZpZWxkSWR4IiwiYXJjUmVxdWlyZWRDb2x1bW5zIiwiYXJjQ29sdW1uTGFiZWxzIiwiYXJjVmlzQ29uZmlncyIsIm9wYWNpdHkiLCJ0aGlja25lc3MiLCJjb2xvclJhbmdlIiwic2l6ZVJhbmdlIiwidGFyZ2V0Q29sb3IiLCJBcmNMYXllciIsInByb3BzIiwicmVnaXN0ZXJWaXNDb25maWciLCJnZXRQb3NpdGlvbkFjY2Vzc29yIiwiZGF0YUNvbnRhaW5lciIsImNvbmZpZyIsImNvbHVtbnMiLCJBcmNMYXllckljb24iLCJkZWZhdWx0TGlua0NvbHVtblBhaXJzIiwic291cmNlQ29sb3IiLCJjb2xvciIsInByb3BlcnR5Iiwia2V5IiwiYWNjZXNzb3IiLCJkZWZhdWx0VmFsdWUiLCJ2aXNDb25maWciLCJzaXplIiwiZ2V0UG9zaXRpb24iLCJmaWx0ZXJlZEluZGV4IiwiZGF0YSIsImkiLCJsZW5ndGgiLCJwb3MiLCJldmVyeSIsIk51bWJlciIsImlzRmluaXRlIiwicHVzaCIsInNvdXJjZVBvc2l0aW9uIiwidGFyZ2V0UG9zaXRpb24iLCJkYXRhc2V0cyIsIm9sZExheWVyRGF0YSIsImRhdGFJZCIsImdwdUZpbHRlciIsInVwZGF0ZURhdGEiLCJhY2Nlc3NvcnMiLCJnZXRBdHRyaWJ1dGVBY2Nlc3NvcnMiLCJnZXRGaWx0ZXJWYWx1ZSIsImZpbHRlclZhbHVlQWNjZXNzb3IiLCJzQm91bmRzIiwiZ2V0UG9pbnRzQm91bmRzIiwidEJvdW5kcyIsImJvdW5kcyIsIk1hdGgiLCJtaW4iLCJtYXgiLCJ1cGRhdGVNZXRhIiwib3B0cyIsIm9iamVjdEhvdmVyZWQiLCJpbnRlcmFjdGlvbkNvbmZpZyIsInVwZGF0ZVRyaWdnZXJzIiwiZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VycyIsImdldFZpc3VhbENoYW5uZWxVcGRhdGVUcmlnZ2VycyIsIndpZHRoU2NhbGUiLCJQUk9KRUNURURfUElYRUxfU0laRV9NVUxUSVBMSUVSIiwiZGVmYXVsdExheWVyUHJvcHMiLCJnZXREZWZhdWx0RGVja0xheWVyUHJvcHMiLCJob3ZlcmVkT2JqZWN0IiwiaGFzSG92ZXJlZE9iamVjdCIsIkRlY2tBcmNMYXllciIsImdldEJydXNoaW5nRXh0ZW5zaW9uUHJvcHMiLCJleHRlbnNpb25zIiwiQnJ1c2hpbmdFeHRlbnNpb24iLCJnZXREZWZhdWx0SG92ZXJMYXllclByb3BzIiwidmlzaWJsZSIsImdldFNvdXJjZUNvbG9yIiwiaGlnaGxpZ2h0Q29sb3IiLCJnZXRUYXJnZXRDb2xvciIsImdldFdpZHRoIiwiZmllbGRQYWlycyIsIkRFRkFVTFRfTEFZRVJfQ09MT1IiLCJ0cmlwQXJjIiwicGFpciIsImxhdCIsImxuZyIsImxhYmVsIiwiZGVmYXVsdE5hbWUiLCJMYXllciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBOztBQU9BOztBQUNBOztBQUVBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0FBdURPLElBQU1BLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUI7QUFBQSxNQUFFQyxJQUFGLFFBQUVBLElBQUY7QUFBQSxNQUFRQyxJQUFSLFFBQVFBLElBQVI7QUFBQSxNQUFjQyxJQUFkLFFBQWNBLElBQWQ7QUFBQSxNQUFvQkMsSUFBcEIsUUFBb0JBLElBQXBCO0FBQUEsU0FBcUQsVUFDakZDLEVBRGlGO0FBQUEsV0FFOUUsVUFBQUMsQ0FBQztBQUFBLGFBQUksQ0FDUkQsRUFBRSxDQUFDRSxPQUFILENBQVdELENBQUMsQ0FBQ0UsS0FBYixFQUFvQk4sSUFBSSxDQUFDTyxRQUF6QixDQURRLEVBRVJKLEVBQUUsQ0FBQ0UsT0FBSCxDQUFXRCxDQUFDLENBQUNFLEtBQWIsRUFBb0JQLElBQUksQ0FBQ1EsUUFBekIsQ0FGUSxFQUdSLENBSFEsRUFJUkosRUFBRSxD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Q0FBQyxDQUFELENBQVYsQ0FBY08sV0FBbkIsaUJBQXFDUCxVQUFVLENBQUMsQ0FBRCxDQUFWLENBQWNPLFdBQW5EO0FBVHlFLE9BQWhGO0FBWUEsYUFBTztBQUFDMUUsUUFBQUEsS0FBSyxFQUFFLENBQUNBLEtBQUQ7QUFBUixPQUFQO0FBQ0Q7OztFQWhGbUMyRSxxQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCBMYXllciwge1xuICBMYXllckNvbHVtbixcbiAgTGF5ZXJCYXNlQ29uZmlnLFxuICBMYXllckNvbG9yQ29uZmlnLFxuICBMYXllclNpemVDb25maWcsXG4gIExheWVyQm91bmRzXG59IGZyb20gJy4uL2Jhc2UtbGF5ZXInO1xuaW1wb3J0IHtCcnVzaGluZ0V4dGVuc2lvbn0gZnJvbSAnQGRlY2suZ2wvZXh0ZW5zaW9ucyc7XG5pbXBvcnQge0FyY0xheWVyIGFzIERlY2tBcmNMYXllcn0gZnJvbSAnQGRlY2suZ2wvbGF5ZXJzJztcblxuaW1wb3J0IHtoZXhUb1JnYiwgRGF0YUNvbnRhaW5lckludGVyZmFjZX0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQgQXJjTGF5ZXJJY29uIGZyb20gJy4vYXJjLWxheWVyLWljb24nO1xuaW1wb3J0IHtcbiAgREVGQVVMVF9MQVlFUl9DT0xPUixcbiAgQ29sb3JSYW5nZSxcbiAgUFJPSkVDVEVEX1BJWEVMX1NJWkVfTVVMVElQTElFUlxufSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7XG4gIFJHQkNvbG9yLFxuICBNZXJnZSxcbiAgVmlzQ29uZmlnQ29sb3JSYW5nZSxcbiAgVmlzQ29uZmlnQ29sb3JTZWxlY3QsXG4gIFZpc0NvbmZpZ051bWJlcixcbiAgVmlzQ29uZmlnUmFuZ2Vcbn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0tlcGxlclRhYmxlfSBmcm9tICdAa2VwbGVyLmdsL3RhYmxlJztcblxuZXhwb3J0IHR5cGUgQXJjTGF5ZXJWaXNDb25maWdTZXR0aW5ncyA9IHtcbiAgb3BhY2l0eTogVmlzQ29uZmlnTnVtYmVyO1xuICB0aGlja25lc3M6IFZpc0NvbmZpZ051bWJlcjtcbiAgY29sb3JSYW5nZTogVmlzQ29uZmlnQ29sb3JSYW5nZTtcbiAgc2l6ZVJhbmdlOiBWaXNDb25maWdSYW5nZTtcbiAgdGFyZ2V0Q29sb3I6IFZpc0NvbmZpZ0NvbG9yU2VsZWN0O1xufTtcblxuZXhwb3J0IHR5cGUgQXJjTGF5ZXJDb2x1bW5zQ29uZmlnID0ge1xuICBsYXQwOiBMYXllckNvbHVtbjtcbiAgbGF0MTogTGF5ZXJDb2x1bW47XG4gIGxuZzA6IExheWVyQ29sdW1uO1xuICBsbmcxOiBMYXllckNvbHVtbjtcbn07XG5cbmV4cG9ydCB0eXBlIEFyY0xheWVyVmlzQ29uZmlnID0ge1xuICBjb2xvclJhbmdlOiBDb2xvclJhbmdlO1xuICBvcGFjaXR5OiBudW1iZXI7XG4gIHNpemVSYW5nZTogW251bWJlciwgbnVtYmVyXTtcbiAgdGFyZ2V0Q29sb3I6IFJHQkNvbG9yO1xuICB0aGlja25lc3M6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIEFyY0xheWVyVmlzdWFsQ2hhbm5lbENvbmZpZyA9IExheWVyQ29sb3JDb25maWcgJiBMYXllclNpemVDb25maWc7XG5leHBvcnQgdHlwZSBBcmNMYXllckNvbmZpZyA9IE1lcmdlPFxuICBMYXllckJhc2VDb25maWcsXG4gIHtjb2x1bW5zOiBBcmNMYXllckNvbHVtbnNDb25maWc7IHZpc0NvbmZpZzogQXJjTGF5ZXJWaXNDb25maWd9XG4+ICZcbiAgQXJjTGF5ZXJWaXN1YWxDaGFubmVsQ29uZmlnO1xuXG5leHBvcnQgdHlwZSBBcmNMYXllckRhdGEgPSB7XG4gIGluZGV4OiBudW1iZXI7XG4gIHNvdXJjZVBvc2l0aW9uOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHRhcmdldFBvc2l0aW9uOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG59O1xuXG5leHBvcnQgdHlwZSBBcmNMYXllck1ldGEgPSB7XG4gIGJvdW5kczogTGF5ZXJCb3VuZHM7XG59O1xuZXhwb3J0IGNvbnN0IGFyY1Bvc0FjY2Vzc29yID0gKHtsYXQwLCBsbmcwLCBsYXQxLCBsbmcxfTogQXJjTGF5ZXJDb2x1bW5zQ29uZmlnKSA9PiAoXG4gIGRjOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlXG4pID0+IGQgPT4gW1xuICBkYy52YWx1ZUF0KGQuaW5kZXgsIGxuZzAuZmllbGRJZHgpLFxuICBkYy52YWx1ZUF0KGQuaW5kZXgsIGxhdDAuZmllbGRJZHgpLFxuICAwLFxuICBkYy52YWx1ZUF0KGQuaW5kZXgsIGxuZzEuZmllbGRJZHgpLFxuICBkYy52YWx1ZUF0KGQuaW5kZXgsIGxhdDEuZmllbGRJZHgpLFxuICAwXG5dO1xuXG5leHBvcnQgY29uc3QgYXJjUmVxdWlyZWRDb2x1bW5zID0gWydsYXQwJywgJ2xuZzAnLCAnbGF0MScsICdsbmcxJ107XG5leHBvcnQgY29uc3QgYXJjQ29sdW1uTGFiZWxzID0ge1xuICBsYXQwOiAnYXJjLmxhdDAnLFxuICBsbmcwOiAnYXJjLmxuZzAnLFxuICBsYXQxOiAnYXJjLmxhdDEnLFxuICBsbmcxOiAnYXJjLmxuZzEnXG59O1xuXG5leHBvcnQgY29uc3QgYXJjVmlzQ29uZmlnczoge1xuICBvcGFjaXR5OiAnb3BhY2l0eSc7XG4gIHRoaWNrbmVzczogJ3RoaWNrbmVzcyc7XG4gIGNvbG9yUmFuZ2U6ICdjb2xvclJhbmdlJztcbiAgc2l6ZVJhbmdlOiAnc3Ryb2tlV2lkdGhSYW5nZSc7XG4gIHRhcmdldENvbG9yOiAndGFyZ2V0Q29sb3InO1xufSA9IHtcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICB0aGlja25lc3M6ICd0aGlja25lc3MnLFxuICBjb2xvclJhbmdlOiAnY29sb3JSYW5nZScsXG4gIHNpemVSYW5nZTogJ3N0cm9rZVdpZHRoUmFuZ2UnLFxuICB0YXJnZXRDb2xvcjogJ3RhcmdldENvbG9yJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJjTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGRlY2xhcmUgdmlzQ29uZmlnU2V0dGluZ3M6IEFyY0xheWVyVmlzQ29uZmlnU2V0dGluZ3M7XG4gIGRlY2xhcmUgY29uZmlnOiBBcmNMYXllckNvbmZpZztcbiAgZGVjbGFyZSBtZXRhOiBBcmNMYXllck1ldGE7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyVmlzQ29uZmlnKGFyY1Zpc0NvbmZpZ3MpO1xuICAgIHRoaXMuZ2V0UG9zaXRpb25BY2Nlc3NvciA9IChkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlKSA9PlxuICAgICAgYXJjUG9zQWNjZXNzb3IodGhpcy5jb25maWcuY29sdW1ucykoZGF0YUNvbnRhaW5lcik7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2FyYyc7XG4gIH1cblxuICBnZXQgaXNBZ2dyZWdhdGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldCBsYXllckljb24oKSB7XG4gICAgcmV0dXJuIEFyY0xheWVySWNvbjtcbiAgfVxuXG4gIGdldCByZXF1aXJlZExheWVyQ29sdW1ucygpIHtcbiAgICByZXR1cm4gYXJjUmVxdWlyZWRDb2x1bW5zO1xuICB9XG5cbiAgZ2V0IGNvbHVtbkxhYmVscygpIHtcbiAgICByZXR1cm4gYXJjQ29sdW1uTGFiZWxzO1xuICB9XG4gIGdldCBjb2x1bW5QYWlycygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0TGlua0NvbHVtblBhaXJzO1xuICB9XG5cbiAgZ2V0IHZpc3VhbENoYW5uZWxzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2VDb2xvcjoge1xuICAgICAgICAuLi5zdXBlci52aXN1YWxDaGFubmVscy5jb2xvcixcbiAgICAgICAgcHJvcGVydHk6ICdjb2xvcicsXG4gICAgICAgIGtleTogJ3NvdXJjZUNvbG9yJyxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRTb3VyY2VDb2xvcicsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogY29uZmlnID0+IGNvbmZpZy5jb2xvclxuICAgICAgfSxcbiAgICAgIHRhcmdldENvbG9yOiB7XG4gICAgICAgIC4uLnN1cGVyLnZpc3VhbENoYW5uZWxzLmNvbG9yLFxuICAgICAgICBwcm9wZXJ0eTogJ3RhcmdldENvbG9yJyxcbiAgICAgICAga2V5OiAndGFyZ2V0Q29sb3InLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldFRhcmdldENvbG9yJyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBjb25maWcgPT4gY29uZmlnLnZpc0NvbmZpZy50YXJnZXRDb2xvciB8fCBjb25maWcuY29sb3JcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnN1cGVyLnZpc3VhbENoYW5uZWxzLnNpemUsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0V2lkdGgnLFxuICAgICAgICBwcm9wZXJ0eTogJ3N0cm9rZSdcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGZpbmREZWZhdWx0TGF5ZXJQcm9wcyh7XG4gICAgZmllbGRQYWlycyA9IFtdXG4gIH06IEtlcGxlclRhYmxlKToge3Byb3BzOiB7Y29sb3I/OiBSR0JDb2xvcjsgY29sdW1uczogQXJjTGF5ZXJDb2x1bW5zQ29uZmlnOyBsYWJlbDogc3RyaW5nfVtdfSB7XG4gICAgaWYgKGZpZWxkUGFpcnMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHtwcm9wczogW119O1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BzOiB7Y29sb3I6IFJHQkNvbG9yOyBjb2x1bW5zOiBBcmNMYXllckNvbHVtbnNDb25maWc7IGxhYmVsOiBzdHJpbmd9ID0ge1xuICAgICAgY29sb3I6IGhleFRvUmdiKERFRkFVTFRfTEFZRVJfQ09MT1IudHJpcEFyYyksXG4gICAgICAvLyBjb25uZWN0IHRoZSBmaXJzdCB0d28gcG9pbnQgbGF5ZXIgd2l0aCBhcmNcbiAgICAgIGNvbHVtbnM6IHtcbiAgICAgICAgbGF0MDogZmllbGRQYWlyc1swXS5wYWlyLmxhdCxcbiAgICAgICAgbG5nMDogZmllbGRQYWlyc1swXS5wYWlyLmxuZyxcbiAgICAgICAgbGF0MTogZmllbGRQYWlyc1sxXS5wYWlyLmxhdCxcbiAgICAgICAgbG5nMTogZmllbGRQYWlyc1sxXS5wYWlyLmxuZ1xuICAgICAgfSxcbiAgICAgIGxhYmVsOiBgJHtmaWVsZFBhaXJzWzBdLmRlZmF1bHROYW1lfSAtPiAke2ZpZWxkUGFpcnNbMV0uZGVmYXVsdE5hbWV9IGFyY2BcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtwcm9wczogW3Byb3BzXX07XG4gIH1cblxuICBjYWxjdWxhdGVEYXRhQXR0cmlidXRlKHtkYXRhQ29udGFpbmVyLCBmaWx0ZXJlZEluZGV4fSwgZ2V0UG9zaXRpb24pIHtcbiAgICBjb25zdCBkYXRhOiBBcmNMYXllckRhdGFbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyZWRJbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBmaWx0ZXJlZEluZGV4W2ldO1xuICAgICAgY29uc3QgcG9zID0gZ2V0UG9zaXRpb24oe2luZGV4fSk7XG5cbiAgICAgIC8vIGlmIGRvZXNuJ3QgaGF2ZSBwb2ludCBsYXQgb3IgbG5nLCBkbyBub3QgYWRkIHRoZSBwb2ludFxuICAgICAgLy8gZGVjay5nbCBjYW4ndCBoYW5kbGUgcG9zaXRpb24gPSBudWxsXG4gICAgICBpZiAocG9zLmV2ZXJ5KE51bWJlci5pc0Zpbml0ZSkpIHtcbiAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBzb3VyY2VQb3NpdGlvbjogW3Bvc1swXSwgcG9zWzFdLCBwb3NbMl1dLFxuICAgICAgICAgIHRhcmdldFBvc2l0aW9uOiBbcG9zWzNdLCBwb3NbNF0sIHBvc1s1XV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBmb3JtYXRMYXllckRhdGEoZGF0YXNldHMsIG9sZExheWVyRGF0YSkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5kYXRhSWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3Qge2dwdUZpbHRlciwgZGF0YUNvbnRhaW5lcn0gPSBkYXRhc2V0c1t0aGlzLmNvbmZpZy5kYXRhSWRdO1xuICAgIGNvbnN0IHtkYXRhfSA9IHRoaXMudXBkYXRlRGF0YShkYXRhc2V0cywgb2xkTGF5ZXJEYXRhKTtcbiAgICBjb25zdCBhY2Nlc3NvcnMgPSB0aGlzLmdldEF0dHJpYnV0ZUFjY2Vzc29ycyh7ZGF0YUNvbnRhaW5lcn0pO1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgZ2V0RmlsdGVyVmFsdWU6IGdwdUZpbHRlci5maWx0ZXJWYWx1ZUFjY2Vzc29yKGRhdGFDb250YWluZXIpKCksXG4gICAgICAuLi5hY2Nlc3NvcnNcbiAgICB9O1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIHVwZGF0ZUxheWVyTWV0YShkYXRhQ29udGFpbmVyKSB7XG4gICAgLy8gZ2V0IGJvdW5kcyBmcm9tIGFyY3NcbiAgICBjb25zdCBnZXRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb25BY2Nlc3NvcihkYXRhQ29udGFpbmVyKTtcblxuICAgIGNvbnN0IHNCb3VuZHMgPSB0aGlzLmdldFBvaW50c0JvdW5kcyhkYXRhQ29udGFpbmVyLCBkID0+IHtcbiAgICAgIGNvbnN0IHBvcyA9IGdldFBvc2l0aW9uKGQpO1xuICAgICAgcmV0dXJuIFtwb3NbMF0sIHBvc1sxXV07XG4gICAgfSk7XG4gICAgY29uc3QgdEJvdW5kcyA9IHRoaXMuZ2V0UG9pbnRzQm91bmRzKGRhdGFDb250YWluZXIsIGQgPT4ge1xuICAgICAgY29uc3QgcG9zID0gZ2V0UG9zaXRpb24oZCk7XG4gICAgICByZXR1cm4gW3Bvc1szXSwgcG9zWzRdXTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGJvdW5kcyA9XG4gICAgICB0Qm91bmRzICYmIHNCb3VuZHNcbiAgICAgICAgPyBbXG4gICAgICAgICAgICBNYXRoLm1pbihzQm91bmRzWzBdLCB0Qm91bmRzWzBdKSxcbiAgICAgICAgICAgIE1hdGgubWluKHNCb3VuZHNbMV0sIHRCb3VuZHNbMV0pLFxuICAgICAgICAgICAgTWF0aC5tYXgoc0JvdW5kc1syXSwgdEJvdW5kc1syXSksXG4gICAgICAgICAgICBNYXRoLm1heChzQm91bmRzWzNdLCB0Qm91bmRzWzNdKVxuICAgICAgICAgIF1cbiAgICAgICAgOiBzQm91bmRzIHx8IHRCb3VuZHM7XG5cbiAgICB0aGlzLnVwZGF0ZU1ldGEoe2JvdW5kc30pO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXIob3B0cykge1xuICAgIGNvbnN0IHtkYXRhLCBncHVGaWx0ZXIsIG9iamVjdEhvdmVyZWQsIGludGVyYWN0aW9uQ29uZmlnfSA9IG9wdHM7XG4gICAgY29uc3QgdXBkYXRlVHJpZ2dlcnMgPSB7XG4gICAgICBnZXRQb3NpdGlvbjogdGhpcy5jb25maWcuY29sdW1ucyxcbiAgICAgIGdldEZpbHRlclZhbHVlOiBncHVGaWx0ZXIuZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VycyxcbiAgICAgIC4uLnRoaXMuZ2V0VmlzdWFsQ2hhbm5lbFVwZGF0ZVRyaWdnZXJzKClcbiAgICB9O1xuICAgIGNvbnN0IHdpZHRoU2NhbGUgPSB0aGlzLmNvbmZpZy52aXNDb25maWcudGhpY2tuZXNzICogUFJPSkVDVEVEX1BJWEVMX1NJWkVfTVVMVElQTElFUjtcbiAgICBjb25zdCBkZWZhdWx0TGF5ZXJQcm9wcyA9IHRoaXMuZ2V0RGVmYXVsdERlY2tMYXllclByb3BzKG9wdHMpO1xuICAgIGNvbnN0IGhvdmVyZWRPYmplY3QgPSB0aGlzLmhhc0hvdmVyZWRPYmplY3Qob2JqZWN0SG92ZXJlZCk7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBEZWNrQXJjTGF5ZXIoe1xuICAgICAgICAuLi5kZWZhdWx0TGF5ZXJQcm9wcyxcbiAgICAgICAgLi4udGhpcy5nZXRCcnVzaGluZ0V4dGVuc2lvblByb3BzKGludGVyYWN0aW9uQ29uZmlnLCAnc291cmNlX3RhcmdldCcpLFxuICAgICAgICAuLi5kYXRhLFxuICAgICAgICB3aWR0aFNjYWxlLFxuICAgICAgICB1cGRhdGVUcmlnZ2VycyxcbiAgICAgICAgZXh0ZW5zaW9uczogWy4uLmRlZmF1bHRMYXllclByb3BzLmV4dGVuc2lvbnMsIG5ldyBCcnVzaGluZ0V4dGVuc2lvbigpXVxuICAgICAgfSksXG4gICAgICAvLyBob3ZlciBsYXllclxuICAgICAgLi4uKGhvdmVyZWRPYmplY3RcbiAgICAgICAgPyBbXG4gICAgICAgICAgICBuZXcgRGVja0FyY0xheWVyKHtcbiAgICAgICAgICAgICAgLi4udGhpcy5nZXREZWZhdWx0SG92ZXJMYXllclByb3BzKCksXG4gICAgICAgICAgICAgIHZpc2libGU6IGRlZmF1bHRMYXllclByb3BzLnZpc2libGUsXG4gICAgICAgICAgICAgIGRhdGE6IFtob3ZlcmVkT2JqZWN0XSxcbiAgICAgICAgICAgICAgd2lkdGhTY2FsZSxcbiAgICAgICAgICAgICAgZ2V0U291cmNlQ29sb3I6IHRoaXMuY29uZmlnLmhpZ2hsaWdodENvbG9yLFxuICAgICAgICAgICAgICBnZXRUYXJnZXRDb2xvcjogdGhpcy5jb25maWcuaGlnaGxpZ2h0Q29sb3IsXG4gICAgICAgICAgICAgIGdldFdpZHRoOiBkYXRhLmdldFdpZHRoXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIF1cbiAgICAgICAgOiBbXSlcbiAgICBdO1xuICB9XG59XG4iXX0=