import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { PreviewEncoder } from '../encoders';
import { AnimationManager } from '../animations';
import { VideoCapture } from '../capture/video-capture';
export default class DeckAdapter {
  constructor(_ref) {
    let {
      animationManager = undefined,
      glContext = undefined
    } = _ref;

    _defineProperty(this, "deck", void 0);

    _defineProperty(this, "animationManager", void 0);

    _defineProperty(this, "shouldAnimate", void 0);

    _defineProperty(this, "enabled", void 0);

    _defineProperty(this, "glContext", void 0);

    this.animationManager = animationManager || new AnimationManager({});
    this.glContext = glContext;
    this.videoCapture = new VideoCapture();
    this.shouldAnimate = false;
    this.enabled = false;
    this.getProps = this.getProps.bind(this);
    this.render = this.render.bind(this);
    this.stop = this.stop.bind(this);
    this.seek = this.seek.bind(this);
  }

  setDeck(deck) {
    this.deck = deck;
  }

  getProps(_ref2) {
    let {
      deck,
      onNextFrame = undefined,
      extraProps = undefined
    } = _ref2;

    if (deck) {
      this.deck = deck;
    }

    const props = {
      _animate: this.shouldAnimate
    };

    if (onNextFrame) {
      props.onAfterRender = () => this.onAfterRender(onNextFrame);
    }

    if (this.enabled) {
      props.controller = false;
    } else {
      props.controller = true;
    }

    if (this.glContext) {
      props.gl = this.glContext;
    }

    return { ...extraProps,
      ...props
    };
  }

  render(_ref3) {
    let {
      Encoder = PreviewEncoder,
      formatConfigs = {},
      filename = undefined,
      timecode = {
        start: 0,
        end: 0,
        framerate: 30
      },
      onStopped = undefined,
      onSave = undefined,
      onComplete = undefined
    } = _ref3;
    this.shouldAnimate = true;
    this.videoCapture.render({
      Encoder,
      formatConfigs,
      timecode,
      filename,
      onStop: () => this.stop({
        onStopped,
        onSave,
        onComplete
      })
    });
    this.enabled = true;
    this.seek({
      timeMs: timecode.start
    });
  }

  stop(_ref4) {
    let {
      onStopped,
      onSave,
      onComplete,
      abort
    } = _ref4;
    this.enabled = false;
    this.shouldAnimate = false;
    this.videoCapture.stop({
      onStopped,
      onSave,
      onComplete,
      abort
    });
  }

  seek(_ref5) {
    let {
      timeMs
    } = _ref5;
    this.animationManager.timeline.setTime(timeMs);
    this.animationManager.draw();
  }

  onAfterRender(proceedToNextFrame) {
    let readyToCapture = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const areAllLayersLoaded = this.deck && this.deck.props.layers.every(layer => layer.isLoaded);

    if (this.videoCapture.isRecording() && areAllLayersLoaded && readyToCapture) {
      this.videoCapture.capture(this.deck.canvas, nextTimeMs => {
        this.seek({
          timeMs: nextTimeMs
        });
        proceedToNextFrame(nextTimeMs);
      });
    }
  }

}
//# sourceMappingURL=deck-adapter.js.map