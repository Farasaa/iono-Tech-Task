"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexedDataContainer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _dataRow = require("./data-row");

var _marked = /*#__PURE__*/_regenerator["default"].mark(rowsIterator),
    _marked2 = /*#__PURE__*/_regenerator["default"].mark(columnIterator);

/**
 * @param dataContainer
 * @param indices
 * @param sharedRow
 * @returns
 */
function rowsIterator(dataContainer, indices, sharedRow) {
  var numRows, rowIndex, mappedRowIndex;
  return _regenerator["default"].wrap(function rowsIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          numRows = indices.length;
          rowIndex = 0;

        case 2:
          if (!(rowIndex < numRows)) {
            _context.next = 9;
            break;
          }

          mappedRowIndex = indices[rowIndex];
          _context.next = 6;
          return dataContainer.row(mappedRowIndex, sharedRow);

        case 6:
          ++rowIndex;
          _context.next = 2;
          break;

        case 9:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}
/**
 * @param dataContainer
 * @param indices
 * @param columnIndex
 * @returns
 */


function columnIterator(dataContainer, indices, columnIndex) {
  var numRows, rowIndex, mappedRowIndex;
  return _regenerator["default"].wrap(function columnIterator$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          numRows = indices.length;
          rowIndex = 0;

        case 2:
          if (!(rowIndex < numRows)) {
            _context2.next = 9;
            break;
          }

          mappedRowIndex = indices[rowIndex];
          _context2.next = 6;
          return dataContainer.valueAt(mappedRowIndex, columnIndex);

        case 6:
          ++rowIndex;
          _context2.next = 2;
          break;

        case 9:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}
/**
 * A data container wrapper around another data container.
 * You have to pass an array of indices to reference rows in the parent data container.
 * For example indices [3, 4, 6, 8] means that IndexedDataContainer is going to have
 * 4 rows and row(2) points to 6th row in the referenced data container.
 */


var IndexedDataContainer = /*#__PURE__*/function () {
  function IndexedDataContainer(parentDataContainer, indices) {
    (0, _classCallCheck2["default"])(this, IndexedDataContainer);
    (0, _defineProperty2["default"])(this, "_parentDataContainer", void 0);
    (0, _defineProperty2["default"])(this, "_indices", void 0);
    this._parentDataContainer = parentDataContainer;
    this._indices = indices;
  }

  (0, _createClass2["default"])(IndexedDataContainer, [{
    key: "numRows",
    value: function numRows() {
      return this._indices.length;
    }
  }, {
    key: "numColumns",
    value: function numColumns() {
      return this._parentDataContainer.numColumns();
    }
    /**
     * Remaps a local index to an index in the parent dataset
     * @param rowIndex
     * @returns number
     */

  }, {
    key: "_mappedRowIndex",
    value: function _mappedRowIndex(rowIndex) {
      return this._indices[rowIndex];
    }
  }, {
    key: "valueAt",
    value: function valueAt(rowIndex, columnIndex) {
      return this._parentDataContainer.valueAt(this._mappedRowIndex(rowIndex), columnIndex);
    }
  }, {
    key: "row",
    value: function row(rowIndex, sharedRow) {
      return this._parentDataContainer.row(this._mappedRowIndex(rowIndex), sharedRow);
    }
  }, {
    key: "rowAsArray",
    value: function rowAsArray(rowIndex) {
      return this._parentDataContainer.rowAsArray(this._mappedRowIndex(rowIndex));
    }
  }, {
    key: "rows",
    value: function rows(sharedRow) {
      return rowsIterator(this._parentDataContainer, this._indices, sharedRow);
    }
  }, {
    key: "column",
    value: function column(columnIndex) {
      return columnIterator(this._parentDataContainer, this._indices, columnIndex);
    }
  }, {
    key: "getPlainIndex",
    value: function getPlainIndex() {
      return this._indices.map(function (_, i) {
        return i;
      });
    }
  }, {
    key: "flattenData",
    value: function flattenData() {
      var _this = this;

      var tSharedRow = _dataRow.DataRow.createSharedRow(true);

      return this._indices.map(function (_, i) {
        return _this.row(i, tSharedRow).values();
      }, this);
    }
  }, {
    key: "map",
    value: function map(func, sharedRow) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var _options$start = options.start,
          start = _options$start === void 0 ? 0 : _options$start,
          _options$end = options.end,
          end = _options$end === void 0 ? this.numRows() : _options$end;
      var endRow = Math.min(this.numRows(), end);

      var tSharedRow = _dataRow.DataRow.createSharedRow(sharedRow);

      var out = [];

      for (var rowIndex = start; rowIndex < endRow; ++rowIndex) {
        var _row = this.row(rowIndex, tSharedRow);

        out.push(func(_row, rowIndex));
      }

      return out;
    }
  }, {
    key: "mapIndex",
    value: function mapIndex(func) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _options$start2 = options.start,
          start = _options$start2 === void 0 ? 0 : _options$start2,
          _options$end2 = options.end,
          end = _options$end2 === void 0 ? this.numRows() : _options$end2;
      var endRow = Math.min(this.numRows(), end);
      var out = [];

      for (var rowIndex = start; rowIndex < endRow; ++rowIndex) {
        out.push(func({
          index: this._mappedRowIndex(rowIndex)
        }, this._parentDataContainer));
      }

      return out;
    }
  }, {
    key: "find",
    value: function find(func, sharedRow) {
      var tSharedRow = _dataRow.DataRow.createSharedRow(sharedRow);

      for (var rowIndex = 0; rowIndex < this.numRows(); ++rowIndex) {
        var _row2 = this.row(rowIndex, tSharedRow);

        if (func(_row2, rowIndex)) {
          return _row2;
        }
      }

      return undefined;
    }
  }, {
    key: "reduce",
    value: function reduce(func, initialValue, sharedRow) {
      var tSharedRow = _dataRow.DataRow.createSharedRow(sharedRow);

      for (var rowIndex = 0; rowIndex < this._indices.length; ++rowIndex) {
        var _row3 = this.row(rowIndex, tSharedRow);

        initialValue = func(initialValue, _row3, rowIndex);
      }

      return initialValue;
    }
  }]);
  return IndexedDataContainer;
}();

exports.IndexedDataContainer = IndexedDataContainer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleGVkLWRhdGEtY29udGFpbmVyLnRzIl0sIm5hbWVzIjpbInJvd3NJdGVyYXRvciIsImNvbHVtbkl0ZXJhdG9yIiwiZGF0YUNvbnRhaW5lciIsImluZGljZXMiLCJzaGFyZWRSb3ciLCJudW1Sb3dzIiwibGVuZ3RoIiwicm93SW5kZXgiLCJtYXBwZWRSb3dJbmRleCIsInJvdyIsImNvbHVtbkluZGV4IiwidmFsdWVBdCIsIkluZGV4ZWREYXRhQ29udGFpbmVyIiwicGFyZW50RGF0YUNvbnRhaW5lciIsIl9wYXJlbnREYXRhQ29udGFpbmVyIiwiX2luZGljZXMiLCJudW1Db2x1bW5zIiwiX21hcHBlZFJvd0luZGV4Iiwicm93QXNBcnJheSIsIm1hcCIsIl8iLCJpIiwidFNoYXJlZFJvdyIsIkRhdGFSb3ciLCJjcmVhdGVTaGFyZWRSb3ciLCJ2YWx1ZXMiLCJmdW5jIiwib3B0aW9ucyIsInN0YXJ0IiwiZW5kIiwiZW5kUm93IiwiTWF0aCIsIm1pbiIsIm91dCIsInB1c2giLCJpbmRleCIsInVuZGVmaW5lZCIsImluaXRpYWxWYWx1ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQTs7d0RBUVVBLFk7eURBa0JBQyxjOztBQXhCVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFVRCxZQUFWLENBQ0VFLGFBREYsRUFFRUMsT0FGRixFQUdFQyxTQUhGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtRQyxVQUFBQSxPQUxSLEdBS2tCRixPQUFPLENBQUNHLE1BTDFCO0FBTVdDLFVBQUFBLFFBTlgsR0FNc0IsQ0FOdEI7O0FBQUE7QUFBQSxnQkFNeUJBLFFBQVEsR0FBR0YsT0FOcEM7QUFBQTtBQUFBO0FBQUE7O0FBT1VHLFVBQUFBLGNBUFYsR0FPMkJMLE9BQU8sQ0FBQ0ksUUFBRCxDQVBsQztBQUFBO0FBUUksaUJBQU1MLGFBQWEsQ0FBQ08sR0FBZCxDQUFrQkQsY0FBbEIsRUFBa0NKLFNBQWxDLENBQU47O0FB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QUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IHtEYXRhQ29udGFpbmVySW50ZXJmYWNlLCBSYW5nZU9wdGlvbnN9IGZyb20gJy4vZGF0YS1jb250YWluZXItaW50ZXJmYWNlJztcbmltcG9ydCB7RGF0YVJvdywgU2hhcmVkUm93T3B0aW9uc30gZnJvbSAnLi9kYXRhLXJvdyc7XG5cbi8qKlxuICogQHBhcmFtIGRhdGFDb250YWluZXJcbiAqIEBwYXJhbSBpbmRpY2VzXG4gKiBAcGFyYW0gc2hhcmVkUm93XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiogcm93c0l0ZXJhdG9yKFxuICBkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlLFxuICBpbmRpY2VzOiBudW1iZXJbXSxcbiAgc2hhcmVkUm93OiBTaGFyZWRSb3dPcHRpb25zXG4pOiBHZW5lcmF0b3I8RGF0YVJvdz4ge1xuICBjb25zdCBudW1Sb3dzID0gaW5kaWNlcy5sZW5ndGg7XG4gIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBudW1Sb3dzOyArK3Jvd0luZGV4KSB7XG4gICAgY29uc3QgbWFwcGVkUm93SW5kZXggPSBpbmRpY2VzW3Jvd0luZGV4XTtcbiAgICB5aWVsZCBkYXRhQ29udGFpbmVyLnJvdyhtYXBwZWRSb3dJbmRleCwgc2hhcmVkUm93KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBkYXRhQ29udGFpbmVyXG4gKiBAcGFyYW0gaW5kaWNlc1xuICogQHBhcmFtIGNvbHVtbkluZGV4XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiogY29sdW1uSXRlcmF0b3IoXG4gIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2UsXG4gIGluZGljZXM6IG51bWJlcltdLFxuICBjb2x1bW5JbmRleDogbnVtYmVyXG4pOiBHZW5lcmF0b3I8YW55PiB7XG4gIGNvbnN0IG51bVJvd3MgPSBpbmRpY2VzLmxlbmd0aDtcbiAgZm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IG51bVJvd3M7ICsrcm93SW5kZXgpIHtcbiAgICBjb25zdCBtYXBwZWRSb3dJbmRleCA9IGluZGljZXNbcm93SW5kZXhdO1xuICAgIHlpZWxkIGRhdGFDb250YWluZXIudmFsdWVBdChtYXBwZWRSb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuICB9XG59XG5cbi8qKlxuICogQSBkYXRhIGNvbnRhaW5lciB3cmFwcGVyIGFyb3VuZCBhbm90aGVyIGRhdGEgY29udGFpbmVyLlxuICogWW91IGhhdmUgdG8gcGFzcyBhbiBhcnJheSBvZiBpbmRpY2VzIHRvIHJlZmVyZW5jZSByb3dzIGluIHRoZSBwYXJlbnQgZGF0YSBjb250YWluZXIuXG4gKiBGb3IgZXhhbXBsZSBpbmRpY2VzIFszLCA0LCA2LCA4XSBtZWFucyB0aGF0IEluZGV4ZWREYXRhQ29udGFpbmVyIGlzIGdvaW5nIHRvIGhhdmVcbiAqIDQgcm93cyBhbmQgcm93KDIpIHBvaW50cyB0byA2dGggcm93IGluIHRoZSByZWZlcmVuY2VkIGRhdGEgY29udGFpbmVyLlxuICovXG5leHBvcnQgY2xhc3MgSW5kZXhlZERhdGFDb250YWluZXIgaW1wbGVtZW50cyBEYXRhQ29udGFpbmVySW50ZXJmYWNlIHtcbiAgX3BhcmVudERhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2U7XG4gIF9pbmRpY2VzOiBudW1iZXJbXTtcblxuICBjb25zdHJ1Y3RvcihwYXJlbnREYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlLCBpbmRpY2VzOiBudW1iZXJbXSkge1xuICAgIHRoaXMuX3BhcmVudERhdGFDb250YWluZXIgPSBwYXJlbnREYXRhQ29udGFpbmVyO1xuICAgIHRoaXMuX2luZGljZXMgPSBpbmRpY2VzO1xuICB9XG5cbiAgbnVtUm93cygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9pbmRpY2VzLmxlbmd0aDtcbiAgfVxuXG4gIG51bUNvbHVtbnMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RGF0YUNvbnRhaW5lci5udW1Db2x1bW5zKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtYXBzIGEgbG9jYWwgaW5kZXggdG8gYW4gaW5kZXggaW4gdGhlIHBhcmVudCBkYXRhc2V0XG4gICAqIEBwYXJhbSByb3dJbmRleFxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIF9tYXBwZWRSb3dJbmRleChyb3dJbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5faW5kaWNlc1tyb3dJbmRleF07XG4gIH1cblxuICB2YWx1ZUF0KHJvd0luZGV4OiBudW1iZXIsIGNvbHVtbkluZGV4OiBudW1iZXIpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnREYXRhQ29udGFpbmVyLnZhbHVlQXQodGhpcy5fbWFwcGVkUm93SW5kZXgocm93SW5kZXgpLCBjb2x1bW5JbmRleCk7XG4gIH1cblxuICByb3cocm93SW5kZXg6IG51bWJlciwgc2hhcmVkUm93PzogU2hhcmVkUm93T3B0aW9ucyk6IERhdGFSb3cge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnREYXRhQ29udGFpbmVyLnJvdyh0aGlzLl9tYXBwZWRSb3dJbmRleChyb3dJbmRleCksIHNoYXJlZFJvdyk7XG4gIH1cblxuICByb3dBc0FycmF5KHJvd0luZGV4OiBudW1iZXIpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudERhdGFDb250YWluZXIucm93QXNBcnJheSh0aGlzLl9tYXBwZWRSb3dJbmRleChyb3dJbmRleCkpO1xuICB9XG5cbiAgcm93cyhzaGFyZWRSb3c/OiBTaGFyZWRSb3dPcHRpb25zKSB7XG4gICAgcmV0dXJuIHJvd3NJdGVyYXRvcih0aGlzLl9wYXJlbnREYXRhQ29udGFpbmVyLCB0aGlzLl9pbmRpY2VzLCBzaGFyZWRSb3cpO1xuICB9XG5cbiAgY29sdW1uKGNvbHVtbkluZGV4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gY29sdW1uSXRlcmF0b3IodGhpcy5fcGFyZW50RGF0YUNvbnRhaW5lciwgdGhpcy5faW5kaWNlcywgY29sdW1uSW5kZXgpO1xuICB9XG5cbiAgZ2V0UGxhaW5JbmRleCgpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGljZXMubWFwKChfLCBpKSA9PiBpKTtcbiAgfVxuXG4gIGZsYXR0ZW5EYXRhKCk6IGFueVtdW10ge1xuICAgIGNvbnN0IHRTaGFyZWRSb3cgPSBEYXRhUm93LmNyZWF0ZVNoYXJlZFJvdyh0cnVlKTtcblxuICAgIHJldHVybiB0aGlzLl9pbmRpY2VzLm1hcCgoXywgaSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucm93KGksIHRTaGFyZWRSb3cpLnZhbHVlcygpO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgbWFwPFQ+KFxuICAgIGZ1bmM6IChyb3c6IERhdGFSb3csIGluZGV4OiBudW1iZXIpID0+IFQsXG4gICAgc2hhcmVkUm93PzogU2hhcmVkUm93T3B0aW9ucyxcbiAgICBvcHRpb25zOiBSYW5nZU9wdGlvbnMgPSB7fVxuICApOiBUW10ge1xuICAgIGNvbnN0IHtzdGFydCA9IDAsIGVuZCA9IHRoaXMubnVtUm93cygpfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW5kUm93ID0gTWF0aC5taW4odGhpcy5udW1Sb3dzKCksIGVuZCk7XG5cbiAgICBjb25zdCB0U2hhcmVkUm93ID0gRGF0YVJvdy5jcmVhdGVTaGFyZWRSb3coc2hhcmVkUm93KTtcblxuICAgIGNvbnN0IG91dDogVFtdID0gW107XG4gICAgZm9yIChsZXQgcm93SW5kZXggPSBzdGFydDsgcm93SW5kZXggPCBlbmRSb3c7ICsrcm93SW5kZXgpIHtcbiAgICAgIGNvbnN0IHJvdyA9IHRoaXMucm93KHJvd0luZGV4LCB0U2hhcmVkUm93KTtcbiAgICAgIG91dC5wdXNoKGZ1bmMocm93LCByb3dJbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgbWFwSW5kZXg8VD4oXG4gICAgZnVuYzogKHtpbmRleDogbnVtYmVyfSwgZGM6IERhdGFDb250YWluZXJJbnRlcmZhY2UpID0+IFQsXG4gICAgb3B0aW9uczogUmFuZ2VPcHRpb25zID0ge31cbiAgKTogVFtdIHtcbiAgICBjb25zdCB7c3RhcnQgPSAwLCBlbmQgPSB0aGlzLm51bVJvd3MoKX0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVuZFJvdyA9IE1hdGgubWluKHRoaXMubnVtUm93cygpLCBlbmQpO1xuXG4gICAgY29uc3Qgb3V0OiBUW10gPSBbXTtcbiAgICBmb3IgKGxldCByb3dJbmRleCA9IHN0YXJ0OyByb3dJbmRleCA8IGVuZFJvdzsgKytyb3dJbmRleCkge1xuICAgICAgb3V0LnB1c2goZnVuYyh7aW5kZXg6IHRoaXMuX21hcHBlZFJvd0luZGV4KHJvd0luZGV4KX0sIHRoaXMuX3BhcmVudERhdGFDb250YWluZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGZpbmQoXG4gICAgZnVuYzogKHJvdzogRGF0YVJvdywgaW5kZXg6IG51bWJlcikgPT4gYm9vbGVhbixcbiAgICBzaGFyZWRSb3c/OiBTaGFyZWRSb3dPcHRpb25zXG4gICk6IERhdGFSb3cgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHRTaGFyZWRSb3cgPSBEYXRhUm93LmNyZWF0ZVNoYXJlZFJvdyhzaGFyZWRSb3cpO1xuXG4gICAgZm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHRoaXMubnVtUm93cygpOyArK3Jvd0luZGV4KSB7XG4gICAgICBjb25zdCByb3cgPSB0aGlzLnJvdyhyb3dJbmRleCwgdFNoYXJlZFJvdyk7XG4gICAgICBpZiAoZnVuYyhyb3csIHJvd0luZGV4KSkge1xuICAgICAgICByZXR1cm4gcm93O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmVkdWNlPFQ+KFxuICAgIGZ1bmM6IChhY2M6IFQsIHJvdzogRGF0YVJvdywgaW5kZXg6IG51bWJlcikgPT4gVCxcbiAgICBpbml0aWFsVmFsdWU6IFQsXG4gICAgc2hhcmVkUm93PzogU2hhcmVkUm93T3B0aW9uc1xuICApOiBUIHtcbiAgICBjb25zdCB0U2hhcmVkUm93ID0gRGF0YVJvdy5jcmVhdGVTaGFyZWRSb3coc2hhcmVkUm93KTtcblxuICAgIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCB0aGlzLl9pbmRpY2VzLmxlbmd0aDsgKytyb3dJbmRleCkge1xuICAgICAgY29uc3Qgcm93ID0gdGhpcy5yb3cocm93SW5kZXgsIHRTaGFyZWRSb3cpO1xuICAgICAgaW5pdGlhbFZhbHVlID0gZnVuYyhpbml0aWFsVmFsdWUsIHJvdywgcm93SW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdGlhbFZhbHVlO1xuICB9XG59XG4iXX0=