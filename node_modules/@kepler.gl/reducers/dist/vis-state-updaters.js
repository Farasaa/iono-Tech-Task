"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateStateWithLayerAndData = updateStateWithLayerAndData;
exports.updateStateOnLayerVisibilityChange = updateStateOnLayerVisibilityChange;
exports.applyLayerConfigUpdater = applyLayerConfigUpdater;
exports.layerConfigChangeUpdater = layerConfigChangeUpdater;
exports.layerSetIsValidUpdater = layerSetIsValidUpdater;
exports.layerTextLabelChangeUpdater = layerTextLabelChangeUpdater;
exports.layerDataIdChangeUpdater = layerDataIdChangeUpdater;
exports.setInitialLayerConfig = setInitialLayerConfig;
exports.layerTypeChangeUpdater = layerTypeChangeUpdater;
exports.layerVisualChannelChangeUpdater = layerVisualChannelChangeUpdater;
exports.layerVisConfigChangeUpdater = layerVisConfigChangeUpdater;
exports.setFilterAnimationTimeUpdater = setFilterAnimationTimeUpdater;
exports.setFilterAnimationWindowUpdater = setFilterAnimationWindowUpdater;
exports.setFilterUpdater = setFilterUpdater;
exports.removeLayerUpdater = removeLayerUpdater;
exports.removeDatasetUpdater = removeDatasetUpdater;
exports.interactionConfigChangeUpdater = interactionConfigChangeUpdater;
exports.applyMergersUpdater = applyMergersUpdater;
exports.renameDatasetUpdater = renameDatasetUpdater;
exports.updateDatasetPropsUpdater = updateDatasetPropsUpdater;
exports.closeSpecificMapAtIndex = closeSpecificMapAtIndex;
exports.loadFileStepSuccessUpdater = loadFileStepSuccessUpdater;
exports.loadNextFileUpdater = loadNextFileUpdater;
exports.makeLoadFileTask = makeLoadFileTask;
exports.processFileContentUpdater = processFileContentUpdater;
exports.parseProgress = parseProgress;
exports.addDefaultLayers = addDefaultLayers;
exports.addDefaultTooltips = addDefaultTooltips;
exports.initialFileLoadingProgress = initialFileLoadingProgress;
exports.updateFileLoadingProgressUpdater = updateFileLoadingProgressUpdater;
exports.updateAllLayerDomainData = updateAllLayerDomainData;
exports.updateAnimationDomain = updateAnimationDomain;
exports.setFeaturesUpdater = setFeaturesUpdater;
exports.deleteFeatureUpdater = deleteFeatureUpdater;
exports.setPolygonFilterLayerUpdater = setPolygonFilterLayerUpdater;
exports.sortTableColumnUpdater = sortTableColumnUpdater;
exports.pinTableColumnUpdater = pinTableColumnUpdater;
exports.copyTableColumnUpdater = copyTableColumnUpdater;
exports.setColumnDisplayFormatUpdater = setColumnDisplayFormatUpdater;
exports.toggleEditorVisibilityUpdater = toggleEditorVisibilityUpdater;
exports.setFilterAnimationTimeConfigUpdater = setFilterAnimationTimeConfigUpdater;
exports.setLayerAnimationTimeConfigUpdater = setLayerAnimationTimeConfigUpdater;
exports.prepareStateForDatasetReplace = prepareStateForDatasetReplace;
exports.replaceDatasetDepsInState = replaceDatasetDepsInState;
exports.setSelectedFeatureUpdater = exports.setEditorModeUpdater = exports.setMapInfoUpdater = exports.applyCPUFilterUpdater = exports.loadFilesErrUpdater = exports.nextFileBatchUpdater = exports.loadFilesUpdater = exports.updateVisDataUpdater = exports.toggleLayerForMapUpdater = exports.toggleSplitMapUpdater = exports.mouseMoveUpdater = exports.mapClickUpdater = exports.layerClickUpdater = exports.layerHoverUpdater = exports.receiveMapConfigUpdater = exports.resetMapConfigUpdater = exports.updateTableColorUpdater = exports.showDatasetTableUpdater = exports.updateOverlayBlendingUpdater = exports.updateLayerBlendingUpdater = exports.updateEffectUpdater = exports.reorderEffectUpdater = exports.removeEffectUpdater = exports.addEffectUpdater = exports.duplicateLayerUpdater = exports.reorderLayerUpdater = exports.addLayerUpdater = exports.removeFilterUpdater = exports.toggleFilterFeatureUpdater = exports.setFilterViewUpdater = exports.updateLayerAnimationSpeedUpdater = exports.setLayerAnimationTimeUpdater = exports.updateFilterAnimationSpeedUpdater = exports.toggleLayerAnimationControlUpdater = exports.toggleLayerAnimationUpdater = exports.toggleFilterAnimationUpdater = exports.layerColorUIChangeUpdater = exports.addFilterUpdater = exports.setFilterPlotUpdater = exports.INITIAL_VIS_STATE = exports.DEFAULT_EDITOR = exports.DEFAULT_ANIMATION_CONFIG = exports.defaultInteractionConfig = void 0;

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _bbox = _interopRequireDefault(require("@turf/bbox"));

var _window = require("global/window");

var _tasks = require("react-palm/tasks");

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _lodash2 = _interopRequireDefault(require("lodash.uniq"));

var _lodash3 = _interopRequireDefault(require("lodash.get"));

var _lodash4 = _interopRequireDefault(require("lodash.xor"));

var _lodash5 = _interopRequireDefault(require("lodash.pick"));

var _lodash6 = _interopRequireDefault(require("lodash.isequal"));

var _copyToClipboard = _interopRequireDefault(require("copy-to-clipboard"));

var _deepmerge = _interopRequireDefault(require("deepmerge"));

var _tasks2 = require("@kepler.gl/tasks");

var _actions = require("@kepler.gl/actions");

var _utils = require("@kepler.gl/utils");

var _visStateMerger = require("./vis-state-merger");

var _mergerHandler = require("./merger-handler");

var _layers = require("@kepler.gl/layers");

var _constants = require("@kepler.gl/constants");

var _composerHelpers = require("./composer-helpers");

var _schemas = _interopRequireDefault(require("@kepler.gl/schemas"));

var _layerUtils = require("./layer-utils");

var _table = require("@kepler.gl/table");

var _interactionUtils = require("./interaction-utils");

var _effects = require("@kepler.gl/effects");

function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// react-palm
// disable capture exception for react-palm call to withTask
(0, _tasks.disableStackCapturing)();
/**
 * Updaters for `visState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 *
 * @public
 * @example
 *
 * import keplerGlReducer, {visStateUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             visState: visStateUpdaters.enlargeFilterUpdater(
 *               state.keplerGl.foo.visState,
 *               {idx: 0}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */
// @ts-ignore

var visStateUpdaters = null;
/* eslint-enable no-unused-vars */

var defaultInteractionConfig = {
  tooltip: {
    id: 'tooltip',
    label: 'interactions.tooltip',
    enabled: true,
    config: {
      fieldsToShow: {},
      compareMode: false,
      compareType: _constants.COMPARE_TYPES.ABSOLUTE
    }
  },
  geocoder: {
    id: 'geocoder',
    label: 'interactions.geocoder',
    enabled: false,
    position: null
  },
  brush: {
    id: 'brush',
    label: 'interactions.brush',
    enabled: false,
    config: {
      // size is in km
      size: 0.5
    }
  },
  coordinate: {
    id: 'coordinate',
    label: 'interactions.coordinate',
    enabled: false,
    position: null
  }
};
exports.defaultInteractionConfig = defaultInteractionConfig;
var DEFAULT_ANIMATION_CONFIG = {
  domain: null,
  currentTime: null,
  speed: 1,
  isAnimating: false,
  timeFormat: null,
  timezone: null,
  defaultTimeFormat: null,
  hideControl: false,
  duration: null
};
exports.DEFAULT_ANIMATION_CONFIG = DEFAULT_ANIMATION_CONFIG;
var DEFAULT_EDITOR = {
  mode: _constants.EDITOR_MODES.DRAW_POLYGON,
  features: [],
  selectedFeature: null,
  visible: true
};
/**
 * Default initial `visState`
 * @memberof visStateUpdaters
 * @constant
 * @public
 */

exports.DEFAULT_EDITOR = DEFAULT_EDITOR;
var INITIAL_VIS_STATE = {
  // map info
  mapInfo: {
    title: '',
    description: ''
  },
  // layers
  layers: [],
  layerData: [],
  layerToBeMerged: [],
  layerOrder: [],
  // filters
  filters: [],
  filterToBeMerged: [],
  // a collection of multiple dataset
  datasets: {},
  editingDataset: undefined,
  // effects
  effects: [],
  effectOrder: [],
  interactionConfig: defaultInteractionConfig,
  interactionToBeMerged: {},
  layerBlending: 'normal',
  overlayBlending: 'normal',
  hoverInfo: undefined,
  clicked: undefined,
  mousePos: {},
  maxDefaultTooltips: _constants.MAX_DEFAULT_TOOLTIPS,
  // this is used when user split maps
  splitMaps: [// this will contain a list of objects to
    // describe the state of layer availability and visibility for each map
    // [
    //   {
    //      layers: {layer_id: true | false}
    //   }
    // ]
  ],
  splitMapsToBeMerged: [],
  isMergingDatasets: {},
  // defaults layer classes
  layerClasses: _layers.LayerClasses,
  // default animation
  // time in unix timestamp (milliseconds) (the number of seconds since the Unix Epoch)
  animationConfig: DEFAULT_ANIMATION_CONFIG,
  editor: DEFAULT_EDITOR,
  fileLoading: false,
  fileLoadingProgress: {},
  loaders: [],
  loadOptions: {},
  // visStateMergers
  mergers: _visStateMerger.VIS_STATE_MERGERS,
  // kepler schemas
  schema: _schemas["default"]
};
exports.INITIAL_VIS_STATE = INITIAL_VIS_STATE;

/**
 * Update state with updated layer and layerData
 *
 */
function updateStateWithLayerAndData(state, _ref) {
  var layerData = _ref.layerData,
      layer = _ref.layer,
      idx = _ref.idx;
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: state.layers.map(function (lyr, i) {
      return i === idx ? layer : lyr;
    }),
    layerData: layerData ? state.layerData.map(function (d, i) {
      return i === idx ? layerData : d;
    }) : state.layerData
  });
}

function updateStateOnLayerVisibilityChange(state, layer) {
  var newState = state;

  if (state.splitMaps.length) {
    newState = _objectSpread(_objectSpread({}, state), {}, {
      splitMaps: layer.config.isVisible ? (0, _utils.addNewLayersToSplitMap)(state.splitMaps, layer) : (0, _utils.removeLayerFromSplitMaps)(state.splitMaps, layer)
    });
  }

  if (layer.config.animation.enabled) {
    newState = updateAnimationDomain(state);
  }

  return newState;
}
/**
 * Compares two objects (or arrays) and returns a new object with only the
 * properties that have changed between the two objects.
 */


function pickChangedProps(prev, next) {
  var changedProps = {};

  var pickPropsOf = function pickPropsOf(obj) {
    Object.keys(obj).forEach(function (key) {
      if (!changedProps.hasOwnProperty(key) && !(0, _lodash6["default"])(prev[key], next[key])) {
        changedProps[key] = next[key];
      }
    });
  };

  pickPropsOf(prev);
  pickPropsOf(next);
  return changedProps;
}

var VISUAL_CHANNEL_PROP_TYPES = ['field', 'scale', 'domain', 'aggregation'];
/**
 * Apply layer config
 * @memberof visStateUpdaters
 * @returns nextState
 */
// eslint-disable-next-line complexity, max-statements

function applyLayerConfigUpdater(state, action) {
  var _serializeLayer;

  var oldLayerId = action.oldLayerId,
      newLayerConfig = action.newLayerConfig,
      layerIndex = action.layerIndex;
  var newParsedLayer = // will move visualChannels to the config prop
  (0, _visStateMerger.parseLayerConfig)(state.schema, newLayerConfig);
  var oldLayer = state.layers.find(function (l) {
    return l.id === oldLayerId;
  });

  if (!oldLayer || !newParsedLayer) {
    return state;
  }

  if (layerIndex !== null && layerIndex !== undefined && state.layers[layerIndex] !== oldLayer) {
    // layerIndex is provided, but it doesn't match the oldLayer
    return state;
  }

  var dataset = state.datasets[newParsedLayer.config.dataId];

  if (!dataset) {
    return state;
  } // Make sure the layer is valid and convert it to Layer


  var newLayer = (0, _visStateMerger.validateLayerWithData)(dataset, newParsedLayer, state.layerClasses);

  if (!newLayer) {
    return state;
  }

  var nextState = state;

  if (newLayer.type && newLayer.type !== oldLayer.type) {
    var oldLayerIndex = state.layers.findIndex(function (l) {
      return l.id === oldLayerId;
    });

    if (oldLayerIndex >= 0) {
      nextState = layerTypeChangeUpdater(nextState, (0, _actions.layerTypeChange)(oldLayer, newLayer.type)); // layerTypeChangeUpdater changes the id of the layer, so we need to obtain the new id
      // but first make sure that the layer was not removed

      if (nextState.layers.length === state.layers.length) {
        var newLayerId = nextState.layers[oldLayerIndex].id;
        nextState = applyLayerConfigUpdater(nextState, (0, _actions.applyLayerConfig)(newLayerId, _objectSpread(_objectSpread({}, newLayerConfig), {}, {
          id: newLayerId
        })));
      }
    }

    return nextState;
  } // serializeLayer() might return null if the old layer is not valid,
  // we should still apply the changes in that case


  var serializedOldLayer = (_serializeLayer = (0, _visStateMerger.serializeLayer)(oldLayer, state.schema)) !== null && _serializeLayer !== void 0 ? _serializeLayer : {
    config: {}
  };
  var serializedNewLayer = (0, _visStateMerger.serializeLayer)(newLayer, state.schema);

  if (!serializedNewLayer) {
    return state;
  }

  if (!(0, _lodash6["default"])(serializedOldLayer, serializedNewLayer)) {
    var changed = pickChangedProps(serializedOldLayer.config, serializedNewLayer.config);

    if ('visConfig' in changed) {
      if (changed.visConfig) {
        nextState = layerVisConfigChangeUpdater(nextState, (0, _actions.layerVisConfigChange)(oldLayer, changed.visConfig));
      }

      delete changed.visConfig;
    }

    Object.keys(oldLayer.visualChannels).forEach(function (channelName) {
      var channel = oldLayer.visualChannels[channelName];
      var channelPropNames = VISUAL_CHANNEL_PROP_TYPES.map(function (prop) {
        return channel[prop];
      });

      if (channelPropNames.some(function (prop) {
        return prop in changed;
      })) {
        nextState = layerVisualChannelChangeUpdater(nextState, (0, _actions.layerVisualChannelConfigChange)(oldLayer, (0, _lodash5["default"])(newLayer.config, channelPropNames), channelName));

        var _iterator = _createForOfIteratorHelper(channelPropNames),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var prop = _step.value;
            delete changed[prop];
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    });

    if (Object.keys(changed).length > 0) {
      nextState = layerConfigChangeUpdater(nextState, (0, _actions.layerConfigChange)(oldLayer, (0, _lodash5["default"])(newLayer.config, Object.keys(changed))));
    }
  }

  return nextState;
}
/**
 * Update layer base config: dataId, label, column, isVisible
 * @memberof visStateUpdaters
 * @returns nextState
 */
// eslint-disable-next-line complexity


function layerConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newConfig);

  if (typeof action.newConfig.dataId === 'string' && action.newConfig.dataId !== oldLayer.config.dataId) {
    var _action$newConfig = action.newConfig,
        dataId = _action$newConfig.dataId,
        restConfig = (0, _objectWithoutProperties2["default"])(_action$newConfig, ["dataId"]);
    var stateWithDataId = layerDataIdChangeUpdater(state, {
      oldLayer: oldLayer,
      newConfig: {
        dataId: dataId
      }
    });
    var nextLayer = stateWithDataId.layers.find(function (l) {
      return l.id === oldLayer.id;
    });
    return nextLayer && Object.keys(restConfig).length ? layerConfigChangeUpdater(stateWithDataId, {
      oldLayer: nextLayer,
      newConfig: restConfig
    }) : stateWithDataId;
  }

  var newLayer = oldLayer.updateLayerConfig(action.newConfig);
  var layerData;

  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];
    var updateLayerDataResult = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData);
    newLayer = updateLayerDataResult.layer;
    layerData = updateLayerDataResult.layerData;
  }

  var newState = state;

  if ('isVisible' in action.newConfig) {
    newState = updateStateOnLayerVisibilityChange(state, newLayer);
  }

  return updateStateWithLayerAndData(newState, {
    layer: newLayer,
    layerData: layerData,
    idx: idx
  });
}
/**
 * Updates isValid flag of a layer.
 * Updates isVisible based on the value of isValid.
 * Triggers update of data for the layer in order to get errors again during next update iteration.
 * @memberof visStateUpdaters
 * @returns nextState
 */


function layerSetIsValidUpdater(state, action) {
  var oldLayer = action.oldLayer,
      isValid = action.isValid;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var layerToUpdate = state.layers[idx];

  if (layerToUpdate) {
    var newLayer;
    var newData = null;

    if (isValid) {
      // Trigger data update in order to show errors again if present.
      var _calculateLayerData = (0, _layerUtils.calculateLayerData)(layerToUpdate, state, undefined),
          layer = _calculateLayerData.layer,
          layerData = _calculateLayerData.layerData;

      newLayer = layer;
      newData = layerData;
    } else {
      newLayer = layerToUpdate.updateLayerConfig({
        isVisible: false
      });
      newLayer.isValid = false;
    }

    return updateStateWithLayerAndData(state, {
      idx: idx,
      layer: newLayer,
      layerData: newData
    });
  }

  return state;
}

function addOrRemoveTextLabels(newFields, textLabel) {
  var defaultTextLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _constants.DEFAULT_TEXT_LABEL;
  var newTextLabel = textLabel.slice();
  var currentFields = textLabel.map(function (tl) {
    return tl.field && tl.field.name;
  }).filter(function (d) {
    return d;
  });
  var addFields = newFields.filter(function (f) {
    return !currentFields.includes(f.name);
  });
  var deleteFields = currentFields.filter(function (f) {
    return !newFields.find(function (fd) {
      return fd.name === f;
    });
  }); // delete

  newTextLabel = newTextLabel.filter(function (tl) {
    return tl.field && !deleteFields.includes(tl.field.name);
  });
  newTextLabel = !newTextLabel.length ? [defaultTextLabel] : newTextLabel; // add

  newTextLabel = [].concat((0, _toConsumableArray2["default"])(newTextLabel.filter(function (tl) {
    return tl.field;
  })), (0, _toConsumableArray2["default"])(addFields.map(function (af) {
    return _objectSpread(_objectSpread({}, defaultTextLabel), {}, {
      field: af
    });
  })));
  return newTextLabel;
}

function updateTextLabelPropAndValue(idx, prop, value, textLabel) {
  if (!textLabel[idx].hasOwnProperty(prop)) {
    return textLabel;
  }

  var newTextLabel = textLabel.slice();

  if (prop === 'field' && value === null && textLabel.length > 1) {
    // remove label when field value is set to null
    newTextLabel.splice(idx, 1);
  } else if (prop) {
    newTextLabel = textLabel.map(function (tl, i) {
      return i === idx ? _objectSpread(_objectSpread({}, tl), {}, (0, _defineProperty2["default"])({}, prop, value)) : tl;
    });
  }

  return newTextLabel;
}
/**
 * Update layer base config: dataId, label, column, isVisible
 * @memberof visStateUpdaters
 * @returns nextState
 */


function layerTextLabelChangeUpdater(state, action) {
  var _oldLayer$getDefaultL, _oldLayer$getDefaultL2, _oldLayer$getDefaultL3;

  var oldLayer = action.oldLayer,
      idx = action.idx,
      prop = action.prop,
      value = action.value;
  var textLabel = oldLayer.config.textLabel; // when adding a new empty text label,
  // rely on the layer's default config, or use the constant DEFAULT_TEXT_LABEL

  var defaultTextLabel = (_oldLayer$getDefaultL = (_oldLayer$getDefaultL2 = oldLayer.getDefaultLayerConfig({
    dataId: ''
  })) === null || _oldLayer$getDefaultL2 === void 0 ? void 0 : (_oldLayer$getDefaultL3 = _oldLayer$getDefaultL2.textLabel) === null || _oldLayer$getDefaultL3 === void 0 ? void 0 : _oldLayer$getDefaultL3[0]) !== null && _oldLayer$getDefaultL !== void 0 ? _oldLayer$getDefaultL : _constants.DEFAULT_TEXT_LABEL;
  var newTextLabel = textLabel.slice();

  if (!textLabel[idx] && idx === textLabel.length) {
    // if idx is set to length, add empty text label
    newTextLabel = [].concat((0, _toConsumableArray2["default"])(textLabel), [defaultTextLabel]);
  }

  if (idx === 'all' && prop === 'fields') {
    newTextLabel = addOrRemoveTextLabels(value, textLabel, defaultTextLabel);
  } else {
    newTextLabel = updateTextLabelPropAndValue(idx, prop, value, newTextLabel);
  } // update text label prop and value


  return layerConfigChangeUpdater(state, {
    oldLayer: oldLayer,
    newConfig: {
      textLabel: newTextLabel
    }
  });
}

function validateExistingLayerWithData(dataset, layerClasses, layer, schema) {
  var loadedLayer = (0, _visStateMerger.serializeLayer)(layer, schema);
  return loadedLayer ? (0, _visStateMerger.validateLayerWithData)(dataset, loadedLayer, layerClasses, {
    allowEmptyColumn: true
  }) : null;
}
/**
 * Update layer config dataId
 * @memberof visStateUpdaters
 * @returns nextState
 */


function layerDataIdChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newConfig = action.newConfig;
  var dataId = newConfig.dataId;

  if (!oldLayer || !state.datasets[dataId]) {
    return state;
  }

  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig({
    dataId: dataId
  }); // this may happen when a layer is new (type: null and no columns) but it's not ready to be saved

  if (newLayer.isValidToSave()) {
    var validated = validateExistingLayerWithData(state.datasets[dataId], state.layerClasses, newLayer, state.schema); // if cant validate it with data create a new one

    if (!validated) {
      // @ts-expect-error TODO: checking oldLayer.type !== null
      newLayer = new state.layerClasses[oldLayer.type]({
        dataId: dataId,
        id: oldLayer.id
      });
    } else {
      newLayer = validated;
    }
  }

  newLayer = newLayer.updateLayerConfig({
    isVisible: oldLayer.config.isVisible,
    isConfigActive: true
  });
  newLayer.updateLayerDomain(state.datasets);

  var _calculateLayerData2 = (0, _layerUtils.calculateLayerData)(newLayer, state, undefined),
      layerData = _calculateLayerData2.layerData,
      layer = _calculateLayerData2.layer;

  return updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}

function setInitialLayerConfig(layer, datasets, layerClasses) {
  var newLayer = layer;

  if (!Object.keys(datasets).length) {
    // no data is loaded
    return layer;
  }

  if (!layer.config.dataId) {
    // set layer dataId
    newLayer = layer.updateLayerConfig({
      dataId: Object.keys(datasets)[0]
    });
  }

  var dataset = datasets[newLayer.config.dataId];

  if (!dataset) {
    return layer;
  } // find defaut layer props


  var result = typeof layerClasses[newLayer.type].findDefaultLayerProps === 'function' ? layerClasses[newLayer.type].findDefaultLayerProps(dataset, []) : {
    props: []
  }; // an array of possible props, use 1st one

  var props = Array.isArray(result) ? result : result.props || [];

  if (props.length) {
    newLayer = new layerClasses[layer.type](_objectSpread(_objectSpread({}, props[0]), {}, {
      label: newLayer.config.label,
      dataId: newLayer.config.dataId,
      isVisible: true,
      isConfigActive: newLayer.config.isConfigActive
    }));
    return typeof newLayer.setInitialLayerConfig === 'function' ? newLayer.setInitialLayerConfig(dataset) : newLayer;
  }

  return newLayer;
}
/**
 * Update layer type. Previews layer config will be copied if applicable.
 * @memberof visStateUpdaters
 * @public
 */


function layerTypeChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newType = action.newType;

  if (!oldLayer) {
    return state;
  }

  var oldId = oldLayer.id;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldId;
  });

  if (!state.layerClasses[newType]) {
    _window.console.error("".concat(newType, " is not a valid layer type"));

    return state;
  }

  var newLayer = new state.layerClasses[newType]({
    // keep old layer lable and isConfigActive
    label: oldLayer.config.label,
    isConfigActive: oldLayer.config.isConfigActive,
    dataId: oldLayer.config.dataId
  });

  if (!oldLayer.type) {
    // if setting layer type on an empty layer
    newLayer = setInitialLayerConfig(newLayer, state.datasets, state.layerClasses);
  } else {
    // get a mint layer, with new id and type
    // because deck.gl uses id to match between new and old layer.
    // If type has changed but id is the same, it will break
    newLayer.assignConfigToLayer(oldLayer.config, oldLayer.visConfigSettings);
    newLayer.updateLayerDomain(state.datasets);
  }

  var clicked = state.clicked,
      hoverInfo = state.hoverInfo;

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    clicked: oldLayer.isLayerHovered(clicked) ? undefined : clicked,
    hoverInfo: oldLayer.isLayerHovered(hoverInfo) ? undefined : hoverInfo
  });

  var _calculateLayerData3 = (0, _layerUtils.calculateLayerData)(newLayer, newState),
      layerData = _calculateLayerData3.layerData,
      layer = _calculateLayerData3.layer;

  newState = updateStateWithLayerAndData(newState, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });

  if (layer.config.animation.enabled || oldLayer.config.animation.enabled) {
    newState = updateAnimationDomain(newState);
  } // update splitMap layer id


  if (state.splitMaps.length) {
    newState = _objectSpread(_objectSpread({}, newState), {}, {
      splitMaps: newState.splitMaps.map(function (settings) {
        var _settings$layers = settings.layers,
            oldLayerMap = _settings$layers[oldId],
            otherLayers = (0, _objectWithoutProperties2["default"])(_settings$layers, [oldId].map(_toPropertyKey));
        return oldId in settings.layers ? _objectSpread(_objectSpread({}, settings), {}, {
          layers: _objectSpread(_objectSpread({}, otherLayers), {}, (0, _defineProperty2["default"])({}, layer.id, oldLayerMap))
        }) : settings;
      })
    });
  } // update layerOrder with new id


  newState = _objectSpread(_objectSpread({}, newState), {}, {
    layerOrder: newState.layerOrder.map(function (layerId) {
      return layerId === oldLayer.id ? newLayer.id : layerId;
    })
  });
  return newState;
}
/**
 * Update layer visual channel
 * @memberof visStateUpdaters
 * @returns {Object} nextState
 * @public
 */


function layerVisualChannelChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newConfig = action.newConfig,
      channel = action.channel;

  if (!oldLayer.config.dataId) {
    return state;
  }

  var dataset = state.datasets[oldLayer.config.dataId];
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig(newConfig);
  newLayer.updateLayerVisualChannel(dataset, channel);
  var oldLayerData = state.layerData[idx];

  var _calculateLayerData4 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData),
      layerData = _calculateLayerData4.layerData,
      layer = _calculateLayerData4.layer;

  return updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}
/**
 * Update layer `visConfig`
 * @memberof visStateUpdaters
 * @public
 */


function layerVisConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newVisConfig);

  var newVisConfig = _objectSpread(_objectSpread({}, oldLayer.config.visConfig), action.newVisConfig);

  var newLayer = oldLayer.updateLayerConfig({
    visConfig: newVisConfig
  });

  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];

    var _calculateLayerData5 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData),
        layerData = _calculateLayerData5.layerData,
        layer = _calculateLayerData5.layer;

    return updateStateWithLayerAndData(state, {
      layerData: layerData,
      layer: layer,
      idx: idx
    });
  }

  return updateStateWithLayerAndData(state, {
    layer: newLayer,
    idx: idx
  });
}
/**
 * Update filter property
 * @memberof visStateUpdaters
 * @public
 */


function setFilterAnimationTimeUpdater(state, action) {
  return setFilterUpdater(state, action);
}
/**
 * Update filter animation window
 * @memberof visStateUpdaters
 * @public
 */


function setFilterAnimationWindowUpdater(state, _ref2) {
  var id = _ref2.id,
      animationWindow = _ref2.animationWindow;
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f) {
      return f.id === id ? _objectSpread(_objectSpread({}, f), {}, {
        animationWindow: animationWindow
      }) : f;
    })
  });
}
/**
 * Update filter property
 * @memberof visStateUpdaters
 * @public
 */


function setFilterUpdater(state, action) {
  var _newFilter$layerId;

  var idx = action.idx,
      prop = action.prop,
      value = action.value,
      _action$valueIndex = action.valueIndex,
      valueIndex = _action$valueIndex === void 0 ? 0 : _action$valueIndex;
  var oldFilter = state.filters[idx];

  if (!oldFilter) {
    _window.console.error("filters.".concat(idx, " is undefined"));

    return state;
  }

  var newFilter = (0, _utils.set)([prop], value, oldFilter);
  var newState = state;
  var _newFilter = newFilter,
      dataId = _newFilter.dataId; // Ensuring backward compatibility

  var datasetIds = (0, _utils.toArray)(dataId);

  switch (prop) {
    // TODO: Next PR for UI if we update dataId, we need to consider two cases:
    // 1. dataId is empty: create a default filter
    // 2. Add a new dataset id
    case _utils.FILTER_UPDATER_PROPS.dataId:
      // if trying to update filter dataId. create an empty new filter
      newFilter = (0, _utils.updateFilterDataId)(dataId);
      break;

    case _utils.FILTER_UPDATER_PROPS.name:
      // we are supporting the current functionality
      // TODO: Next PR for UI filter name will only update filter name but it won't have side effects
      // we are gonna use pair of datasets and fieldIdx to update the filter
      var datasetId = newFilter.dataId[valueIndex];

      var _applyFilterFieldName = (0, _utils.applyFilterFieldName)(newFilter, state.datasets[datasetId], value, valueIndex, {
        mergeDomain: false
      }),
          updatedFilter = _applyFilterFieldName.filter,
          newDataset = _applyFilterFieldName.dataset;

      if (!updatedFilter) {
        return state;
      }

      newFilter = updatedFilter;

      if (newFilter.gpu) {
        newFilter = (0, _table.setFilterGpuMode)(newFilter, state.filters);
        newFilter = (0, _table.assignGpuChannel)(newFilter, state.filters);
      }

      newState = (0, _utils.set)(['datasets', datasetId], newDataset, state); // only filter the current dataset

      break;

    case _utils.FILTER_UPDATER_PROPS.layerId:
      // We need to update only datasetId/s if we have added/removed layers
      // - check for layerId changes (XOR works because of string values)
      // if no differences between layerIds, don't do any filtering
      // @ts-ignore
      var layerIdDifference = (0, _lodash4["default"])(newFilter.layerId, oldFilter.layerId);
      var layerDataIds = (0, _lodash2["default"])(layerIdDifference.map(function (lid) {
        return (0, _lodash3["default"])(state.layers.find(function (l) {
          return l.id === lid;
        }), ['config', 'dataId']);
      }).filter(function (d) {
        return d;
      })); // only filter datasetsIds

      datasetIds = layerDataIds; // Update newFilter dataIds

      var newDataIds = (0, _lodash2["default"])((_newFilter$layerId = newFilter.layerId) === null || _newFilter$layerId === void 0 ? void 0 : _newFilter$layerId.map(function (lid) {
        return (0, _lodash3["default"])(state.layers.find(function (l) {
          return l.id === lid;
        }), ['config', 'dataId']);
      }).filter(function (d) {
        return d;
      }));
      newFilter = _objectSpread(_objectSpread({}, newFilter), {}, {
        dataId: newDataIds
      });
      break;

    default:
      break;
  }

  var enlargedFilter = state.filters.find(function (f) {
    return f.view === _constants.FILTER_VIEW_TYPES.enlarged;
  });

  if (enlargedFilter && enlargedFilter.id !== newFilter.id) {
    // there should be only one enlarged filter
    newFilter.view = _constants.FILTER_VIEW_TYPES.side;
  } // save new filters to newState


  newState = (0, _utils.set)(['filters', idx], newFilter, newState); // if we are currently setting a prop that only requires to filter the current
  // dataset we will pass only the current dataset to applyFiltersToDatasets and
  // updateAllLayerDomainData otherwise we pass the all list of datasets as defined in dataId

  var datasetIdsToFilter = _utils.LIMITED_FILTER_EFFECT_PROPS[prop] ? [datasetIds[valueIndex]] : datasetIds; // filter data

  var filteredDatasets = (0, _utils.applyFiltersToDatasets)(datasetIdsToFilter, newState.datasets, newState.filters, newState.layers);
  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState); // dataId is an array
  // pass only the dataset we need to update

  newState = updateAllLayerDomainData(newState, datasetIdsToFilter, newFilter);
  return newState;
}
/**
 * Set the property of a filter plot
 * @memberof visStateUpdaters
 * @public
 */


var setFilterPlotUpdater = function setFilterPlotUpdater(state, _ref3) {
  var idx = _ref3.idx,
      newProp = _ref3.newProp,
      _ref3$valueIndex = _ref3.valueIndex,
      valueIndex = _ref3$valueIndex === void 0 ? 0 : _ref3$valueIndex;

  var newFilter = _objectSpread(_objectSpread({}, state.filters[idx]), newProp);

  var prop = Object.keys(newProp)[0];

  if (prop === 'yAxis') {
    var plotType = (0, _utils.getDefaultFilterPlotType)(newFilter); // TODO: plot is not supported in multi dataset filter for now

    if (plotType) {
      newFilter = _objectSpread(_objectSpread(_objectSpread({}, newFilter), (0, _utils.getFilterPlot)(_objectSpread(_objectSpread({}, newFilter), {}, {
        plotType: plotType
      }), state.datasets[newFilter.dataId[valueIndex]])), {}, {
        plotType: plotType
      });
    }
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? newFilter : f;
    })
  });
};
/**
 * Add a new filter
 * @memberof visStateUpdaters
 * @public
 */


exports.setFilterPlotUpdater = setFilterPlotUpdater;

var addFilterUpdater = function addFilterUpdater(state, action) {
  return !action.dataId ? state : _objectSpread(_objectSpread({}, state), {}, {
    filters: [].concat((0, _toConsumableArray2["default"])(state.filters), [(0, _utils.getDefaultFilter)({
      dataId: action.dataId,
      id: action.id
    })])
  });
};
/**
 * Set layer color palette ui state
 * @memberof visStateUpdaters
 */


exports.addFilterUpdater = addFilterUpdater;

var layerColorUIChangeUpdater = function layerColorUIChangeUpdater(state, _ref4) {
  var oldLayer = _ref4.oldLayer,
      prop = _ref4.prop,
      newConfig = _ref4.newConfig;
  var oldVixConfig = oldLayer.config.visConfig[prop];
  var newLayer = oldLayer.updateLayerColorUI(prop, newConfig);
  var newVisConfig = newLayer.config.visConfig[prop];

  if (oldVixConfig !== newVisConfig) {
    return layerVisConfigChangeUpdater(state, {
      oldLayer: oldLayer,
      newVisConfig: (0, _defineProperty2["default"])({}, prop, newVisConfig)
    });
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    layers: state.layers.map(function (l) {
      return l.id === oldLayer.id ? newLayer : l;
    })
  });
};
/**
 * Start and end filter animation
 * @memberof visStateUpdaters
 * @public
 */


exports.layerColorUIChangeUpdater = layerColorUIChangeUpdater;

var toggleFilterAnimationUpdater = function toggleFilterAnimationUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {
        isAnimating: !f.isAnimating
      }) : f;
    })
  });
};
/**
 * @memberof visStateUpdaters
 * @public
 */


exports.toggleFilterAnimationUpdater = toggleFilterAnimationUpdater;

var toggleLayerAnimationUpdater = function toggleLayerAnimationUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      isAnimating: !state.animationConfig.isAnimating
    })
  });
};
/**
 * Hide and show layer animation control
 * @memberof visStateUpdaters
 * @public
 */


exports.toggleLayerAnimationUpdater = toggleLayerAnimationUpdater;

var toggleLayerAnimationControlUpdater = function toggleLayerAnimationControlUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      hideControl: !state.animationConfig.hideControl
    })
  });
};
/**
 * Change filter animation speed
 * @memberof visStateUpdaters
 * @public
 */


exports.toggleLayerAnimationControlUpdater = toggleLayerAnimationControlUpdater;

var updateFilterAnimationSpeedUpdater = function updateFilterAnimationSpeedUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {
        speed: action.speed
      }) : f;
    })
  });
};
/**
 * Reset animation config current time to a specified value
 * @memberof visStateUpdaters
 * @public
 *
 */


exports.updateFilterAnimationSpeedUpdater = updateFilterAnimationSpeedUpdater;

var setLayerAnimationTimeUpdater = function setLayerAnimationTimeUpdater(state, _ref5) {
  var value = _ref5.value;
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      currentTime: value
    })
  });
};
/**
 * Update animation speed with the vertical speed slider
 * @memberof visStateUpdaters
 * @public
 *
 */


exports.setLayerAnimationTimeUpdater = setLayerAnimationTimeUpdater;

var updateLayerAnimationSpeedUpdater = function updateLayerAnimationSpeedUpdater(state, _ref6) {
  var speed = _ref6.speed;
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      speed: speed
    })
  });
};
/**
 * Show larger time filter at bottom for time playback (apply to time filter only)
 * @memberof visStateUpdaters
 * @public
 */


exports.updateLayerAnimationSpeedUpdater = updateLayerAnimationSpeedUpdater;

var setFilterViewUpdater = function setFilterViewUpdater(state, action) {
  var view = action.view,
      idx = action.idx;
  var shouldResetOtherFiltersView = view === _constants.FILTER_VIEW_TYPES.enlarged;
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? _objectSpread(_objectSpread({}, f), {}, {
        view: view
      }) : shouldResetOtherFiltersView ? _objectSpread(_objectSpread({}, f), {}, {
        view: _constants.FILTER_VIEW_TYPES.side
      }) : f;
    })
  });
};
/**
 * Toggles filter feature visibility
 * @memberof visStateUpdaters
 */


exports.setFilterViewUpdater = setFilterViewUpdater;

var toggleFilterFeatureUpdater = function toggleFilterFeatureUpdater(state, action) {
  var filter = state.filters[action.idx];
  var isVisible = (0, _lodash3["default"])(filter, ['value', 'properties', 'isVisible']);
  var newState = setFilterUpdater(state, {
    idx: action.idx,
    prop: 'enabled',
    value: !isVisible
  });
  newState = setFilterUpdater(newState, {
    idx: action.idx,
    prop: 'value',
    value: (0, _utils.featureToFilterValue)(filter.value, filter.id, {
      isVisible: !isVisible
    })
  });
  return newState;
};
/**
 * Remove a filter
 * @memberof visStateUpdaters
 * @public
 */


exports.toggleFilterFeatureUpdater = toggleFilterFeatureUpdater;

var removeFilterUpdater = function removeFilterUpdater(state, action) {
  var idx = action.idx;
  var _state$filters$idx = state.filters[idx],
      dataId = _state$filters$idx.dataId,
      id = _state$filters$idx.id;
  var newFilters = [].concat((0, _toConsumableArray2["default"])(state.filters.slice(0, idx)), (0, _toConsumableArray2["default"])(state.filters.slice(idx + 1, state.filters.length)));
  var filteredDatasets = (0, _utils.applyFiltersToDatasets)(dataId, state.datasets, newFilters, state.layers);
  var newEditor = (0, _utils.getFilterIdInFeature)(state.editor.selectedFeature) === id ? _objectSpread(_objectSpread({}, state.editor), {}, {
    selectedFeature: null
  }) : state.editor;
  var newState = (0, _utils.set)(['filters'], newFilters, state);
  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState);
  newState = (0, _utils.set)(['editor'], newEditor, newState);
  return updateAllLayerDomainData(newState, dataId, undefined);
};
/**
 * Add a new layer
 * @memberof visStateUpdaters
 * @public
 */


exports.removeFilterUpdater = removeFilterUpdater;

var addLayerUpdater = function addLayerUpdater(state, action) {
  var newLayer;
  var newLayerData;

  if (action.config) {
    newLayer = (0, _visStateMerger.createLayerFromConfig)(state, action.config);

    if (!newLayer) {
      _window.console.warn('Failed to create layer from config, it usually means the config is not be in correct format', action.config);

      return state;
    }

    var result = (0, _layerUtils.calculateLayerData)(newLayer, state);
    newLayer = result.layer;
    newLayerData = result.layerData;
  } else {
    var _action$datasetId;

    // create an empty layer with a specific dataset or a default one
    var defaultDataset = (_action$datasetId = action.datasetId) !== null && _action$datasetId !== void 0 ? _action$datasetId : Object.keys(state.datasets)[0];
    newLayer = new _layers.Layer({
      isVisible: true,
      isConfigActive: true,
      dataId: defaultDataset
    });
    newLayerData = {};
  }

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    layers: [].concat((0, _toConsumableArray2["default"])(state.layers), [newLayer]),
    layerData: [].concat((0, _toConsumableArray2["default"])(state.layerData), [newLayerData]),
    // add new layer at the top
    layerOrder: [newLayer.id].concat((0, _toConsumableArray2["default"])(state.layerOrder)),
    splitMaps: (0, _utils.addNewLayersToSplitMap)(state.splitMaps, newLayer)
  });

  if (newLayer.config.animation.enabled) {
    newState = updateAnimationDomain(newState);
  }

  return newState;
};
/**
 * remove layer
 * @memberof visStateUpdaters
 * @public
 */


exports.addLayerUpdater = addLayerUpdater;

function removeLayerUpdater(state, _ref7) {
  var id = _ref7.id;
  var idx = Number.isFinite(id) ? // support older API, remove layer by idx
  Number(id) : state.layers.findIndex(function (l) {
    return l.id === id;
  });

  if (idx < 0 || idx >= state.layers.length) {
    // invalid index
    _window.console.warn("can not remove layer with invalid id|idx ".concat(id));

    return state;
  }

  var layers = state.layers,
      layerData = state.layerData,
      layerOrder = state.layerOrder,
      clicked = state.clicked,
      hoverInfo = state.hoverInfo;
  var layerToRemove = layers[idx];

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    layers: (0, _composerHelpers.filterOutById)(layerToRemove.id)(layers),
    layerData: (0, _composerHelpers.removeElementAtIndex)(idx)(layerData),
    layerOrder: layerOrder.filter(function (layerId) {
      return layerId !== layerToRemove.id;
    }),
    clicked: layerToRemove.isLayerHovered(clicked) ? undefined : clicked,
    hoverInfo: layerToRemove.isLayerHovered(hoverInfo) ? undefined : hoverInfo,
    splitMaps: (0, _utils.removeLayerFromSplitMaps)(state.splitMaps, layerToRemove) // TODO: update filters, create helper to remove layer form filter (remove layerid and dataid) if mapped

  });

  return updateAnimationDomain(newState);
}
/**
 * Reorder layer
 * @memberof visStateUpdaters
 * @public
 */


var reorderLayerUpdater = function reorderLayerUpdater(state, _ref8) {
  var order = _ref8.order;
  return _objectSpread(_objectSpread({}, state), {}, {
    layerOrder: order
  });
};
/**
 * duplicate layer
 * @memberof visStateUpdaters
 * @public
 */


exports.reorderLayerUpdater = reorderLayerUpdater;

var duplicateLayerUpdater = function duplicateLayerUpdater(state, _ref9) {
  var id = _ref9.id;
  var idx = Number.isFinite(id) ? // support older API, remove layer by idx
  Number(id) : state.layers.findIndex(function (l) {
    return l.id === id;
  });

  if (idx < 0 || !state.layers[idx]) {
    _window.console.warn("layer ".concat(idx, " not found in layerOrder"));

    return state;
  }

  var layers = state.layers;
  var original = layers[idx];
  var originalLayerOrderIdx = state.layerOrder.findIndex(function (lid) {
    return lid === original.id;
  });
  var newLabel = "Copy of ".concat(original.config.label);
  var postfix = 0; // eslint-disable-next-line no-loop-func

  while (layers.find(function (l) {
    return l.config.label === newLabel;
  })) {
    newLabel = "Copy of ".concat(original.config.label, " ").concat(++postfix);
  } // collect layer config from original


  var loadedLayer = (0, _visStateMerger.serializeLayer)(original, state.schema); // assign new id and label to copied layer

  if (!(loadedLayer !== null && loadedLayer !== void 0 && loadedLayer.config)) {
    return state;
  }

  loadedLayer.config.label = newLabel;
  loadedLayer.id = (0, _utils.generateHashId)(_layers.LAYER_ID_LENGTH); // add layer to state

  var nextState = addLayerUpdater(state, {
    config: loadedLayer
  }); // retrieve newly created layer

  var newLayer = nextState.layers[nextState.layers.length - 1]; // update layer order with newLyaer.id

  var newLayerOrder = (0, _utils.arrayInsert)(nextState.layerOrder.slice(1, nextState.layerOrder.length), originalLayerOrderIdx, newLayer.id);
  nextState = reorderLayerUpdater(nextState, {
    order: newLayerOrder
  });
  return updateAnimationDomain(nextState);
};
/**
 * Add a new effect
 * @memberof visStateUpdaters
 * @public
 */


exports.duplicateLayerUpdater = duplicateLayerUpdater;

var addEffectUpdater = function addEffectUpdater(state, action) {
  var newEffect = (0, _effects.createEffect)(action.config); // collapse configurators for other effects

  state.effects.forEach(function (effect) {
    return effect.setProps({
      isConfigActive: false
    });
  });
  var effects = [].concat((0, _toConsumableArray2["default"])(state.effects), [newEffect]);
  var effectOrder = (0, _utils.fixEffectOrder)(effects, [newEffect.id].concat((0, _toConsumableArray2["default"])(state.effectOrder)));
  return _objectSpread(_objectSpread({}, state), {}, {
    effects: effects,
    effectOrder: effectOrder
  });
};
/**
 * remove effect
 * @memberof visStateUpdaters
 * @public
 */


exports.addEffectUpdater = addEffectUpdater;

var removeEffectUpdater = function removeEffectUpdater(state, _ref10) {
  var id = _ref10.id;
  var idx = state.effects.findIndex(function (l) {
    return l.id === id;
  });

  if (idx < 0 || idx >= state.effects.length) {
    _window.console.warn("can not remove effect with invalid id ".concat(id));

    return state;
  }

  var effects = state.effects,
      effectOrder = state.effectOrder;
  var effectToRemove = effects[idx];
  return _objectSpread(_objectSpread({}, state), {}, {
    // @ts-expect-error fixed in ts
    effects: (0, _composerHelpers.filterOutById)(effectToRemove.id)(effects),
    effectOrder: effectOrder.filter(function (effectId) {
      return effectId !== effectToRemove.id;
    })
  });
};
/**
 * Reorder effect
 * @memberof visStateUpdaters
 * @public
 */


exports.removeEffectUpdater = removeEffectUpdater;

var reorderEffectUpdater = function reorderEffectUpdater(state, _ref11) {
  var order = _ref11.order;
  return _objectSpread(_objectSpread({}, state), {}, {
    effectOrder: (0, _utils.fixEffectOrder)(state.effects, (0, _toConsumableArray2["default"])(order))
  });
};
/**
 * Update effect
 * @memberof visStateUpdaters
 * @public
 */


exports.reorderEffectUpdater = reorderEffectUpdater;

var updateEffectUpdater = function updateEffectUpdater(state, _ref12) {
  var id = _ref12.id,
      props = _ref12.props;
  var idx = state.effects.findIndex(function (l) {
    return l.id === id;
  });

  if (idx < 0 || idx >= state.effects.length) {
    _window.console.warn("can not update effect with invalid id ".concat(id));

    return state;
  }

  var effectOrder = state.effectOrder;

  if (props.id !== undefined && props.id !== id) {
    var idx2 = state.effects.findIndex(function (l) {
      return l.id === props.id;
    });

    if (idx2 >= 0) {
      _window.console.warn("can not update effect with existing effect id ".concat(id));

      return state;
    }

    effectOrder = effectOrder.map(function (effectOrderId) {
      return effectOrderId === id ? props.id : effectOrderId;
    });
  }

  var newEffects = (0, _toConsumableArray2["default"])(state.effects);
  newEffects[idx].setProps(props);
  return _objectSpread(_objectSpread({}, state), {}, {
    effects: newEffects,
    effectOrder: effectOrder
  });
};
/**
 * Remove a dataset and all layers, filters, tooltip configs that based on it
 * @memberof visStateUpdaters
 * @public
 */


exports.updateEffectUpdater = updateEffectUpdater;

function removeDatasetUpdater(state, action) {
  // extract dataset key
  var datasetKey = action.dataId;
  var datasets = state.datasets; // check if dataset is present

  if (!datasets[datasetKey]) {
    return state;
  }
  /* eslint-disable no-unused-vars */


  var layers = state.layers,
      _state$datasets = state.datasets,
      dataset = _state$datasets[datasetKey],
      newDatasets = (0, _objectWithoutProperties2["default"])(_state$datasets, [datasetKey].map(_toPropertyKey));
  /* eslint-enable no-unused-vars */

  var layersToRemove = layers.filter(function (l) {
    return l.config.dataId === datasetKey;
  }).map(function (l) {
    return l.id;
  }); // remove layers and datasets

  var newState = layersToRemove.reduce(function (accu, id) {
    return removeLayerUpdater(accu, {
      id: id
    });
  }, _objectSpread(_objectSpread({}, state), {}, {
    datasets: newDatasets
  })); // remove filters

  var filters = newState.filters.filter(function (filter) {
    return !filter.dataId.includes(datasetKey);
  });
  newState = _objectSpread(_objectSpread({}, newState), {}, {
    filters: filters
  });
  return removeDatasetFromInteractionConfig(newState, {
    dataId: datasetKey
  });
}

function removeDatasetFromInteractionConfig(state, _ref13) {
  var dataId = _ref13.dataId;
  var interactionConfig = state.interactionConfig;
  var _interactionConfig = interactionConfig,
      tooltip = _interactionConfig.tooltip;

  if (tooltip) {
    var config = tooltip.config;
    /* eslint-disable no-unused-vars */

    var _config$fieldsToShow = config.fieldsToShow,
        fields = _config$fieldsToShow[dataId],
        fieldsToShow = (0, _objectWithoutProperties2["default"])(_config$fieldsToShow, [dataId].map(_toPropertyKey));
    /* eslint-enable no-unused-vars */

    interactionConfig = _objectSpread(_objectSpread({}, interactionConfig), {}, {
      tooltip: _objectSpread(_objectSpread({}, tooltip), {}, {
        config: _objectSpread(_objectSpread({}, config), {}, {
          fieldsToShow: fieldsToShow
        })
      })
    });
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    interactionConfig: interactionConfig
  });
}
/**
 * update layer blending mode
 * @memberof visStateUpdaters
 * @public
 */


var updateLayerBlendingUpdater = function updateLayerBlendingUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    layerBlending: action.mode
  });
};
/**
 * update overlay blending mode
 * @memberof visStateUpdaters
 * @public
 */


exports.updateLayerBlendingUpdater = updateLayerBlendingUpdater;

var updateOverlayBlendingUpdater = function updateOverlayBlendingUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    overlayBlending: action.mode
  });
};
/**
 * Display dataset table in a modal
 * @memberof visStateUpdaters
 * @public
 */


exports.updateOverlayBlendingUpdater = updateOverlayBlendingUpdater;

var showDatasetTableUpdater = function showDatasetTableUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    editingDataset: action.dataId
  });
};
/**
 * Add custom color for datasets and layers
 * @memberof visStateUpdaters
 * @public
 */


exports.showDatasetTableUpdater = showDatasetTableUpdater;

var updateTableColorUpdater = function updateTableColorUpdater(state, action) {
  return updateDatasetPropsUpdater(state, {
    dataId: action.dataId,
    props: {
      color: action.newColor
    }
  });
};
/**
 * reset visState to initial State
 * @memberof visStateUpdaters
 * @public
 */


exports.updateTableColorUpdater = updateTableColorUpdater;

var resetMapConfigUpdater = function resetMapConfigUpdater(state) {
  return _objectSpread(_objectSpread(_objectSpread({}, INITIAL_VIS_STATE), state.initialState), {}, {
    initialState: state.initialState
  });
};
/**
 * Propagate `visState` reducer with a new configuration. Current config will be override.
 * @memberof visStateUpdaters
 * @public
 */


exports.resetMapConfigUpdater = resetMapConfigUpdater;

var receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref14) {
  var _ref14$payload = _ref14.payload,
      _ref14$payload$config = _ref14$payload.config,
      config = _ref14$payload$config === void 0 ? {} : _ref14$payload$config,
      _ref14$payload$option = _ref14$payload.options,
      options = _ref14$payload$option === void 0 ? {} : _ref14$payload$option;

  if (!config.visState) {
    return state;
  }

  var keepExistingConfig = options.keepExistingConfig; // reset config if keepExistingConfig is falsy

  var mergedState = !keepExistingConfig ? resetMapConfigUpdater(state) : state;

  var _iterator2 = _createForOfIteratorHelper(state.mergers),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var merger = _step2.value;

      if ((0, _mergerHandler.isValidMerger)(merger) && (0, _mergerHandler.hasPropsToMerge)(config.visState, merger.prop)) {
        mergedState = merger.merge(mergedState, (0, _mergerHandler.getPropValueToMerger)(config.visState, merger.prop, merger.toMergeProp), // fromConfig
        true);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return mergedState;
};
/**
 * Trigger layer hover event with hovered object
 * @memberof visStateUpdaters
 * @public
 */


exports.receiveMapConfigUpdater = receiveMapConfigUpdater;

var layerHoverUpdater = function layerHoverUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    hoverInfo: _objectSpread({}, action.info)
  });
};
/* eslint-enable max-statements */

/**
 * Update `interactionConfig`
 * @memberof visStateUpdaters
 * @public
 */


exports.layerHoverUpdater = layerHoverUpdater;

function interactionConfigChangeUpdater(state, action) {
  var config = action.config;

  var interactionConfig = _objectSpread(_objectSpread({}, state.interactionConfig), (0, _defineProperty2["default"])({}, config.id, config)); // Don't enable tooltip and brush at the same time
  // but coordinates can be shown at all time


  var contradict = ['brush', 'tooltip'];

  if (contradict.includes(config.id) && config.enabled && !state.interactionConfig[config.id].enabled) {
    // only enable one interaction at a time
    contradict.forEach(function (k) {
      if (k !== config.id) {
        interactionConfig[k] = _objectSpread(_objectSpread({}, interactionConfig[k]), {}, {
          enabled: false
        });
      }
    });
  }

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    interactionConfig: interactionConfig
  });

  if (config.id === 'geocoder' && !config.enabled) {
    return removeDatasetUpdater(newState, {
      dataId: 'geocoder_dataset'
    });
  }

  return newState;
}
/**
 * Trigger layer click event with clicked object
 * @memberof visStateUpdaters
 * @public
 */


var layerClickUpdater = function layerClickUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    mousePos: state.interactionConfig.coordinate.enabled ? _objectSpread(_objectSpread({}, state.mousePos), {}, {
      pinned: state.mousePos.pinned ? null : (0, _lodash["default"])(state.mousePos)
    }) : state.mousePos,
    clicked: action.info && action.info.picked ? action.info : null
  });
};
/**
 * Trigger map click event, unselect clicked object
 * @memberof visStateUpdaters
 * @public
 */


exports.layerClickUpdater = layerClickUpdater;

var mapClickUpdater = function mapClickUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    clicked: null
  });
};
/**
 * Trigger map move event
 * @memberof visStateUpdaters
 * @public
 */


exports.mapClickUpdater = mapClickUpdater;

var mouseMoveUpdater = function mouseMoveUpdater(state, _ref15) {
  var evt = _ref15.evt;

  if (Object.values(state.interactionConfig).some(function (config) {
    return config.enabled;
  })) {
    return _objectSpread(_objectSpread({}, state), {}, {
      mousePos: _objectSpread(_objectSpread(_objectSpread({}, state.mousePos), Array.isArray(evt.point) ? {
        mousePosition: (0, _toConsumableArray2["default"])(evt.point)
      } : {}), Array.isArray(evt.lngLat) ? {
        coordinate: (0, _toConsumableArray2["default"])(evt.lngLat)
      } : {})
    });
  }

  return state;
};
/**
 * Toggle visibility of a layer for a split map
 * @memberof visStateUpdaters
 * @public
 */


exports.mouseMoveUpdater = mouseMoveUpdater;

var toggleSplitMapUpdater = function toggleSplitMapUpdater(state, action) {
  return state.splitMaps && state.splitMaps.length === 0 ? _objectSpread(_objectSpread({}, state), {}, {
    // maybe we should use an array to store state for a single map as well
    // if current maps length is equal to 0 it means that we are about to split the view
    splitMaps: (0, _utils.computeSplitMapLayers)(state.layers, {
      duplicate: false
    })
  }) : closeSpecificMapAtIndex(state, action);
};
/**
 * Toggle visibility of a layer in a split map
 * @memberof visStateUpdaters
 * @public
 */


exports.toggleSplitMapUpdater = toggleSplitMapUpdater;

var toggleLayerForMapUpdater = function toggleLayerForMapUpdater(state, _ref16) {
  var mapIndex = _ref16.mapIndex,
      layerId = _ref16.layerId;
  var splitMaps = state.splitMaps;
  return _objectSpread(_objectSpread({}, state), {}, {
    splitMaps: splitMaps.map(function (sm, i) {
      return i === mapIndex ? _objectSpread(_objectSpread({}, splitMaps[i]), {}, {
        layers: _objectSpread(_objectSpread({}, splitMaps[i].layers), {}, (0, _defineProperty2["default"])({}, layerId, !splitMaps[i].layers[layerId]))
      }) : sm;
    })
  });
};
/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 * @memberof visStateUpdaters
 * @public
 */
// eslint-disable-next-line complexity


exports.toggleLayerForMapUpdater = toggleLayerForMapUpdater;

var updateVisDataUpdater = function updateVisDataUpdater(state, action) {
  // datasets can be a single data entries or an array of multiple data entries
  var config = action.config,
      options = action.options; // apply config if passed from action
  // TODO: we don't handle asyn mergers here yet

  var previousState = config ? receiveMapConfigUpdater(state, {
    payload: {
      config: config,
      options: options
    }
  }) : state;
  var datasets = (0, _utils.toArray)(action.datasets);
  var newDataEntries = datasets.reduce( // @ts-expect-error  Type '{}' is missing the following properties from type 'ProtoDataset': data, info
  function (accu) {
    var _ref17 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref17$info = _ref17.info,
        info = _ref17$info === void 0 ? {} : _ref17$info,
        rest = (0, _objectWithoutProperties2["default"])(_ref17, ["info"]);

    return _objectSpread(_objectSpread({}, accu), (0, _table.createNewDataEntry)(_objectSpread({
      info: info
    }, rest), state.datasets) || {});
  }, {}); // save new dataset entry to state

  var mergedState = _objectSpread(_objectSpread({}, previousState), {}, {
    datasets: (0, _visStateMerger.mergeDatasetsByOrder)(previousState, newDataEntries)
  }); // merge state with config to be merged


  var layerMergers = state.mergers.filter(function (m) {
    return m.waitForLayerData;
  });
  var datasetMergers = state.mergers.filter(function (m) {
    return !layerMergers.includes(m);
  });
  var newDataIds = Object.keys(newDataEntries);
  var postMergerPayload = {
    newDataIds: newDataIds,
    options: options,
    layerMergers: layerMergers
  };
  return applyMergersUpdater(mergedState, {
    mergers: datasetMergers,
    postMergerPayload: postMergerPayload
  });
};
/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 */


exports.updateVisDataUpdater = updateVisDataUpdater;

function applyMergersUpdater(state, action) {
  var mergers = action.mergers,
      postMergerPayload = action.postMergerPayload; // merge state with config to be merged

  var mergeStateResult = (0, _mergerHandler.mergeStateFromMergers)(state, _objectSpread(_objectSpread({}, INITIAL_VIS_STATE), state.initialState), mergers, // newDataIds,
  postMergerPayload); // if all merged, kickup post merge process
  // if not wait

  return mergeStateResult.allMerged ? postMergeUpdater(mergeStateResult.mergedState, postMergerPayload) : mergeStateResult.mergedState;
}
/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 */


function postMergeUpdater(mergedState, postMergerPayload) {
  var newDataIds = postMergerPayload.newDataIds,
      options = postMergerPayload.options,
      layerMergers = postMergerPayload.layerMergers;
  var newFilters = mergedState.filters.filter(function (f) {
    return f.dataId.find(function (fDataId) {
      return newDataIds.includes(fDataId);
    });
  });
  var datasetFiltered = (0, _lodash2["default"])(newFilters.reduce(function (accu, f) {
    return [].concat((0, _toConsumableArray2["default"])(accu), (0, _toConsumableArray2["default"])(f.dataId));
  }, []));
  var dataEmpty = newDataIds.length < 1;
  var newLayers = !dataEmpty ? mergedState.layers.filter(function (l) {
    return l.config.dataId && newDataIds.includes(l.config.dataId);
  }) : [];
  var newDataEntries = newDataIds.reduce(function (accu, id) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, id, mergedState.datasets[id]));
  }, {});

  if (!newLayers.length && (options || {}).autoCreateLayers !== false) {
    // no layer merged, find defaults
    var result = addDefaultLayers(mergedState, newDataEntries);
    mergedState = result.state;
    newLayers = result.newLayers;
  }

  if (mergedState.splitMaps.length) {
    // if map is split, add new layers to splitMaps
    newLayers = mergedState.layers.filter(function (l) {
      return l.config.dataId && newDataIds.includes(l.config.dataId);
    });
    mergedState = _objectSpread(_objectSpread({}, mergedState), {}, {
      splitMaps: (0, _utils.addNewLayersToSplitMap)(mergedState.splitMaps, newLayers)
    });
  } // if no tooltips merged add default tooltips


  newDataIds.forEach(function (dataId) {
    var tooltipFields = mergedState.interactionConfig.tooltip.config.fieldsToShow[dataId]; // loading dataset: autoCreateTooltips is false and we don't want to run addDefaultTooltips when tooltipFields is empty

    if ((options === null || options === void 0 ? void 0 : options.autoCreateTooltips) !== false && (!Array.isArray(tooltipFields) || !tooltipFields.length)) {
      // adding dataset: autoCreateTooltips is true
      mergedState = addDefaultTooltips(mergedState, newDataEntries[dataId]);
    }
  });
  var updatedDatasets = dataEmpty ? Object.keys(mergedState.datasets) : (0, _lodash2["default"])(Object.keys(newDataEntries).concat(datasetFiltered));
  var updatedState = updateAllLayerDomainData(mergedState, updatedDatasets, undefined); // register layer animation domain,
  // need to be called after layer data is calculated

  updatedState = updateAnimationDomain(updatedState); // try to process layerMergers after dataset+datasetMergers

  return layerMergers && layerMergers.length > 0 ? applyMergersUpdater(updatedState, {
    mergers: layerMergers,
    postMergerPayload: _objectSpread(_objectSpread({}, postMergerPayload), {}, {
      layerMergers: []
    })
  }) : updatedState;
}
/**
 * Rename an existing dataset in `visState`
 * @memberof visStateUpdaters
 * @public
 */


function renameDatasetUpdater(state, action) {
  return updateDatasetPropsUpdater(state, {
    dataId: action.dataId,
    props: {
      label: action.label
    }
  });
}

var ALLOWED_UPDATE_DATASET_PROPS = ['label', 'color', 'metadata'];
/**
 * Validates properties before updating the dataset.
 * Makes sure each property is in the allowed list
 * Makes sure color value is RGB
 * Performs deep merge when updating metadata
 */

var validateDatasetUpdateProps = function validateDatasetUpdateProps(props, dataset) {
  var validatedProps = Object.entries(props).reduce(function (acc, entry) {
    var _entry = (0, _slicedToArray2["default"])(entry, 2),
        key = _entry[0],
        value = _entry[1]; // is it allowed ?


    if (!ALLOWED_UPDATE_DATASET_PROPS.includes(key)) {
      return acc;
    } // if we are adding a color but it is not RGB we don't accept the value
    // in the future as we add more props we should change this if into a switch


    if (key === 'color' && !(0, _utils.isRgbColor)(value)) {
      return acc;
    } // do we need deep merge ?


    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, key, (0, _utils.isPlainObject)(value) ? (0, _deepmerge["default"])(dataset[key] || {}, value) : value));
  }, {});
  return validatedProps;
};
/**
 * Update Dataset props (label, color, meta). Do not use to update data or any related properties
 * @memberof visStateUpdaters
 * @public
 */


function updateDatasetPropsUpdater(state, action) {
  var dataId = action.dataId,
      props = action.props;
  var datasets = state.datasets;
  var existing = datasets[dataId];

  if (existing) {
    var validatedProps = validateDatasetUpdateProps(props, existing); //  validate props: just color for now
    //  we only allow label, color and meta to be updated
    // const newTable = copyTableAndUpdate(existing, validatedProps);

    return _objectSpread(_objectSpread({}, state), {}, {
      datasets: _objectSpread(_objectSpread({}, datasets), {}, (0, _defineProperty2["default"])({}, dataId, (0, _table.copyTableAndUpdate)(existing, validatedProps)))
    });
  }

  return state;
}
/**
 * When a user clicks on the specific map closing icon
 * the application will close the selected map
 * and will merge the remaining one with the global state
 * TODO: i think in the future this action should be called merge map layers with global settings
 * @param {Object} state `visState`
 * @param {Object} action action
 * @returns {Object} nextState
 */


function closeSpecificMapAtIndex(state, action) {
  var _state$splitMaps$inde;

  // retrieve layers meta data from the remaining map that we need to keep
  var indexToRetrieve = 1 - action.payload;
  var mapLayers = (_state$splitMaps$inde = state.splitMaps[indexToRetrieve]) === null || _state$splitMaps$inde === void 0 ? void 0 : _state$splitMaps$inde.layers;
  var layers = state.layers; // update layer visibility

  var newLayers = layers.map(function (layer) {
    return mapLayers && !mapLayers[layer.id] && layer.config.isVisible ? layer.updateLayerConfig({
      // if layer.id is not in mapLayers, it should be inVisible
      isVisible: false
    }) : layer;
  }); // delete map

  return _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    splitMaps: []
  });
}
/**
 * Trigger file loading dispatch `addDataToMap` if succeed, or `loadFilesErr` if failed
 * @memberof visStateUpdaters
 * @public
 */


var loadFilesUpdater = function loadFilesUpdater(state, action) {
  var files = action.files,
      _action$onFinish = action.onFinish,
      onFinish = _action$onFinish === void 0 ? _actions.loadFilesSuccess : _action$onFinish;

  if (!files.length) {
    return state;
  }

  var fileLoadingProgress = Array.from(files).reduce(function (accu, f, i) {
    return (0, _composerHelpers.merge_)(initialFileLoadingProgress(f, i))(accu);
  }, {});
  var fileLoading = {
    fileCache: [],
    filesToLoad: files,
    onFinish: onFinish
  };
  var nextState = (0, _composerHelpers.merge_)({
    fileLoadingProgress: fileLoadingProgress,
    fileLoading: fileLoading
  })(state);
  return loadNextFileUpdater(nextState);
};
/**
 * Sucessfully loaded one file, move on to the next one
 * @memberof visStateUpdaters
 * @public
 */


exports.loadFilesUpdater = loadFilesUpdater;

function loadFileStepSuccessUpdater(state, action) {
  if (!state.fileLoading) {
    return state;
  }

  var fileName = action.fileName,
      fileCache = action.fileCache;
  var _state$fileLoading = state.fileLoading,
      filesToLoad = _state$fileLoading.filesToLoad,
      onFinish = _state$fileLoading.onFinish;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: {
      percent: 1,
      message: 'Done'
    }
  }); // save processed file to fileCache

  var stateWithCache = (0, _composerHelpers.pick_)('fileLoading')((0, _composerHelpers.merge_)({
    fileCache: fileCache
  }))(stateWithProgress);
  return (0, _tasks.withTask)(stateWithCache, (0, _tasks2.DELAY_TASK)(200).map(filesToLoad.length ? _actions.loadNextFile : function () {
    return onFinish(fileCache);
  }));
} // withTask<T>(state: T, task: any): T

/**
 *
 * @memberof visStateUpdaters
 * @public
 */


function loadNextFileUpdater(state) {
  if (!state.fileLoading) {
    return state;
  }

  var filesToLoad = state.fileLoading.filesToLoad;

  var _filesToLoad = (0, _toArray2["default"])(filesToLoad),
      file = _filesToLoad[0],
      remainingFilesToLoad = _filesToLoad.slice(1); // save filesToLoad to state


  var nextState = (0, _composerHelpers.pick_)('fileLoading')((0, _composerHelpers.merge_)({
    filesToLoad: remainingFilesToLoad
  }))(state);
  var stateWithProgress = updateFileLoadingProgressUpdater(nextState, {
    fileName: file.name,
    progress: {
      percent: 0,
      message: 'loading...'
    }
  });
  var loaders = state.loaders,
      loadOptions = state.loadOptions;
  return (0, _tasks.withTask)(stateWithProgress, makeLoadFileTask(file, nextState.fileLoading && nextState.fileLoading.fileCache, loaders, loadOptions));
}

function makeLoadFileTask(file, fileCache) {
  var loaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var loadOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return (0, _tasks2.LOAD_FILE_TASK)({
    file: file,
    fileCache: fileCache,
    loaders: loaders,
    loadOptions: loadOptions
  }).bimap( // prettier ignore
  // success
  function (gen) {
    return (0, _actions.nextFileBatch)({
      gen: gen,
      fileName: file.name,
      onFinish: function onFinish(result) {
        return (0, _actions.processFileContent)({
          content: result,
          fileCache: fileCache
        });
      }
    });
  }, // error
  function (err) {
    return (0, _actions.loadFilesErr)(file.name, err);
  });
}
/**
 *
 * @memberof visStateUpdaters
 * @public
 */


function processFileContentUpdater(state, action) {
  var _action$payload = action.payload,
      content = _action$payload.content,
      fileCache = _action$payload.fileCache;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: content.fileName,
    progress: {
      percent: 1,
      message: 'processing...'
    }
  });
  return (0, _tasks.withTask)(stateWithProgress, (0, _tasks2.PROCESS_FILE_DATA)({
    content: content,
    fileCache: fileCache
  }).bimap(function (result) {
    return (0, _actions.loadFileStepSuccess)({
      fileName: content.fileName,
      fileCache: result
    });
  }, function (err) {
    return (0, _actions.loadFilesErr)(content.fileName, err);
  }));
}

function parseProgress() {
  var prevProgress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var progress = arguments.length > 1 ? arguments[1] : undefined;

  // This happens when receiving query metadata or other cases we don't
  // have an update for the user.
  if (!progress || !progress.percent) {
    return {};
  }

  return {
    percent: progress.percent
  };
}
/**
 * gets called with payload = AsyncGenerator<???>
 * @memberof visStateUpdaters
 * @public
 */


var nextFileBatchUpdater = function nextFileBatchUpdater(state, _ref18) {
  var _accumulated$data;

  var _ref18$payload = _ref18.payload,
      gen = _ref18$payload.gen,
      fileName = _ref18$payload.fileName,
      progress = _ref18$payload.progress,
      accumulated = _ref18$payload.accumulated,
      onFinish = _ref18$payload.onFinish;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: parseProgress(state.fileLoadingProgress[fileName], progress)
  });
  return (0, _tasks.withTask)(stateWithProgress, [].concat((0, _toConsumableArray2["default"])(fileName.endsWith('arrow') && (accumulated === null || accumulated === void 0 ? void 0 : (_accumulated$data = accumulated.data) === null || _accumulated$data === void 0 ? void 0 : _accumulated$data.length) > 0 ? [(0, _tasks2.PROCESS_FILE_DATA)({
    content: accumulated,
    fileCache: []
  }).bimap(function (result) {
    return (0, _actions.loadFilesSuccess)(result);
  }, function (err) {
    return (0, _actions.loadFilesErr)(fileName, err);
  })] : []), [(0, _tasks2.UNWRAP_TASK)(gen.next()).bimap(function (_ref19) {
    var value = _ref19.value,
        done = _ref19.done;
    return done ? onFinish(accumulated) : (0, _actions.nextFileBatch)({
      gen: gen,
      fileName: fileName,
      progress: value.progress,
      accumulated: value,
      onFinish: onFinish
    });
  }, function (err) {
    return (0, _actions.loadFilesErr)(fileName, err);
  })]));
};
/**
 * Trigger loading file error
 * @memberof visStateUpdaters
 * @public
 */


exports.nextFileBatchUpdater = nextFileBatchUpdater;

var loadFilesErrUpdater = function loadFilesErrUpdater(state, _ref20) {
  var error = _ref20.error,
      fileName = _ref20.fileName;

  // update ui with error message
  _window.console.warn(error);

  if (!state.fileLoading) {
    return state;
  }

  var _state$fileLoading2 = state.fileLoading,
      filesToLoad = _state$fileLoading2.filesToLoad,
      onFinish = _state$fileLoading2.onFinish,
      fileCache = _state$fileLoading2.fileCache;
  var nextState = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: {
      error: error
    }
  }); // kick off next file or finish

  return (0, _tasks.withTask)(nextState, (0, _tasks2.DELAY_TASK)(200).map(filesToLoad.length ? _actions.loadNextFile : function () {
    return onFinish(fileCache);
  }));
};
/**
 * When select dataset for export, apply cpu filter to selected dataset
 * @memberof visStateUpdaters
 * @public
 */


exports.loadFilesErrUpdater = loadFilesErrUpdater;

var applyCPUFilterUpdater = function applyCPUFilterUpdater(state, _ref21) {
  var dataId = _ref21.dataId;
  // apply cpuFilter
  var dataIds = (0, _utils.toArray)(dataId);
  return dataIds.reduce(function (accu, id) {
    return (0, _utils.filterDatasetCPU)(accu, id);
  }, state);
};
/**
 * User input to update the info of the map
 * @memberof visStateUpdaters
 * @public
 */


exports.applyCPUFilterUpdater = applyCPUFilterUpdater;

var setMapInfoUpdater = function setMapInfoUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    mapInfo: _objectSpread(_objectSpread({}, state.mapInfo), action.info)
  });
};
/**
 * Helper function to update All layer domain and layer data of state
 */


exports.setMapInfoUpdater = setMapInfoUpdater;

function addDefaultLayers(state, datasets) {
  var empty = [];
  var defaultLayers = Object.values(datasets).reduce(function (accu, dataset) {
    var foundLayers = (0, _layerUtils.findDefaultLayer)(dataset, state.layerClasses);
    return foundLayers && foundLayers.length ? accu.concat(foundLayers) : accu;
  }, empty);
  return {
    state: _objectSpread(_objectSpread({}, state), {}, {
      layers: [].concat((0, _toConsumableArray2["default"])(state.layers), (0, _toConsumableArray2["default"])(defaultLayers)),
      layerOrder: [].concat((0, _toConsumableArray2["default"])((0, _layerUtils.getLayerOrderFromLayers)(defaultLayers)), (0, _toConsumableArray2["default"])(state.layerOrder))
    }),
    newLayers: defaultLayers
  };
}
/**
 * helper function to find default tooltips
 * @param {Object} state
 * @param {Object} dataset
 * @returns {Object} nextState
 */


function addDefaultTooltips(state, dataset) {
  var tooltipFields = (0, _interactionUtils.findFieldsToShow)(_objectSpread(_objectSpread({}, dataset), {}, {
    maxDefaultTooltips: state.maxDefaultTooltips
  }));

  var merged = _objectSpread(_objectSpread({}, state.interactionConfig.tooltip.config.fieldsToShow), tooltipFields);

  return (0, _utils.set)(['interactionConfig', 'tooltip', 'config', 'fieldsToShow'], merged, state);
}

function initialFileLoadingProgress(file, index) {
  var fileName = file.name || "Untitled File ".concat(index);
  return (0, _defineProperty2["default"])({}, fileName, {
    // percent of current file
    percent: 0,
    message: '',
    fileName: fileName,
    error: null
  });
}

function updateFileLoadingProgressUpdater(state, _ref23) {
  var fileName = _ref23.fileName,
      progress = _ref23.progress;
  // @ts-expect-error
  return (0, _composerHelpers.pick_)('fileLoadingProgress')((0, _composerHelpers.pick_)(fileName)((0, _composerHelpers.merge_)(progress)))(state);
}
/**
 * Helper function to update layer domains for an array of datasets
 */


function updateAllLayerDomainData(state, dataId, updatedFilter) {
  var dataIds = typeof dataId === 'string' ? [dataId] : dataId;
  var newLayers = [];
  var newLayerData = [];
  state.layers.forEach(function (oldLayer, i) {
    if (oldLayer.config.dataId && dataIds.includes(oldLayer.config.dataId)) {
      // No need to recalculate layer domain if filter has fixed domain
      var newLayer = updatedFilter && updatedFilter.fixedDomain ? oldLayer : oldLayer.updateLayerDomain(state.datasets, updatedFilter);

      var _calculateLayerData6 = (0, _layerUtils.calculateLayerData)(newLayer, state, state.layerData[i]),
          layerData = _calculateLayerData6.layerData,
          layer = _calculateLayerData6.layer;

      newLayers.push(layer);
      newLayerData.push(layerData);
    } else {
      newLayers.push(oldLayer);
      newLayerData.push(state.layerData[i]);
    }
  });

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    layerData: newLayerData
  });

  return newState;
}

function updateAnimationDomain(state) {
  // merge all animatable layer domain and update global config
  var animatableLayers = state.layers.filter(function (l) {
    return l.config.isVisible && l.config.animation && l.config.animation.enabled && // @ts-expect-error trip-layer-only
    Array.isArray(l.animationDomain);
  });

  if (!animatableLayers.length) {
    return _objectSpread(_objectSpread({}, state), {}, {
      animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
        domain: null,
        defaultTimeFormat: null
      })
    });
  }

  var mergedDomain = animatableLayers.reduce(function (accu, layer) {
    return [// @ts-expect-error trip-layer-only
    Math.min(accu[0], layer.animationDomain[0]), // @ts-expect-error trip-layer-only
    Math.max(accu[1], layer.animationDomain[1])];
  }, [Number(Infinity), -Infinity]);
  var defaultTimeFormat = (0, _utils.getTimeWidgetTitleFormatter)(mergedDomain);
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      currentTime: (0, _utils.isInRange)(state.animationConfig.currentTime, mergedDomain) ? state.animationConfig.currentTime : mergedDomain[0],
      domain: mergedDomain,
      defaultTimeFormat: defaultTimeFormat
    })
  });
}
/**
 * Update the status of the editor
 * @memberof visStateUpdaters
 */


var setEditorModeUpdater = function setEditorModeUpdater(state, _ref24) {
  var mode = _ref24.mode;
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      mode: mode,
      selectedFeature: null
    })
  });
}; // const featureToFilterValue = (feature) => ({...feature, id: feature.id});

/**
 * Update editor features
 * @memberof visStateUpdaters
 */


exports.setEditorModeUpdater = setEditorModeUpdater;

function setFeaturesUpdater(state, _ref25) {
  var _ref25$features = _ref25.features,
      features = _ref25$features === void 0 ? [] : _ref25$features;
  var lastFeature = features.length && features[features.length - 1];

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      // only save none filter features to editor
      features: features.filter(function (f) {
        return !(0, _utils.getFilterIdInFeature)(f);
      }),
      mode: lastFeature && lastFeature.properties.isClosed ? _constants.EDITOR_MODES.EDIT : state.editor.mode
    })
  }); // Retrieve existing feature


  var selectedFeature = state.editor.selectedFeature; // If no feature is selected we can simply return since no operations

  if (!selectedFeature) {
    return newState;
  } // TODO: check if the feature has changed


  var feature = features.find(function (f) {
    return f.id === selectedFeature.id;
  }); // if feature is part of a filter

  var filterId = feature && (0, _utils.getFilterIdInFeature)(feature);

  if (filterId && feature) {
    // add bbox for polygon filter to speed up filtering
    if (feature.properties) feature.properties.bbox = (0, _bbox["default"])(feature);
    var featureValue = (0, _utils.featureToFilterValue)(feature, filterId);
    var filterIdx = state.filters.findIndex(function (fil) {
      return fil.id === filterId;
    }); // @ts-ignore

    return setFilterUpdater(newState, {
      idx: filterIdx,
      prop: 'value',
      value: featureValue
    });
  }

  return newState;
}
/**
 * Set the current selected feature
 * @memberof uiStateUpdaters
 */


var setSelectedFeatureUpdater = function setSelectedFeatureUpdater(state, _ref26) {
  var feature = _ref26.feature,
      selectionContext = _ref26.selectionContext;
  // add bbox for polygon filter to speed up filtering
  if (feature && feature.properties) feature.properties.bbox = (0, _bbox["default"])(feature);
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      selectedFeature: feature,
      selectionContext: selectionContext
    })
  });
};
/**
 * Delete existing feature from filters
 * @memberof visStateUpdaters
 */


exports.setSelectedFeatureUpdater = setSelectedFeatureUpdater;

function deleteFeatureUpdater(state, _ref27) {
  var feature = _ref27.feature;

  if (!feature) {
    return state;
  }

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      selectedFeature: null
    })
  });

  if ((0, _utils.getFilterIdInFeature)(feature)) {
    var filterIdx = newState.filters.findIndex(function (f) {
      return f.id === (0, _utils.getFilterIdInFeature)(feature);
    });
    return filterIdx > -1 ? removeFilterUpdater(newState, {
      idx: filterIdx
    }) : newState;
  } // modify editor object


  var newEditor = _objectSpread(_objectSpread({}, state.editor), {}, {
    features: state.editor.features.filter(function (f) {
      return f.id !== feature.id;
    }),
    selectedFeature: null
  });

  return _objectSpread(_objectSpread({}, state), {}, {
    editor: newEditor
  });
}
/**
 * Toggle feature as layer filter
 * @memberof visStateUpdaters
 */


function setPolygonFilterLayerUpdater(state, payload) {
  var layer = payload.layer,
      feature = payload.feature;
  var filterId = (0, _utils.getFilterIdInFeature)(feature); // let newFilter = null;

  var filterIdx;
  var newLayerId = [layer.id];
  var newState = state; // If polygon filter already exists, we need to find out if the current layer is already included

  if (filterId) {
    filterIdx = state.filters.findIndex(function (f) {
      return f.id === filterId;
    });

    if (!state.filters[filterIdx]) {
      // what if filter doesn't exist?... not possible.
      // because features in the editor is passed in from filters and editors.
      // but we will move this feature back to editor just in case
      var noneFilterFeature = _objectSpread(_objectSpread({}, feature), {}, {
        properties: _objectSpread(_objectSpread({}, feature.properties), {}, {
          filterId: null
        })
      });

      return _objectSpread(_objectSpread({}, state), {}, {
        editor: _objectSpread(_objectSpread({}, state.editor), {}, {
          features: [].concat((0, _toConsumableArray2["default"])(state.editor.features), [noneFilterFeature]),
          selectedFeature: noneFilterFeature
        })
      });
    }

    var filter = state.filters[filterIdx];
    var _filter$layerId = filter.layerId,
        layerId = _filter$layerId === void 0 ? [] : _filter$layerId;
    var isLayerIncluded = layerId.includes(layer.id);
    newLayerId = isLayerIncluded ? // if layer is included, remove it
    layerId.filter(function (l) {
      return l !== layer.id;
    }) : [].concat((0, _toConsumableArray2["default"])(layerId), [layer.id]);
  } else {
    // if we haven't create the polygon filter, create it
    var newFilter = (0, _utils.generatePolygonFilter)([], feature);
    filterIdx = state.filters.length; // add feature, remove feature from eidtor

    newState = _objectSpread(_objectSpread({}, state), {}, {
      filters: [].concat((0, _toConsumableArray2["default"])(state.filters), [newFilter]),
      editor: _objectSpread(_objectSpread({}, state.editor), {}, {
        features: state.editor.features.filter(function (f) {
          return f.id !== feature.id;
        }),
        selectedFeature: newFilter.value
      })
    });
  }

  return setFilterUpdater(newState, {
    idx: filterIdx,
    prop: 'layerId',
    value: newLayerId
  });
}
/**
 * @memberof visStateUpdaters
 * @public
 */


function sortTableColumnUpdater(state, _ref28) {
  var dataId = _ref28.dataId,
      column = _ref28.column,
      mode = _ref28.mode;
  var dataset = state.datasets[dataId];

  if (!dataset) {
    return state;
  }

  var sortMode = mode;

  if (!sortMode) {
    var currentMode = (0, _lodash3["default"])(dataset, ['sortColumn', column]); // @ts-ignore - should be fixable in a TS file

    sortMode = currentMode ? Object.keys(_constants.SORT_ORDER).find(function (m) {
      return m !== currentMode;
    }) : _constants.SORT_ORDER.ASCENDING;
  }

  var sorted = (0, _table.sortDatasetByColumn)(dataset, column, sortMode);
  return (0, _utils.set)(['datasets', dataId], sorted, state);
}
/**
 * @memberof visStateUpdaters
 * @public
 */


function pinTableColumnUpdater(state, _ref29) {
  var dataId = _ref29.dataId,
      column = _ref29.column;
  var dataset = state.datasets[dataId];

  if (!dataset) {
    return state;
  }

  var newDataset = (0, _table.pinTableColumns)(dataset, column);
  return (0, _utils.set)(['datasets', dataId], newDataset, state);
}
/**
 * Copy column content as strings
 * @memberof visStateUpdaters
 * @public
 */


function copyTableColumnUpdater(state, _ref30) {
  var dataId = _ref30.dataId,
      column = _ref30.column;
  var dataset = state.datasets[dataId];

  if (!dataset) {
    return state;
  }

  var fieldIdx = dataset.fields.findIndex(function (f) {
    return f.name === column;
  });

  if (fieldIdx < 0) {
    return state;
  }

  var type = dataset.fields[fieldIdx].type;
  var text = dataset.dataContainer.map(function (row) {
    return (0, _utils.parseFieldValue)(row.valueAt(fieldIdx), type);
  }, true).join('\n');
  (0, _copyToClipboard["default"])(text);
  return state;
}
/**
 * Set display format from columns from user selection
 * @memberof visStateUpdaters
 * @public
 */


function setColumnDisplayFormatUpdater(state, _ref31) {
  var dataId = _ref31.dataId,
      formats = _ref31.formats;
  var dataset = state.datasets[dataId];

  if (!dataset) {
    return state;
  }

  var newFields = dataset.fields;
  Object.keys(formats).forEach(function (column) {
    var fieldIdx = dataset.fields.findIndex(function (f) {
      return f.name === column;
    });

    if (fieldIdx >= 0) {
      var displayFormat = formats[column];
      var field = newFields[fieldIdx];
      newFields = (0, _composerHelpers.swap_)((0, _composerHelpers.merge_)({
        displayFormat: displayFormat
      })(field))(newFields);
    }
  });
  var newDataset = (0, _table.copyTableAndUpdate)(dataset, {
    fields: newFields
  });
  return (0, _composerHelpers.pick_)('datasets')((0, _composerHelpers.merge_)((0, _defineProperty2["default"])({}, dataId, newDataset)))(state);
}
/**
 * Update editor
 */


function toggleEditorVisibilityUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      visible: !state.editor.visible
    })
  });
}

function setFilterAnimationTimeConfigUpdater(state, _ref32) {
  var idx = _ref32.idx,
      config = _ref32.config;
  var oldFilter = state.filters[idx];

  if (!oldFilter) {
    _window.console.error("filters.".concat(idx, " is undefined"));

    return state;
  }

  if (oldFilter.type !== _constants.FILTER_TYPES.timeRange) {
    _window.console.error("setFilterAnimationTimeConfig can only be called to update a time filter. check filter.type === 'timeRange'");

    return state;
  }

  var updates = checkTimeConfigArgs(config);
  return (0, _composerHelpers.pick_)('filters')((0, _composerHelpers.swap_)((0, _composerHelpers.merge_)(updates)(oldFilter)))(state);
}

function checkTimeConfigArgs(config) {
  var allowed = ['timeFormat', 'timezone'];
  return Object.keys(config).reduce(function (accu, prop) {
    if (!allowed.includes(prop)) {
      _window.console.error("setLayerAnimationTimeConfig takes timeFormat and/or timezone as options, found ".concat(prop));

      return accu;
    } // here we are NOT checking if timezone or timeFormat input is valid


    accu[prop] = config[prop];
    return accu;
  }, {});
}
/**
 * Update editor
 */


function setLayerAnimationTimeConfigUpdater(state, _ref33) {
  var config = _ref33.config;

  if (!config) {
    return state;
  }

  var updates = checkTimeConfigArgs(config);
  return (0, _composerHelpers.pick_)('animationConfig')((0, _composerHelpers.merge_)(updates))(state);
} // Find dataId from a saved visState property:
// layers, filters, interactions, layerBlending, overlayBlending, splitMaps, animationConfig, editor
// replace it with another dataId


function defaultReplaceParentDatasetIds(value, dataId, dataIdToReplace) {
  var _value$config, _value$config2;

  if (Array.isArray(value)) {
    // for layers, filters, call defaultReplaceParentDatasetIds on each item in array
    var replaced = value.map(function (v) {
      return defaultReplaceParentDatasetIds(v, dataId, dataIdToReplace);
    }).filter(function (d) {
      return d;
    });
    return replaced.length ? replaced : null;
  }

  if (typeof value.dataId === 'string' && value.dataId === dataId) {
    // others
    return _objectSpread(_objectSpread({}, value), {}, {
      dataId: dataIdToReplace
    });
  } else if (Array.isArray(value.dataId) && value.dataId.includes(dataId)) {
    // filter
    return _objectSpread(_objectSpread({}, value), {}, {
      dataId: value.dataId.map(function (d) {
        return d === dataId ? dataIdToReplace : d;
      })
    });
  } else if ((_value$config = value.config) !== null && _value$config !== void 0 && _value$config.dataId && ((_value$config2 = value.config) === null || _value$config2 === void 0 ? void 0 : _value$config2.dataId) === dataId) {
    // layer
    return _objectSpread(_objectSpread({}, value), {}, {
      config: _objectSpread(_objectSpread({}, value.config), {}, {
        dataId: dataIdToReplace
      })
    });
  } else if ((0, _utils.isObject)(value) && value.hasOwnProperty(dataId)) {
    // for value saved as {[dataId]: {...}}
    return (0, _defineProperty2["default"])({}, dataIdToReplace, value[dataId]);
  }

  return null;
} // Find datasetIds derived a saved visState Property;


function findChildDatasetIds(value) {
  var _value$newDataset;

  if (Array.isArray(value)) {
    // for layers, filters, call defaultReplaceParentDatasetIds on each item in array
    var childDataIds = value.map(findChildDatasetIds).filter(function (d) {
      return d;
    });
    return childDataIds.length ? childDataIds : null;
  } // child data id usually stores in the derived dataset info


  return (value === null || value === void 0 ? void 0 : (_value$newDataset = value.newDataset) === null || _value$newDataset === void 0 ? void 0 : _value$newDataset.info.id) || null;
} // moved unmerged layers, filters, interactions


function moveValueToBeMerged(state, propValues, _ref35) {
  var prop = _ref35.prop,
      toMergeProp = _ref35.toMergeProp,
      saveUnmerged = _ref35.saveUnmerged;

  // remove prop value from state
  // TODO: should we add remove updater to merger as well?
  if (!propValues) {
    return state;
  }

  var stateRemoved = prop === 'layers' ? propValues.reduce(function (accu, propValue) {
    return removeLayerUpdater(accu, {
      id: propValue.id
    });
  }, state) : Array.isArray(state[prop]) ? _objectSpread(_objectSpread({}, state), {}, (0, _defineProperty2["default"])({}, prop, state[prop].filter(function (p) {
    return !propValues.find(function (propValue) {
      return p.id === propValue.id;
    });
  }))) : // if not array, we won't remove it, remove dataset should handle it
  state; // move to stateToBeMerged

  var toBeMerged = (0, _defineProperty2["default"])({}, toMergeProp, saveUnmerged ? // call merge saveUnmerged method
  saveUnmerged(stateRemoved, propValues) : // if toMergeProp is araay, append to it
  Array.isArray(stateRemoved[toMergeProp]) ? [].concat((0, _toConsumableArray2["default"])(stateRemoved[toMergeProp]), (0, _toConsumableArray2["default"])(propValues)) : // save propValues to toMerge
  (0, _utils.isObject)(stateRemoved[toMergeProp]) ? _objectSpread(_objectSpread({}, stateRemoved[toMergeProp]), propValues) : stateRemoved[toMergeProp]);
  return _objectSpread(_objectSpread({}, stateRemoved), toBeMerged);
}

function replaceDatasetAndDeps(state, dataId, dataIdToUse) {
  return (0, _composerHelpers.compose_)([(0, _composerHelpers.apply_)(replaceDatasetDepsInState, {
    dataId: dataId,
    dataIdToUse: dataIdToUse
  }), (0, _composerHelpers.apply_)(removeDatasetUpdater, {
    dataId: dataId
  })])(state);
}

function prepareStateForDatasetReplace(state, dataId, dataIdToUse) {
  var _nextState$layerToBeM;

  var serializedState = (0, _visStateMerger.serializeVisState)(state, state.schema);
  var nextState = replaceDatasetAndDeps(state, dataId, dataIdToUse); // make a copy of layerOrder, because layer id will be removed from it by calling removeLayerUpdater

  var preserveLayerOrder = (0, _toConsumableArray2["default"])(state.layerOrder); // preserve dataset order

  nextState.preserveDatasetOrder = Object.keys(state.datasets).map(function (d) {
    return d === dataId ? dataIdToUse : d;
  }); // preserveLayerOrder

  if ((_nextState$layerToBeM = nextState.layerToBeMerged) !== null && _nextState$layerToBeM !== void 0 && _nextState$layerToBeM.length) {
    var _serializedState$spli;

    // copy split maps to be merged, because it will be reset in remove layer
    nextState.splitMapsToBeMerged = (_serializedState$spli = serializedState === null || serializedState === void 0 ? void 0 : serializedState.splitMaps) !== null && _serializedState$spli !== void 0 ? _serializedState$spli : [];
    nextState.layerOrder = (0, _toConsumableArray2["default"])(preserveLayerOrder);
  }

  return nextState;
}

function replaceDatasetDepsInState(state, _ref36) {
  var dataId = _ref36.dataId,
      dataIdToUse = _ref36.dataIdToUse;
  var serializedState = (0, _visStateMerger.serializeVisState)(state, state.schema);
  var nextState = state.mergers.reduce(function (accuState, _ref37) {
    var prop = _ref37.prop,
        toMergeProp = _ref37.toMergeProp,
        replaceParentDatasetIds = _ref37.replaceParentDatasetIds,
        getChildDatasetIds = _ref37.getChildDatasetIds,
        saveUnmerged = _ref37.saveUnmerged,
        preserveOrder = _ref37.preserveOrder;
    // get dataset ids that are depends on this dataset
    var props = (0, _utils.toArray)(prop);
    var toMergeProps = (0, _utils.toArray)(toMergeProp);
    var savedProps = serializedState ? props.map(function (p) {
      return serializedState[p];
    }) : [];
    var replacedState = accuState;
    savedProps.forEach(function (propValue, i) {
      var _replacedState$merger;

      var mergerOptions = {
        prop: props[i],
        toMergeProp: toMergeProps[i],
        getChildDatasetIds: getChildDatasetIds,
        saveUnmerged: saveUnmerged
      };
      var replacedItem = (replaceParentDatasetIds === null || replaceParentDatasetIds === void 0 ? void 0 : replaceParentDatasetIds(propValue, dataId, dataIdToUse)) || defaultReplaceParentDatasetIds(propValue, dataId, dataIdToUse);
      replacedState = replacedItem ? replacePropValueInState(replacedState, replacedItem, mergerOptions) : replacedState;

      if (mergerOptions.toMergeProp !== undefined && (_replacedState$merger = replacedState[mergerOptions.toMergeProp]) !== null && _replacedState$merger !== void 0 && _replacedState$merger.length && preserveOrder) {
        replacedState[preserveOrder] = propValue.map(function (item) {
          return item.id;
        });
      }
    });
    return replacedState;
  }, state);
  return nextState;
}

function replacePropValueInState(state, replacedItem, _ref38) {
  var prop = _ref38.prop,
      toMergeProp = _ref38.toMergeProp,
      getChildDatasetIds = _ref38.getChildDatasetIds,
      saveUnmerged = _ref38.saveUnmerged;
  // prop is depends on the dataset to be replaced
  // remove prop from state, and move it to toBeMerged
  var nextState = moveValueToBeMerged(state, replacedItem, {
    prop: prop,
    toMergeProp: toMergeProp,
    saveUnmerged: saveUnmerged
  });
  var childDataIds = (getChildDatasetIds === null || getChildDatasetIds === void 0 ? void 0 : getChildDatasetIds(replacedItem)) || findChildDatasetIds(replacedItem);

  if (childDataIds) {
    nextState = (0, _utils.toArray)(childDataIds).reduce(function (accu, childDataId) {
      // shouldn't need to change child dataset id,
      // but still need to move out of state and merge back in
      return replaceDatasetAndDeps(accu, childDataId, childDataId);
    }, nextState);
  }

  return nextState;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aXMtc3RhdGUtdXBkYXRlcnMudHMiXSwibmFtZXMiOlsidmlzU3RhdGVVcGRhdGVycyIsImRlZmF1bHRJbnRlcmFjdGlvbkNvbmZpZyIsInRvb2x0aXAiLCJpZCIsImxhYmVsIiwiZW5hYmxlZCIsImNvbmZpZyIsImZpZWxkc1RvU2hvdyIsImNvbXBhcmVNb2RlIiwiY29tcGFyZVR5cGUiLCJDT01QQVJFX1RZUEVTIiwiQUJTT0xVVEUiLCJnZW9jb2RlciIsInBvc2l0aW9uIiwiYnJ1c2giLCJzaXplIiwiY29vcmRpbmF0ZSIsIkRFRkFVTFRfQU5JTUFUSU9OX0NPTkZJRyIsImRvbWFpbiIsImN1cnJlbnRUaW1lIiwic3BlZWQiLCJpc0FuaW1hdGluZyIsInRpbWVGb3JtYXQiLCJ0aW1lem9uZSIsImRlZmF1bHRUaW1lRm9ybWF0IiwiaGlkZUNvbnRyb2wiLCJkdXJhdGlvbiIsIkRFRkFVTFRfRURJVE9SIiwibW9kZSIsIkVESVRPUl9NT0RFUyIsIkRSQVdfUE9MWUdPTiIsImZlYXR1cmVzIiwic2VsZWN0ZWRGZWF0dXJlIiwidmlzaWJsZSIsIklOSVRJQUxfVklTX1NUQVRFIiwibWFwSW5mbyIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJsYXllcnMiLCJsYXllckRhdGEiLCJsYXllclRvQmVNZXJnZWQiLCJsYXllck9yZGVyIiwiZmlsdGVycyIsImZpbHRlclRvQmVNZXJnZWQiLCJkYXRhc2V0cyIsImVkaXRpbmdEYXRhc2V0IiwidW5kZWZpbmVkIiwiZWZmZWN0cyIsImVmZmVjdE9yZGVyIiwiaW50ZXJhY3Rpb25Db25maWciLCJpbnRlcmFjdGlvblRvQmVNZXJnZWQiLCJsYXllckJsZW5kaW5nIiwib3ZlcmxheUJsZW5kaW5nIiwiaG92ZXJJbmZvIiwiY2xpY2tlZCIsIm1vdXNlUG9zIiwibWF4RGVmYXVsdFRvb2x0aXBzIiwiTUFYX0RFRkFVTFRfVE9PTFRJUFMiLCJzcGxpdE1hcHMiLCJzcGxpdE1hcHNUb0JlTWVyZ2VkIiwiaXNNZXJnaW5nRGF0YXNldHMiLCJsYXllckNsYXNzZXMiLCJMYXllckNsYXNzZXMiLCJhbmltYXRpb25Db25maWciLCJlZGl0b3IiLCJmaWxlTG9hZGluZyIsImZpbGVMb2FkaW5nUHJvZ3Jlc3MiLCJsb2FkZXJzIiwibG9hZE9wdGlvbnMiLCJtZXJnZXJzIiwiVklTX1NUQVRFX01FUkdFUlMiLCJzY2hlbWEiLCJLZXBsZXJHTFNjaGVtYSIsInVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YSIsInN0YXRlIiwibGF5ZXIiLCJpZHgiLCJtYXAiLCJseXIiLCJpIiwiZCIsInVwZGF0ZVN0YXRlT25MYXllclZpc2liaWxpdHlDaGFuZ2UiLCJuZXdTdGF0ZSIsImxlbmd0aCIsImlzVmlzaWJsZSIsImFuaW1hdGlvbiIsInVwZGF0ZUFuaW1hdGlvbkRvbWFpbiIsInBpY2tDaGFuZ2VkUHJvcHMiLCJwcmV2IiwibmV4dCIsImNoYW5nZWRQcm9wcyIsInBpY2tQcm9wc09mIiwib2JqIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsIlZJU1VBTF9DSEFOTkVMX1BST1BfVFlQRVMiLCJhcHBseUxheWVyQ29uZmlnVXBkYXRlciIsImFjdGlvbiIsIm9sZExheWVySWQiLCJuZXdMYXllckNvbmZpZyIsImxheWVySW5kZXgiLCJuZXdQYXJzZWRMYXllciIsIm9sZExheWVyIiwiZmluZCIsImwiLCJkYXRhc2V0IiwiZGF0YUlkIiwibmV3TGF5ZXIiLCJuZXh0U3RhdGUiLCJ0eXBlIiwib2xkTGF5ZXJJbmRleCIsImZpbmRJbmRleCIsImxheWVyVHlwZUNoYW5nZVVwZGF0ZXIiLCJuZXdMYXllcklkIiwic2VyaWFsaXplZE9sZExheWVyIiwic2VyaWFsaXplZE5ld0xheWVyIiwiY2hhbmdlZCIsInZpc0NvbmZpZyIsImxheWVyVmlzQ29uZmlnQ2hhbmdlVXBkYXRlciIsInZpc3VhbENoYW5uZWxzIiwiY2hhbm5lbE5hbWUiLCJjaGFubmVsIiwiY2hhbm5lbFByb3BOYW1lcyIsInByb3AiLCJzb21lIiwibGF5ZXJWaXN1YWxDaGFubmVsQ2hhbmdlVXBkYXRlciIsImxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlciIsInByb3BzIiwibmV3Q29uZmlnIiwicmVzdENvbmZpZyIsInN0YXRlV2l0aERhdGFJZCIsImxheWVyRGF0YUlkQ2hhbmdlVXBkYXRlciIsIm5leHRMYXllciIsInVwZGF0ZUxheWVyQ29uZmlnIiwic2hvdWxkQ2FsY3VsYXRlTGF5ZXJEYXRhIiwib2xkTGF5ZXJEYXRhIiwidXBkYXRlTGF5ZXJEYXRhUmVzdWx0IiwibGF5ZXJTZXRJc1ZhbGlkVXBkYXRlciIsImlzVmFsaWQiLCJsYXllclRvVXBkYXRlIiwibmV3RGF0YSIsImFkZE9yUmVtb3ZlVGV4dExhYmVscyIsIm5ld0ZpZWxkcyIsInRleHRMYWJlbCIsImRlZmF1bHRUZXh0TGFiZWwiLCJERUZBVUxUX1RFWFRfTEFCRUwiLCJuZXdUZXh0TGFiZWwiLCJzbGljZSIsImN1cnJlbnRGaWVsZHMiLCJ0bCIsImZpZWxkIiwibmFtZSIsImZpbHRlciIsImFkZEZpZWxkcyIsImYiLCJpbmNsdWRlcyIsImRlbGV0ZUZpZWxkcyIsImZkIiwiYWYiLCJ1cGRhdGVUZXh0TGFiZWxQcm9wQW5kVmFsdWUiLCJ2YWx1ZSIsInNwbGljZSIsImxheWVyVGV4dExhYmVsQ2hhbmdlVXBkYXRlciIsImdldERlZmF1bHRMYXllckNvbmZpZyIsInZhbGlkYXRlRXhpc3RpbmdMYXllcldpdGhEYXRhIiwibG9hZGVkTGF5ZXIiLCJhbGxvd0VtcHR5Q29sdW1uIiwiaXNWYWxpZFRvU2F2ZSIsInZhbGlkYXRlZCIsImlzQ29uZmlnQWN0aXZlIiwidXBkYXRlTGF5ZXJEb21haW4iLCJzZXRJbml0aWFsTGF5ZXJDb25maWciLCJyZXN1bHQiLCJmaW5kRGVmYXVsdExheWVyUHJvcHMiLCJBcnJheSIsImlzQXJyYXkiLCJuZXdUeXBlIiwib2xkSWQiLCJDb25zb2xlIiwiZXJyb3IiLCJhc3NpZ25Db25maWdUb0xheWVyIiwidmlzQ29uZmlnU2V0dGluZ3MiLCJpc0xheWVySG92ZXJlZCIsInNldHRpbmdzIiwib2xkTGF5ZXJNYXAiLCJvdGhlckxheWVycyIsImxheWVySWQiLCJ1cGRhdGVMYXllclZpc3VhbENoYW5uZWwiLCJuZXdWaXNDb25maWciLCJzZXRGaWx0ZXJBbmltYXRpb25UaW1lVXBkYXRlciIsInNldEZpbHRlclVwZGF0ZXIiLCJzZXRGaWx0ZXJBbmltYXRpb25XaW5kb3dVcGRhdGVyIiwiYW5pbWF0aW9uV2luZG93IiwidmFsdWVJbmRleCIsIm9sZEZpbHRlciIsIm5ld0ZpbHRlciIsImRhdGFzZXRJZHMiLCJGSUxURVJfVVBEQVRFUl9QUk9QUyIsImRhdGFzZXRJZCIsIm1lcmdlRG9tYWluIiwidXBkYXRlZEZpbHRlciIsIm5ld0RhdGFzZXQiLCJncHUiLCJsYXllcklkRGlmZmVyZW5jZSIsImxheWVyRGF0YUlkcyIsImxpZCIsIm5ld0RhdGFJZHMiLCJlbmxhcmdlZEZpbHRlciIsInZpZXciLCJGSUxURVJfVklFV19UWVBFUyIsImVubGFyZ2VkIiwic2lkZSIsImRhdGFzZXRJZHNUb0ZpbHRlciIsIkxJTUlURURfRklMVEVSX0VGRkVDVF9QUk9QUyIsImZpbHRlcmVkRGF0YXNldHMiLCJ1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEiLCJzZXRGaWx0ZXJQbG90VXBkYXRlciIsIm5ld1Byb3AiLCJwbG90VHlwZSIsImFkZEZpbHRlclVwZGF0ZXIiLCJsYXllckNvbG9yVUlDaGFuZ2VVcGRhdGVyIiwib2xkVml4Q29uZmlnIiwidXBkYXRlTGF5ZXJDb2xvclVJIiwidG9nZ2xlRmlsdGVyQW5pbWF0aW9uVXBkYXRlciIsInRvZ2dsZUxheWVyQW5pbWF0aW9uVXBkYXRlciIsInRvZ2dsZUxheWVyQW5pbWF0aW9uQ29udHJvbFVwZGF0ZXIiLCJ1cGRhdGVGaWx0ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXIiLCJzZXRMYXllckFuaW1hdGlvblRpbWVVcGRhdGVyIiwidXBkYXRlTGF5ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXIiLCJzZXRGaWx0ZXJWaWV3VXBkYXRlciIsInNob3VsZFJlc2V0T3RoZXJGaWx0ZXJzVmlldyIsInRvZ2dsZUZpbHRlckZlYXR1cmVVcGRhdGVyIiwicmVtb3ZlRmlsdGVyVXBkYXRlciIsIm5ld0ZpbHRlcnMiLCJuZXdFZGl0b3IiLCJhZGRMYXllclVwZGF0ZXIiLCJuZXdMYXllckRhdGEiLCJ3YXJuIiwiZGVmYXVsdERhdGFzZXQiLCJMYXllciIsInJlbW92ZUxheWVyVXBkYXRlciIsIk51bWJlciIsImlzRmluaXRlIiwibGF5ZXJUb1JlbW92ZSIsInJlb3JkZXJMYXllclVwZGF0ZXIiLCJvcmRlciIsImR1cGxpY2F0ZUxheWVyVXBkYXRlciIsIm9yaWdpbmFsIiwib3JpZ2luYWxMYXllck9yZGVySWR4IiwibmV3TGFiZWwiLCJwb3N0Zml4IiwiTEFZRVJfSURfTEVOR1RIIiwibmV3TGF5ZXJPcmRlciIsImFkZEVmZmVjdFVwZGF0ZXIiLCJuZXdFZmZlY3QiLCJlZmZlY3QiLCJzZXRQcm9wcyIsInJlbW92ZUVmZmVjdFVwZGF0ZXIiLCJlZmZlY3RUb1JlbW92ZSIsImVmZmVjdElkIiwicmVvcmRlckVmZmVjdFVwZGF0ZXIiLCJ1cGRhdGVFZmZlY3RVcGRhdGVyIiwiaWR4MiIsImVmZmVjdE9yZGVySWQiLCJuZXdFZmZlY3RzIiwicmVtb3ZlRGF0YXNldFVwZGF0ZXIiLCJkYXRhc2V0S2V5IiwibmV3RGF0YXNldHMiLCJsYXllcnNUb1JlbW92ZSIsInJlZHVjZSIsImFjY3UiLCJyZW1vdmVEYXRhc2V0RnJvbUludGVyYWN0aW9uQ29uZmlnIiwiZmllbGRzIiwidXBkYXRlTGF5ZXJCbGVuZGluZ1VwZGF0ZXIiLCJ1cGRhdGVPdmVybGF5QmxlbmRpbmdVcGRhdGVyIiwic2hvd0RhdGFzZXRUYWJsZVVwZGF0ZXIiLCJ1cGRhdGVUYWJsZUNvbG9yVXBkYXRlciIsInVwZGF0ZURhdGFzZXRQcm9wc1VwZGF0ZXIiLCJjb2xvciIsIm5ld0NvbG9yIiwicmVzZXRNYXBDb25maWdVcGRhdGVyIiwiaW5pdGlhbFN0YXRlIiwicmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIiLCJwYXlsb2FkIiwib3B0aW9ucyIsInZpc1N0YXRlIiwia2VlcEV4aXN0aW5nQ29uZmlnIiwibWVyZ2VkU3RhdGUiLCJtZXJnZXIiLCJtZXJnZSIsInRvTWVyZ2VQcm9wIiwibGF5ZXJIb3ZlclVwZGF0ZXIiLCJpbmZvIiwiaW50ZXJhY3Rpb25Db25maWdDaGFuZ2VVcGRhdGVyIiwiY29udHJhZGljdCIsImsiLCJsYXllckNsaWNrVXBkYXRlciIsInBpbm5lZCIsInBpY2tlZCIsIm1hcENsaWNrVXBkYXRlciIsIm1vdXNlTW92ZVVwZGF0ZXIiLCJldnQiLCJ2YWx1ZXMiLCJwb2ludCIsIm1vdXNlUG9zaXRpb24iLCJsbmdMYXQiLCJ0b2dnbGVTcGxpdE1hcFVwZGF0ZXIiLCJkdXBsaWNhdGUiLCJjbG9zZVNwZWNpZmljTWFwQXRJbmRleCIsInRvZ2dsZUxheWVyRm9yTWFwVXBkYXRlciIsIm1hcEluZGV4Iiwic20iLCJ1cGRhdGVWaXNEYXRhVXBkYXRlciIsInByZXZpb3VzU3RhdGUiLCJuZXdEYXRhRW50cmllcyIsInJlc3QiLCJsYXllck1lcmdlcnMiLCJtIiwid2FpdEZvckxheWVyRGF0YSIsImRhdGFzZXRNZXJnZXJzIiwicG9zdE1lcmdlclBheWxvYWQiLCJhcHBseU1lcmdlcnNVcGRhdGVyIiwibWVyZ2VTdGF0ZVJlc3VsdCIsImFsbE1lcmdlZCIsInBvc3RNZXJnZVVwZGF0ZXIiLCJmRGF0YUlkIiwiZGF0YXNldEZpbHRlcmVkIiwiZGF0YUVtcHR5IiwibmV3TGF5ZXJzIiwiYXV0b0NyZWF0ZUxheWVycyIsImFkZERlZmF1bHRMYXllcnMiLCJ0b29sdGlwRmllbGRzIiwiYXV0b0NyZWF0ZVRvb2x0aXBzIiwiYWRkRGVmYXVsdFRvb2x0aXBzIiwidXBkYXRlZERhdGFzZXRzIiwiY29uY2F0IiwidXBkYXRlZFN0YXRlIiwicmVuYW1lRGF0YXNldFVwZGF0ZXIiLCJBTExPV0VEX1VQREFURV9EQVRBU0VUX1BST1BTIiwidmFsaWRhdGVEYXRhc2V0VXBkYXRlUHJvcHMiLCJ2YWxpZGF0ZWRQcm9wcyIsImVudHJpZXMiLCJhY2MiLCJlbnRyeSIsImV4aXN0aW5nIiwiaW5kZXhUb1JldHJpZXZlIiwibWFwTGF5ZXJzIiwibG9hZEZpbGVzVXBkYXRlciIsImZpbGVzIiwib25GaW5pc2giLCJsb2FkRmlsZXNTdWNjZXNzIiwiZnJvbSIsImluaXRpYWxGaWxlTG9hZGluZ1Byb2dyZXNzIiwiZmlsZUNhY2hlIiwiZmlsZXNUb0xvYWQiLCJsb2FkTmV4dEZpbGVVcGRhdGVyIiwibG9hZEZpbGVTdGVwU3VjY2Vzc1VwZGF0ZXIiLCJmaWxlTmFtZSIsInN0YXRlV2l0aFByb2dyZXNzIiwidXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIiLCJwcm9ncmVzcyIsInBlcmNlbnQiLCJtZXNzYWdlIiwic3RhdGVXaXRoQ2FjaGUiLCJsb2FkTmV4dEZpbGUiLCJmaWxlIiwicmVtYWluaW5nRmlsZXNUb0xvYWQiLCJtYWtlTG9hZEZpbGVUYXNrIiwiYmltYXAiLCJnZW4iLCJjb250ZW50IiwiZXJyIiwicHJvY2Vzc0ZpbGVDb250ZW50VXBkYXRlciIsInBhcnNlUHJvZ3Jlc3MiLCJwcmV2UHJvZ3Jlc3MiLCJuZXh0RmlsZUJhdGNoVXBkYXRlciIsImFjY3VtdWxhdGVkIiwiZW5kc1dpdGgiLCJkYXRhIiwiZG9uZSIsImxvYWRGaWxlc0VyclVwZGF0ZXIiLCJhcHBseUNQVUZpbHRlclVwZGF0ZXIiLCJkYXRhSWRzIiwic2V0TWFwSW5mb1VwZGF0ZXIiLCJlbXB0eSIsImRlZmF1bHRMYXllcnMiLCJmb3VuZExheWVycyIsIm1lcmdlZCIsImluZGV4IiwiZml4ZWREb21haW4iLCJwdXNoIiwiYW5pbWF0YWJsZUxheWVycyIsImFuaW1hdGlvbkRvbWFpbiIsIm1lcmdlZERvbWFpbiIsIk1hdGgiLCJtaW4iLCJtYXgiLCJJbmZpbml0eSIsInNldEVkaXRvck1vZGVVcGRhdGVyIiwic2V0RmVhdHVyZXNVcGRhdGVyIiwibGFzdEZlYXR1cmUiLCJwcm9wZXJ0aWVzIiwiaXNDbG9zZWQiLCJFRElUIiwiZmVhdHVyZSIsImZpbHRlcklkIiwiYmJveCIsImZlYXR1cmVWYWx1ZSIsImZpbHRlcklkeCIsImZpbCIsInNldFNlbGVjdGVkRmVhdHVyZVVwZGF0ZXIiLCJzZWxlY3Rpb25Db250ZXh0IiwiZGVsZXRlRmVhdHVyZVVwZGF0ZXIiLCJzZXRQb2x5Z29uRmlsdGVyTGF5ZXJVcGRhdGVyIiwibm9uZUZpbHRlckZlYXR1cmUiLCJpc0xheWVySW5jbHVkZWQiLCJzb3J0VGFibGVDb2x1bW5VcGRhdGVyIiwiY29sdW1uIiwic29ydE1vZGUiLCJjdXJyZW50TW9kZSIsIlNPUlRfT1JERVIiLCJBU0NFTkRJTkciLCJzb3J0ZWQiLCJwaW5UYWJsZUNvbHVtblVwZGF0ZXIiLCJjb3B5VGFibGVDb2x1bW5VcGRhdGVyIiwiZmllbGRJZHgiLCJ0ZXh0IiwiZGF0YUNvbnRhaW5lciIsInJvdyIsInZhbHVlQXQiLCJqb2luIiwic2V0Q29sdW1uRGlzcGxheUZvcm1hdFVwZGF0ZXIiLCJmb3JtYXRzIiwiZGlzcGxheUZvcm1hdCIsInRvZ2dsZUVkaXRvclZpc2liaWxpdHlVcGRhdGVyIiwic2V0RmlsdGVyQW5pbWF0aW9uVGltZUNvbmZpZ1VwZGF0ZXIiLCJGSUxURVJfVFlQRVMiLCJ0aW1lUmFuZ2UiLCJ1cGRhdGVzIiwiY2hlY2tUaW1lQ29uZmlnQXJncyIsImFsbG93ZWQiLCJzZXRMYXllckFuaW1hdGlvblRpbWVDb25maWdVcGRhdGVyIiwiZGVmYXVsdFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzIiwiZGF0YUlkVG9SZXBsYWNlIiwicmVwbGFjZWQiLCJ2IiwiZmluZENoaWxkRGF0YXNldElkcyIsImNoaWxkRGF0YUlkcyIsIm1vdmVWYWx1ZVRvQmVNZXJnZWQiLCJwcm9wVmFsdWVzIiwic2F2ZVVubWVyZ2VkIiwic3RhdGVSZW1vdmVkIiwicHJvcFZhbHVlIiwicCIsInRvQmVNZXJnZWQiLCJyZXBsYWNlRGF0YXNldEFuZERlcHMiLCJkYXRhSWRUb1VzZSIsInJlcGxhY2VEYXRhc2V0RGVwc0luU3RhdGUiLCJwcmVwYXJlU3RhdGVGb3JEYXRhc2V0UmVwbGFjZSIsInNlcmlhbGl6ZWRTdGF0ZSIsInByZXNlcnZlTGF5ZXJPcmRlciIsInByZXNlcnZlRGF0YXNldE9yZGVyIiwiYWNjdVN0YXRlIiwicmVwbGFjZVBhcmVudERhdGFzZXRJZHMiLCJnZXRDaGlsZERhdGFzZXRJZHMiLCJwcmVzZXJ2ZU9yZGVyIiwidG9NZXJnZVByb3BzIiwic2F2ZWRQcm9wcyIsInJlcGxhY2VkU3RhdGUiLCJtZXJnZXJPcHRpb25zIiwicmVwbGFjZWRJdGVtIiwicmVwbGFjZVByb3BWYWx1ZUluU3RhdGUiLCJpdGVtIiwiY2hpbGREYXRhSWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBbUJBOztBQTZCQTs7QUFRQTs7QUFDQTs7QUFDQTs7QUFTQTs7QUFVQTs7QUFLQTs7QUFDQTs7QUFTQTs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBLElBQU1BLGdCQUFnQixHQUFHLElBQXpCO0FBQ0E7O0FBRU8sSUFBTUMsd0JBQTJDLEdBQUc7QUFDekRDLEVBQUFBLE9BQU8sRUFBRTtBQUNQQyxJQUFBQSxFQUFFLEVBQUUsU0FERztBQUVQQyxJQUFBQSxLQUFLLEVBQUUsc0JBRkE7QUFHUEMsSUFBQUEsT0FBTyxFQUFFLElBSEY7QUFJ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dEJEO0FBd0JBLFdBQU9vZCxhQUFQO0FBQ0QsR0FwQ2UsRUFxQ2hCN1ksS0FyQ2dCLENBQWxCO0FBd0NBLFNBQU9xQyxTQUFQO0FBQ0Q7O0FBRUQsU0FBUzJXLHVCQUFULENBQ0VoWixLQURGLEVBRUUrWSxZQUZGLFVBSUU7QUFBQSxNQURDM1YsSUFDRCxVQURDQSxJQUNEO0FBQUEsTUFET3VLLFdBQ1AsVUFET0EsV0FDUDtBQUFBLE1BRG9COEssa0JBQ3BCLFVBRG9CQSxrQkFDcEI7QUFBQSxNQUR3Q2QsWUFDeEMsVUFEd0NBLFlBQ3hDO0FBQ0E7QUFDQTtBQUNBLE1BQUl0VixTQUFTLEdBQUdvVixtQkFBbUIsQ0FBQ3pYLEtBQUQsRUFBUStZLFlBQVIsRUFBc0I7QUFBQzNWLElBQUFBLElBQUksRUFBSkEsSUFBRDtBQUFPdUssSUFBQUEsV0FBVyxFQUFYQSxXQUFQO0FBQW9CZ0ssSUFBQUEsWUFBWSxFQUFaQTtBQUFwQixHQUF0QixDQUFuQztBQUNBLE1BQU1ILFlBQVksR0FBRyxDQUFBaUIsa0JBQWtCLFNBQWxCLElBQUFBLGtCQUFrQixXQUFsQixZQUFBQSxrQkFBa0IsQ0FBR00sWUFBSCxDQUFsQixLQUFzQ3hCLG1CQUFtQixDQUFDd0IsWUFBRCxDQUE5RTs7QUFFQSxNQUFJdkIsWUFBSixFQUFrQjtBQUNoQm5WLElBQUFBLFNBQVMsR0FBRyxvQkFBUW1WLFlBQVIsRUFBc0JsTCxNQUF0QixDQUE2QixVQUFDQyxJQUFELEVBQU8yTSxXQUFQLEVBQXVCO0FBQzlEO0FBQ0E7QUFDQSxhQUFPbEIscUJBQXFCLENBQUN6TCxJQUFELEVBQU8yTSxXQUFQLEVBQW9CQSxXQUFwQixDQUE1QjtBQUNELEtBSlcsRUFJVDdXLFNBSlMsQ0FBWjtBQUtEOztBQUNELFNBQU9BLFNBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCBiYm94IGZyb20gJ0B0dXJmL2Jib3gnO1xuaW1wb3J0IHtjb25zb2xlIGFzIENvbnNvbGV9IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IHtkaXNhYmxlU3RhY2tDYXB0dXJpbmcsIHdpdGhUYXNrfSBmcm9tICdyZWFjdC1wYWxtL3Rhc2tzJztcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoLmNsb25lZGVlcCc7XG5pbXBvcnQgdW5pcSBmcm9tICdsb2Rhc2gudW5pcSc7XG5pbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC5nZXQnO1xuaW1wb3J0IHhvciBmcm9tICdsb2Rhc2gueG9yJztcbmltcG9ydCBwaWNrIGZyb20gJ2xvZGFzaC5waWNrJztcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC5pc2VxdWFsJztcbmltcG9ydCBjb3B5IGZyb20gJ2NvcHktdG8tY2xpcGJvYXJkJztcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcbi8vIFRhc2tzXG5pbXBvcnQge0xPQURfRklMRV9UQVNLLCBVTldSQVBfVEFTSywgUFJPQ0VTU19GSUxFX0RBVEEsIERFTEFZX1RBU0t9IGZyb20gJ0BrZXBsZXIuZ2wvdGFza3MnO1xuLy8gQWN0aW9uc1xuaW1wb3J0IHtcbiAgYXBwbHlMYXllckNvbmZpZyxcbiAgbGF5ZXJDb25maWdDaGFuZ2UsXG4gIGxheWVyVHlwZUNoYW5nZSxcbiAgbGF5ZXJWaXNDb25maWdDaGFuZ2UsXG4gIGxheWVyVmlzdWFsQ2hhbm5lbENvbmZpZ0NoYW5nZSxcbiAgbG9hZEZpbGVzRXJyLFxuICBsb2FkRmlsZXNTdWNjZXNzLFxuICBsb2FkRmlsZVN0ZXBTdWNjZXNzLFxuICBsb2FkTmV4dEZpbGUsXG4gIG5leHRGaWxlQmF0Y2gsXG4gIFJlY2VpdmVNYXBDb25maWdQYXlsb2FkLFxuICBWaXNTdGF0ZUFjdGlvbnMsXG4gIE1hcFN0YXRlQWN0aW9ucyxcbiAgcHJvY2Vzc0ZpbGVDb250ZW50LFxuICBBY3Rpb25UeXBlc1xufSBmcm9tICdAa2VwbGVyLmdsL2FjdGlvbnMnO1xuXG4vLyBVdGlsc1xuaW1wb3J0IHtcbiAgc2V0LFxuICB0b0FycmF5LFxuICBhcnJheUluc2VydCxcbiAgZ2VuZXJhdGVIYXNoSWQsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzT2JqZWN0LFxuICBhZGROZXdMYXllcnNUb1NwbGl0TWFwLFxuICBjb21wdXRlU3BsaXRNYXBMYXllcnMsXG4gIHJlbW92ZUxheWVyRnJvbVNwbGl0TWFwcyxcbiAgaXNSZ2JDb2xvcixcbiAgcGFyc2VGaWVsZFZhbHVlLFxuICBhcHBseUZpbHRlckZpZWxkTmFtZSxcbiAgYXBwbHlGaWx0ZXJzVG9EYXRhc2V0cyxcbiAgZmVhdHVyZVRvRmlsdGVyVmFsdWUsXG4gIGZpbHRlckRhdGFzZXRDUFUsXG4gIEZJTFRFUl9VUERBVEVSX1BST1BTLFxuICBnZW5lcmF0ZVBvbHlnb25GaWx0ZXIsXG4gIGdldERlZmF1bHRGaWx0ZXIsXG4gIGdldEZpbHRlcklkSW5GZWF0dXJlLFxuICBnZXRUaW1lV2lkZ2V0VGl0bGVGb3JtYXR0ZXIsXG4gIGlzSW5SYW5nZSxcbiAgTElNSVRFRF9GSUxURVJfRUZGRUNUX1BST1BTLFxuICB1cGRhdGVGaWx0ZXJEYXRhSWQsXG4gIGdldEZpbHRlclBsb3QsXG4gIGdldERlZmF1bHRGaWx0ZXJQbG90VHlwZVxufSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcblxuLy8gTWVyZ2Vyc1xuaW1wb3J0IHtcbiAgVklTX1NUQVRFX01FUkdFUlMsXG4gIHZhbGlkYXRlTGF5ZXJXaXRoRGF0YSxcbiAgY3JlYXRlTGF5ZXJGcm9tQ29uZmlnLFxuICBzZXJpYWxpemVMYXllcixcbiAgc2VyaWFsaXplVmlzU3RhdGUsXG4gIHBhcnNlTGF5ZXJDb25maWdcbn0gZnJvbSAnLi92aXMtc3RhdGUtbWVyZ2VyJztcbmltcG9ydCB7bWVyZ2VTdGF0ZUZyb21NZXJnZXJzLCBpc1ZhbGlkTWVyZ2VyfSBmcm9tICcuL21lcmdlci1oYW5kbGVyJztcbmltcG9ydCB7TGF5ZXIsIExheWVyQ2xhc3NlcywgTEFZRVJfSURfTEVOR1RIfSBmcm9tICdAa2VwbGVyLmdsL2xheWVycyc7XG5pbXBvcnQge1xuICBFRElUT1JfTU9ERVMsXG4gIFNPUlRfT1JERVIsXG4gIEZJTFRFUl9UWVBFUyxcbiAgRklMVEVSX1ZJRVdfVFlQRVMsXG4gIE1BWF9ERUZBVUxUX1RPT0xUSVBTLFxuICBERUZBVUxUX1RFWFRfTEFCRUwsXG4gIENPTVBBUkVfVFlQRVNcbn0gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtcbiAgcGlja18sXG4gIG1lcmdlXyxcbiAgc3dhcF8sXG4gIGFwcGx5XyxcbiAgY29tcG9zZV8sXG4gIHJlbW92ZUVsZW1lbnRBdEluZGV4LFxuICBmaWx0ZXJPdXRCeUlkXG59IGZyb20gJy4vY29tcG9zZXItaGVscGVycyc7XG5cbmltcG9ydCBLZXBsZXJHTFNjaGVtYSwge1Zpc1N0YXRlLCBNZXJnZXIsIFBvc3RNZXJnZXJQYXlsb2FkfSBmcm9tICdAa2VwbGVyLmdsL3NjaGVtYXMnO1xuXG5pbXBvcnQge0ZpbHRlciwgSW50ZXJhY3Rpb25Db25maWcsIEFuaW1hdGlvbkNvbmZpZywgRWRpdG9yLCBGaWVsZH0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0xvYWRlcn0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcblxuaW1wb3J0IHtjYWxjdWxhdGVMYXllckRhdGEsIGZpbmREZWZhdWx0TGF5ZXIsIGdldExheWVyT3JkZXJGcm9tTGF5ZXJzfSBmcm9tICcuL2xheWVyLXV0aWxzJztcbmltcG9ydCB7XG4gIGNvcHlUYWJsZUFuZFVwZGF0ZSxcbiAgRGF0YXNldHMsXG4gIHBpblRhYmxlQ29sdW1ucyxcbiAgc29ydERhdGFzZXRCeUNvbHVtbixcbiAgYXNzaWduR3B1Q2hhbm5lbCxcbiAgc2V0RmlsdGVyR3B1TW9kZSxcbiAgY3JlYXRlTmV3RGF0YUVudHJ5XG59IGZyb20gJ0BrZXBsZXIuZ2wvdGFibGUnO1xuaW1wb3J0IHtmaW5kRmllbGRzVG9TaG93fSBmcm9tICcuL2ludGVyYWN0aW9uLXV0aWxzJztcbmltcG9ydCB7aGFzUHJvcHNUb01lcmdlLCBnZXRQcm9wVmFsdWVUb01lcmdlcn0gZnJvbSAnLi9tZXJnZXItaGFuZGxlcic7XG5pbXBvcnQge21lcmdlRGF0YXNldHNCeU9yZGVyfSBmcm9tICcuL3Zpcy1zdGF0ZS1tZXJnZXInO1xuaW1wb3J0IHtmaXhFZmZlY3RPcmRlcn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQge2NyZWF0ZUVmZmVjdH0gZnJvbSAnQGtlcGxlci5nbC9lZmZlY3RzJztcblxuLy8gcmVhY3QtcGFsbVxuLy8gZGlzYWJsZSBjYXB0dXJlIGV4Y2VwdGlvbiBmb3IgcmVhY3QtcGFsbSBjYWxsIHRvIHdpdGhUYXNrXG5kaXNhYmxlU3RhY2tDYXB0dXJpbmcoKTtcblxuLyoqXG4gKiBVcGRhdGVycyBmb3IgYHZpc1N0YXRlYCByZWR1Y2VyLiBDYW4gYmUgdXNlZCBpbiB5b3VyIHJvb3QgcmVkdWNlciB0byBkaXJlY3RseSBtb2RpZnkga2VwbGVyLmdsJ3Mgc3RhdGUuXG4gKiBSZWFkIG1vcmUgYWJvdXQgW1VzaW5nIHVwZGF0ZXJzXSguLi9hZHZhbmNlZC11c2FnZS91c2luZy11cGRhdGVycy5tZClcbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBrZXBsZXJHbFJlZHVjZXIsIHt2aXNTdGF0ZVVwZGF0ZXJzfSBmcm9tICdrZXBsZXIuZ2wvcmVkdWNlcnMnO1xuICogLy8gUm9vdCBSZWR1Y2VyXG4gKiBjb25zdCByZWR1Y2VycyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gKiAga2VwbGVyR2w6IGtlcGxlckdsUmVkdWNlcixcbiAqICBhcHA6IGFwcFJlZHVjZXJcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGNvbXBvc2VkUmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gKiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICogICAgY2FzZSAnQ0xJQ0tfQlVUVE9OJzpcbiAqICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAuLi5zdGF0ZSxcbiAqICAgICAgICBrZXBsZXJHbDoge1xuICogICAgICAgICAgLi4uc3RhdGUua2VwbGVyR2wsXG4gKiAgICAgICAgICBmb286IHtcbiAqICAgICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLmZvbyxcbiAqICAgICAgICAgICAgIHZpc1N0YXRlOiB2aXNTdGF0ZVVwZGF0ZXJzLmVubGFyZ2VGaWx0ZXJVcGRhdGVyKFxuICogICAgICAgICAgICAgICBzdGF0ZS5rZXBsZXJHbC5mb28udmlzU3RhdGUsXG4gKiAgICAgICAgICAgICAgIHtpZHg6IDB9XG4gKiAgICAgICAgICAgICApXG4gKiAgICAgICAgICB9XG4gKiAgICAgICAgfVxuICogICAgICB9O1xuICogIH1cbiAqICByZXR1cm4gcmVkdWNlcnMoc3RhdGUsIGFjdGlvbik7XG4gKiB9O1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGNvbXBvc2VkUmVkdWNlcjtcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IHZpc1N0YXRlVXBkYXRlcnMgPSBudWxsO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdEludGVyYWN0aW9uQ29uZmlnOiBJbnRlcmFjdGlvbkNvbmZpZyA9IHtcbiAgdG9vbHRpcDoge1xuICAgIGlkOiAndG9vbHRpcCcsXG4gICAgbGFiZWw6ICdpbnRlcmFjdGlvbnMudG9vbHRpcCcsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBjb25maWc6IHtcbiAgICAgIGZpZWxkc1RvU2hvdzoge30sXG4gICAgICBjb21wYXJlTW9kZTogZmFsc2UsXG4gICAgICBjb21wYXJlVHlwZTogQ09NUEFSRV9UWVBFUy5BQlNPTFVURVxuICAgIH1cbiAgfSxcbiAgZ2VvY29kZXI6IHtcbiAgICBpZDogJ2dlb2NvZGVyJyxcbiAgICBsYWJlbDogJ2ludGVyYWN0aW9ucy5nZW9jb2RlcicsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgcG9zaXRpb246IG51bGxcbiAgfSxcbiAgYnJ1c2g6IHtcbiAgICBpZDogJ2JydXNoJyxcbiAgICBsYWJlbDogJ2ludGVyYWN0aW9ucy5icnVzaCcsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgY29uZmlnOiB7XG4gICAgICAvLyBzaXplIGlzIGluIGttXG4gICAgICBzaXplOiAwLjVcbiAgICB9XG4gIH0sXG4gIGNvb3JkaW5hdGU6IHtcbiAgICBpZDogJ2Nvb3JkaW5hdGUnLFxuICAgIGxhYmVsOiAnaW50ZXJhY3Rpb25zLmNvb3JkaW5hdGUnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIHBvc2l0aW9uOiBudWxsXG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0FOSU1BVElPTl9DT05GSUc6IEFuaW1hdGlvbkNvbmZpZyA9IHtcbiAgZG9tYWluOiBudWxsLFxuICBjdXJyZW50VGltZTogbnVsbCxcbiAgc3BlZWQ6IDEsXG4gIGlzQW5pbWF0aW5nOiBmYWxzZSxcbiAgdGltZUZvcm1hdDogbnVsbCxcbiAgdGltZXpvbmU6IG51bGwsXG4gIGRlZmF1bHRUaW1lRm9ybWF0OiBudWxsLFxuICBoaWRlQ29udHJvbDogZmFsc2UsXG4gIGR1cmF0aW9uOiBudWxsXG59O1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9FRElUT1I6IEVkaXRvciA9IHtcbiAgbW9kZTogRURJVE9SX01PREVTLkRSQVdfUE9MWUdPTixcbiAgZmVhdHVyZXM6IFtdLFxuICBzZWxlY3RlZEZlYXR1cmU6IG51bGwsXG4gIHZpc2libGU6IHRydWVcbn07XG5cbi8qKlxuICogRGVmYXVsdCBpbml0aWFsIGB2aXNTdGF0ZWBcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAY29uc3RhbnRcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IElOSVRJQUxfVklTX1NUQVRFOiBWaXNTdGF0ZSA9IHtcbiAgLy8gbWFwIGluZm9cbiAgbWFwSW5mbzoge1xuICAgIHRpdGxlOiAnJyxcbiAgICBkZXNjcmlwdGlvbjogJydcbiAgfSxcbiAgLy8gbGF5ZXJzXG4gIGxheWVyczogW10sXG4gIGxheWVyRGF0YTogW10sXG4gIGxheWVyVG9CZU1lcmdlZDogW10sXG4gIGxheWVyT3JkZXI6IFtdLFxuXG4gIC8vIGZpbHRlcnNcbiAgZmlsdGVyczogW10sXG4gIGZpbHRlclRvQmVNZXJnZWQ6IFtdLFxuXG4gIC8vIGEgY29sbGVjdGlvbiBvZiBtdWx0aXBsZSBkYXRhc2V0XG4gIGRhdGFzZXRzOiB7fSxcbiAgZWRpdGluZ0RhdGFzZXQ6IHVuZGVmaW5lZCxcblxuICAvLyBlZmZlY3RzXG4gIGVmZmVjdHM6IFtdLFxuICBlZmZlY3RPcmRlcjogW10sXG5cbiAgaW50ZXJhY3Rpb25Db25maWc6IGRlZmF1bHRJbnRlcmFjdGlvbkNvbmZpZyxcbiAgaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkOiB7fSxcblxuICBsYXllckJsZW5kaW5nOiAnbm9ybWFsJyxcbiAgb3ZlcmxheUJsZW5kaW5nOiAnbm9ybWFsJyxcbiAgaG92ZXJJbmZvOiB1bmRlZmluZWQsXG4gIGNsaWNrZWQ6IHVuZGVmaW5lZCxcbiAgbW91c2VQb3M6IHt9LFxuICBtYXhEZWZhdWx0VG9vbHRpcHM6IE1BWF9ERUZBVUxUX1RPT0xUSVBTLFxuXG4gIC8vIHRoaXMgaXMgdXNlZCB3aGVuIHVzZXIgc3BsaXQgbWFwc1xuICBzcGxpdE1hcHM6IFtcbiAgICAvLyB0aGlzIHdpbGwgY29udGFpbiBhIGxpc3Qgb2Ygb2JqZWN0cyB0b1xuICAgIC8vIGRlc2NyaWJlIHRoZSBzdGF0ZSBvZiBsYXllciBhdmFpbGFiaWxpdHkgYW5kIHZpc2liaWxpdHkgZm9yIGVhY2ggbWFwXG4gICAgLy8gW1xuICAgIC8vICAge1xuICAgIC8vICAgICAgbGF5ZXJzOiB7bGF5ZXJfaWQ6IHRydWUgfCBmYWxzZX1cbiAgICAvLyAgIH1cbiAgICAvLyBdXG4gIF0sXG4gIHNwbGl0TWFwc1RvQmVNZXJnZWQ6IFtdLFxuICBpc01lcmdpbmdEYXRhc2V0czoge30sXG4gIC8vIGRlZmF1bHRzIGxheWVyIGNsYXNzZXNcbiAgbGF5ZXJDbGFzc2VzOiBMYXllckNsYXNzZXMsXG5cbiAgLy8gZGVmYXVsdCBhbmltYXRpb25cbiAgLy8gdGltZSBpbiB1bml4IHRpbWVzdGFtcCAobWlsbGlzZWNvbmRzKSAodGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVbml4IEVwb2NoKVxuICBhbmltYXRpb25Db25maWc6IERFRkFVTFRfQU5JTUFUSU9OX0NPTkZJRyxcblxuICBlZGl0b3I6IERFRkFVTFRfRURJVE9SLFxuXG4gIGZpbGVMb2FkaW5nOiBmYWxzZSxcbiAgZmlsZUxvYWRpbmdQcm9ncmVzczoge30sXG5cbiAgbG9hZGVyczogW10sXG4gIGxvYWRPcHRpb25zOiB7fSxcblxuICAvLyB2aXNTdGF0ZU1lcmdlcnNcbiAgbWVyZ2VyczogVklTX1NUQVRFX01FUkdFUlMsXG5cbiAgLy8ga2VwbGVyIHNjaGVtYXNcbiAgc2NoZW1hOiBLZXBsZXJHTFNjaGVtYVxufTtcblxudHlwZSBVcGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGFUeXBlID0ge1xuICBsYXllcnM6IExheWVyW107XG4gIGxheWVyRGF0YTogYW55W107XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBzdGF0ZSB3aXRoIHVwZGF0ZWQgbGF5ZXIgYW5kIGxheWVyRGF0YVxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YTxTIGV4dGVuZHMgVXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhVHlwZT4oXG4gIHN0YXRlOiBTLFxuICB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fToge2xheWVyRGF0YT86IGFueTsgbGF5ZXI6IExheWVyOyBpZHg6IG51bWJlcn1cbik6IFMge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogc3RhdGUubGF5ZXJzLm1hcCgobHlyLCBpKSA9PiAoaSA9PT0gaWR4ID8gbGF5ZXIgOiBseXIpKSxcbiAgICBsYXllckRhdGE6IGxheWVyRGF0YVxuICAgICAgPyBzdGF0ZS5sYXllckRhdGEubWFwKChkLCBpKSA9PiAoaSA9PT0gaWR4ID8gbGF5ZXJEYXRhIDogZCkpXG4gICAgICA6IHN0YXRlLmxheWVyRGF0YVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU3RhdGVPbkxheWVyVmlzaWJpbGl0eUNoYW5nZTxTIGV4dGVuZHMgVmlzU3RhdGU+KHN0YXRlOiBTLCBsYXllcjogTGF5ZXIpOiBTIHtcbiAgbGV0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGlmIChzdGF0ZS5zcGxpdE1hcHMubGVuZ3RoKSB7XG4gICAgbmV3U3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNwbGl0TWFwczogbGF5ZXIuY29uZmlnLmlzVmlzaWJsZVxuICAgICAgICA/IGFkZE5ld0xheWVyc1RvU3BsaXRNYXAoc3RhdGUuc3BsaXRNYXBzLCBsYXllcilcbiAgICAgICAgOiByZW1vdmVMYXllckZyb21TcGxpdE1hcHMoc3RhdGUuc3BsaXRNYXBzLCBsYXllcilcbiAgICB9O1xuICB9XG5cbiAgaWYgKGxheWVyLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlZCkge1xuICAgIG5ld1N0YXRlID0gdXBkYXRlQW5pbWF0aW9uRG9tYWluKHN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0d28gb2JqZWN0cyAob3IgYXJyYXlzKSBhbmQgcmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBvbmx5IHRoZVxuICogcHJvcGVydGllcyB0aGF0IGhhdmUgY2hhbmdlZCBiZXR3ZWVuIHRoZSB0d28gb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gcGlja0NoYW5nZWRQcm9wczxUPihwcmV2OiBULCBuZXh0OiBUKTogUGFydGlhbDxUPiB7XG4gIGNvbnN0IGNoYW5nZWRQcm9wczogUGFydGlhbDxUPiA9IHt9O1xuICBjb25zdCBwaWNrUHJvcHNPZiA9IG9iaiA9PiB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIWNoYW5nZWRQcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc0VxdWFsKHByZXZba2V5XSwgbmV4dFtrZXldKSkge1xuICAgICAgICBjaGFuZ2VkUHJvcHNba2V5XSA9IG5leHRba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcGlja1Byb3BzT2YocHJldik7XG4gIHBpY2tQcm9wc09mKG5leHQpO1xuICByZXR1cm4gY2hhbmdlZFByb3BzO1xufVxuXG5jb25zdCBWSVNVQUxfQ0hBTk5FTF9QUk9QX1RZUEVTID0gWydmaWVsZCcsICdzY2FsZScsICdkb21haW4nLCAnYWdncmVnYXRpb24nXTtcblxuLyoqXG4gKiBBcHBseSBsYXllciBjb25maWdcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlMYXllckNvbmZpZ1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuQXBwbHlMYXllckNvbmZpZ1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge29sZExheWVySWQsIG5ld0xheWVyQ29uZmlnLCBsYXllckluZGV4fSA9IGFjdGlvbjtcbiAgY29uc3QgbmV3UGFyc2VkTGF5ZXIgPVxuICAgIC8vIHdpbGwgbW92ZSB2aXN1YWxDaGFubmVscyB0byB0aGUgY29uZmlnIHByb3BcbiAgICBwYXJzZUxheWVyQ29uZmlnKHN0YXRlLnNjaGVtYSwgbmV3TGF5ZXJDb25maWcpO1xuICBjb25zdCBvbGRMYXllciA9IHN0YXRlLmxheWVycy5maW5kKGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXJJZCk7XG4gIGlmICghb2xkTGF5ZXIgfHwgIW5ld1BhcnNlZExheWVyKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGlmIChsYXllckluZGV4ICE9PSBudWxsICYmIGxheWVySW5kZXggIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS5sYXllcnNbbGF5ZXJJbmRleF0gIT09IG9sZExheWVyKSB7XG4gICAgLy8gbGF5ZXJJbmRleCBpcyBwcm92aWRlZCwgYnV0IGl0IGRvZXNuJ3QgbWF0Y2ggdGhlIG9sZExheWVyXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IGRhdGFzZXQgPSBzdGF0ZS5kYXRhc2V0c1tuZXdQYXJzZWRMYXllci5jb25maWcuZGF0YUlkXTtcbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXIgaXMgdmFsaWQgYW5kIGNvbnZlcnQgaXQgdG8gTGF5ZXJcbiAgY29uc3QgbmV3TGF5ZXIgPSB2YWxpZGF0ZUxheWVyV2l0aERhdGEoZGF0YXNldCwgbmV3UGFyc2VkTGF5ZXIsIHN0YXRlLmxheWVyQ2xhc3Nlcyk7XG4gIGlmICghbmV3TGF5ZXIpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBsZXQgbmV4dFN0YXRlID0gc3RhdGU7XG5cbiAgaWYgKG5ld0xheWVyLnR5cGUgJiYgbmV3TGF5ZXIudHlwZSAhPT0gb2xkTGF5ZXIudHlwZSkge1xuICAgIGNvbnN0IG9sZExheWVySW5kZXggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXJJZCk7XG4gICAgaWYgKG9sZExheWVySW5kZXggPj0gMCkge1xuICAgICAgbmV4dFN0YXRlID0gbGF5ZXJUeXBlQ2hhbmdlVXBkYXRlcihuZXh0U3RhdGUsIGxheWVyVHlwZUNoYW5nZShvbGRMYXllciwgbmV3TGF5ZXIudHlwZSkpO1xuICAgICAgLy8gbGF5ZXJUeXBlQ2hhbmdlVXBkYXRlciBjaGFuZ2VzIHRoZSBpZCBvZiB0aGUgbGF5ZXIsIHNvIHdlIG5lZWQgdG8gb2J0YWluIHRoZSBuZXcgaWRcbiAgICAgIC8vIGJ1dCBmaXJzdCBtYWtlIHN1cmUgdGhhdCB0aGUgbGF5ZXIgd2FzIG5vdCByZW1vdmVkXG4gICAgICBpZiAobmV4dFN0YXRlLmxheWVycy5sZW5ndGggPT09IHN0YXRlLmxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbmV3TGF5ZXJJZCA9IG5leHRTdGF0ZS5sYXllcnNbb2xkTGF5ZXJJbmRleF0uaWQ7XG4gICAgICAgIG5leHRTdGF0ZSA9IGFwcGx5TGF5ZXJDb25maWdVcGRhdGVyKFxuICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICBhcHBseUxheWVyQ29uZmlnKG5ld0xheWVySWQsIHsuLi5uZXdMYXllckNvbmZpZywgaWQ6IG5ld0xheWVySWR9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9XG5cbiAgLy8gc2VyaWFsaXplTGF5ZXIoKSBtaWdodCByZXR1cm4gbnVsbCBpZiB0aGUgb2xkIGxheWVyIGlzIG5vdCB2YWxpZCxcbiAgLy8gd2Ugc2hvdWxkIHN0aWxsIGFwcGx5IHRoZSBjaGFuZ2VzIGluIHRoYXQgY2FzZVxuICBjb25zdCBzZXJpYWxpemVkT2xkTGF5ZXIgPSBzZXJpYWxpemVMYXllcihvbGRMYXllciwgc3RhdGUuc2NoZW1hKSA/PyB7Y29uZmlnOiB7fX07XG4gIGNvbnN0IHNlcmlhbGl6ZWROZXdMYXllciA9IHNlcmlhbGl6ZUxheWVyKG5ld0xheWVyLCBzdGF0ZS5zY2hlbWEpO1xuICBpZiAoIXNlcmlhbGl6ZWROZXdMYXllcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAoIWlzRXF1YWwoc2VyaWFsaXplZE9sZExheWVyLCBzZXJpYWxpemVkTmV3TGF5ZXIpKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHBpY2tDaGFuZ2VkUHJvcHMoc2VyaWFsaXplZE9sZExheWVyLmNvbmZpZywgc2VyaWFsaXplZE5ld0xheWVyLmNvbmZpZyk7XG5cbiAgICBpZiAoJ3Zpc0NvbmZpZycgaW4gY2hhbmdlZCkge1xuICAgICAgaWYgKGNoYW5nZWQudmlzQ29uZmlnKSB7XG4gICAgICAgIG5leHRTdGF0ZSA9IGxheWVyVmlzQ29uZmlnQ2hhbmdlVXBkYXRlcihcbiAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgbGF5ZXJWaXNDb25maWdDaGFuZ2Uob2xkTGF5ZXIsIGNoYW5nZWQudmlzQ29uZmlnKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGNoYW5nZWQudmlzQ29uZmlnO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKG9sZExheWVyLnZpc3VhbENoYW5uZWxzKS5mb3JFYWNoKGNoYW5uZWxOYW1lID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBvbGRMYXllci52aXN1YWxDaGFubmVsc1tjaGFubmVsTmFtZV07XG4gICAgICBjb25zdCBjaGFubmVsUHJvcE5hbWVzID0gVklTVUFMX0NIQU5ORUxfUFJPUF9UWVBFUy5tYXAocHJvcCA9PiBjaGFubmVsW3Byb3BdKTtcbiAgICAgIGlmIChjaGFubmVsUHJvcE5hbWVzLnNvbWUocHJvcCA9PiBwcm9wIGluIGNoYW5nZWQpKSB7XG4gICAgICAgIG5leHRTdGF0ZSA9IGxheWVyVmlzdWFsQ2hhbm5lbENoYW5nZVVwZGF0ZXIoXG4gICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgIGxheWVyVmlzdWFsQ2hhbm5lbENvbmZpZ0NoYW5nZShcbiAgICAgICAgICAgIG9sZExheWVyLFxuICAgICAgICAgICAgcGljayhuZXdMYXllci5jb25maWcsIGNoYW5uZWxQcm9wTmFtZXMpLFxuICAgICAgICAgICAgY2hhbm5lbE5hbWVcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBjaGFubmVsUHJvcE5hbWVzKSB7XG4gICAgICAgICAgZGVsZXRlIGNoYW5nZWRbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhjaGFuZ2VkKS5sZW5ndGggPiAwKSB7XG4gICAgICBuZXh0U3RhdGUgPSBsYXllckNvbmZpZ0NoYW5nZVVwZGF0ZXIoXG4gICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgbGF5ZXJDb25maWdDaGFuZ2Uob2xkTGF5ZXIsIHBpY2sobmV3TGF5ZXIuY29uZmlnLCBPYmplY3Qua2V5cyhjaGFuZ2VkKSkpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0U3RhdGU7XG59XG5cbi8qKlxuICogVXBkYXRlIGxheWVyIGJhc2UgY29uZmlnOiBkYXRhSWQsIGxhYmVsLCBjb2x1bW4sIGlzVmlzaWJsZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5MYXllckNvbmZpZ0NoYW5nZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge29sZExheWVyfSA9IGFjdGlvbjtcbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZExheWVyLmlkKTtcbiAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhhY3Rpb24ubmV3Q29uZmlnKTtcbiAgaWYgKFxuICAgIHR5cGVvZiBhY3Rpb24ubmV3Q29uZmlnLmRhdGFJZCA9PT0gJ3N0cmluZycgJiZcbiAgICBhY3Rpb24ubmV3Q29uZmlnLmRhdGFJZCAhPT0gb2xkTGF5ZXIuY29uZmlnLmRhdGFJZFxuICApIHtcbiAgICBjb25zdCB7ZGF0YUlkLCAuLi5yZXN0Q29uZmlnfSA9IGFjdGlvbi5uZXdDb25maWc7XG4gICAgY29uc3Qgc3RhdGVXaXRoRGF0YUlkID0gbGF5ZXJEYXRhSWRDaGFuZ2VVcGRhdGVyKHN0YXRlLCB7XG4gICAgICBvbGRMYXllcixcbiAgICAgIG5ld0NvbmZpZzoge2RhdGFJZH1cbiAgICB9KTtcbiAgICBjb25zdCBuZXh0TGF5ZXIgPSBzdGF0ZVdpdGhEYXRhSWQubGF5ZXJzLmZpbmQobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG4gICAgcmV0dXJuIG5leHRMYXllciAmJiBPYmplY3Qua2V5cyhyZXN0Q29uZmlnKS5sZW5ndGhcbiAgICAgID8gbGF5ZXJDb25maWdDaGFuZ2VVcGRhdGVyKHN0YXRlV2l0aERhdGFJZCwge29sZExheWVyOiBuZXh0TGF5ZXIsIG5ld0NvbmZpZzogcmVzdENvbmZpZ30pXG4gICAgICA6IHN0YXRlV2l0aERhdGFJZDtcbiAgfVxuXG4gIGxldCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29uZmlnKGFjdGlvbi5uZXdDb25maWcpO1xuXG4gIGxldCBsYXllckRhdGE7XG5cbiAgaWYgKG5ld0xheWVyLnNob3VsZENhbGN1bGF0ZUxheWVyRGF0YShwcm9wcykpIHtcbiAgICBjb25zdCBvbGRMYXllckRhdGEgPSBzdGF0ZS5sYXllckRhdGFbaWR4XTtcblxuICAgIGNvbnN0IHVwZGF0ZUxheWVyRGF0YVJlc3VsdCA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgc3RhdGUsIG9sZExheWVyRGF0YSk7XG4gICAgbmV3TGF5ZXIgPSB1cGRhdGVMYXllckRhdGFSZXN1bHQubGF5ZXI7XG4gICAgbGF5ZXJEYXRhID0gdXBkYXRlTGF5ZXJEYXRhUmVzdWx0LmxheWVyRGF0YTtcbiAgfVxuXG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBpZiAoJ2lzVmlzaWJsZScgaW4gYWN0aW9uLm5ld0NvbmZpZykge1xuICAgIG5ld1N0YXRlID0gdXBkYXRlU3RhdGVPbkxheWVyVmlzaWJpbGl0eUNoYW5nZShzdGF0ZSwgbmV3TGF5ZXIpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShuZXdTdGF0ZSwge1xuICAgIGxheWVyOiBuZXdMYXllcixcbiAgICBsYXllckRhdGEsXG4gICAgaWR4XG4gIH0pO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgaXNWYWxpZCBmbGFnIG9mIGEgbGF5ZXIuXG4gKiBVcGRhdGVzIGlzVmlzaWJsZSBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgaXNWYWxpZC5cbiAqIFRyaWdnZXJzIHVwZGF0ZSBvZiBkYXRhIGZvciB0aGUgbGF5ZXIgaW4gb3JkZXIgdG8gZ2V0IGVycm9ycyBhZ2FpbiBkdXJpbmcgbmV4dCB1cGRhdGUgaXRlcmF0aW9uLlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJTZXRJc1ZhbGlkVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5MYXllclNldElzVmFsaWRVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllciwgaXNWYWxpZH0gPSBhY3Rpb247XG5cbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZExheWVyLmlkKTtcbiAgY29uc3QgbGF5ZXJUb1VwZGF0ZSA9IHN0YXRlLmxheWVyc1tpZHhdO1xuICBpZiAobGF5ZXJUb1VwZGF0ZSkge1xuICAgIGxldCBuZXdMYXllcjtcbiAgICBsZXQgbmV3RGF0YSA9IG51bGw7XG5cbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgLy8gVHJpZ2dlciBkYXRhIHVwZGF0ZSBpbiBvcmRlciB0byBzaG93IGVycm9ycyBhZ2FpbiBpZiBwcmVzZW50LlxuICAgICAgY29uc3Qge2xheWVyLCBsYXllckRhdGF9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKGxheWVyVG9VcGRhdGUsIHN0YXRlLCB1bmRlZmluZWQpO1xuICAgICAgbmV3TGF5ZXIgPSBsYXllcjtcbiAgICAgIG5ld0RhdGEgPSBsYXllckRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0xheWVyID0gbGF5ZXJUb1VwZGF0ZS51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgICAgIGlzVmlzaWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgbmV3TGF5ZXIuaXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtpZHgsIGxheWVyOiBuZXdMYXllciwgbGF5ZXJEYXRhOiBuZXdEYXRhfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGFkZE9yUmVtb3ZlVGV4dExhYmVscyhuZXdGaWVsZHMsIHRleHRMYWJlbCwgZGVmYXVsdFRleHRMYWJlbCA9IERFRkFVTFRfVEVYVF9MQUJFTCkge1xuICBsZXQgbmV3VGV4dExhYmVsID0gdGV4dExhYmVsLnNsaWNlKCk7XG5cbiAgY29uc3QgY3VycmVudEZpZWxkcyA9IHRleHRMYWJlbC5tYXAodGwgPT4gdGwuZmllbGQgJiYgdGwuZmllbGQubmFtZSkuZmlsdGVyKGQgPT4gZCk7XG5cbiAgY29uc3QgYWRkRmllbGRzID0gbmV3RmllbGRzLmZpbHRlcihmID0+ICFjdXJyZW50RmllbGRzLmluY2x1ZGVzKGYubmFtZSkpO1xuICBjb25zdCBkZWxldGVGaWVsZHMgPSBjdXJyZW50RmllbGRzLmZpbHRlcihmID0+ICFuZXdGaWVsZHMuZmluZChmZCA9PiBmZC5uYW1lID09PSBmKSk7XG5cbiAgLy8gZGVsZXRlXG4gIG5ld1RleHRMYWJlbCA9IG5ld1RleHRMYWJlbC5maWx0ZXIodGwgPT4gdGwuZmllbGQgJiYgIWRlbGV0ZUZpZWxkcy5pbmNsdWRlcyh0bC5maWVsZC5uYW1lKSk7XG4gIG5ld1RleHRMYWJlbCA9ICFuZXdUZXh0TGFiZWwubGVuZ3RoID8gW2RlZmF1bHRUZXh0TGFiZWxdIDogbmV3VGV4dExhYmVsO1xuXG4gIC8vIGFkZFxuICBuZXdUZXh0TGFiZWwgPSBbXG4gICAgLi4ubmV3VGV4dExhYmVsLmZpbHRlcih0bCA9PiB0bC5maWVsZCksXG4gICAgLi4uYWRkRmllbGRzLm1hcChhZiA9PiAoe1xuICAgICAgLi4uZGVmYXVsdFRleHRMYWJlbCxcbiAgICAgIGZpZWxkOiBhZlxuICAgIH0pKVxuICBdO1xuXG4gIHJldHVybiBuZXdUZXh0TGFiZWw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRleHRMYWJlbFByb3BBbmRWYWx1ZShpZHgsIHByb3AsIHZhbHVlLCB0ZXh0TGFiZWwpIHtcbiAgaWYgKCF0ZXh0TGFiZWxbaWR4XS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgIHJldHVybiB0ZXh0TGFiZWw7XG4gIH1cblxuICBsZXQgbmV3VGV4dExhYmVsID0gdGV4dExhYmVsLnNsaWNlKCk7XG5cbiAgaWYgKHByb3AgPT09ICdmaWVsZCcgJiYgdmFsdWUgPT09IG51bGwgJiYgdGV4dExhYmVsLmxlbmd0aCA+IDEpIHtcbiAgICAvLyByZW1vdmUgbGFiZWwgd2hlbiBmaWVsZCB2YWx1ZSBpcyBzZXQgdG8gbnVsbFxuICAgIG5ld1RleHRMYWJlbC5zcGxpY2UoaWR4LCAxKTtcbiAgfSBlbHNlIGlmIChwcm9wKSB7XG4gICAgbmV3VGV4dExhYmVsID0gdGV4dExhYmVsLm1hcCgodGwsIGkpID0+IChpID09PSBpZHggPyB7Li4udGwsIFtwcm9wXTogdmFsdWV9IDogdGwpKTtcbiAgfVxuXG4gIHJldHVybiBuZXdUZXh0TGFiZWw7XG59XG5cbi8qKlxuICogVXBkYXRlIGxheWVyIGJhc2UgY29uZmlnOiBkYXRhSWQsIGxhYmVsLCBjb2x1bW4sIGlzVmlzaWJsZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJUZXh0TGFiZWxDaGFuZ2VVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxheWVyVGV4dExhYmVsQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7b2xkTGF5ZXIsIGlkeCwgcHJvcCwgdmFsdWV9ID0gYWN0aW9uO1xuICBjb25zdCB7dGV4dExhYmVsfSA9IG9sZExheWVyLmNvbmZpZztcblxuICAvLyB3aGVuIGFkZGluZyBhIG5ldyBlbXB0eSB0ZXh0IGxhYmVsLFxuICAvLyByZWx5IG9uIHRoZSBsYXllcidzIGRlZmF1bHQgY29uZmlnLCBvciB1c2UgdGhlIGNvbnN0YW50IERFRkFVTFRfVEVYVF9MQUJFTFxuICBjb25zdCBkZWZhdWx0VGV4dExhYmVsID1cbiAgICBvbGRMYXllci5nZXREZWZhdWx0TGF5ZXJDb25maWcoe2RhdGFJZDogJyd9KT8udGV4dExhYmVsPy5bMF0gPz8gREVGQVVMVF9URVhUX0xBQkVMO1xuXG4gIGxldCBuZXdUZXh0TGFiZWwgPSB0ZXh0TGFiZWwuc2xpY2UoKTtcbiAgaWYgKCF0ZXh0TGFiZWxbaWR4XSAmJiBpZHggPT09IHRleHRMYWJlbC5sZW5ndGgpIHtcbiAgICAvLyBpZiBpZHggaXMgc2V0IHRvIGxlbmd0aCwgYWRkIGVtcHR5IHRleHQgbGFiZWxcbiAgICBuZXdUZXh0TGFiZWwgPSBbLi4udGV4dExhYmVsLCBkZWZhdWx0VGV4dExhYmVsXTtcbiAgfVxuXG4gIGlmIChpZHggPT09ICdhbGwnICYmIHByb3AgPT09ICdmaWVsZHMnKSB7XG4gICAgbmV3VGV4dExhYmVsID0gYWRkT3JSZW1vdmVUZXh0TGFiZWxzKHZhbHVlLCB0ZXh0TGFiZWwsIGRlZmF1bHRUZXh0TGFiZWwpO1xuICB9IGVsc2Uge1xuICAgIG5ld1RleHRMYWJlbCA9IHVwZGF0ZVRleHRMYWJlbFByb3BBbmRWYWx1ZShpZHgsIHByb3AsIHZhbHVlLCBuZXdUZXh0TGFiZWwpO1xuICB9XG4gIC8vIHVwZGF0ZSB0ZXh0IGxhYmVsIHByb3AgYW5kIHZhbHVlXG4gIHJldHVybiBsYXllckNvbmZpZ0NoYW5nZVVwZGF0ZXIoc3RhdGUsIHtcbiAgICBvbGRMYXllcixcbiAgICBuZXdDb25maWc6IHt0ZXh0TGFiZWw6IG5ld1RleHRMYWJlbH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhpc3RpbmdMYXllcldpdGhEYXRhKGRhdGFzZXQsIGxheWVyQ2xhc3NlcywgbGF5ZXIsIHNjaGVtYSkge1xuICBjb25zdCBsb2FkZWRMYXllciA9IHNlcmlhbGl6ZUxheWVyKGxheWVyLCBzY2hlbWEpO1xuICByZXR1cm4gbG9hZGVkTGF5ZXJcbiAgICA/IHZhbGlkYXRlTGF5ZXJXaXRoRGF0YShkYXRhc2V0LCBsb2FkZWRMYXllciwgbGF5ZXJDbGFzc2VzLCB7XG4gICAgICAgIGFsbG93RW1wdHlDb2x1bW46IHRydWVcbiAgICAgIH0pXG4gICAgOiBudWxsO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBsYXllciBjb25maWcgZGF0YUlkXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllckRhdGFJZENoYW5nZVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiB7XG4gICAgb2xkTGF5ZXI6IExheWVyO1xuICAgIG5ld0NvbmZpZzoge1xuICAgICAgZGF0YUlkOiBzdHJpbmc7XG4gICAgfTtcbiAgfVxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7b2xkTGF5ZXIsIG5ld0NvbmZpZ30gPSBhY3Rpb247XG4gIGNvbnN0IHtkYXRhSWR9ID0gbmV3Q29uZmlnO1xuXG4gIGlmICghb2xkTGF5ZXIgfHwgIXN0YXRlLmRhdGFzZXRzW2RhdGFJZF0pIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZExheWVyLmlkKTtcblxuICBsZXQgbmV3TGF5ZXIgPSBvbGRMYXllci51cGRhdGVMYXllckNvbmZpZyh7ZGF0YUlkfSk7XG4gIC8vIHRoaXMgbWF5IGhhcHBlbiB3aGVuIGEgbGF5ZXIgaXMgbmV3ICh0eXBlOiBudWxsIGFuZCBubyBjb2x1bW5zKSBidXQgaXQncyBub3QgcmVhZHkgdG8gYmUgc2F2ZWRcbiAgaWYgKG5ld0xheWVyLmlzVmFsaWRUb1NhdmUoKSkge1xuICAgIGNvbnN0IHZhbGlkYXRlZCA9IHZhbGlkYXRlRXhpc3RpbmdMYXllcldpdGhEYXRhKFxuICAgICAgc3RhdGUuZGF0YXNldHNbZGF0YUlkXSxcbiAgICAgIHN0YXRlLmxheWVyQ2xhc3NlcyxcbiAgICAgIG5ld0xheWVyLFxuICAgICAgc3RhdGUuc2NoZW1hXG4gICAgKTtcbiAgICAvLyBpZiBjYW50IHZhbGlkYXRlIGl0IHdpdGggZGF0YSBjcmVhdGUgYSBuZXcgb25lXG4gICAgaWYgKCF2YWxpZGF0ZWQpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogY2hlY2tpbmcgb2xkTGF5ZXIudHlwZSAhPT0gbnVsbFxuICAgICAgbmV3TGF5ZXIgPSBuZXcgc3RhdGUubGF5ZXJDbGFzc2VzW29sZExheWVyLnR5cGVdKHtkYXRhSWQsIGlkOiBvbGRMYXllci5pZH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdMYXllciA9IHZhbGlkYXRlZDtcbiAgICB9XG4gIH1cblxuICBuZXdMYXllciA9IG5ld0xheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICBpc1Zpc2libGU6IG9sZExheWVyLmNvbmZpZy5pc1Zpc2libGUsXG4gICAgaXNDb25maWdBY3RpdmU6IHRydWVcbiAgfSk7XG5cbiAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJEb21haW4oc3RhdGUuZGF0YXNldHMpO1xuICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlLCB1bmRlZmluZWQpO1xuXG4gIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEluaXRpYWxMYXllckNvbmZpZyhsYXllciwgZGF0YXNldHMsIGxheWVyQ2xhc3Nlcyk6IExheWVyIHtcbiAgbGV0IG5ld0xheWVyID0gbGF5ZXI7XG4gIGlmICghT2JqZWN0LmtleXMoZGF0YXNldHMpLmxlbmd0aCkge1xuICAgIC8vIG5vIGRhdGEgaXMgbG9hZGVkXG4gICAgcmV0dXJuIGxheWVyO1xuICB9XG4gIGlmICghbGF5ZXIuY29uZmlnLmRhdGFJZCkge1xuICAgIC8vIHNldCBsYXllciBkYXRhSWRcbiAgICBuZXdMYXllciA9IGxheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtkYXRhSWQ6IE9iamVjdC5rZXlzKGRhdGFzZXRzKVswXX0pO1xuICB9XG4gIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tuZXdMYXllci5jb25maWcuZGF0YUlkXTtcbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIGxheWVyO1xuICB9XG5cbiAgLy8gZmluZCBkZWZhdXQgbGF5ZXIgcHJvcHNcbiAgY29uc3QgcmVzdWx0ID1cbiAgICB0eXBlb2YgbGF5ZXJDbGFzc2VzW25ld0xheWVyLnR5cGVdLmZpbmREZWZhdWx0TGF5ZXJQcm9wcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBsYXllckNsYXNzZXNbbmV3TGF5ZXIudHlwZV0uZmluZERlZmF1bHRMYXllclByb3BzKGRhdGFzZXQsIFtdKVxuICAgICAgOiB7cHJvcHM6IFtdfTtcblxuICAvLyBhbiBhcnJheSBvZiBwb3NzaWJsZSBwcm9wcywgdXNlIDFzdCBvbmVcbiAgY29uc3QgcHJvcHMgPSBBcnJheS5pc0FycmF5KHJlc3VsdCkgPyByZXN1bHQgOiByZXN1bHQucHJvcHMgfHwgW107XG5cbiAgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgIG5ld0xheWVyID0gbmV3IGxheWVyQ2xhc3Nlc1tsYXllci50eXBlXSh7XG4gICAgICAuLi5wcm9wc1swXSxcbiAgICAgIGxhYmVsOiBuZXdMYXllci5jb25maWcubGFiZWwsXG4gICAgICBkYXRhSWQ6IG5ld0xheWVyLmNvbmZpZy5kYXRhSWQsXG4gICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICBpc0NvbmZpZ0FjdGl2ZTogbmV3TGF5ZXIuY29uZmlnLmlzQ29uZmlnQWN0aXZlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHlwZW9mIG5ld0xheWVyLnNldEluaXRpYWxMYXllckNvbmZpZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBuZXdMYXllci5zZXRJbml0aWFsTGF5ZXJDb25maWcoZGF0YXNldClcbiAgICAgIDogbmV3TGF5ZXI7XG4gIH1cblxuICByZXR1cm4gbmV3TGF5ZXI7XG59XG4vKipcbiAqIFVwZGF0ZSBsYXllciB0eXBlLiBQcmV2aWV3cyBsYXllciBjb25maWcgd2lsbCBiZSBjb3BpZWQgaWYgYXBwbGljYWJsZS5cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllclR5cGVDaGFuZ2VVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxheWVyVHlwZUNoYW5nZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge29sZExheWVyLCBuZXdUeXBlfSA9IGFjdGlvbjtcbiAgaWYgKCFvbGRMYXllcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBvbGRJZCA9IG9sZExheWVyLmlkO1xuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkSWQpO1xuXG4gIGlmICghc3RhdGUubGF5ZXJDbGFzc2VzW25ld1R5cGVdKSB7XG4gICAgQ29uc29sZS5lcnJvcihgJHtuZXdUeXBlfSBpcyBub3QgYSB2YWxpZCBsYXllciB0eXBlYCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGxldCBuZXdMYXllciA9IG5ldyBzdGF0ZS5sYXllckNsYXNzZXNbbmV3VHlwZV0oe1xuICAgIC8vIGtlZXAgb2xkIGxheWVyIGxhYmxlIGFuZCBpc0NvbmZpZ0FjdGl2ZVxuICAgIGxhYmVsOiBvbGRMYXllci5jb25maWcubGFiZWwsXG4gICAgaXNDb25maWdBY3RpdmU6IG9sZExheWVyLmNvbmZpZy5pc0NvbmZpZ0FjdGl2ZSxcbiAgICBkYXRhSWQ6IG9sZExheWVyLmNvbmZpZy5kYXRhSWRcbiAgfSk7XG5cbiAgaWYgKCFvbGRMYXllci50eXBlKSB7XG4gICAgLy8gaWYgc2V0dGluZyBsYXllciB0eXBlIG9uIGFuIGVtcHR5IGxheWVyXG4gICAgbmV3TGF5ZXIgPSBzZXRJbml0aWFsTGF5ZXJDb25maWcobmV3TGF5ZXIsIHN0YXRlLmRhdGFzZXRzLCBzdGF0ZS5sYXllckNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIC8vIGdldCBhIG1pbnQgbGF5ZXIsIHdpdGggbmV3IGlkIGFuZCB0eXBlXG4gICAgLy8gYmVjYXVzZSBkZWNrLmdsIHVzZXMgaWQgdG8gbWF0Y2ggYmV0d2VlbiBuZXcgYW5kIG9sZCBsYXllci5cbiAgICAvLyBJZiB0eXBlIGhhcyBjaGFuZ2VkIGJ1dCBpZCBpcyB0aGUgc2FtZSwgaXQgd2lsbCBicmVha1xuICAgIG5ld0xheWVyLmFzc2lnbkNvbmZpZ1RvTGF5ZXIob2xkTGF5ZXIuY29uZmlnLCBvbGRMYXllci52aXNDb25maWdTZXR0aW5ncyk7XG4gICAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJEb21haW4oc3RhdGUuZGF0YXNldHMpO1xuICB9XG5cbiAgY29uc3Qge2NsaWNrZWQsIGhvdmVySW5mb30gPSBzdGF0ZTtcblxuICBsZXQgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgY2xpY2tlZDogb2xkTGF5ZXIuaXNMYXllckhvdmVyZWQoY2xpY2tlZCkgPyB1bmRlZmluZWQgOiBjbGlja2VkLFxuICAgIGhvdmVySW5mbzogb2xkTGF5ZXIuaXNMYXllckhvdmVyZWQoaG92ZXJJbmZvKSA/IHVuZGVmaW5lZCA6IGhvdmVySW5mb1xuICB9O1xuXG4gIGNvbnN0IHtsYXllckRhdGEsIGxheWVyfSA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgbmV3U3RhdGUpO1xuICBuZXdTdGF0ZSA9IHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShuZXdTdGF0ZSwge2xheWVyRGF0YSwgbGF5ZXIsIGlkeH0pO1xuXG4gIGlmIChsYXllci5jb25maWcuYW5pbWF0aW9uLmVuYWJsZWQgfHwgb2xkTGF5ZXIuY29uZmlnLmFuaW1hdGlvbi5lbmFibGVkKSB7XG4gICAgbmV3U3RhdGUgPSB1cGRhdGVBbmltYXRpb25Eb21haW4obmV3U3RhdGUpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHNwbGl0TWFwIGxheWVyIGlkXG4gIGlmIChzdGF0ZS5zcGxpdE1hcHMubGVuZ3RoKSB7XG4gICAgbmV3U3RhdGUgPSB7XG4gICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgIHNwbGl0TWFwczogbmV3U3RhdGUuc3BsaXRNYXBzLm1hcChzZXR0aW5ncyA9PiB7XG4gICAgICAgIGNvbnN0IHtbb2xkSWRdOiBvbGRMYXllck1hcCwgLi4ub3RoZXJMYXllcnN9ID0gc2V0dGluZ3MubGF5ZXJzO1xuICAgICAgICByZXR1cm4gb2xkSWQgaW4gc2V0dGluZ3MubGF5ZXJzXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICAgICAgICBsYXllcnM6IHtcbiAgICAgICAgICAgICAgICAuLi5vdGhlckxheWVycyxcbiAgICAgICAgICAgICAgICBbbGF5ZXIuaWRdOiBvbGRMYXllck1hcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBzZXR0aW5ncztcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsYXllck9yZGVyIHdpdGggbmV3IGlkXG4gIG5ld1N0YXRlID0ge1xuICAgIC4uLm5ld1N0YXRlLFxuICAgIGxheWVyT3JkZXI6IG5ld1N0YXRlLmxheWVyT3JkZXIubWFwKGxheWVySWQgPT5cbiAgICAgIGxheWVySWQgPT09IG9sZExheWVyLmlkID8gbmV3TGF5ZXIuaWQgOiBsYXllcklkXG4gICAgKVxuICB9O1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgdmlzdWFsIGNoYW5uZWxcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxheWVyVmlzdWFsQ2hhbm5lbENoYW5nZVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuTGF5ZXJWaXN1YWxDaGFubmVsQ29uZmlnQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7b2xkTGF5ZXIsIG5ld0NvbmZpZywgY2hhbm5lbH0gPSBhY3Rpb247XG4gIGlmICghb2xkTGF5ZXIuY29uZmlnLmRhdGFJZCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbb2xkTGF5ZXIuY29uZmlnLmRhdGFJZF07XG5cbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZExheWVyLmlkKTtcbiAgY29uc3QgbmV3TGF5ZXIgPSBvbGRMYXllci51cGRhdGVMYXllckNvbmZpZyhuZXdDb25maWcpO1xuXG4gIG5ld0xheWVyLnVwZGF0ZUxheWVyVmlzdWFsQ2hhbm5lbChkYXRhc2V0LCBjaGFubmVsKTtcblxuICBjb25zdCBvbGRMYXllckRhdGEgPSBzdGF0ZS5sYXllckRhdGFbaWR4XTtcbiAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCBzdGF0ZSwgb2xkTGF5ZXJEYXRhKTtcblxuICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKHN0YXRlLCB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGxheWVyIGB2aXNDb25maWdgXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJWaXNDb25maWdDaGFuZ2VVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxheWVyVmlzQ29uZmlnQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7b2xkTGF5ZXJ9ID0gYWN0aW9uO1xuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQpO1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKGFjdGlvbi5uZXdWaXNDb25maWcpO1xuICBjb25zdCBuZXdWaXNDb25maWcgPSB7XG4gICAgLi4ub2xkTGF5ZXIuY29uZmlnLnZpc0NvbmZpZyxcbiAgICAuLi5hY3Rpb24ubmV3VmlzQ29uZmlnXG4gIH07XG5cbiAgY29uc3QgbmV3TGF5ZXIgPSBvbGRMYXllci51cGRhdGVMYXllckNvbmZpZyh7dmlzQ29uZmlnOiBuZXdWaXNDb25maWd9KTtcblxuICBpZiAobmV3TGF5ZXIuc2hvdWxkQ2FsY3VsYXRlTGF5ZXJEYXRhKHByb3BzKSkge1xuICAgIGNvbnN0IG9sZExheWVyRGF0YSA9IHN0YXRlLmxheWVyRGF0YVtpZHhdO1xuICAgIGNvbnN0IHtsYXllckRhdGEsIGxheWVyfSA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgc3RhdGUsIG9sZExheWVyRGF0YSk7XG4gICAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShzdGF0ZSwge2xheWVyRGF0YSwgbGF5ZXIsIGlkeH0pO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShzdGF0ZSwge2xheWVyOiBuZXdMYXllciwgaWR4fSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGZpbHRlciBwcm9wZXJ0eVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZpbHRlckFuaW1hdGlvblRpbWVVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlNldEZpbHRlckFuaW1hdGlvblRpbWVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIHJldHVybiBzZXRGaWx0ZXJVcGRhdGVyKHN0YXRlLCBhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBmaWx0ZXIgYW5pbWF0aW9uIHdpbmRvd1xuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZpbHRlckFuaW1hdGlvbldpbmRvd1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2lkLCBhbmltYXRpb25XaW5kb3d9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0RmlsdGVyQW5pbWF0aW9uV2luZG93VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGZpbHRlcnM6IHN0YXRlLmZpbHRlcnMubWFwKGYgPT5cbiAgICAgIGYuaWQgPT09IGlkXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uZixcbiAgICAgICAgICAgIGFuaW1hdGlvbldpbmRvd1xuICAgICAgICAgIH1cbiAgICAgICAgOiBmXG4gICAgKVxuICB9O1xufVxuLyoqXG4gKiBVcGRhdGUgZmlsdGVyIHByb3BlcnR5XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RmlsdGVyVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5TZXRGaWx0ZXJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtpZHgsIHByb3AsIHZhbHVlLCB2YWx1ZUluZGV4ID0gMH0gPSBhY3Rpb247XG4gIGNvbnN0IG9sZEZpbHRlciA9IHN0YXRlLmZpbHRlcnNbaWR4XTtcblxuICBpZiAoIW9sZEZpbHRlcikge1xuICAgIENvbnNvbGUuZXJyb3IoYGZpbHRlcnMuJHtpZHh9IGlzIHVuZGVmaW5lZGApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBsZXQgbmV3RmlsdGVyID0gc2V0KFtwcm9wXSwgdmFsdWUsIG9sZEZpbHRlcik7XG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuXG4gIGNvbnN0IHtkYXRhSWR9ID0gbmV3RmlsdGVyO1xuXG4gIC8vIEVuc3VyaW5nIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgbGV0IGRhdGFzZXRJZHMgPSB0b0FycmF5KGRhdGFJZCk7XG5cbiAgc3dpdGNoIChwcm9wKSB7XG4gICAgLy8gVE9ETzogTmV4dCBQUiBmb3IgVUkgaWYgd2UgdXBkYXRlIGRhdGFJZCwgd2UgbmVlZCB0byBjb25zaWRlciB0d28gY2FzZXM6XG4gICAgLy8gMS4gZGF0YUlkIGlzIGVtcHR5OiBjcmVhdGUgYSBkZWZhdWx0IGZpbHRlclxuICAgIC8vIDIuIEFkZCBhIG5ldyBkYXRhc2V0IGlkXG4gICAgY2FzZSBGSUxURVJfVVBEQVRFUl9QUk9QUy5kYXRhSWQ6XG4gICAgICAvLyBpZiB0cnlpbmcgdG8gdXBkYXRlIGZpbHRlciBkYXRhSWQuIGNyZWF0ZSBhbiBlbXB0eSBuZXcgZmlsdGVyXG4gICAgICBuZXdGaWx0ZXIgPSB1cGRhdGVGaWx0ZXJEYXRhSWQoZGF0YUlkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBGSUxURVJfVVBEQVRFUl9QUk9QUy5uYW1lOlxuICAgICAgLy8gd2UgYXJlIHN1cHBvcnRpbmcgdGhlIGN1cnJlbnQgZnVuY3Rpb25hbGl0eVxuICAgICAgLy8gVE9ETzogTmV4dCBQUiBmb3IgVUkgZmlsdGVyIG5hbWUgd2lsbCBvbmx5IHVwZGF0ZSBmaWx0ZXIgbmFtZSBidXQgaXQgd29uJ3QgaGF2ZSBzaWRlIGVmZmVjdHNcbiAgICAgIC8vIHdlIGFyZSBnb25uYSB1c2UgcGFpciBvZiBkYXRhc2V0cyBhbmQgZmllbGRJZHggdG8gdXBkYXRlIHRoZSBmaWx0ZXJcbiAgICAgIGNvbnN0IGRhdGFzZXRJZCA9IG5ld0ZpbHRlci5kYXRhSWRbdmFsdWVJbmRleF07XG4gICAgICBjb25zdCB7ZmlsdGVyOiB1cGRhdGVkRmlsdGVyLCBkYXRhc2V0OiBuZXdEYXRhc2V0fSA9IGFwcGx5RmlsdGVyRmllbGROYW1lKFxuICAgICAgICBuZXdGaWx0ZXIsXG4gICAgICAgIHN0YXRlLmRhdGFzZXRzW2RhdGFzZXRJZF0sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YWx1ZUluZGV4LFxuICAgICAgICB7bWVyZ2VEb21haW46IGZhbHNlfVxuICAgICAgKTtcbiAgICAgIGlmICghdXBkYXRlZEZpbHRlcikge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIG5ld0ZpbHRlciA9IHVwZGF0ZWRGaWx0ZXI7XG5cbiAgICAgIGlmIChuZXdGaWx0ZXIuZ3B1KSB7XG4gICAgICAgIG5ld0ZpbHRlciA9IHNldEZpbHRlckdwdU1vZGUobmV3RmlsdGVyLCBzdGF0ZS5maWx0ZXJzKTtcbiAgICAgICAgbmV3RmlsdGVyID0gYXNzaWduR3B1Q2hhbm5lbChuZXdGaWx0ZXIsIHN0YXRlLmZpbHRlcnMpO1xuICAgICAgfVxuXG4gICAgICBuZXdTdGF0ZSA9IHNldChbJ2RhdGFzZXRzJywgZGF0YXNldElkXSwgbmV3RGF0YXNldCwgc3RhdGUpO1xuXG4gICAgICAvLyBvbmx5IGZpbHRlciB0aGUgY3VycmVudCBkYXRhc2V0XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZJTFRFUl9VUERBVEVSX1BST1BTLmxheWVySWQ6XG4gICAgICAvLyBXZSBuZWVkIHRvIHVwZGF0ZSBvbmx5IGRhdGFzZXRJZC9zIGlmIHdlIGhhdmUgYWRkZWQvcmVtb3ZlZCBsYXllcnNcbiAgICAgIC8vIC0gY2hlY2sgZm9yIGxheWVySWQgY2hhbmdlcyAoWE9SIHdvcmtzIGJlY2F1c2Ugb2Ygc3RyaW5nIHZhbHVlcylcbiAgICAgIC8vIGlmIG5vIGRpZmZlcmVuY2VzIGJldHdlZW4gbGF5ZXJJZHMsIGRvbid0IGRvIGFueSBmaWx0ZXJpbmdcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IGxheWVySWREaWZmZXJlbmNlID0geG9yKG5ld0ZpbHRlci5sYXllcklkLCBvbGRGaWx0ZXIubGF5ZXJJZCk7XG5cbiAgICAgIGNvbnN0IGxheWVyRGF0YUlkcyA9IHVuaXE8c3RyaW5nPihcbiAgICAgICAgbGF5ZXJJZERpZmZlcmVuY2VcbiAgICAgICAgICAubWFwKGxpZCA9PlxuICAgICAgICAgICAgZ2V0KFxuICAgICAgICAgICAgICBzdGF0ZS5sYXllcnMuZmluZChsID0+IGwuaWQgPT09IGxpZCksXG4gICAgICAgICAgICAgIFsnY29uZmlnJywgJ2RhdGFJZCddXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICAgIC5maWx0ZXIoZCA9PiBkKSBhcyBzdHJpbmdbXVxuICAgICAgKTtcblxuICAgICAgLy8gb25seSBmaWx0ZXIgZGF0YXNldHNJZHNcbiAgICAgIGRhdGFzZXRJZHMgPSBsYXllckRhdGFJZHM7XG5cbiAgICAgIC8vIFVwZGF0ZSBuZXdGaWx0ZXIgZGF0YUlkc1xuICAgICAgY29uc3QgbmV3RGF0YUlkcyA9IHVuaXE8c3RyaW5nPihcbiAgICAgICAgbmV3RmlsdGVyLmxheWVySWRcbiAgICAgICAgICA/Lm1hcChsaWQgPT5cbiAgICAgICAgICAgIGdldChcbiAgICAgICAgICAgICAgc3RhdGUubGF5ZXJzLmZpbmQobCA9PiBsLmlkID09PSBsaWQpLFxuICAgICAgICAgICAgICBbJ2NvbmZpZycsICdkYXRhSWQnXVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgICAuZmlsdGVyKGQgPT4gZCkgYXMgc3RyaW5nW11cbiAgICAgICk7XG5cbiAgICAgIG5ld0ZpbHRlciA9IHtcbiAgICAgICAgLi4ubmV3RmlsdGVyLFxuICAgICAgICBkYXRhSWQ6IG5ld0RhdGFJZHNcbiAgICAgIH07XG5cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGNvbnN0IGVubGFyZ2VkRmlsdGVyID0gc3RhdGUuZmlsdGVycy5maW5kKGYgPT4gZi52aWV3ID09PSBGSUxURVJfVklFV19UWVBFUy5lbmxhcmdlZCk7XG5cbiAgaWYgKGVubGFyZ2VkRmlsdGVyICYmIGVubGFyZ2VkRmlsdGVyLmlkICE9PSBuZXdGaWx0ZXIuaWQpIHtcbiAgICAvLyB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgZW5sYXJnZWQgZmlsdGVyXG4gICAgbmV3RmlsdGVyLnZpZXcgPSBGSUxURVJfVklFV19UWVBFUy5zaWRlO1xuICB9XG5cbiAgLy8gc2F2ZSBuZXcgZmlsdGVycyB0byBuZXdTdGF0ZVxuICBuZXdTdGF0ZSA9IHNldChbJ2ZpbHRlcnMnLCBpZHhdLCBuZXdGaWx0ZXIsIG5ld1N0YXRlKTtcblxuICAvLyBpZiB3ZSBhcmUgY3VycmVudGx5IHNldHRpbmcgYSBwcm9wIHRoYXQgb25seSByZXF1aXJlcyB0byBmaWx0ZXIgdGhlIGN1cnJlbnRcbiAgLy8gZGF0YXNldCB3ZSB3aWxsIHBhc3Mgb25seSB0aGUgY3VycmVudCBkYXRhc2V0IHRvIGFwcGx5RmlsdGVyc1RvRGF0YXNldHMgYW5kXG4gIC8vIHVwZGF0ZUFsbExheWVyRG9tYWluRGF0YSBvdGhlcndpc2Ugd2UgcGFzcyB0aGUgYWxsIGxpc3Qgb2YgZGF0YXNldHMgYXMgZGVmaW5lZCBpbiBkYXRhSWRcbiAgY29uc3QgZGF0YXNldElkc1RvRmlsdGVyID0gTElNSVRFRF9GSUxURVJfRUZGRUNUX1BST1BTW3Byb3BdXG4gICAgPyBbZGF0YXNldElkc1t2YWx1ZUluZGV4XV1cbiAgICA6IGRhdGFzZXRJZHM7XG5cbiAgLy8gZmlsdGVyIGRhdGFcbiAgY29uc3QgZmlsdGVyZWREYXRhc2V0cyA9IGFwcGx5RmlsdGVyc1RvRGF0YXNldHMoXG4gICAgZGF0YXNldElkc1RvRmlsdGVyLFxuICAgIG5ld1N0YXRlLmRhdGFzZXRzLFxuICAgIG5ld1N0YXRlLmZpbHRlcnMsXG4gICAgbmV3U3RhdGUubGF5ZXJzXG4gICk7XG5cbiAgbmV3U3RhdGUgPSBzZXQoWydkYXRhc2V0cyddLCBmaWx0ZXJlZERhdGFzZXRzLCBuZXdTdGF0ZSk7XG4gIC8vIGRhdGFJZCBpcyBhbiBhcnJheVxuICAvLyBwYXNzIG9ubHkgdGhlIGRhdGFzZXQgd2UgbmVlZCB0byB1cGRhdGVcbiAgbmV3U3RhdGUgPSB1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEobmV3U3RhdGUsIGRhdGFzZXRJZHNUb0ZpbHRlciwgbmV3RmlsdGVyKTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogU2V0IHRoZSBwcm9wZXJ0eSBvZiBhIGZpbHRlciBwbG90XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgc2V0RmlsdGVyUGxvdFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2lkeCwgbmV3UHJvcCwgdmFsdWVJbmRleCA9IDB9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0RmlsdGVyUGxvdFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgbGV0IG5ld0ZpbHRlciA9IHsuLi5zdGF0ZS5maWx0ZXJzW2lkeF0sIC4uLm5ld1Byb3B9O1xuICBjb25zdCBwcm9wID0gT2JqZWN0LmtleXMobmV3UHJvcClbMF07XG4gIGlmIChwcm9wID09PSAneUF4aXMnKSB7XG4gICAgY29uc3QgcGxvdFR5cGUgPSBnZXREZWZhdWx0RmlsdGVyUGxvdFR5cGUobmV3RmlsdGVyKTtcbiAgICAvLyBUT0RPOiBwbG90IGlzIG5vdCBzdXBwb3J0ZWQgaW4gbXVsdGkgZGF0YXNldCBmaWx0ZXIgZm9yIG5vd1xuICAgIGlmIChwbG90VHlwZSkge1xuICAgICAgbmV3RmlsdGVyID0ge1xuICAgICAgICAuLi5uZXdGaWx0ZXIsXG4gICAgICAgIC4uLmdldEZpbHRlclBsb3Qoey4uLm5ld0ZpbHRlciwgcGxvdFR5cGV9LCBzdGF0ZS5kYXRhc2V0c1tuZXdGaWx0ZXIuZGF0YUlkW3ZhbHVlSW5kZXhdXSksXG4gICAgICAgIHBsb3RUeXBlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoKGYsIGkpID0+IChpID09PSBpZHggPyBuZXdGaWx0ZXIgOiBmKSlcbiAgfTtcbn07XG5cbi8qKlxuICogQWRkIGEgbmV3IGZpbHRlclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEZpbHRlclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuQWRkRmlsdGVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT5cbiAgIWFjdGlvbi5kYXRhSWRcbiAgICA/IHN0YXRlXG4gICAgOiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBmaWx0ZXJzOiBbLi4uc3RhdGUuZmlsdGVycywgZ2V0RGVmYXVsdEZpbHRlcih7ZGF0YUlkOiBhY3Rpb24uZGF0YUlkLCBpZDogYWN0aW9uLmlkfSldXG4gICAgICB9O1xuXG4vKipcbiAqIFNldCBsYXllciBjb2xvciBwYWxldHRlIHVpIHN0YXRlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICovXG5leHBvcnQgY29uc3QgbGF5ZXJDb2xvclVJQ2hhbmdlVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7b2xkTGF5ZXIsIHByb3AsIG5ld0NvbmZpZ306IFZpc1N0YXRlQWN0aW9ucy5MYXllckNvbG9yVUlDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IG9sZFZpeENvbmZpZyA9IG9sZExheWVyLmNvbmZpZy52aXNDb25maWdbcHJvcF07XG4gIGNvbnN0IG5ld0xheWVyID0gb2xkTGF5ZXIudXBkYXRlTGF5ZXJDb2xvclVJKHByb3AsIG5ld0NvbmZpZyk7XG4gIGNvbnN0IG5ld1Zpc0NvbmZpZyA9IG5ld0xheWVyLmNvbmZpZy52aXNDb25maWdbcHJvcF07XG4gIGlmIChvbGRWaXhDb25maWcgIT09IG5ld1Zpc0NvbmZpZykge1xuICAgIHJldHVybiBsYXllclZpc0NvbmZpZ0NoYW5nZVVwZGF0ZXIoc3RhdGUsIHtcbiAgICAgIG9sZExheWVyLFxuICAgICAgbmV3VmlzQ29uZmlnOiB7XG4gICAgICAgIFtwcm9wXTogbmV3VmlzQ29uZmlnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IHN0YXRlLmxheWVycy5tYXAobCA9PiAobC5pZCA9PT0gb2xkTGF5ZXIuaWQgPyBuZXdMYXllciA6IGwpKVxuICB9O1xufTtcblxuLyoqXG4gKiBTdGFydCBhbmQgZW5kIGZpbHRlciBhbmltYXRpb25cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVGaWx0ZXJBbmltYXRpb25VcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlRvZ2dsZUZpbHRlckFuaW1hdGlvblVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT4gKGkgPT09IGFjdGlvbi5pZHggPyB7Li4uZiwgaXNBbmltYXRpbmc6ICFmLmlzQW5pbWF0aW5nfSA6IGYpKVxufSk7XG5cbi8qKlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUxheWVyQW5pbWF0aW9uVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Ub2dnbGVMYXllckFuaW1hdGlvblVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBhbmltYXRpb25Db25maWc6IHtcbiAgICAuLi5zdGF0ZS5hbmltYXRpb25Db25maWcsXG4gICAgaXNBbmltYXRpbmc6ICFzdGF0ZS5hbmltYXRpb25Db25maWcuaXNBbmltYXRpbmdcbiAgfVxufSk7XG5cbi8qKlxuICogSGlkZSBhbmQgc2hvdyBsYXllciBhbmltYXRpb24gY29udHJvbFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUxheWVyQW5pbWF0aW9uQ29udHJvbFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuVG9nZ2xlTGF5ZXJBbmltYXRpb25Db250cm9sVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGFuaW1hdGlvbkNvbmZpZzoge1xuICAgIC4uLnN0YXRlLmFuaW1hdGlvbkNvbmZpZyxcbiAgICBoaWRlQ29udHJvbDogIXN0YXRlLmFuaW1hdGlvbkNvbmZpZy5oaWRlQ29udHJvbFxuICB9XG59KTtcblxuLyoqXG4gKiBDaGFuZ2UgZmlsdGVyIGFuaW1hdGlvbiBzcGVlZFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUZpbHRlckFuaW1hdGlvblNwZWVkVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5VcGRhdGVGaWx0ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT4gKGkgPT09IGFjdGlvbi5pZHggPyB7Li4uZiwgc3BlZWQ6IGFjdGlvbi5zcGVlZH0gOiBmKSlcbn0pO1xuXG4vKipcbiAqIFJlc2V0IGFuaW1hdGlvbiBjb25maWcgY3VycmVudCB0aW1lIHRvIGEgc3BlY2lmaWVkIHZhbHVlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHNldExheWVyQW5pbWF0aW9uVGltZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge3ZhbHVlfTogVmlzU3RhdGVBY3Rpb25zLlNldExheWVyQW5pbWF0aW9uVGltZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBhbmltYXRpb25Db25maWc6IHtcbiAgICAuLi5zdGF0ZS5hbmltYXRpb25Db25maWcsXG4gICAgY3VycmVudFRpbWU6IHZhbHVlXG4gIH1cbn0pO1xuXG4vKipcbiAqIFVwZGF0ZSBhbmltYXRpb24gc3BlZWQgd2l0aCB0aGUgdmVydGljYWwgc3BlZWQgc2xpZGVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUxheWVyQW5pbWF0aW9uU3BlZWRVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtzcGVlZH06IFZpc1N0YXRlQWN0aW9ucy5VcGRhdGVMYXllckFuaW1hdGlvblNwZWVkVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGFuaW1hdGlvbkNvbmZpZzoge1xuICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgc3BlZWRcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFNob3cgbGFyZ2VyIHRpbWUgZmlsdGVyIGF0IGJvdHRvbSBmb3IgdGltZSBwbGF5YmFjayAoYXBwbHkgdG8gdGltZSBmaWx0ZXIgb25seSlcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRGaWx0ZXJWaWV3VXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5TZXRGaWx0ZXJWaWV3VXBkYXRlckFjdGlvblxuKSA9PiB7XG4gIGNvbnN0IHt2aWV3LCBpZHh9ID0gYWN0aW9uO1xuICBjb25zdCBzaG91bGRSZXNldE90aGVyRmlsdGVyc1ZpZXcgPSB2aWV3ID09PSBGSUxURVJfVklFV19UWVBFUy5lbmxhcmdlZDtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT5cbiAgICAgIGkgPT09IGlkeFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLmYsXG4gICAgICAgICAgICB2aWV3XG4gICAgICAgICAgfVxuICAgICAgICA6IHNob3VsZFJlc2V0T3RoZXJGaWx0ZXJzVmlld1xuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLmYsXG4gICAgICAgICAgICB2aWV3OiBGSUxURVJfVklFV19UWVBFUy5zaWRlXG4gICAgICAgICAgfVxuICAgICAgICA6IGZcbiAgICApXG4gIH07XG59O1xuXG4vKipcbiAqIFRvZ2dsZXMgZmlsdGVyIGZlYXR1cmUgdmlzaWJpbGl0eVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUZpbHRlckZlYXR1cmVVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlRvZ2dsZUZpbHRlckZlYXR1cmVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IGZpbHRlciA9IHN0YXRlLmZpbHRlcnNbYWN0aW9uLmlkeF07XG4gIGNvbnN0IGlzVmlzaWJsZSA9IGdldChmaWx0ZXIsIFsndmFsdWUnLCAncHJvcGVydGllcycsICdpc1Zpc2libGUnXSk7XG5cbiAgbGV0IG5ld1N0YXRlID0gc2V0RmlsdGVyVXBkYXRlcihzdGF0ZSwge1xuICAgIGlkeDogYWN0aW9uLmlkeCxcbiAgICBwcm9wOiAnZW5hYmxlZCcsXG4gICAgdmFsdWU6ICFpc1Zpc2libGVcbiAgfSk7XG5cbiAgbmV3U3RhdGUgPSBzZXRGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgaWR4OiBhY3Rpb24uaWR4LFxuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZlYXR1cmVUb0ZpbHRlclZhbHVlKGZpbHRlci52YWx1ZSwgZmlsdGVyLmlkLCB7XG4gICAgICBpc1Zpc2libGU6ICFpc1Zpc2libGVcbiAgICB9KVxuICB9KTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGZpbHRlclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUZpbHRlclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuUmVtb3ZlRmlsdGVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCB7aWR4fSA9IGFjdGlvbjtcbiAgY29uc3Qge2RhdGFJZCwgaWR9ID0gc3RhdGUuZmlsdGVyc1tpZHhdO1xuXG4gIGNvbnN0IG5ld0ZpbHRlcnMgPSBbXG4gICAgLi4uc3RhdGUuZmlsdGVycy5zbGljZSgwLCBpZHgpLFxuICAgIC4uLnN0YXRlLmZpbHRlcnMuc2xpY2UoaWR4ICsgMSwgc3RhdGUuZmlsdGVycy5sZW5ndGgpXG4gIF07XG5cbiAgY29uc3QgZmlsdGVyZWREYXRhc2V0cyA9IGFwcGx5RmlsdGVyc1RvRGF0YXNldHMoZGF0YUlkLCBzdGF0ZS5kYXRhc2V0cywgbmV3RmlsdGVycywgc3RhdGUubGF5ZXJzKTtcbiAgY29uc3QgbmV3RWRpdG9yID1cbiAgICBnZXRGaWx0ZXJJZEluRmVhdHVyZShzdGF0ZS5lZGl0b3Iuc2VsZWN0ZWRGZWF0dXJlKSA9PT0gaWRcbiAgICAgID8ge1xuICAgICAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgICAgICBzZWxlY3RlZEZlYXR1cmU6IG51bGxcbiAgICAgICAgfVxuICAgICAgOiBzdGF0ZS5lZGl0b3I7XG5cbiAgbGV0IG5ld1N0YXRlID0gc2V0KFsnZmlsdGVycyddLCBuZXdGaWx0ZXJzLCBzdGF0ZSk7XG4gIG5ld1N0YXRlID0gc2V0KFsnZGF0YXNldHMnXSwgZmlsdGVyZWREYXRhc2V0cywgbmV3U3RhdGUpO1xuICBuZXdTdGF0ZSA9IHNldChbJ2VkaXRvciddLCBuZXdFZGl0b3IsIG5ld1N0YXRlKTtcblxuICByZXR1cm4gdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhKG5ld1N0YXRlLCBkYXRhSWQsIHVuZGVmaW5lZCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG5ldyBsYXllclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZExheWVyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5BZGRMYXllclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgbGV0IG5ld0xheWVyO1xuICBsZXQgbmV3TGF5ZXJEYXRhO1xuICBpZiAoYWN0aW9uLmNvbmZpZykge1xuICAgIG5ld0xheWVyID0gY3JlYXRlTGF5ZXJGcm9tQ29uZmlnKHN0YXRlLCBhY3Rpb24uY29uZmlnKTtcbiAgICBpZiAoIW5ld0xheWVyKSB7XG4gICAgICBDb25zb2xlLndhcm4oXG4gICAgICAgICdGYWlsZWQgdG8gY3JlYXRlIGxheWVyIGZyb20gY29uZmlnLCBpdCB1c3VhbGx5IG1lYW5zIHRoZSBjb25maWcgaXMgbm90IGJlIGluIGNvcnJlY3QgZm9ybWF0JyxcbiAgICAgICAgYWN0aW9uLmNvbmZpZ1xuICAgICAgKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlKTtcbiAgICBuZXdMYXllciA9IHJlc3VsdC5sYXllcjtcbiAgICBuZXdMYXllckRhdGEgPSByZXN1bHQubGF5ZXJEYXRhO1xuICB9IGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBsYXllciB3aXRoIGEgc3BlY2lmaWMgZGF0YXNldCBvciBhIGRlZmF1bHQgb25lXG4gICAgY29uc3QgZGVmYXVsdERhdGFzZXQgPSBhY3Rpb24uZGF0YXNldElkID8/IE9iamVjdC5rZXlzKHN0YXRlLmRhdGFzZXRzKVswXTtcbiAgICBuZXdMYXllciA9IG5ldyBMYXllcih7XG4gICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICBpc0NvbmZpZ0FjdGl2ZTogdHJ1ZSxcbiAgICAgIGRhdGFJZDogZGVmYXVsdERhdGFzZXRcbiAgICB9KTtcbiAgICBuZXdMYXllckRhdGEgPSB7fTtcbiAgfVxuXG4gIGxldCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IFsuLi5zdGF0ZS5sYXllcnMsIG5ld0xheWVyXSxcbiAgICBsYXllckRhdGE6IFsuLi5zdGF0ZS5sYXllckRhdGEsIG5ld0xheWVyRGF0YV0sXG4gICAgLy8gYWRkIG5ldyBsYXllciBhdCB0aGUgdG9wXG4gICAgbGF5ZXJPcmRlcjogW25ld0xheWVyLmlkLCAuLi5zdGF0ZS5sYXllck9yZGVyXSxcbiAgICBzcGxpdE1hcHM6IGFkZE5ld0xheWVyc1RvU3BsaXRNYXAoc3RhdGUuc3BsaXRNYXBzLCBuZXdMYXllcilcbiAgfTtcblxuICBpZiAobmV3TGF5ZXIuY29uZmlnLmFuaW1hdGlvbi5lbmFibGVkKSB7XG4gICAgbmV3U3RhdGUgPSB1cGRhdGVBbmltYXRpb25Eb21haW4obmV3U3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufTtcblxuLyoqXG4gKiByZW1vdmUgbGF5ZXJcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMYXllclVwZGF0ZXI8VCBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFQsXG4gIHtpZH06IFZpc1N0YXRlQWN0aW9ucy5SZW1vdmVMYXllclVwZGF0ZXJBY3Rpb25cbik6IFQge1xuICBjb25zdCBpZHggPSBOdW1iZXIuaXNGaW5pdGUoaWQpXG4gICAgPyAvLyBzdXBwb3J0IG9sZGVyIEFQSSwgcmVtb3ZlIGxheWVyIGJ5IGlkeFxuICAgICAgTnVtYmVyKGlkKVxuICAgIDogc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IGlkKTtcbiAgaWYgKGlkeCA8IDAgfHwgaWR4ID49IHN0YXRlLmxheWVycy5sZW5ndGgpIHtcbiAgICAvLyBpbnZhbGlkIGluZGV4XG4gICAgQ29uc29sZS53YXJuKGBjYW4gbm90IHJlbW92ZSBsYXllciB3aXRoIGludmFsaWQgaWR8aWR4ICR7aWR9YCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3Qge2xheWVycywgbGF5ZXJEYXRhLCBsYXllck9yZGVyLCBjbGlja2VkLCBob3ZlckluZm99ID0gc3RhdGU7XG4gIGNvbnN0IGxheWVyVG9SZW1vdmUgPSBsYXllcnNbaWR4XTtcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBmaWx0ZXJPdXRCeUlkKGxheWVyVG9SZW1vdmUuaWQpKGxheWVycyksXG4gICAgbGF5ZXJEYXRhOiByZW1vdmVFbGVtZW50QXRJbmRleChpZHgpKGxheWVyRGF0YSksXG4gICAgbGF5ZXJPcmRlcjogbGF5ZXJPcmRlci5maWx0ZXIobGF5ZXJJZCA9PiBsYXllcklkICE9PSBsYXllclRvUmVtb3ZlLmlkKSxcbiAgICBjbGlja2VkOiBsYXllclRvUmVtb3ZlLmlzTGF5ZXJIb3ZlcmVkKGNsaWNrZWQpID8gdW5kZWZpbmVkIDogY2xpY2tlZCxcbiAgICBob3ZlckluZm86IGxheWVyVG9SZW1vdmUuaXNMYXllckhvdmVyZWQoaG92ZXJJbmZvKSA/IHVuZGVmaW5lZCA6IGhvdmVySW5mbyxcbiAgICBzcGxpdE1hcHM6IHJlbW92ZUxheWVyRnJvbVNwbGl0TWFwcyhzdGF0ZS5zcGxpdE1hcHMsIGxheWVyVG9SZW1vdmUpXG4gICAgLy8gVE9ETzogdXBkYXRlIGZpbHRlcnMsIGNyZWF0ZSBoZWxwZXIgdG8gcmVtb3ZlIGxheWVyIGZvcm0gZmlsdGVyIChyZW1vdmUgbGF5ZXJpZCBhbmQgZGF0YWlkKSBpZiBtYXBwZWRcbiAgfTtcblxuICByZXR1cm4gdXBkYXRlQW5pbWF0aW9uRG9tYWluKG5ld1N0YXRlKTtcbn1cblxuLyoqXG4gKiBSZW9yZGVyIGxheWVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVvcmRlckxheWVyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7b3JkZXJ9OiBWaXNTdGF0ZUFjdGlvbnMuUmVvcmRlckxheWVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGxheWVyT3JkZXI6IG9yZGVyXG59KTtcblxuLyoqXG4gKiBkdXBsaWNhdGUgbGF5ZXJcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBkdXBsaWNhdGVMYXllclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2lkfTogVmlzU3RhdGVBY3Rpb25zLkR1cGxpY2F0ZUxheWVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCBpZHggPSBOdW1iZXIuaXNGaW5pdGUoaWQpXG4gICAgPyAvLyBzdXBwb3J0IG9sZGVyIEFQSSwgcmVtb3ZlIGxheWVyIGJ5IGlkeFxuICAgICAgTnVtYmVyKGlkKVxuICAgIDogc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IGlkKTtcbiAgaWYgKGlkeCA8IDAgfHwgIXN0YXRlLmxheWVyc1tpZHhdKSB7XG4gICAgQ29uc29sZS53YXJuKGBsYXllciAke2lkeH0gbm90IGZvdW5kIGluIGxheWVyT3JkZXJgKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB7bGF5ZXJzfSA9IHN0YXRlO1xuICBjb25zdCBvcmlnaW5hbCA9IGxheWVyc1tpZHhdO1xuXG4gIGNvbnN0IG9yaWdpbmFsTGF5ZXJPcmRlcklkeCA9IHN0YXRlLmxheWVyT3JkZXIuZmluZEluZGV4KGxpZCA9PiBsaWQgPT09IG9yaWdpbmFsLmlkKTtcbiAgbGV0IG5ld0xhYmVsID0gYENvcHkgb2YgJHtvcmlnaW5hbC5jb25maWcubGFiZWx9YDtcbiAgbGV0IHBvc3RmaXggPSAwO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gIHdoaWxlIChsYXllcnMuZmluZChsID0+IGwuY29uZmlnLmxhYmVsID09PSBuZXdMYWJlbCkpIHtcbiAgICBuZXdMYWJlbCA9IGBDb3B5IG9mICR7b3JpZ2luYWwuY29uZmlnLmxhYmVsfSAkeysrcG9zdGZpeH1gO1xuICB9XG5cbiAgLy8gY29sbGVjdCBsYXllciBjb25maWcgZnJvbSBvcmlnaW5hbFxuICBjb25zdCBsb2FkZWRMYXllciA9IHNlcmlhbGl6ZUxheWVyKG9yaWdpbmFsLCBzdGF0ZS5zY2hlbWEpO1xuXG4gIC8vIGFzc2lnbiBuZXcgaWQgYW5kIGxhYmVsIHRvIGNvcGllZCBsYXllclxuICBpZiAoIWxvYWRlZExheWVyPy5jb25maWcpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgbG9hZGVkTGF5ZXIuY29uZmlnLmxhYmVsID0gbmV3TGFiZWw7XG4gIGxvYWRlZExheWVyLmlkID0gZ2VuZXJhdGVIYXNoSWQoTEFZRVJfSURfTEVOR1RIKTtcblxuICAvLyBhZGQgbGF5ZXIgdG8gc3RhdGVcbiAgbGV0IG5leHRTdGF0ZSA9IGFkZExheWVyVXBkYXRlcihzdGF0ZSwge2NvbmZpZzogbG9hZGVkTGF5ZXJ9KTtcbiAgLy8gcmV0cmlldmUgbmV3bHkgY3JlYXRlZCBsYXllclxuICBjb25zdCBuZXdMYXllciA9IG5leHRTdGF0ZS5sYXllcnNbbmV4dFN0YXRlLmxheWVycy5sZW5ndGggLSAxXTtcbiAgLy8gdXBkYXRlIGxheWVyIG9yZGVyIHdpdGggbmV3THlhZXIuaWRcbiAgY29uc3QgbmV3TGF5ZXJPcmRlciA9IGFycmF5SW5zZXJ0KFxuICAgIG5leHRTdGF0ZS5sYXllck9yZGVyLnNsaWNlKDEsIG5leHRTdGF0ZS5sYXllck9yZGVyLmxlbmd0aCksXG4gICAgb3JpZ2luYWxMYXllck9yZGVySWR4LFxuICAgIG5ld0xheWVyLmlkXG4gICk7XG5cbiAgbmV4dFN0YXRlID0gcmVvcmRlckxheWVyVXBkYXRlcihuZXh0U3RhdGUsIHtvcmRlcjogbmV3TGF5ZXJPcmRlcn0pO1xuXG4gIHJldHVybiB1cGRhdGVBbmltYXRpb25Eb21haW4obmV4dFN0YXRlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgbmV3IGVmZmVjdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEVmZmVjdFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuQWRkRWZmZWN0VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCBuZXdFZmZlY3QgPSBjcmVhdGVFZmZlY3QoYWN0aW9uLmNvbmZpZyk7XG5cbiAgLy8gY29sbGFwc2UgY29uZmlndXJhdG9ycyBmb3Igb3RoZXIgZWZmZWN0c1xuICBzdGF0ZS5lZmZlY3RzLmZvckVhY2goZWZmZWN0ID0+IGVmZmVjdC5zZXRQcm9wcyh7aXNDb25maWdBY3RpdmU6IGZhbHNlfSkpO1xuXG4gIGNvbnN0IGVmZmVjdHMgPSBbLi4uc3RhdGUuZWZmZWN0cywgbmV3RWZmZWN0XTtcbiAgY29uc3QgZWZmZWN0T3JkZXIgPSBmaXhFZmZlY3RPcmRlcihlZmZlY3RzLCBbbmV3RWZmZWN0LmlkLCAuLi5zdGF0ZS5lZmZlY3RPcmRlcl0pO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWZmZWN0cyxcbiAgICBlZmZlY3RPcmRlclxuICB9O1xufTtcblxuLyoqXG4gKiByZW1vdmUgZWZmZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRWZmZWN0VXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7aWR9OiBWaXNTdGF0ZUFjdGlvbnMuUmVtb3ZlRWZmZWN0VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCBpZHggPSBzdGF0ZS5lZmZlY3RzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IGlkKTtcbiAgaWYgKGlkeCA8IDAgfHwgaWR4ID49IHN0YXRlLmVmZmVjdHMubGVuZ3RoKSB7XG4gICAgQ29uc29sZS53YXJuKGBjYW4gbm90IHJlbW92ZSBlZmZlY3Qgd2l0aCBpbnZhbGlkIGlkICR7aWR9YCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3Qge2VmZmVjdHMsIGVmZmVjdE9yZGVyfSA9IHN0YXRlO1xuICBjb25zdCBlZmZlY3RUb1JlbW92ZSA9IGVmZmVjdHNbaWR4XTtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZpeGVkIGluIHRzXG4gICAgZWZmZWN0czogZmlsdGVyT3V0QnlJZChlZmZlY3RUb1JlbW92ZS5pZCkoZWZmZWN0cyksXG4gICAgZWZmZWN0T3JkZXI6IGVmZmVjdE9yZGVyLmZpbHRlcihlZmZlY3RJZCA9PiBlZmZlY3RJZCAhPT0gZWZmZWN0VG9SZW1vdmUuaWQpXG4gIH07XG59O1xuXG4vKipcbiAqIFJlb3JkZXIgZWZmZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVvcmRlckVmZmVjdFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge29yZGVyfTogVmlzU3RhdGVBY3Rpb25zLlJlb3JkZXJFZmZlY3RVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZWZmZWN0T3JkZXI6IGZpeEVmZmVjdE9yZGVyKHN0YXRlLmVmZmVjdHMsIFsuLi5vcmRlcl0pXG59KTtcblxuLyoqXG4gKiBVcGRhdGUgZWZmZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlRWZmZWN0VXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7aWQsIHByb3BzfTogVmlzU3RhdGVBY3Rpb25zLlVwZGF0ZUVmZmVjdFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgY29uc3QgaWR4ID0gc3RhdGUuZWZmZWN0cy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBpZCk7XG4gIGlmIChpZHggPCAwIHx8IGlkeCA+PSBzdGF0ZS5lZmZlY3RzLmxlbmd0aCkge1xuICAgIENvbnNvbGUud2FybihgY2FuIG5vdCB1cGRhdGUgZWZmZWN0IHdpdGggaW52YWxpZCBpZCAke2lkfWApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGxldCBlZmZlY3RPcmRlciA9IHN0YXRlLmVmZmVjdE9yZGVyO1xuICBpZiAocHJvcHMuaWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5pZCAhPT0gaWQpIHtcbiAgICBjb25zdCBpZHgyID0gc3RhdGUuZWZmZWN0cy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBwcm9wcy5pZCk7XG4gICAgaWYgKGlkeDIgPj0gMCkge1xuICAgICAgQ29uc29sZS53YXJuKGBjYW4gbm90IHVwZGF0ZSBlZmZlY3Qgd2l0aCBleGlzdGluZyBlZmZlY3QgaWQgJHtpZH1gKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBlZmZlY3RPcmRlciA9IGVmZmVjdE9yZGVyLm1hcChlZmZlY3RPcmRlcklkID0+XG4gICAgICBlZmZlY3RPcmRlcklkID09PSBpZCA/IChwcm9wcy5pZCBhcyBzdHJpbmcpIDogZWZmZWN0T3JkZXJJZFxuICAgICk7XG4gIH1cblxuICBjb25zdCBuZXdFZmZlY3RzID0gWy4uLnN0YXRlLmVmZmVjdHNdO1xuICBuZXdFZmZlY3RzW2lkeF0uc2V0UHJvcHMocHJvcHMpO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWZmZWN0czogbmV3RWZmZWN0cyxcbiAgICBlZmZlY3RPcmRlclxuICB9O1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBkYXRhc2V0IGFuZCBhbGwgbGF5ZXJzLCBmaWx0ZXJzLCB0b29sdGlwIGNvbmZpZ3MgdGhhdCBiYXNlZCBvbiBpdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZURhdGFzZXRVcGRhdGVyPFQgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBULFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5SZW1vdmVEYXRhc2V0VXBkYXRlckFjdGlvblxuKTogVCB7XG4gIC8vIGV4dHJhY3QgZGF0YXNldCBrZXlcbiAgY29uc3Qge2RhdGFJZDogZGF0YXNldEtleX0gPSBhY3Rpb247XG4gIGNvbnN0IHtkYXRhc2V0c30gPSBzdGF0ZTtcblxuICAvLyBjaGVjayBpZiBkYXRhc2V0IGlzIHByZXNlbnRcbiAgaWYgKCFkYXRhc2V0c1tkYXRhc2V0S2V5XSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIGNvbnN0IHtcbiAgICBsYXllcnMsXG4gICAgZGF0YXNldHM6IHtbZGF0YXNldEtleV06IGRhdGFzZXQsIC4uLm5ld0RhdGFzZXRzfVxuICB9ID0gc3RhdGU7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICBjb25zdCBsYXllcnNUb1JlbW92ZSA9IGxheWVycy5maWx0ZXIobCA9PiBsLmNvbmZpZy5kYXRhSWQgPT09IGRhdGFzZXRLZXkpLm1hcChsID0+IGwuaWQpO1xuXG4gIC8vIHJlbW92ZSBsYXllcnMgYW5kIGRhdGFzZXRzXG4gIGxldCBuZXdTdGF0ZSA9IGxheWVyc1RvUmVtb3ZlLnJlZHVjZSgoYWNjdSwgaWQpID0+IHJlbW92ZUxheWVyVXBkYXRlcihhY2N1LCB7aWR9KSwge1xuICAgIC4uLnN0YXRlLFxuICAgIGRhdGFzZXRzOiBuZXdEYXRhc2V0c1xuICB9KTtcblxuICAvLyByZW1vdmUgZmlsdGVyc1xuICBjb25zdCBmaWx0ZXJzID0gbmV3U3RhdGUuZmlsdGVycy5maWx0ZXIoZmlsdGVyID0+ICFmaWx0ZXIuZGF0YUlkLmluY2x1ZGVzKGRhdGFzZXRLZXkpKTtcblxuICBuZXdTdGF0ZSA9IHsuLi5uZXdTdGF0ZSwgZmlsdGVyc307XG5cbiAgcmV0dXJuIHJlbW92ZURhdGFzZXRGcm9tSW50ZXJhY3Rpb25Db25maWcobmV3U3RhdGUsIHtkYXRhSWQ6IGRhdGFzZXRLZXl9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRGF0YXNldEZyb21JbnRlcmFjdGlvbkNvbmZpZyhzdGF0ZSwge2RhdGFJZH0pIHtcbiAgbGV0IHtpbnRlcmFjdGlvbkNvbmZpZ30gPSBzdGF0ZTtcbiAgY29uc3Qge3Rvb2x0aXB9ID0gaW50ZXJhY3Rpb25Db25maWc7XG4gIGlmICh0b29sdGlwKSB7XG4gICAgY29uc3Qge2NvbmZpZ30gPSB0b29sdGlwO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgY29uc3Qge1tkYXRhSWRdOiBmaWVsZHMsIC4uLmZpZWxkc1RvU2hvd30gPSBjb25maWcuZmllbGRzVG9TaG93O1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICBpbnRlcmFjdGlvbkNvbmZpZyA9IHtcbiAgICAgIC4uLmludGVyYWN0aW9uQ29uZmlnLFxuICAgICAgdG9vbHRpcDogey4uLnRvb2x0aXAsIGNvbmZpZzogey4uLmNvbmZpZywgZmllbGRzVG9TaG93fX1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHsuLi5zdGF0ZSwgaW50ZXJhY3Rpb25Db25maWd9O1xufVxuLyoqXG4gKiB1cGRhdGUgbGF5ZXIgYmxlbmRpbmcgbW9kZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUxheWVyQmxlbmRpbmdVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlVwZGF0ZUxheWVyQmxlbmRpbmdVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgbGF5ZXJCbGVuZGluZzogYWN0aW9uLm1vZGVcbn0pO1xuXG4vKipcbiAqIHVwZGF0ZSBvdmVybGF5IGJsZW5kaW5nIG1vZGVcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVPdmVybGF5QmxlbmRpbmdVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlVwZGF0ZU92ZXJsYXlCbGVuZGluZ1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBvdmVybGF5QmxlbmRpbmc6IGFjdGlvbi5tb2RlXG59KTtcblxuLyoqXG4gKiBEaXNwbGF5IGRhdGFzZXQgdGFibGUgaW4gYSBtb2RhbFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNob3dEYXRhc2V0VGFibGVVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlNob3dEYXRhc2V0VGFibGVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWRpdGluZ0RhdGFzZXQ6IGFjdGlvbi5kYXRhSWRcbiAgfTtcbn07XG5cbi8qKlxuICogQWRkIGN1c3RvbSBjb2xvciBmb3IgZGF0YXNldHMgYW5kIGxheWVyc1xuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVRhYmxlQ29sb3JVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlVwZGF0ZURhdGFzZXRDb2xvclVwZGF0ZXJcbik6IFZpc1N0YXRlID0+IHtcbiAgcmV0dXJuIHVwZGF0ZURhdGFzZXRQcm9wc1VwZGF0ZXIoc3RhdGUsIHtkYXRhSWQ6IGFjdGlvbi5kYXRhSWQsIHByb3BzOiB7Y29sb3I6IGFjdGlvbi5uZXdDb2xvcn19KTtcbn07XG5cbi8qKlxuICogcmVzZXQgdmlzU3RhdGUgdG8gaW5pdGlhbCBTdGF0ZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc2V0TWFwQ29uZmlnVXBkYXRlciA9IChzdGF0ZTogVmlzU3RhdGUpOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5JTklUSUFMX1ZJU19TVEFURSxcbiAgLi4uc3RhdGUuaW5pdGlhbFN0YXRlLFxuICBpbml0aWFsU3RhdGU6IHN0YXRlLmluaXRpYWxTdGF0ZVxufSk7XG5cbi8qKlxuICogUHJvcGFnYXRlIGB2aXNTdGF0ZWAgcmVkdWNlciB3aXRoIGEgbmV3IGNvbmZpZ3VyYXRpb24uIEN1cnJlbnQgY29uZmlnIHdpbGwgYmUgb3ZlcnJpZGUuXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge1xuICAgIHBheWxvYWQ6IHtjb25maWcgPSB7fSwgb3B0aW9ucyA9IHt9fVxuICB9OiB7XG4gICAgdHlwZT86IHR5cGVvZiBBY3Rpb25UeXBlcy5SRUNFSVZFX01BUF9DT05GSUc7XG4gICAgcGF5bG9hZDogUmVjZWl2ZU1hcENvbmZpZ1BheWxvYWQ7XG4gIH1cbik6IFZpc1N0YXRlID0+IHtcbiAgaWYgKCFjb25maWcudmlzU3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB7a2VlcEV4aXN0aW5nQ29uZmlnfSA9IG9wdGlvbnM7XG5cbiAgLy8gcmVzZXQgY29uZmlnIGlmIGtlZXBFeGlzdGluZ0NvbmZpZyBpcyBmYWxzeVxuICBsZXQgbWVyZ2VkU3RhdGUgPSAha2VlcEV4aXN0aW5nQ29uZmlnID8gcmVzZXRNYXBDb25maWdVcGRhdGVyKHN0YXRlKSA6IHN0YXRlO1xuICBmb3IgKGNvbnN0IG1lcmdlciBvZiBzdGF0ZS5tZXJnZXJzKSB7XG4gICAgaWYgKGlzVmFsaWRNZXJnZXIobWVyZ2VyKSAmJiBoYXNQcm9wc1RvTWVyZ2UoY29uZmlnLnZpc1N0YXRlLCBtZXJnZXIucHJvcCkpIHtcbiAgICAgIG1lcmdlZFN0YXRlID0gbWVyZ2VyLm1lcmdlKFxuICAgICAgICBtZXJnZWRTdGF0ZSxcbiAgICAgICAgZ2V0UHJvcFZhbHVlVG9NZXJnZXIoY29uZmlnLnZpc1N0YXRlLCBtZXJnZXIucHJvcCwgbWVyZ2VyLnRvTWVyZ2VQcm9wKSxcbiAgICAgICAgLy8gZnJvbUNvbmZpZ1xuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXJnZWRTdGF0ZTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBsYXllciBob3ZlciBldmVudCB3aXRoIGhvdmVyZWQgb2JqZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbGF5ZXJIb3ZlclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuT25MYXllckhvdmVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGhvdmVySW5mbzoge1xuICAgIC8vIGRlY2suZ2wgaW5mbyBpcyBtdXRhYmxlXG4gICAgLi4uYWN0aW9uLmluZm9cbiAgfVxufSk7XG5cbi8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuLyoqXG4gKiBVcGRhdGUgYGludGVyYWN0aW9uQ29uZmlnYFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyYWN0aW9uQ29uZmlnQ2hhbmdlVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5JbnRlcmFjdGlvbkNvbmZpZ0NoYW5nZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge2NvbmZpZ30gPSBhY3Rpb247XG5cbiAgY29uc3QgaW50ZXJhY3Rpb25Db25maWcgPSB7XG4gICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWcsXG4gICAgLi4ue1tjb25maWcuaWRdOiBjb25maWd9XG4gIH07XG5cbiAgLy8gRG9uJ3QgZW5hYmxlIHRvb2x0aXAgYW5kIGJydXNoIGF0IHRoZSBzYW1lIHRpbWVcbiAgLy8gYnV0IGNvb3JkaW5hdGVzIGNhbiBiZSBzaG93biBhdCBhbGwgdGltZVxuICBjb25zdCBjb250cmFkaWN0ID0gWydicnVzaCcsICd0b29sdGlwJ107XG5cbiAgaWYgKFxuICAgIGNvbnRyYWRpY3QuaW5jbHVkZXMoY29uZmlnLmlkKSAmJlxuICAgIGNvbmZpZy5lbmFibGVkICYmXG4gICAgIXN0YXRlLmludGVyYWN0aW9uQ29uZmlnW2NvbmZpZy5pZF0uZW5hYmxlZFxuICApIHtcbiAgICAvLyBvbmx5IGVuYWJsZSBvbmUgaW50ZXJhY3Rpb24gYXQgYSB0aW1lXG4gICAgY29udHJhZGljdC5mb3JFYWNoKGsgPT4ge1xuICAgICAgaWYgKGsgIT09IGNvbmZpZy5pZCkge1xuICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZ1trXSA9IHsuLi5pbnRlcmFjdGlvbkNvbmZpZ1trXSwgZW5hYmxlZDogZmFsc2V9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgaW50ZXJhY3Rpb25Db25maWdcbiAgfTtcblxuICBpZiAoY29uZmlnLmlkID09PSAnZ2VvY29kZXInICYmICFjb25maWcuZW5hYmxlZCkge1xuICAgIHJldHVybiByZW1vdmVEYXRhc2V0VXBkYXRlcihuZXdTdGF0ZSwge2RhdGFJZDogJ2dlb2NvZGVyX2RhdGFzZXQnfSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogVHJpZ2dlciBsYXllciBjbGljayBldmVudCB3aXRoIGNsaWNrZWQgb2JqZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbGF5ZXJDbGlja1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuT25MYXllckNsaWNrVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIG1vdXNlUG9zOiBzdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZy5jb29yZGluYXRlLmVuYWJsZWRcbiAgICA/IHtcbiAgICAgICAgLi4uc3RhdGUubW91c2VQb3MsXG4gICAgICAgIHBpbm5lZDogc3RhdGUubW91c2VQb3MucGlubmVkID8gbnVsbCA6IGNsb25lRGVlcChzdGF0ZS5tb3VzZVBvcylcbiAgICAgIH1cbiAgICA6IHN0YXRlLm1vdXNlUG9zLFxuICBjbGlja2VkOiBhY3Rpb24uaW5mbyAmJiBhY3Rpb24uaW5mby5waWNrZWQgPyBhY3Rpb24uaW5mbyA6IG51bGxcbn0pO1xuXG4vKipcbiAqIFRyaWdnZXIgbWFwIGNsaWNrIGV2ZW50LCB1bnNlbGVjdCBjbGlja2VkIG9iamVjdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcENsaWNrVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Pbk1hcENsaWNrVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGNsaWNrZWQ6IG51bGxcbiAgfTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBtYXAgbW92ZSBldmVudFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1vdXNlTW92ZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2V2dH06IFZpc1N0YXRlQWN0aW9ucy5Pbk1vdXNlTW92ZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgaWYgKE9iamVjdC52YWx1ZXMoc3RhdGUuaW50ZXJhY3Rpb25Db25maWcpLnNvbWUoY29uZmlnID0+IGNvbmZpZy5lbmFibGVkKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIG1vdXNlUG9zOiB7XG4gICAgICAgIC4uLnN0YXRlLm1vdXNlUG9zLFxuICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShldnQucG9pbnQpID8ge21vdXNlUG9zaXRpb246IFsuLi5ldnQucG9pbnRdfSA6IHt9KSxcbiAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoZXZ0LmxuZ0xhdCkgPyB7Y29vcmRpbmF0ZTogWy4uLmV2dC5sbmdMYXRdfSA6IHt9KVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59O1xuLyoqXG4gKiBUb2dnbGUgdmlzaWJpbGl0eSBvZiBhIGxheWVyIGZvciBhIHNwbGl0IG1hcFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZVNwbGl0TWFwVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IE1hcFN0YXRlQWN0aW9ucy5Ub2dnbGVTcGxpdE1hcFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+XG4gIHN0YXRlLnNwbGl0TWFwcyAmJiBzdGF0ZS5zcGxpdE1hcHMubGVuZ3RoID09PSAwXG4gICAgPyB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAvLyBtYXliZSB3ZSBzaG91bGQgdXNlIGFuIGFycmF5IHRvIHN0b3JlIHN0YXRlIGZvciBhIHNpbmdsZSBtYXAgYXMgd2VsbFxuICAgICAgICAvLyBpZiBjdXJyZW50IG1hcHMgbGVuZ3RoIGlzIGVxdWFsIHRvIDAgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgYWJvdXQgdG8gc3BsaXQgdGhlIHZpZXdcbiAgICAgICAgc3BsaXRNYXBzOiBjb21wdXRlU3BsaXRNYXBMYXllcnMoc3RhdGUubGF5ZXJzLCB7ZHVwbGljYXRlOiBmYWxzZX0pXG4gICAgICB9XG4gICAgOiBjbG9zZVNwZWNpZmljTWFwQXRJbmRleChzdGF0ZSwgYWN0aW9uKTtcblxuLyoqXG4gKiBUb2dnbGUgdmlzaWJpbGl0eSBvZiBhIGxheWVyIGluIGEgc3BsaXQgbWFwXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlTGF5ZXJGb3JNYXBVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHttYXBJbmRleCwgbGF5ZXJJZH06IFZpc1N0YXRlQWN0aW9ucy5Ub2dnbGVMYXllckZvck1hcFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgY29uc3Qge3NwbGl0TWFwc30gPSBzdGF0ZTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIHNwbGl0TWFwczogc3BsaXRNYXBzLm1hcCgoc20sIGkpID0+XG4gICAgICBpID09PSBtYXBJbmRleFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLnNwbGl0TWFwc1tpXSxcbiAgICAgICAgICAgIGxheWVyczoge1xuICAgICAgICAgICAgICAuLi5zcGxpdE1hcHNbaV0ubGF5ZXJzLFxuICAgICAgICAgICAgICAvLyBpZiBsYXllcklkIG5vdCBpbiBsYXllcnMsIHNldCBpdCB0byB2aXNpYmxlXG4gICAgICAgICAgICAgIFtsYXllcklkXTogIXNwbGl0TWFwc1tpXS5sYXllcnNbbGF5ZXJJZF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIDogc21cbiAgICApXG4gIH07XG59O1xuXG4vKipcbiAqIEFkZCBuZXcgZGF0YXNldCB0byBgdmlzU3RhdGVgLCB3aXRoIG9wdGlvbiB0byBsb2FkIGEgbWFwIGNvbmZpZyBhbG9uZyB3aXRoIHRoZSBkYXRhc2V0c1xuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBjb25zdCB1cGRhdGVWaXNEYXRhVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5VcGRhdGVWaXNEYXRhVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICAvLyBkYXRhc2V0cyBjYW4gYmUgYSBzaW5nbGUgZGF0YSBlbnRyaWVzIG9yIGFuIGFycmF5IG9mIG11bHRpcGxlIGRhdGEgZW50cmllc1xuICBjb25zdCB7Y29uZmlnLCBvcHRpb25zfSA9IGFjdGlvbjtcblxuICAvLyBhcHBseSBjb25maWcgaWYgcGFzc2VkIGZyb20gYWN0aW9uXG4gIC8vIFRPRE86IHdlIGRvbid0IGhhbmRsZSBhc3luIG1lcmdlcnMgaGVyZSB5ZXRcbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IGNvbmZpZ1xuICAgID8gcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIoc3RhdGUsIHtcbiAgICAgICAgcGF5bG9hZDoge2NvbmZpZywgb3B0aW9uc31cbiAgICAgIH0pXG4gICAgOiBzdGF0ZTtcblxuICBjb25zdCBkYXRhc2V0cyA9IHRvQXJyYXkoYWN0aW9uLmRhdGFzZXRzKTtcblxuICBjb25zdCBuZXdEYXRhRW50cmllcyA9IGRhdGFzZXRzLnJlZHVjZShcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICBUeXBlICd7fScgaXMgbWlzc2luZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgZnJvbSB0eXBlICdQcm90b0RhdGFzZXQnOiBkYXRhLCBpbmZvXG4gICAgKGFjY3UsIHtpbmZvID0ge30sIC4uLnJlc3R9ID0ge30pID0+ICh7XG4gICAgICAuLi5hY2N1LFxuICAgICAgLi4uKGNyZWF0ZU5ld0RhdGFFbnRyeSh7aW5mbywgLi4ucmVzdH0sIHN0YXRlLmRhdGFzZXRzKSB8fCB7fSlcbiAgICB9KSxcbiAgICB7fVxuICApO1xuXG4gIC8vIHNhdmUgbmV3IGRhdGFzZXQgZW50cnkgdG8gc3RhdGVcbiAgY29uc3QgbWVyZ2VkU3RhdGUgPSB7XG4gICAgLi4ucHJldmlvdXNTdGF0ZSxcbiAgICBkYXRhc2V0czogbWVyZ2VEYXRhc2V0c0J5T3JkZXIocHJldmlvdXNTdGF0ZSwgbmV3RGF0YUVudHJpZXMpXG4gIH07XG5cbiAgLy8gbWVyZ2Ugc3RhdGUgd2l0aCBjb25maWcgdG8gYmUgbWVyZ2VkXG4gIGNvbnN0IGxheWVyTWVyZ2VycyA9IHN0YXRlLm1lcmdlcnMuZmlsdGVyKG0gPT4gbS53YWl0Rm9yTGF5ZXJEYXRhKTtcbiAgY29uc3QgZGF0YXNldE1lcmdlcnMgPSBzdGF0ZS5tZXJnZXJzLmZpbHRlcihtID0+ICFsYXllck1lcmdlcnMuaW5jbHVkZXMobSkpO1xuXG4gIGNvbnN0IG5ld0RhdGFJZHMgPSBPYmplY3Qua2V5cyhuZXdEYXRhRW50cmllcyk7XG4gIGNvbnN0IHBvc3RNZXJnZXJQYXlsb2FkID0ge1xuICAgIG5ld0RhdGFJZHMsXG4gICAgb3B0aW9ucyxcbiAgICBsYXllck1lcmdlcnNcbiAgfTtcblxuICByZXR1cm4gYXBwbHlNZXJnZXJzVXBkYXRlcihtZXJnZWRTdGF0ZSwge21lcmdlcnM6IGRhdGFzZXRNZXJnZXJzLCBwb3N0TWVyZ2VyUGF5bG9hZH0pO1xufTtcblxuLyoqXG4gKiBBZGQgbmV3IGRhdGFzZXQgdG8gYHZpc1N0YXRlYCwgd2l0aCBvcHRpb24gdG8gbG9hZCBhIG1hcCBjb25maWcgYWxvbmcgd2l0aCB0aGUgZGF0YXNldHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TWVyZ2Vyc1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiB7XG4gICAgbWVyZ2VyczogTWVyZ2VyPGFueT5bXTtcbiAgICBwb3N0TWVyZ2VyUGF5bG9hZDogUG9zdE1lcmdlclBheWxvYWQ7XG4gIH1cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge21lcmdlcnMsIHBvc3RNZXJnZXJQYXlsb2FkfSA9IGFjdGlvbjtcblxuICAvLyBtZXJnZSBzdGF0ZSB3aXRoIGNvbmZpZyB0byBiZSBtZXJnZWRcbiAgY29uc3QgbWVyZ2VTdGF0ZVJlc3VsdCA9IG1lcmdlU3RhdGVGcm9tTWVyZ2VycyhcbiAgICBzdGF0ZSxcbiAgICB7XG4gICAgICAuLi5JTklUSUFMX1ZJU19TVEFURSxcbiAgICAgIC4uLnN0YXRlLmluaXRpYWxTdGF0ZVxuICAgIH0sXG4gICAgbWVyZ2VycyxcbiAgICAvLyBuZXdEYXRhSWRzLFxuICAgIHBvc3RNZXJnZXJQYXlsb2FkXG4gICk7XG5cbiAgLy8gaWYgYWxsIG1lcmdlZCwga2lja3VwIHBvc3QgbWVyZ2UgcHJvY2Vzc1xuICAvLyBpZiBub3Qgd2FpdFxuICByZXR1cm4gbWVyZ2VTdGF0ZVJlc3VsdC5hbGxNZXJnZWRcbiAgICA/IHBvc3RNZXJnZVVwZGF0ZXIobWVyZ2VTdGF0ZVJlc3VsdC5tZXJnZWRTdGF0ZSwgcG9zdE1lcmdlclBheWxvYWQpXG4gICAgOiBtZXJnZVN0YXRlUmVzdWx0Lm1lcmdlZFN0YXRlO1xufVxuXG4vKipcbiAqIEFkZCBuZXcgZGF0YXNldCB0byBgdmlzU3RhdGVgLCB3aXRoIG9wdGlvbiB0byBsb2FkIGEgbWFwIGNvbmZpZyBhbG9uZyB3aXRoIHRoZSBkYXRhc2V0c1xuICovXG5mdW5jdGlvbiBwb3N0TWVyZ2VVcGRhdGVyKG1lcmdlZFN0YXRlOiBWaXNTdGF0ZSwgcG9zdE1lcmdlclBheWxvYWQ6IFBvc3RNZXJnZXJQYXlsb2FkKTogVmlzU3RhdGUge1xuICBjb25zdCB7bmV3RGF0YUlkcywgb3B0aW9ucywgbGF5ZXJNZXJnZXJzfSA9IHBvc3RNZXJnZXJQYXlsb2FkO1xuICBjb25zdCBuZXdGaWx0ZXJzID0gbWVyZ2VkU3RhdGUuZmlsdGVycy5maWx0ZXIoZiA9PlxuICAgIGYuZGF0YUlkLmZpbmQoZkRhdGFJZCA9PiBuZXdEYXRhSWRzLmluY2x1ZGVzKGZEYXRhSWQpKVxuICApO1xuICBjb25zdCBkYXRhc2V0RmlsdGVyZWQ6IHN0cmluZ1tdID0gdW5pcShcbiAgICBuZXdGaWx0ZXJzLnJlZHVjZSgoYWNjdSwgZikgPT4gWy4uLmFjY3UsIC4uLmYuZGF0YUlkXSwgW10gYXMgc3RyaW5nW10pXG4gICk7XG4gIGNvbnN0IGRhdGFFbXB0eSA9IG5ld0RhdGFJZHMubGVuZ3RoIDwgMTtcblxuICBsZXQgbmV3TGF5ZXJzID0gIWRhdGFFbXB0eVxuICAgID8gbWVyZ2VkU3RhdGUubGF5ZXJzLmZpbHRlcihsID0+IGwuY29uZmlnLmRhdGFJZCAmJiBuZXdEYXRhSWRzLmluY2x1ZGVzKGwuY29uZmlnLmRhdGFJZCkpXG4gICAgOiBbXTtcblxuICBjb25zdCBuZXdEYXRhRW50cmllcyA9IG5ld0RhdGFJZHMucmVkdWNlKFxuICAgIChhY2N1LCBpZCkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICBbaWRdOiBtZXJnZWRTdGF0ZS5kYXRhc2V0c1tpZF1cbiAgICB9KSxcbiAgICB7fVxuICApO1xuXG4gIGlmICghbmV3TGF5ZXJzLmxlbmd0aCAmJiAob3B0aW9ucyB8fCB7fSkuYXV0b0NyZWF0ZUxheWVycyAhPT0gZmFsc2UpIHtcbiAgICAvLyBubyBsYXllciBtZXJnZWQsIGZpbmQgZGVmYXVsdHNcbiAgICBjb25zdCByZXN1bHQgPSBhZGREZWZhdWx0TGF5ZXJzKG1lcmdlZFN0YXRlLCBuZXdEYXRhRW50cmllcyk7XG4gICAgbWVyZ2VkU3RhdGUgPSByZXN1bHQuc3RhdGU7XG4gICAgbmV3TGF5ZXJzID0gcmVzdWx0Lm5ld0xheWVycztcbiAgfVxuXG4gIGlmIChtZXJnZWRTdGF0ZS5zcGxpdE1hcHMubGVuZ3RoKSB7XG4gICAgLy8gaWYgbWFwIGlzIHNwbGl0LCBhZGQgbmV3IGxheWVycyB0byBzcGxpdE1hcHNcbiAgICBuZXdMYXllcnMgPSBtZXJnZWRTdGF0ZS5sYXllcnMuZmlsdGVyKFxuICAgICAgbCA9PiBsLmNvbmZpZy5kYXRhSWQgJiYgbmV3RGF0YUlkcy5pbmNsdWRlcyhsLmNvbmZpZy5kYXRhSWQpXG4gICAgKTtcbiAgICBtZXJnZWRTdGF0ZSA9IHtcbiAgICAgIC4uLm1lcmdlZFN0YXRlLFxuICAgICAgc3BsaXRNYXBzOiBhZGROZXdMYXllcnNUb1NwbGl0TWFwKG1lcmdlZFN0YXRlLnNwbGl0TWFwcywgbmV3TGF5ZXJzKVxuICAgIH07XG4gIH1cblxuICAvLyBpZiBubyB0b29sdGlwcyBtZXJnZWQgYWRkIGRlZmF1bHQgdG9vbHRpcHNcbiAgbmV3RGF0YUlkcy5mb3JFYWNoKGRhdGFJZCA9PiB7XG4gICAgY29uc3QgdG9vbHRpcEZpZWxkcyA9IG1lcmdlZFN0YXRlLmludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAuY29uZmlnLmZpZWxkc1RvU2hvd1tkYXRhSWRdO1xuICAgIC8vIGxvYWRpbmcgZGF0YXNldDogYXV0b0NyZWF0ZVRvb2x0aXBzIGlzIGZhbHNlIGFuZCB3ZSBkb24ndCB3YW50IHRvIHJ1biBhZGREZWZhdWx0VG9vbHRpcHMgd2hlbiB0b29sdGlwRmllbGRzIGlzIGVtcHR5XG4gICAgaWYgKFxuICAgICAgb3B0aW9ucz8uYXV0b0NyZWF0ZVRvb2x0aXBzICE9PSBmYWxzZSAmJlxuICAgICAgKCFBcnJheS5pc0FycmF5KHRvb2x0aXBGaWVsZHMpIHx8ICF0b29sdGlwRmllbGRzLmxlbmd0aClcbiAgICApIHtcbiAgICAgIC8vIGFkZGluZyBkYXRhc2V0OiBhdXRvQ3JlYXRlVG9vbHRpcHMgaXMgdHJ1ZVxuICAgICAgbWVyZ2VkU3RhdGUgPSBhZGREZWZhdWx0VG9vbHRpcHMobWVyZ2VkU3RhdGUsIG5ld0RhdGFFbnRyaWVzW2RhdGFJZF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdXBkYXRlZERhdGFzZXRzID0gZGF0YUVtcHR5XG4gICAgPyBPYmplY3Qua2V5cyhtZXJnZWRTdGF0ZS5kYXRhc2V0cylcbiAgICA6IHVuaXEoT2JqZWN0LmtleXMobmV3RGF0YUVudHJpZXMpLmNvbmNhdChkYXRhc2V0RmlsdGVyZWQpKTtcblxuICBsZXQgdXBkYXRlZFN0YXRlID0gdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhKG1lcmdlZFN0YXRlLCB1cGRhdGVkRGF0YXNldHMsIHVuZGVmaW5lZCk7XG5cbiAgLy8gcmVnaXN0ZXIgbGF5ZXIgYW5pbWF0aW9uIGRvbWFpbixcbiAgLy8gbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXIgbGF5ZXIgZGF0YSBpcyBjYWxjdWxhdGVkXG4gIHVwZGF0ZWRTdGF0ZSA9IHVwZGF0ZUFuaW1hdGlvbkRvbWFpbih1cGRhdGVkU3RhdGUpO1xuXG4gIC8vIHRyeSB0byBwcm9jZXNzIGxheWVyTWVyZ2VycyBhZnRlciBkYXRhc2V0K2RhdGFzZXRNZXJnZXJzXG4gIHJldHVybiBsYXllck1lcmdlcnMgJiYgbGF5ZXJNZXJnZXJzLmxlbmd0aCA+IDBcbiAgICA/IGFwcGx5TWVyZ2Vyc1VwZGF0ZXIodXBkYXRlZFN0YXRlLCB7XG4gICAgICAgIG1lcmdlcnM6IGxheWVyTWVyZ2VycyxcbiAgICAgICAgcG9zdE1lcmdlclBheWxvYWQ6IHsuLi5wb3N0TWVyZ2VyUGF5bG9hZCwgbGF5ZXJNZXJnZXJzOiBbXX1cbiAgICAgIH0pXG4gICAgOiB1cGRhdGVkU3RhdGU7XG59XG5cbi8qKlxuICogUmVuYW1lIGFuIGV4aXN0aW5nIGRhdGFzZXQgaW4gYHZpc1N0YXRlYFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmFtZURhdGFzZXRVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlJlbmFtZURhdGFzZXRVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIHJldHVybiB1cGRhdGVEYXRhc2V0UHJvcHNVcGRhdGVyKHN0YXRlLCB7ZGF0YUlkOiBhY3Rpb24uZGF0YUlkLCBwcm9wczoge2xhYmVsOiBhY3Rpb24ubGFiZWx9fSk7XG59XG5cbmNvbnN0IEFMTE9XRURfVVBEQVRFX0RBVEFTRVRfUFJPUFMgPSBbJ2xhYmVsJywgJ2NvbG9yJywgJ21ldGFkYXRhJ107XG5cbi8qKlxuICogVmFsaWRhdGVzIHByb3BlcnRpZXMgYmVmb3JlIHVwZGF0aW5nIHRoZSBkYXRhc2V0LlxuICogTWFrZXMgc3VyZSBlYWNoIHByb3BlcnR5IGlzIGluIHRoZSBhbGxvd2VkIGxpc3RcbiAqIE1ha2VzIHN1cmUgY29sb3IgdmFsdWUgaXMgUkdCXG4gKiBQZXJmb3JtcyBkZWVwIG1lcmdlIHdoZW4gdXBkYXRpbmcgbWV0YWRhdGFcbiAqL1xuY29uc3QgdmFsaWRhdGVEYXRhc2V0VXBkYXRlUHJvcHMgPSAocHJvcHMsIGRhdGFzZXQpID0+IHtcbiAgY29uc3QgdmFsaWRhdGVkUHJvcHMgPSBPYmplY3QuZW50cmllcyhwcm9wcykucmVkdWNlKChhY2MsIGVudHJ5KSA9PiB7XG4gICAgY29uc3QgW2tleSwgdmFsdWVdID0gZW50cnk7XG4gICAgLy8gaXMgaXQgYWxsb3dlZCA/XG4gICAgaWYgKCFBTExPV0VEX1VQREFURV9EQVRBU0VUX1BST1BTLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgYXJlIGFkZGluZyBhIGNvbG9yIGJ1dCBpdCBpcyBub3QgUkdCIHdlIGRvbid0IGFjY2VwdCB0aGUgdmFsdWVcbiAgICAvLyBpbiB0aGUgZnV0dXJlIGFzIHdlIGFkZCBtb3JlIHByb3BzIHdlIHNob3VsZCBjaGFuZ2UgdGhpcyBpZiBpbnRvIGEgc3dpdGNoXG4gICAgaWYgKGtleSA9PT0gJ2NvbG9yJyAmJiAhaXNSZ2JDb2xvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuXG4gICAgLy8gZG8gd2UgbmVlZCBkZWVwIG1lcmdlID9cbiAgICByZXR1cm4gey4uLmFjYywgW2tleV06IGlzUGxhaW5PYmplY3QodmFsdWUpID8gZGVlcG1lcmdlKGRhdGFzZXRba2V5XSB8fCB7fSwgdmFsdWUpIDogdmFsdWV9O1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIHZhbGlkYXRlZFByb3BzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgRGF0YXNldCBwcm9wcyAobGFiZWwsIGNvbG9yLCBtZXRhKS4gRG8gbm90IHVzZSB0byB1cGRhdGUgZGF0YSBvciBhbnkgcmVsYXRlZCBwcm9wZXJ0aWVzXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRGF0YXNldFByb3BzVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5VcGRhdGVEYXRhc2V0UHJvcHNVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtkYXRhSWQsIHByb3BzfSA9IGFjdGlvbjtcbiAgY29uc3Qge2RhdGFzZXRzfSA9IHN0YXRlO1xuICBjb25zdCBleGlzdGluZyA9IGRhdGFzZXRzW2RhdGFJZF07XG5cbiAgaWYgKGV4aXN0aW5nKSB7XG4gICAgY29uc3QgdmFsaWRhdGVkUHJvcHMgPSB2YWxpZGF0ZURhdGFzZXRVcGRhdGVQcm9wcyhwcm9wcywgZXhpc3RpbmcpO1xuICAgIC8vICB2YWxpZGF0ZSBwcm9wczoganVzdCBjb2xvciBmb3Igbm93XG4gICAgLy8gIHdlIG9ubHkgYWxsb3cgbGFiZWwsIGNvbG9yIGFuZCBtZXRhIHRvIGJlIHVwZGF0ZWRcbiAgICAvLyBjb25zdCBuZXdUYWJsZSA9IGNvcHlUYWJsZUFuZFVwZGF0ZShleGlzdGluZywgdmFsaWRhdGVkUHJvcHMpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGRhdGFzZXRzOiB7XG4gICAgICAgIC4uLmRhdGFzZXRzLFxuICAgICAgICBbZGF0YUlkXTogY29weVRhYmxlQW5kVXBkYXRlKGV4aXN0aW5nLCB2YWxpZGF0ZWRQcm9wcylcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIFdoZW4gYSB1c2VyIGNsaWNrcyBvbiB0aGUgc3BlY2lmaWMgbWFwIGNsb3NpbmcgaWNvblxuICogdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2xvc2UgdGhlIHNlbGVjdGVkIG1hcFxuICogYW5kIHdpbGwgbWVyZ2UgdGhlIHJlbWFpbmluZyBvbmUgd2l0aCB0aGUgZ2xvYmFsIHN0YXRlXG4gKiBUT0RPOiBpIHRoaW5rIGluIHRoZSBmdXR1cmUgdGhpcyBhY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBtZXJnZSBtYXAgbGF5ZXJzIHdpdGggZ2xvYmFsIHNldHRpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VTcGVjaWZpY01hcEF0SW5kZXg8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIGFjdGlvbjogTWFwU3RhdGVBY3Rpb25zLlRvZ2dsZVNwbGl0TWFwVXBkYXRlckFjdGlvblxuKTogUyB7XG4gIC8vIHJldHJpZXZlIGxheWVycyBtZXRhIGRhdGEgZnJvbSB0aGUgcmVtYWluaW5nIG1hcCB0aGF0IHdlIG5lZWQgdG8ga2VlcFxuICBjb25zdCBpbmRleFRvUmV0cmlldmUgPSAxIC0gYWN0aW9uLnBheWxvYWQ7XG4gIGNvbnN0IG1hcExheWVycyA9IHN0YXRlLnNwbGl0TWFwc1tpbmRleFRvUmV0cmlldmVdPy5sYXllcnM7XG4gIGNvbnN0IHtsYXllcnN9ID0gc3RhdGU7XG5cbiAgLy8gdXBkYXRlIGxheWVyIHZpc2liaWxpdHlcbiAgY29uc3QgbmV3TGF5ZXJzID0gbGF5ZXJzLm1hcChsYXllciA9PlxuICAgIG1hcExheWVycyAmJiAhbWFwTGF5ZXJzW2xheWVyLmlkXSAmJiBsYXllci5jb25maWcuaXNWaXNpYmxlXG4gICAgICA/IGxheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICAgICAgICAvLyBpZiBsYXllci5pZCBpcyBub3QgaW4gbWFwTGF5ZXJzLCBpdCBzaG91bGQgYmUgaW5WaXNpYmxlXG4gICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgOiBsYXllclxuICApO1xuXG4gIC8vIGRlbGV0ZSBtYXBcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IG5ld0xheWVycyxcbiAgICBzcGxpdE1hcHM6IFtdXG4gIH07XG59XG5cbi8qKlxuICogVHJpZ2dlciBmaWxlIGxvYWRpbmcgZGlzcGF0Y2ggYGFkZERhdGFUb01hcGAgaWYgc3VjY2VlZCwgb3IgYGxvYWRGaWxlc0VycmAgaWYgZmFpbGVkXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbG9hZEZpbGVzVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Mb2FkRmlsZXNVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IHtmaWxlcywgb25GaW5pc2ggPSBsb2FkRmlsZXNTdWNjZXNzfSA9IGFjdGlvbjtcbiAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCBmaWxlTG9hZGluZ1Byb2dyZXNzID0gQXJyYXkuZnJvbShmaWxlcykucmVkdWNlKFxuICAgIChhY2N1LCBmLCBpKSA9PiBtZXJnZV8oaW5pdGlhbEZpbGVMb2FkaW5nUHJvZ3Jlc3MoZiwgaSkpKGFjY3UpLFxuICAgIHt9XG4gICk7XG5cbiAgY29uc3QgZmlsZUxvYWRpbmcgPSB7XG4gICAgZmlsZUNhY2hlOiBbXSxcbiAgICBmaWxlc1RvTG9hZDogZmlsZXMsXG4gICAgb25GaW5pc2hcbiAgfTtcblxuICBjb25zdCBuZXh0U3RhdGUgPSBtZXJnZV8oe2ZpbGVMb2FkaW5nUHJvZ3Jlc3MsIGZpbGVMb2FkaW5nfSkoc3RhdGUpO1xuXG4gIHJldHVybiBsb2FkTmV4dEZpbGVVcGRhdGVyKG5leHRTdGF0ZSk7XG59O1xuXG4vKipcbiAqIFN1Y2Vzc2Z1bGx5IGxvYWRlZCBvbmUgZmlsZSwgbW92ZSBvbiB0byB0aGUgbmV4dCBvbmVcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRmlsZVN0ZXBTdWNjZXNzVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Mb2FkRmlsZVN0ZXBTdWNjZXNzQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGlmICghc3RhdGUuZmlsZUxvYWRpbmcpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3Qge2ZpbGVOYW1lLCBmaWxlQ2FjaGV9ID0gYWN0aW9uO1xuICBjb25zdCB7ZmlsZXNUb0xvYWQsIG9uRmluaXNofSA9IHN0YXRlLmZpbGVMb2FkaW5nO1xuICBjb25zdCBzdGF0ZVdpdGhQcm9ncmVzcyA9IHVwZGF0ZUZpbGVMb2FkaW5nUHJvZ3Jlc3NVcGRhdGVyKHN0YXRlLCB7XG4gICAgZmlsZU5hbWUsXG4gICAgcHJvZ3Jlc3M6IHtwZXJjZW50OiAxLCBtZXNzYWdlOiAnRG9uZSd9XG4gIH0pO1xuXG4gIC8vIHNhdmUgcHJvY2Vzc2VkIGZpbGUgdG8gZmlsZUNhY2hlXG4gIGNvbnN0IHN0YXRlV2l0aENhY2hlID0gcGlja18oJ2ZpbGVMb2FkaW5nJykobWVyZ2VfKHtmaWxlQ2FjaGV9KSkoc3RhdGVXaXRoUHJvZ3Jlc3MpO1xuXG4gIHJldHVybiB3aXRoVGFzayhcbiAgICBzdGF0ZVdpdGhDYWNoZSxcbiAgICBERUxBWV9UQVNLKDIwMCkubWFwKGZpbGVzVG9Mb2FkLmxlbmd0aCA/IGxvYWROZXh0RmlsZSA6ICgpID0+IG9uRmluaXNoKGZpbGVDYWNoZSkpXG4gICk7XG59XG5cbi8vIHdpdGhUYXNrPFQ+KHN0YXRlOiBULCB0YXNrOiBhbnkpOiBUXG5cbi8qKlxuICpcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkTmV4dEZpbGVVcGRhdGVyKHN0YXRlOiBWaXNTdGF0ZSk6IFZpc1N0YXRlIHtcbiAgaWYgKCFzdGF0ZS5maWxlTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB7ZmlsZXNUb0xvYWR9ID0gc3RhdGUuZmlsZUxvYWRpbmc7XG4gIGNvbnN0IFtmaWxlLCAuLi5yZW1haW5pbmdGaWxlc1RvTG9hZF0gPSBmaWxlc1RvTG9hZDtcblxuICAvLyBzYXZlIGZpbGVzVG9Mb2FkIHRvIHN0YXRlXG4gIGNvbnN0IG5leHRTdGF0ZSA9IHBpY2tfKCdmaWxlTG9hZGluZycpKG1lcmdlXyh7ZmlsZXNUb0xvYWQ6IHJlbWFpbmluZ0ZpbGVzVG9Mb2FkfSkpKHN0YXRlKTtcblxuICBjb25zdCBzdGF0ZVdpdGhQcm9ncmVzcyA9IHVwZGF0ZUZpbGVMb2FkaW5nUHJvZ3Jlc3NVcGRhdGVyKG5leHRTdGF0ZSwge1xuICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgcHJvZ3Jlc3M6IHtwZXJjZW50OiAwLCBtZXNzYWdlOiAnbG9hZGluZy4uLid9XG4gIH0pO1xuXG4gIGNvbnN0IHtsb2FkZXJzLCBsb2FkT3B0aW9uc30gPSBzdGF0ZTtcbiAgcmV0dXJuIHdpdGhUYXNrKFxuICAgIHN0YXRlV2l0aFByb2dyZXNzLFxuICAgIG1ha2VMb2FkRmlsZVRhc2soXG4gICAgICBmaWxlLFxuICAgICAgbmV4dFN0YXRlLmZpbGVMb2FkaW5nICYmIG5leHRTdGF0ZS5maWxlTG9hZGluZy5maWxlQ2FjaGUsXG4gICAgICBsb2FkZXJzLFxuICAgICAgbG9hZE9wdGlvbnNcbiAgICApXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTG9hZEZpbGVUYXNrKGZpbGUsIGZpbGVDYWNoZSwgbG9hZGVyczogTG9hZGVyW10gPSBbXSwgbG9hZE9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gTE9BRF9GSUxFX1RBU0soe2ZpbGUsIGZpbGVDYWNoZSwgbG9hZGVycywgbG9hZE9wdGlvbnN9KS5iaW1hcChcbiAgICAvLyBwcmV0dGllciBpZ25vcmVcbiAgICAvLyBzdWNjZXNzXG4gICAgZ2VuID0+XG4gICAgICBuZXh0RmlsZUJhdGNoKHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICBvbkZpbmlzaDogcmVzdWx0ID0+XG4gICAgICAgICAgcHJvY2Vzc0ZpbGVDb250ZW50KHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJlc3VsdCxcbiAgICAgICAgICAgIGZpbGVDYWNoZVxuICAgICAgICAgIH0pXG4gICAgICB9KSxcblxuICAgIC8vIGVycm9yXG4gICAgZXJyID0+IGxvYWRGaWxlc0VycihmaWxlLm5hbWUsIGVycilcbiAgKTtcbn1cblxuLyoqXG4gKlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NGaWxlQ29udGVudFVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuUHJvY2Vzc0ZpbGVDb250ZW50VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7Y29udGVudCwgZmlsZUNhY2hlfSA9IGFjdGlvbi5wYXlsb2FkO1xuXG4gIGNvbnN0IHN0YXRlV2l0aFByb2dyZXNzID0gdXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIoc3RhdGUsIHtcbiAgICBmaWxlTmFtZTogY29udGVudC5maWxlTmFtZSxcbiAgICBwcm9ncmVzczoge3BlcmNlbnQ6IDEsIG1lc3NhZ2U6ICdwcm9jZXNzaW5nLi4uJ31cbiAgfSk7XG5cbiAgcmV0dXJuIHdpdGhUYXNrKFxuICAgIHN0YXRlV2l0aFByb2dyZXNzLFxuICAgIFBST0NFU1NfRklMRV9EQVRBKHtjb250ZW50LCBmaWxlQ2FjaGV9KS5iaW1hcChcbiAgICAgIHJlc3VsdCA9PiBsb2FkRmlsZVN0ZXBTdWNjZXNzKHtmaWxlTmFtZTogY29udGVudC5maWxlTmFtZSwgZmlsZUNhY2hlOiByZXN1bHR9KSxcbiAgICAgIGVyciA9PiBsb2FkRmlsZXNFcnIoY29udGVudC5maWxlTmFtZSwgZXJyKVxuICAgIClcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHJvZ3Jlc3MocHJldlByb2dyZXNzID0ge30sIHByb2dyZXNzKSB7XG4gIC8vIFRoaXMgaGFwcGVucyB3aGVuIHJlY2VpdmluZyBxdWVyeSBtZXRhZGF0YSBvciBvdGhlciBjYXNlcyB3ZSBkb24ndFxuICAvLyBoYXZlIGFuIHVwZGF0ZSBmb3IgdGhlIHVzZXIuXG4gIGlmICghcHJvZ3Jlc3MgfHwgIXByb2dyZXNzLnBlcmNlbnQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBlcmNlbnQ6IHByb2dyZXNzLnBlcmNlbnRcbiAgfTtcbn1cblxuLyoqXG4gKiBnZXRzIGNhbGxlZCB3aXRoIHBheWxvYWQgPSBBc3luY0dlbmVyYXRvcjw/Pz8+XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbmV4dEZpbGVCYXRjaFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge1xuICAgIHBheWxvYWQ6IHtnZW4sIGZpbGVOYW1lLCBwcm9ncmVzcywgYWNjdW11bGF0ZWQsIG9uRmluaXNofVxuICB9OiBWaXNTdGF0ZUFjdGlvbnMuTmV4dEZpbGVCYXRjaFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgY29uc3Qgc3RhdGVXaXRoUHJvZ3Jlc3MgPSB1cGRhdGVGaWxlTG9hZGluZ1Byb2dyZXNzVXBkYXRlcihzdGF0ZSwge1xuICAgIGZpbGVOYW1lLFxuICAgIHByb2dyZXNzOiBwYXJzZVByb2dyZXNzKHN0YXRlLmZpbGVMb2FkaW5nUHJvZ3Jlc3NbZmlsZU5hbWVdLCBwcm9ncmVzcylcbiAgfSk7XG5cbiAgcmV0dXJuIHdpdGhUYXNrKHN0YXRlV2l0aFByb2dyZXNzLCBbXG4gICAgLi4uKGZpbGVOYW1lLmVuZHNXaXRoKCdhcnJvdycpICYmIGFjY3VtdWxhdGVkPy5kYXRhPy5sZW5ndGggPiAwXG4gICAgICA/IFtcbiAgICAgICAgICBQUk9DRVNTX0ZJTEVfREFUQSh7Y29udGVudDogYWNjdW11bGF0ZWQsIGZpbGVDYWNoZTogW119KS5iaW1hcChcbiAgICAgICAgICAgIHJlc3VsdCA9PiBsb2FkRmlsZXNTdWNjZXNzKHJlc3VsdCksXG4gICAgICAgICAgICBlcnIgPT4gbG9hZEZpbGVzRXJyKGZpbGVOYW1lLCBlcnIpXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICA6IFtdKSxcbiAgICBVTldSQVBfVEFTSyhnZW4ubmV4dCgpKS5iaW1hcChcbiAgICAgICh7dmFsdWUsIGRvbmV9KSA9PiB7XG4gICAgICAgIHJldHVybiBkb25lXG4gICAgICAgICAgPyBvbkZpbmlzaChhY2N1bXVsYXRlZClcbiAgICAgICAgICA6IG5leHRGaWxlQmF0Y2goe1xuICAgICAgICAgICAgICBnZW4sXG4gICAgICAgICAgICAgIGZpbGVOYW1lLFxuICAgICAgICAgICAgICBwcm9ncmVzczogdmFsdWUucHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGFjY3VtdWxhdGVkOiB2YWx1ZSxcbiAgICAgICAgICAgICAgb25GaW5pc2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGVyciA9PiBsb2FkRmlsZXNFcnIoZmlsZU5hbWUsIGVycilcbiAgICApXG4gIF0pO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGxvYWRpbmcgZmlsZSBlcnJvclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRGaWxlc0VyclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2Vycm9yLCBmaWxlTmFtZX06IFZpc1N0YXRlQWN0aW9ucy5Mb2FkRmlsZXNFcnJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIC8vIHVwZGF0ZSB1aSB3aXRoIGVycm9yIG1lc3NhZ2VcbiAgQ29uc29sZS53YXJuKGVycm9yKTtcbiAgaWYgKCFzdGF0ZS5maWxlTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB7ZmlsZXNUb0xvYWQsIG9uRmluaXNoLCBmaWxlQ2FjaGV9ID0gc3RhdGUuZmlsZUxvYWRpbmc7XG5cbiAgY29uc3QgbmV4dFN0YXRlID0gdXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIoc3RhdGUsIHtcbiAgICBmaWxlTmFtZSxcbiAgICBwcm9ncmVzczoge2Vycm9yfVxuICB9KTtcblxuICAvLyBraWNrIG9mZiBuZXh0IGZpbGUgb3IgZmluaXNoXG4gIHJldHVybiB3aXRoVGFzayhcbiAgICBuZXh0U3RhdGUsXG4gICAgREVMQVlfVEFTSygyMDApLm1hcChmaWxlc1RvTG9hZC5sZW5ndGggPyBsb2FkTmV4dEZpbGUgOiAoKSA9PiBvbkZpbmlzaChmaWxlQ2FjaGUpKVxuICApO1xufTtcblxuLyoqXG4gKiBXaGVuIHNlbGVjdCBkYXRhc2V0IGZvciBleHBvcnQsIGFwcGx5IGNwdSBmaWx0ZXIgdG8gc2VsZWN0ZWQgZGF0YXNldFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5Q1BVRmlsdGVyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZGF0YUlkfTogVmlzU3RhdGVBY3Rpb25zLkFwcGx5Q1BVRmlsdGVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICAvLyBhcHBseSBjcHVGaWx0ZXJcbiAgY29uc3QgZGF0YUlkcyA9IHRvQXJyYXkoZGF0YUlkKTtcblxuICByZXR1cm4gZGF0YUlkcy5yZWR1Y2UoKGFjY3UsIGlkKSA9PiBmaWx0ZXJEYXRhc2V0Q1BVKGFjY3UsIGlkKSwgc3RhdGUpO1xufTtcblxuLyoqXG4gKiBVc2VyIGlucHV0IHRvIHVwZGF0ZSB0aGUgaW5mbyBvZiB0aGUgbWFwXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgc2V0TWFwSW5mb1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuU2V0TWFwSW5mb1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBtYXBJbmZvOiB7XG4gICAgLi4uc3RhdGUubWFwSW5mbyxcbiAgICAuLi5hY3Rpb24uaW5mb1xuICB9XG59KTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHVwZGF0ZSBBbGwgbGF5ZXIgZG9tYWluIGFuZCBsYXllciBkYXRhIG9mIHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGREZWZhdWx0TGF5ZXJzKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGRhdGFzZXRzOiBEYXRhc2V0c1xuKToge3N0YXRlOiBWaXNTdGF0ZTsgbmV3TGF5ZXJzOiBMYXllcltdfSB7XG4gIGNvbnN0IGVtcHR5OiBMYXllcltdID0gW107XG4gIGNvbnN0IGRlZmF1bHRMYXllcnMgPSBPYmplY3QudmFsdWVzKGRhdGFzZXRzKS5yZWR1Y2UoKGFjY3U6IExheWVyW10sIGRhdGFzZXQpID0+IHtcbiAgICBjb25zdCBmb3VuZExheWVycyA9IGZpbmREZWZhdWx0TGF5ZXIoZGF0YXNldCwgc3RhdGUubGF5ZXJDbGFzc2VzKTtcbiAgICByZXR1cm4gZm91bmRMYXllcnMgJiYgZm91bmRMYXllcnMubGVuZ3RoID8gYWNjdS5jb25jYXQoZm91bmRMYXllcnMpIDogYWNjdTtcbiAgfSwgZW1wdHkpO1xuXG4gIHJldHVybiB7XG4gICAgc3RhdGU6IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgbGF5ZXJzOiBbLi4uc3RhdGUubGF5ZXJzLCAuLi5kZWZhdWx0TGF5ZXJzXSxcbiAgICAgIGxheWVyT3JkZXI6IFtcbiAgICAgICAgLy8gcHV0IG5ldyBsYXllcnMgb24gdG9wIG9mIG9sZCBvbmVzIGluIHJldmVyc2VcbiAgICAgICAgLi4uZ2V0TGF5ZXJPcmRlckZyb21MYXllcnMoZGVmYXVsdExheWVycyksXG4gICAgICAgIC4uLnN0YXRlLmxheWVyT3JkZXJcbiAgICAgIF1cbiAgICB9LFxuICAgIG5ld0xheWVyczogZGVmYXVsdExheWVyc1xuICB9O1xufVxuXG4vKipcbiAqIGhlbHBlciBmdW5jdGlvbiB0byBmaW5kIGRlZmF1bHQgdG9vbHRpcHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFzZXRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRGVmYXVsdFRvb2x0aXBzKHN0YXRlLCBkYXRhc2V0KSB7XG4gIGNvbnN0IHRvb2x0aXBGaWVsZHMgPSBmaW5kRmllbGRzVG9TaG93KHtcbiAgICAuLi5kYXRhc2V0LFxuICAgIG1heERlZmF1bHRUb29sdGlwczogc3RhdGUubWF4RGVmYXVsdFRvb2x0aXBzXG4gIH0pO1xuICBjb25zdCBtZXJnZWQgPSB7XG4gICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcC5jb25maWcuZmllbGRzVG9TaG93LFxuICAgIC4uLnRvb2x0aXBGaWVsZHNcbiAgfTtcblxuICByZXR1cm4gc2V0KFsnaW50ZXJhY3Rpb25Db25maWcnLCAndG9vbHRpcCcsICdjb25maWcnLCAnZmllbGRzVG9TaG93J10sIG1lcmdlZCwgc3RhdGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbEZpbGVMb2FkaW5nUHJvZ3Jlc3MoZmlsZSwgaW5kZXgpIHtcbiAgY29uc3QgZmlsZU5hbWUgPSBmaWxlLm5hbWUgfHwgYFVudGl0bGVkIEZpbGUgJHtpbmRleH1gO1xuICByZXR1cm4ge1xuICAgIFtmaWxlTmFtZV06IHtcbiAgICAgIC8vIHBlcmNlbnQgb2YgY3VycmVudCBmaWxlXG4gICAgICBwZXJjZW50OiAwLFxuICAgICAgbWVzc2FnZTogJycsXG4gICAgICBmaWxlTmFtZSxcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIoc3RhdGUsIHtmaWxlTmFtZSwgcHJvZ3Jlc3N9KSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgcmV0dXJuIHBpY2tfKCdmaWxlTG9hZGluZ1Byb2dyZXNzJykocGlja18oZmlsZU5hbWUpKG1lcmdlXyhwcm9ncmVzcykpKShzdGF0ZSk7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB1cGRhdGUgbGF5ZXIgZG9tYWlucyBmb3IgYW4gYXJyYXkgb2YgZGF0YXNldHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUFsbExheWVyRG9tYWluRGF0YShcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBkYXRhSWQ6IHN0cmluZyB8IHN0cmluZ1tdLFxuICB1cGRhdGVkRmlsdGVyPzogRmlsdGVyXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IGRhdGFJZHMgPSB0eXBlb2YgZGF0YUlkID09PSAnc3RyaW5nJyA/IFtkYXRhSWRdIDogZGF0YUlkO1xuICBjb25zdCBuZXdMYXllcnM6IExheWVyW10gPSBbXTtcbiAgY29uc3QgbmV3TGF5ZXJEYXRhOiBhbnlbXSA9IFtdO1xuXG4gIHN0YXRlLmxheWVycy5mb3JFYWNoKChvbGRMYXllciwgaSkgPT4ge1xuICAgIGlmIChvbGRMYXllci5jb25maWcuZGF0YUlkICYmIGRhdGFJZHMuaW5jbHVkZXMob2xkTGF5ZXIuY29uZmlnLmRhdGFJZCkpIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gcmVjYWxjdWxhdGUgbGF5ZXIgZG9tYWluIGlmIGZpbHRlciBoYXMgZml4ZWQgZG9tYWluXG4gICAgICBjb25zdCBuZXdMYXllciA9XG4gICAgICAgIHVwZGF0ZWRGaWx0ZXIgJiYgdXBkYXRlZEZpbHRlci5maXhlZERvbWFpblxuICAgICAgICAgID8gb2xkTGF5ZXJcbiAgICAgICAgICA6IG9sZExheWVyLnVwZGF0ZUxheWVyRG9tYWluKHN0YXRlLmRhdGFzZXRzLCB1cGRhdGVkRmlsdGVyKTtcblxuICAgICAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCBzdGF0ZSwgc3RhdGUubGF5ZXJEYXRhW2ldKTtcblxuICAgICAgbmV3TGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgbmV3TGF5ZXJEYXRhLnB1c2gobGF5ZXJEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3TGF5ZXJzLnB1c2gob2xkTGF5ZXIpO1xuICAgICAgbmV3TGF5ZXJEYXRhLnB1c2goc3RhdGUubGF5ZXJEYXRhW2ldKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogbmV3TGF5ZXJzLFxuICAgIGxheWVyRGF0YTogbmV3TGF5ZXJEYXRhXG4gIH07XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQW5pbWF0aW9uRG9tYWluPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oc3RhdGU6IFMpOiBTIHtcbiAgLy8gbWVyZ2UgYWxsIGFuaW1hdGFibGUgbGF5ZXIgZG9tYWluIGFuZCB1cGRhdGUgZ2xvYmFsIGNvbmZpZ1xuICBjb25zdCBhbmltYXRhYmxlTGF5ZXJzID0gc3RhdGUubGF5ZXJzLmZpbHRlcihcbiAgICBsID0+XG4gICAgICBsLmNvbmZpZy5pc1Zpc2libGUgJiZcbiAgICAgIGwuY29uZmlnLmFuaW1hdGlvbiAmJlxuICAgICAgbC5jb25maWcuYW5pbWF0aW9uLmVuYWJsZWQgJiZcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHJpcC1sYXllci1vbmx5XG4gICAgICBBcnJheS5pc0FycmF5KGwuYW5pbWF0aW9uRG9tYWluKVxuICApO1xuXG4gIGlmICghYW5pbWF0YWJsZUxheWVycy5sZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBhbmltYXRpb25Db25maWc6IHtcbiAgICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgICBkb21haW46IG51bGwsXG4gICAgICAgIGRlZmF1bHRUaW1lRm9ybWF0OiBudWxsXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IG1lcmdlZERvbWFpbjogW251bWJlciwgbnVtYmVyXSA9IGFuaW1hdGFibGVMYXllcnMucmVkdWNlKFxuICAgIChhY2N1LCBsYXllcikgPT4gW1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0cmlwLWxheWVyLW9ubHlcbiAgICAgIE1hdGgubWluKGFjY3VbMF0sIGxheWVyLmFuaW1hdGlvbkRvbWFpblswXSksXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRyaXAtbGF5ZXItb25seVxuICAgICAgTWF0aC5tYXgoYWNjdVsxXSwgbGF5ZXIuYW5pbWF0aW9uRG9tYWluWzFdKVxuICAgIF0sXG4gICAgW051bWJlcihJbmZpbml0eSksIC1JbmZpbml0eV1cbiAgKTtcbiAgY29uc3QgZGVmYXVsdFRpbWVGb3JtYXQgPSBnZXRUaW1lV2lkZ2V0VGl0bGVGb3JtYXR0ZXIobWVyZ2VkRG9tYWluKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGFuaW1hdGlvbkNvbmZpZzoge1xuICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgY3VycmVudFRpbWU6IGlzSW5SYW5nZShzdGF0ZS5hbmltYXRpb25Db25maWcuY3VycmVudFRpbWUsIG1lcmdlZERvbWFpbilcbiAgICAgICAgPyBzdGF0ZS5hbmltYXRpb25Db25maWcuY3VycmVudFRpbWVcbiAgICAgICAgOiBtZXJnZWREb21haW5bMF0sXG4gICAgICBkb21haW46IG1lcmdlZERvbWFpbixcbiAgICAgIGRlZmF1bHRUaW1lRm9ybWF0XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgc3RhdHVzIG9mIHRoZSBlZGl0b3JcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRFZGl0b3JNb2RlVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7bW9kZX06IFZpc1N0YXRlQWN0aW9ucy5TZXRFZGl0b3JNb2RlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGVkaXRvcjoge1xuICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICBtb2RlLFxuICAgIHNlbGVjdGVkRmVhdHVyZTogbnVsbFxuICB9XG59KTtcblxuLy8gY29uc3QgZmVhdHVyZVRvRmlsdGVyVmFsdWUgPSAoZmVhdHVyZSkgPT4gKHsuLi5mZWF0dXJlLCBpZDogZmVhdHVyZS5pZH0pO1xuLyoqXG4gKiBVcGRhdGUgZWRpdG9yIGZlYXR1cmVzXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RmVhdHVyZXNVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtmZWF0dXJlcyA9IFtdfTogVmlzU3RhdGVBY3Rpb25zLlNldEZlYXR1cmVzVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCBsYXN0RmVhdHVyZSA9IGZlYXR1cmVzLmxlbmd0aCAmJiBmZWF0dXJlc1tmZWF0dXJlcy5sZW5ndGggLSAxXTtcblxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZGl0b3I6IHtcbiAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgIC8vIG9ubHkgc2F2ZSBub25lIGZpbHRlciBmZWF0dXJlcyB0byBlZGl0b3JcbiAgICAgIGZlYXR1cmVzOiBmZWF0dXJlcy5maWx0ZXIoZiA9PiAhZ2V0RmlsdGVySWRJbkZlYXR1cmUoZikpLFxuICAgICAgbW9kZTogbGFzdEZlYXR1cmUgJiYgbGFzdEZlYXR1cmUucHJvcGVydGllcy5pc0Nsb3NlZCA/IEVESVRPUl9NT0RFUy5FRElUIDogc3RhdGUuZWRpdG9yLm1vZGVcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgZXhpc3RpbmcgZmVhdHVyZVxuICBjb25zdCB7c2VsZWN0ZWRGZWF0dXJlfSA9IHN0YXRlLmVkaXRvcjtcblxuICAvLyBJZiBubyBmZWF0dXJlIGlzIHNlbGVjdGVkIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHNpbmNlIG5vIG9wZXJhdGlvbnNcbiAgaWYgKCFzZWxlY3RlZEZlYXR1cmUpIHtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cblxuICAvLyBUT0RPOiBjaGVjayBpZiB0aGUgZmVhdHVyZSBoYXMgY2hhbmdlZFxuICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXMuZmluZChmID0+IGYuaWQgPT09IHNlbGVjdGVkRmVhdHVyZS5pZCk7XG5cbiAgLy8gaWYgZmVhdHVyZSBpcyBwYXJ0IG9mIGEgZmlsdGVyXG4gIGNvbnN0IGZpbHRlcklkID0gZmVhdHVyZSAmJiBnZXRGaWx0ZXJJZEluRmVhdHVyZShmZWF0dXJlKTtcbiAgaWYgKGZpbHRlcklkICYmIGZlYXR1cmUpIHtcbiAgICAvLyBhZGQgYmJveCBmb3IgcG9seWdvbiBmaWx0ZXIgdG8gc3BlZWQgdXAgZmlsdGVyaW5nXG4gICAgaWYgKGZlYXR1cmUucHJvcGVydGllcykgZmVhdHVyZS5wcm9wZXJ0aWVzLmJib3ggPSBiYm94KGZlYXR1cmUpO1xuICAgIGNvbnN0IGZlYXR1cmVWYWx1ZSA9IGZlYXR1cmVUb0ZpbHRlclZhbHVlKGZlYXR1cmUsIGZpbHRlcklkKTtcbiAgICBjb25zdCBmaWx0ZXJJZHggPSBzdGF0ZS5maWx0ZXJzLmZpbmRJbmRleChmaWwgPT4gZmlsLmlkID09PSBmaWx0ZXJJZCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBzZXRGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgICBpZHg6IGZpbHRlcklkeCxcbiAgICAgIHByb3A6ICd2YWx1ZScsXG4gICAgICB2YWx1ZTogZmVhdHVyZVZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IHNlbGVjdGVkIGZlYXR1cmVcbiAqIEBtZW1iZXJvZiB1aVN0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldFNlbGVjdGVkRmVhdHVyZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2ZlYXR1cmUsIHNlbGVjdGlvbkNvbnRleHR9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0U2VsZWN0ZWRGZWF0dXJlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICAvLyBhZGQgYmJveCBmb3IgcG9seWdvbiBmaWx0ZXIgdG8gc3BlZWQgdXAgZmlsdGVyaW5nXG4gICBpZiAoZmVhdHVyZSAmJiBmZWF0dXJlLnByb3BlcnRpZXMpIGZlYXR1cmUucHJvcGVydGllcy5iYm94ID0gYmJveChmZWF0dXJlKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZGl0b3I6IHtcbiAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgIHNlbGVjdGVkRmVhdHVyZTogZmVhdHVyZSxcbiAgICAgIHNlbGVjdGlvbkNvbnRleHRcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIERlbGV0ZSBleGlzdGluZyBmZWF0dXJlIGZyb20gZmlsdGVyc1xuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZUZlYXR1cmVVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtmZWF0dXJlfTogVmlzU3RhdGVBY3Rpb25zLkRlbGV0ZUZlYXR1cmVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGlmICghZmVhdHVyZSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRvcjoge1xuICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgc2VsZWN0ZWRGZWF0dXJlOiBudWxsXG4gICAgfVxuICB9O1xuXG4gIGlmIChnZXRGaWx0ZXJJZEluRmVhdHVyZShmZWF0dXJlKSkge1xuICAgIGNvbnN0IGZpbHRlcklkeCA9IG5ld1N0YXRlLmZpbHRlcnMuZmluZEluZGV4KGYgPT4gZi5pZCA9PT0gZ2V0RmlsdGVySWRJbkZlYXR1cmUoZmVhdHVyZSkpO1xuXG4gICAgcmV0dXJuIGZpbHRlcklkeCA+IC0xID8gcmVtb3ZlRmlsdGVyVXBkYXRlcihuZXdTdGF0ZSwge2lkeDogZmlsdGVySWR4fSkgOiBuZXdTdGF0ZTtcbiAgfVxuXG4gIC8vIG1vZGlmeSBlZGl0b3Igb2JqZWN0XG4gIGNvbnN0IG5ld0VkaXRvciA9IHtcbiAgICAuLi5zdGF0ZS5lZGl0b3IsXG4gICAgZmVhdHVyZXM6IHN0YXRlLmVkaXRvci5mZWF0dXJlcy5maWx0ZXIoZiA9PiBmLmlkICE9PSBmZWF0dXJlLmlkKSxcbiAgICBzZWxlY3RlZEZlYXR1cmU6IG51bGxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRvcjogbmV3RWRpdG9yXG4gIH07XG59XG5cbi8qKlxuICogVG9nZ2xlIGZlYXR1cmUgYXMgbGF5ZXIgZmlsdGVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9seWdvbkZpbHRlckxheWVyVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBwYXlsb2FkOiBWaXNTdGF0ZUFjdGlvbnMuU2V0UG9seWdvbkZpbHRlckxheWVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7bGF5ZXIsIGZlYXR1cmV9ID0gcGF5bG9hZDtcbiAgY29uc3QgZmlsdGVySWQgPSBnZXRGaWx0ZXJJZEluRmVhdHVyZShmZWF0dXJlKTtcblxuICAvLyBsZXQgbmV3RmlsdGVyID0gbnVsbDtcbiAgbGV0IGZpbHRlcklkeDtcbiAgbGV0IG5ld0xheWVySWQgPSBbbGF5ZXIuaWRdO1xuICBsZXQgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgLy8gSWYgcG9seWdvbiBmaWx0ZXIgYWxyZWFkeSBleGlzdHMsIHdlIG5lZWQgdG8gZmluZCBvdXQgaWYgdGhlIGN1cnJlbnQgbGF5ZXIgaXMgYWxyZWFkeSBpbmNsdWRlZFxuICBpZiAoZmlsdGVySWQpIHtcbiAgICBmaWx0ZXJJZHggPSBzdGF0ZS5maWx0ZXJzLmZpbmRJbmRleChmID0+IGYuaWQgPT09IGZpbHRlcklkKTtcblxuICAgIGlmICghc3RhdGUuZmlsdGVyc1tmaWx0ZXJJZHhdKSB7XG4gICAgICAvLyB3aGF0IGlmIGZpbHRlciBkb2Vzbid0IGV4aXN0Py4uLiBub3QgcG9zc2libGUuXG4gICAgICAvLyBiZWNhdXNlIGZlYXR1cmVzIGluIHRoZSBlZGl0b3IgaXMgcGFzc2VkIGluIGZyb20gZmlsdGVycyBhbmQgZWRpdG9ycy5cbiAgICAgIC8vIGJ1dCB3ZSB3aWxsIG1vdmUgdGhpcyBmZWF0dXJlIGJhY2sgdG8gZWRpdG9yIGp1c3QgaW4gY2FzZVxuICAgICAgY29uc3Qgbm9uZUZpbHRlckZlYXR1cmUgPSB7XG4gICAgICAgIC4uLmZlYXR1cmUsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAuLi5mZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICAgICAgZmlsdGVySWQ6IG51bGxcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGVkaXRvcjoge1xuICAgICAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgICAgICBmZWF0dXJlczogWy4uLnN0YXRlLmVkaXRvci5mZWF0dXJlcywgbm9uZUZpbHRlckZlYXR1cmVdLFxuICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZTogbm9uZUZpbHRlckZlYXR1cmVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyID0gc3RhdGUuZmlsdGVyc1tmaWx0ZXJJZHhdO1xuICAgIGNvbnN0IHtsYXllcklkID0gW119ID0gZmlsdGVyO1xuICAgIGNvbnN0IGlzTGF5ZXJJbmNsdWRlZCA9IGxheWVySWQuaW5jbHVkZXMobGF5ZXIuaWQpO1xuXG4gICAgbmV3TGF5ZXJJZCA9IGlzTGF5ZXJJbmNsdWRlZFxuICAgICAgPyAvLyBpZiBsYXllciBpcyBpbmNsdWRlZCwgcmVtb3ZlIGl0XG4gICAgICAgIGxheWVySWQuZmlsdGVyKGwgPT4gbCAhPT0gbGF5ZXIuaWQpXG4gICAgICA6IFsuLi5sYXllcklkLCBsYXllci5pZF07XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgd2UgaGF2ZW4ndCBjcmVhdGUgdGhlIHBvbHlnb24gZmlsdGVyLCBjcmVhdGUgaXRcbiAgICBjb25zdCBuZXdGaWx0ZXIgPSBnZW5lcmF0ZVBvbHlnb25GaWx0ZXIoW10sIGZlYXR1cmUpO1xuICAgIGZpbHRlcklkeCA9IHN0YXRlLmZpbHRlcnMubGVuZ3RoO1xuXG4gICAgLy8gYWRkIGZlYXR1cmUsIHJlbW92ZSBmZWF0dXJlIGZyb20gZWlkdG9yXG4gICAgbmV3U3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGZpbHRlcnM6IFsuLi5zdGF0ZS5maWx0ZXJzLCBuZXdGaWx0ZXJdLFxuICAgICAgZWRpdG9yOiB7XG4gICAgICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICAgICAgZmVhdHVyZXM6IHN0YXRlLmVkaXRvci5mZWF0dXJlcy5maWx0ZXIoZiA9PiBmLmlkICE9PSBmZWF0dXJlLmlkKSxcbiAgICAgICAgc2VsZWN0ZWRGZWF0dXJlOiBuZXdGaWx0ZXIudmFsdWVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHNldEZpbHRlclVwZGF0ZXIobmV3U3RhdGUsIHtcbiAgICBpZHg6IGZpbHRlcklkeCxcbiAgICBwcm9wOiAnbGF5ZXJJZCcsXG4gICAgdmFsdWU6IG5ld0xheWVySWRcbiAgfSk7XG59XG5cbi8qKlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvcnRUYWJsZUNvbHVtblVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2RhdGFJZCwgY29sdW1uLCBtb2RlfTogVmlzU3RhdGVBY3Rpb25zLlNvcnRUYWJsZUNvbHVtblVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3QgZGF0YXNldCA9IHN0YXRlLmRhdGFzZXRzW2RhdGFJZF07XG4gIGlmICghZGF0YXNldCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBsZXQgc29ydE1vZGUgPSBtb2RlO1xuICBpZiAoIXNvcnRNb2RlKSB7XG4gICAgY29uc3QgY3VycmVudE1vZGUgPSBnZXQoZGF0YXNldCwgWydzb3J0Q29sdW1uJywgY29sdW1uXSk7XG4gICAgLy8gQHRzLWlnbm9yZSAtIHNob3VsZCBiZSBmaXhhYmxlIGluIGEgVFMgZmlsZVxuICAgIHNvcnRNb2RlID0gY3VycmVudE1vZGVcbiAgICAgID8gT2JqZWN0LmtleXMoU09SVF9PUkRFUikuZmluZChtID0+IG0gIT09IGN1cnJlbnRNb2RlKVxuICAgICAgOiBTT1JUX09SREVSLkFTQ0VORElORztcbiAgfVxuXG4gIGNvbnN0IHNvcnRlZCA9IHNvcnREYXRhc2V0QnlDb2x1bW4oZGF0YXNldCwgY29sdW1uLCBzb3J0TW9kZSk7XG4gIHJldHVybiBzZXQoWydkYXRhc2V0cycsIGRhdGFJZF0sIHNvcnRlZCwgc3RhdGUpO1xufVxuXG4vKipcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaW5UYWJsZUNvbHVtblVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2RhdGFJZCwgY29sdW1ufTogVmlzU3RhdGVBY3Rpb25zLlBpblRhYmxlQ29sdW1uVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbZGF0YUlkXTtcbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IG5ld0RhdGFzZXQgPSBwaW5UYWJsZUNvbHVtbnMoZGF0YXNldCwgY29sdW1uKTtcblxuICByZXR1cm4gc2V0KFsnZGF0YXNldHMnLCBkYXRhSWRdLCBuZXdEYXRhc2V0LCBzdGF0ZSk7XG59XG5cbi8qKlxuICogQ29weSBjb2x1bW4gY29udGVudCBhcyBzdHJpbmdzXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29weVRhYmxlQ29sdW1uVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZGF0YUlkLCBjb2x1bW59OiBWaXNTdGF0ZUFjdGlvbnMuQ29weVRhYmxlQ29sdW1uVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbZGF0YUlkXTtcbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IGZpZWxkSWR4ID0gZGF0YXNldC5maWVsZHMuZmluZEluZGV4KGYgPT4gZi5uYW1lID09PSBjb2x1bW4pO1xuICBpZiAoZmllbGRJZHggPCAwKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHt0eXBlfSA9IGRhdGFzZXQuZmllbGRzW2ZpZWxkSWR4XTtcbiAgY29uc3QgdGV4dCA9IGRhdGFzZXQuZGF0YUNvbnRhaW5lclxuICAgIC5tYXAocm93ID0+IHBhcnNlRmllbGRWYWx1ZShyb3cudmFsdWVBdChmaWVsZElkeCksIHR5cGUpLCB0cnVlKVxuICAgIC5qb2luKCdcXG4nKTtcblxuICBjb3B5KHRleHQpO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBTZXQgZGlzcGxheSBmb3JtYXQgZnJvbSBjb2x1bW5zIGZyb20gdXNlciBzZWxlY3Rpb25cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb2x1bW5EaXNwbGF5Rm9ybWF0VXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZGF0YUlkLCBmb3JtYXRzfTogVmlzU3RhdGVBY3Rpb25zLlNldENvbHVtbkRpc3BsYXlGb3JtYXRVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBzdGF0ZS5kYXRhc2V0c1tkYXRhSWRdO1xuICBpZiAoIWRhdGFzZXQpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgbGV0IG5ld0ZpZWxkcyA9IGRhdGFzZXQuZmllbGRzO1xuICBPYmplY3Qua2V5cyhmb3JtYXRzKS5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgY29uc3QgZmllbGRJZHggPSBkYXRhc2V0LmZpZWxkcy5maW5kSW5kZXgoZiA9PiBmLm5hbWUgPT09IGNvbHVtbik7XG4gICAgaWYgKGZpZWxkSWR4ID49IDApIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlGb3JtYXQgPSBmb3JtYXRzW2NvbHVtbl07XG4gICAgICBjb25zdCBmaWVsZCA9IG5ld0ZpZWxkc1tmaWVsZElkeF07XG4gICAgICBuZXdGaWVsZHMgPSBzd2FwXyhtZXJnZV8oe2Rpc3BsYXlGb3JtYXR9KShmaWVsZCkgYXMge2lkOiBzdHJpbmd9KShcbiAgICAgICAgbmV3RmllbGRzIGFzIHtpZDogc3RyaW5nfVtdXG4gICAgICApIGFzIEZpZWxkW107XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBuZXdEYXRhc2V0ID0gY29weVRhYmxlQW5kVXBkYXRlKGRhdGFzZXQsIHtmaWVsZHM6IG5ld0ZpZWxkcyBhcyBGaWVsZFtdfSk7XG4gIHJldHVybiBwaWNrXygnZGF0YXNldHMnKShtZXJnZV8oe1tkYXRhSWRdOiBuZXdEYXRhc2V0fSkpKHN0YXRlKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgZWRpdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVFZGl0b3JWaXNpYmlsaXR5VXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Ub2dnbGVFZGl0b3JWaXNpYmlsaXR5VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRvcjoge1xuICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgdmlzaWJsZTogIXN0YXRlLmVkaXRvci52aXNpYmxlXG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RmlsdGVyQW5pbWF0aW9uVGltZUNvbmZpZ1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2lkeCwgY29uZmlnfTogVmlzU3RhdGVBY3Rpb25zLlNldEZpbHRlckFuaW1hdGlvblRpbWVDb25maWdBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qgb2xkRmlsdGVyID0gc3RhdGUuZmlsdGVyc1tpZHhdO1xuICBpZiAoIW9sZEZpbHRlcikge1xuICAgIENvbnNvbGUuZXJyb3IoYGZpbHRlcnMuJHtpZHh9IGlzIHVuZGVmaW5lZGApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAob2xkRmlsdGVyLnR5cGUgIT09IEZJTFRFUl9UWVBFUy50aW1lUmFuZ2UpIHtcbiAgICBDb25zb2xlLmVycm9yKFxuICAgICAgYHNldEZpbHRlckFuaW1hdGlvblRpbWVDb25maWcgY2FuIG9ubHkgYmUgY2FsbGVkIHRvIHVwZGF0ZSBhIHRpbWUgZmlsdGVyLiBjaGVjayBmaWx0ZXIudHlwZSA9PT0gJ3RpbWVSYW5nZSdgXG4gICAgKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB1cGRhdGVzID0gY2hlY2tUaW1lQ29uZmlnQXJncyhjb25maWcpO1xuXG4gIHJldHVybiBwaWNrXygnZmlsdGVycycpKHN3YXBfKG1lcmdlXyh1cGRhdGVzKShvbGRGaWx0ZXIpKSkoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaGVja1RpbWVDb25maWdBcmdzKGNvbmZpZykge1xuICBjb25zdCBhbGxvd2VkID0gWyd0aW1lRm9ybWF0JywgJ3RpbWV6b25lJ107XG4gIHJldHVybiBPYmplY3Qua2V5cyhjb25maWcpLnJlZHVjZSgoYWNjdSwgcHJvcCkgPT4ge1xuICAgIGlmICghYWxsb3dlZC5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgQ29uc29sZS5lcnJvcihcbiAgICAgICAgYHNldExheWVyQW5pbWF0aW9uVGltZUNvbmZpZyB0YWtlcyB0aW1lRm9ybWF0IGFuZC9vciB0aW1lem9uZSBhcyBvcHRpb25zLCBmb3VuZCAke3Byb3B9YFxuICAgICAgKTtcbiAgICAgIHJldHVybiBhY2N1O1xuICAgIH1cblxuICAgIC8vIGhlcmUgd2UgYXJlIE5PVCBjaGVja2luZyBpZiB0aW1lem9uZSBvciB0aW1lRm9ybWF0IGlucHV0IGlzIHZhbGlkXG4gICAgYWNjdVtwcm9wXSA9IGNvbmZpZ1twcm9wXTtcbiAgICByZXR1cm4gYWNjdTtcbiAgfSwge30pO1xufVxuLyoqXG4gKiBVcGRhdGUgZWRpdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRMYXllckFuaW1hdGlvblRpbWVDb25maWdVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtjb25maWd9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0TGF5ZXJBbmltYXRpb25UaW1lQ29uZmlnQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGlmICghY29uZmlnKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHVwZGF0ZXMgPSBjaGVja1RpbWVDb25maWdBcmdzKGNvbmZpZyk7XG4gIHJldHVybiBwaWNrXygnYW5pbWF0aW9uQ29uZmlnJykobWVyZ2VfKHVwZGF0ZXMpKShzdGF0ZSk7XG59XG5cbi8vIEZpbmQgZGF0YUlkIGZyb20gYSBzYXZlZCB2aXNTdGF0ZSBwcm9wZXJ0eTpcbi8vIGxheWVycywgZmlsdGVycywgaW50ZXJhY3Rpb25zLCBsYXllckJsZW5kaW5nLCBvdmVybGF5QmxlbmRpbmcsIHNwbGl0TWFwcywgYW5pbWF0aW9uQ29uZmlnLCBlZGl0b3Jcbi8vIHJlcGxhY2UgaXQgd2l0aCBhbm90aGVyIGRhdGFJZFxuZnVuY3Rpb24gZGVmYXVsdFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzKHZhbHVlOiBhbnksIGRhdGFJZDogc3RyaW5nLCBkYXRhSWRUb1JlcGxhY2U6IHN0cmluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBmb3IgbGF5ZXJzLCBmaWx0ZXJzLCBjYWxsIGRlZmF1bHRSZXBsYWNlUGFyZW50RGF0YXNldElkcyBvbiBlYWNoIGl0ZW0gaW4gYXJyYXlcbiAgICBjb25zdCByZXBsYWNlZCA9IHZhbHVlXG4gICAgICAubWFwKHYgPT4gZGVmYXVsdFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzKHYsIGRhdGFJZCwgZGF0YUlkVG9SZXBsYWNlKSlcbiAgICAgIC5maWx0ZXIoZCA9PiBkKTtcbiAgICByZXR1cm4gcmVwbGFjZWQubGVuZ3RoID8gcmVwbGFjZWQgOiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUuZGF0YUlkID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5kYXRhSWQgPT09IGRhdGFJZCkge1xuICAgIC8vIG90aGVyc1xuICAgIHJldHVybiB7XG4gICAgICAuLi52YWx1ZSxcbiAgICAgIGRhdGFJZDogZGF0YUlkVG9SZXBsYWNlXG4gICAgfTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlLmRhdGFJZCkgJiYgdmFsdWUuZGF0YUlkLmluY2x1ZGVzKGRhdGFJZCkpIHtcbiAgICAvLyBmaWx0ZXJcbiAgICByZXR1cm4ge1xuICAgICAgLi4udmFsdWUsXG4gICAgICBkYXRhSWQ6IHZhbHVlLmRhdGFJZC5tYXAoZCA9PiAoZCA9PT0gZGF0YUlkID8gZGF0YUlkVG9SZXBsYWNlIDogZCkpXG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5jb25maWc/LmRhdGFJZCAmJiB2YWx1ZS5jb25maWc/LmRhdGFJZCA9PT0gZGF0YUlkKSB7XG4gICAgLy8gbGF5ZXJcbiAgICByZXR1cm4ge1xuICAgICAgLi4udmFsdWUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgLi4udmFsdWUuY29uZmlnLFxuICAgICAgICBkYXRhSWQ6IGRhdGFJZFRvUmVwbGFjZVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLmhhc093blByb3BlcnR5KGRhdGFJZCkpIHtcbiAgICAvLyBmb3IgdmFsdWUgc2F2ZWQgYXMge1tkYXRhSWRdOiB7Li4ufX1cbiAgICByZXR1cm4ge1tkYXRhSWRUb1JlcGxhY2VdOiB2YWx1ZVtkYXRhSWRdfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBGaW5kIGRhdGFzZXRJZHMgZGVyaXZlZCBhIHNhdmVkIHZpc1N0YXRlIFByb3BlcnR5O1xuZnVuY3Rpb24gZmluZENoaWxkRGF0YXNldElkcyh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBmb3IgbGF5ZXJzLCBmaWx0ZXJzLCBjYWxsIGRlZmF1bHRSZXBsYWNlUGFyZW50RGF0YXNldElkcyBvbiBlYWNoIGl0ZW0gaW4gYXJyYXlcbiAgICBjb25zdCBjaGlsZERhdGFJZHMgPSB2YWx1ZS5tYXAoZmluZENoaWxkRGF0YXNldElkcykuZmlsdGVyKGQgPT4gZCk7XG4gICAgcmV0dXJuIGNoaWxkRGF0YUlkcy5sZW5ndGggPyBjaGlsZERhdGFJZHMgOiBudWxsO1xuICB9XG5cbiAgLy8gY2hpbGQgZGF0YSBpZCB1c3VhbGx5IHN0b3JlcyBpbiB0aGUgZGVyaXZlZCBkYXRhc2V0IGluZm9cbiAgcmV0dXJuIHZhbHVlPy5uZXdEYXRhc2V0Py5pbmZvLmlkIHx8IG51bGw7XG59XG5cbi8vIG1vdmVkIHVubWVyZ2VkIGxheWVycywgZmlsdGVycywgaW50ZXJhY3Rpb25zXG5mdW5jdGlvbiBtb3ZlVmFsdWVUb0JlTWVyZ2VkKHN0YXRlLCBwcm9wVmFsdWVzLCB7cHJvcCwgdG9NZXJnZVByb3AsIHNhdmVVbm1lcmdlZH0pIHtcbiAgLy8gcmVtb3ZlIHByb3AgdmFsdWUgZnJvbSBzdGF0ZVxuICAvLyBUT0RPOiBzaG91bGQgd2UgYWRkIHJlbW92ZSB1cGRhdGVyIHRvIG1lcmdlciBhcyB3ZWxsP1xuICBpZiAoIXByb3BWYWx1ZXMpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3Qgc3RhdGVSZW1vdmVkID1cbiAgICBwcm9wID09PSAnbGF5ZXJzJ1xuICAgICAgPyBwcm9wVmFsdWVzLnJlZHVjZSgoYWNjdSwgcHJvcFZhbHVlKSA9PiByZW1vdmVMYXllclVwZGF0ZXIoYWNjdSwge2lkOiBwcm9wVmFsdWUuaWR9KSwgc3RhdGUpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoc3RhdGVbcHJvcF0pXG4gICAgICA/IHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICBbcHJvcF06IHN0YXRlW3Byb3BdLmZpbHRlcihwID0+ICFwcm9wVmFsdWVzLmZpbmQocHJvcFZhbHVlID0+IHAuaWQgPT09IHByb3BWYWx1ZS5pZCkpXG4gICAgICAgIH1cbiAgICAgIDogLy8gaWYgbm90IGFycmF5LCB3ZSB3b24ndCByZW1vdmUgaXQsIHJlbW92ZSBkYXRhc2V0IHNob3VsZCBoYW5kbGUgaXRcbiAgICAgICAgc3RhdGU7XG5cbiAgLy8gbW92ZSB0byBzdGF0ZVRvQmVNZXJnZWRcbiAgY29uc3QgdG9CZU1lcmdlZCA9IHtcbiAgICBbdG9NZXJnZVByb3BdOiBzYXZlVW5tZXJnZWRcbiAgICAgID8gLy8gY2FsbCBtZXJnZSBzYXZlVW5tZXJnZWQgbWV0aG9kXG4gICAgICAgIHNhdmVVbm1lcmdlZChzdGF0ZVJlbW92ZWQsIHByb3BWYWx1ZXMpXG4gICAgICA6IC8vIGlmIHRvTWVyZ2VQcm9wIGlzIGFyYWF5LCBhcHBlbmQgdG8gaXRcbiAgICAgIEFycmF5LmlzQXJyYXkoc3RhdGVSZW1vdmVkW3RvTWVyZ2VQcm9wXSlcbiAgICAgID8gWy4uLnN0YXRlUmVtb3ZlZFt0b01lcmdlUHJvcF0sIC4uLnByb3BWYWx1ZXNdXG4gICAgICA6IC8vIHNhdmUgcHJvcFZhbHVlcyB0byB0b01lcmdlXG4gICAgICBpc09iamVjdChzdGF0ZVJlbW92ZWRbdG9NZXJnZVByb3BdKVxuICAgICAgPyB7XG4gICAgICAgICAgLi4uc3RhdGVSZW1vdmVkW3RvTWVyZ2VQcm9wXSxcbiAgICAgICAgICAuLi5wcm9wVmFsdWVzXG4gICAgICAgIH1cbiAgICAgIDogc3RhdGVSZW1vdmVkW3RvTWVyZ2VQcm9wXVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGVSZW1vdmVkLFxuICAgIC4uLnRvQmVNZXJnZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZURhdGFzZXRBbmREZXBzPFQgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBULFxuICBkYXRhSWQ6IHN0cmluZyxcbiAgZGF0YUlkVG9Vc2U6IHN0cmluZ1xuKTogVCB7XG4gIHJldHVybiBjb21wb3NlXzxUPihbXG4gICAgYXBwbHlfKHJlcGxhY2VEYXRhc2V0RGVwc0luU3RhdGUsIHtkYXRhSWQsIGRhdGFJZFRvVXNlfSksXG4gICAgYXBwbHlfKHJlbW92ZURhdGFzZXRVcGRhdGVyLCB7ZGF0YUlkfSlcbiAgXSkoc3RhdGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVN0YXRlRm9yRGF0YXNldFJlcGxhY2U8VCBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFQsXG4gIGRhdGFJZDogc3RyaW5nLFxuICBkYXRhSWRUb1VzZTogc3RyaW5nXG4pOiBUIHtcbiAgY29uc3Qgc2VyaWFsaXplZFN0YXRlID0gc2VyaWFsaXplVmlzU3RhdGUoc3RhdGUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IG5leHRTdGF0ZSA9IHJlcGxhY2VEYXRhc2V0QW5kRGVwcyhzdGF0ZSwgZGF0YUlkLCBkYXRhSWRUb1VzZSk7XG4gIC8vIG1ha2UgYSBjb3B5IG9mIGxheWVyT3JkZXIsIGJlY2F1c2UgbGF5ZXIgaWQgd2lsbCBiZSByZW1vdmVkIGZyb20gaXQgYnkgY2FsbGluZyByZW1vdmVMYXllclVwZGF0ZXJcbiAgY29uc3QgcHJlc2VydmVMYXllck9yZGVyID0gWy4uLnN0YXRlLmxheWVyT3JkZXJdO1xuXG4gIC8vIHByZXNlcnZlIGRhdGFzZXQgb3JkZXJcbiAgbmV4dFN0YXRlLnByZXNlcnZlRGF0YXNldE9yZGVyID0gT2JqZWN0LmtleXMoc3RhdGUuZGF0YXNldHMpLm1hcChkID0+XG4gICAgZCA9PT0gZGF0YUlkID8gZGF0YUlkVG9Vc2UgOiBkXG4gICk7XG5cbiAgLy8gcHJlc2VydmVMYXllck9yZGVyXG4gIGlmIChuZXh0U3RhdGUubGF5ZXJUb0JlTWVyZ2VkPy5sZW5ndGgpIHtcbiAgICAvLyBjb3B5IHNwbGl0IG1hcHMgdG8gYmUgbWVyZ2VkLCBiZWNhdXNlIGl0IHdpbGwgYmUgcmVzZXQgaW4gcmVtb3ZlIGxheWVyXG4gICAgbmV4dFN0YXRlLnNwbGl0TWFwc1RvQmVNZXJnZWQgPSBzZXJpYWxpemVkU3RhdGU/LnNwbGl0TWFwcyA/PyBbXTtcbiAgICBuZXh0U3RhdGUubGF5ZXJPcmRlciA9IFsuLi5wcmVzZXJ2ZUxheWVyT3JkZXJdO1xuICB9XG5cbiAgcmV0dXJuIG5leHRTdGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VEYXRhc2V0RGVwc0luU3RhdGU8VCBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFQsXG4gIHtkYXRhSWQsIGRhdGFJZFRvVXNlfToge2RhdGFJZDogc3RyaW5nOyBkYXRhSWRUb1VzZTogc3RyaW5nfVxuKTogVCB7XG4gIGNvbnN0IHNlcmlhbGl6ZWRTdGF0ZSA9IHNlcmlhbGl6ZVZpc1N0YXRlKHN0YXRlLCBzdGF0ZS5zY2hlbWEpO1xuXG4gIGNvbnN0IG5leHRTdGF0ZSA9IHN0YXRlLm1lcmdlcnMucmVkdWNlKFxuICAgIChcbiAgICAgIGFjY3VTdGF0ZSxcbiAgICAgIHtwcm9wLCB0b01lcmdlUHJvcCwgcmVwbGFjZVBhcmVudERhdGFzZXRJZHMsIGdldENoaWxkRGF0YXNldElkcywgc2F2ZVVubWVyZ2VkLCBwcmVzZXJ2ZU9yZGVyfVxuICAgICkgPT4ge1xuICAgICAgLy8gZ2V0IGRhdGFzZXQgaWRzIHRoYXQgYXJlIGRlcGVuZHMgb24gdGhpcyBkYXRhc2V0XG4gICAgICBjb25zdCBwcm9wcyA9IHRvQXJyYXkocHJvcCk7XG4gICAgICBjb25zdCB0b01lcmdlUHJvcHMgPSB0b0FycmF5KHRvTWVyZ2VQcm9wKTtcbiAgICAgIGNvbnN0IHNhdmVkUHJvcHMgPSBzZXJpYWxpemVkU3RhdGUgPyBwcm9wcy5tYXAocCA9PiBzZXJpYWxpemVkU3RhdGVbcF0pIDogW107XG5cbiAgICAgIGxldCByZXBsYWNlZFN0YXRlID0gYWNjdVN0YXRlO1xuICAgICAgc2F2ZWRQcm9wcy5mb3JFYWNoKChwcm9wVmFsdWUsIGkpID0+IHtcbiAgICAgICAgY29uc3QgbWVyZ2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICBwcm9wOiBwcm9wc1tpXSxcbiAgICAgICAgICB0b01lcmdlUHJvcDogdG9NZXJnZVByb3BzW2ldLFxuICAgICAgICAgIGdldENoaWxkRGF0YXNldElkcyxcbiAgICAgICAgICBzYXZlVW5tZXJnZWRcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByZXBsYWNlZEl0ZW0gPVxuICAgICAgICAgIHJlcGxhY2VQYXJlbnREYXRhc2V0SWRzPy4ocHJvcFZhbHVlLCBkYXRhSWQsIGRhdGFJZFRvVXNlKSB8fFxuICAgICAgICAgIGRlZmF1bHRSZXBsYWNlUGFyZW50RGF0YXNldElkcyhwcm9wVmFsdWUsIGRhdGFJZCwgZGF0YUlkVG9Vc2UpO1xuICAgICAgICByZXBsYWNlZFN0YXRlID0gcmVwbGFjZWRJdGVtXG4gICAgICAgICAgPyByZXBsYWNlUHJvcFZhbHVlSW5TdGF0ZShyZXBsYWNlZFN0YXRlLCByZXBsYWNlZEl0ZW0sIG1lcmdlck9wdGlvbnMpXG4gICAgICAgICAgOiByZXBsYWNlZFN0YXRlO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBtZXJnZXJPcHRpb25zLnRvTWVyZ2VQcm9wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICByZXBsYWNlZFN0YXRlW21lcmdlck9wdGlvbnMudG9NZXJnZVByb3BdPy5sZW5ndGggJiZcbiAgICAgICAgICBwcmVzZXJ2ZU9yZGVyXG4gICAgICAgICkge1xuICAgICAgICAgIHJlcGxhY2VkU3RhdGVbcHJlc2VydmVPcmRlcl0gPSBwcm9wVmFsdWUubWFwKGl0ZW0gPT4gaXRlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVwbGFjZWRTdGF0ZTtcbiAgICB9LFxuICAgIHN0YXRlXG4gICk7XG5cbiAgcmV0dXJuIG5leHRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVByb3BWYWx1ZUluU3RhdGUoXG4gIHN0YXRlLFxuICByZXBsYWNlZEl0ZW0sXG4gIHtwcm9wLCB0b01lcmdlUHJvcCwgZ2V0Q2hpbGREYXRhc2V0SWRzLCBzYXZlVW5tZXJnZWR9XG4pIHtcbiAgLy8gcHJvcCBpcyBkZXBlbmRzIG9uIHRoZSBkYXRhc2V0IHRvIGJlIHJlcGxhY2VkXG4gIC8vIHJlbW92ZSBwcm9wIGZyb20gc3RhdGUsIGFuZCBtb3ZlIGl0IHRvIHRvQmVNZXJnZWRcbiAgbGV0IG5leHRTdGF0ZSA9IG1vdmVWYWx1ZVRvQmVNZXJnZWQoc3RhdGUsIHJlcGxhY2VkSXRlbSwge3Byb3AsIHRvTWVyZ2VQcm9wLCBzYXZlVW5tZXJnZWR9KTtcbiAgY29uc3QgY2hpbGREYXRhSWRzID0gZ2V0Q2hpbGREYXRhc2V0SWRzPy4ocmVwbGFjZWRJdGVtKSB8fCBmaW5kQ2hpbGREYXRhc2V0SWRzKHJlcGxhY2VkSXRlbSk7XG5cbiAgaWYgKGNoaWxkRGF0YUlkcykge1xuICAgIG5leHRTdGF0ZSA9IHRvQXJyYXkoY2hpbGREYXRhSWRzKS5yZWR1Y2UoKGFjY3UsIGNoaWxkRGF0YUlkKSA9PiB7XG4gICAgICAvLyBzaG91bGRuJ3QgbmVlZCB0byBjaGFuZ2UgY2hpbGQgZGF0YXNldCBpZCxcbiAgICAgIC8vIGJ1dCBzdGlsbCBuZWVkIHRvIG1vdmUgb3V0IG9mIHN0YXRlIGFuZCBtZXJnZSBiYWNrIGluXG4gICAgICByZXR1cm4gcmVwbGFjZURhdGFzZXRBbmREZXBzKGFjY3UsIGNoaWxkRGF0YUlkLCBjaGlsZERhdGFJZCk7XG4gICAgfSwgbmV4dFN0YXRlKTtcbiAgfVxuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuIl19