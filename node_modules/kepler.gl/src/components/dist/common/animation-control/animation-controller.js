"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _react = require("react");

var _d3Array = require("d3-array");

var _window = require("global/window");

var _console = _interopRequireDefault(require("global/console"));

var _constants = require("@kepler.gl/constants");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var AnimationControllerType = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(AnimationControllerType, _Component);

  var _super = _createSuper(AnimationControllerType);

  function AnimationControllerType() {
    (0, _classCallCheck2["default"])(this, AnimationControllerType);
    return _super.apply(this, arguments);
  }

  return AnimationControllerType;
}(_react.Component);

function AnimationControllerFactory() {
  /**
   * 4 Animation Window Types
   * 1. free
   *  |->  |->
   * Current time is a fixed range, animate a moving window that calls next animation frames continuously
   * The increment id based on domain / BASE_SPEED * SPEED
   *
   * 2. incremental
   * |    |->
   * Same as free, current time is a growing range, only the max value of range increment during animation.
   * The increment is also based on domain / BASE_SPEED * SPEED
   *
   * 3. point
   * o -> o
   * Current time is a point, animate a moving point calls next animation frame continuously
   * The increment is based on domain / BASE_SPEED * SPEED
   *
   * 4. interval
   * o ~> o
   * Current time is a point. An array of sorted time steps are provided,
   * animate a moving point jumps to the next step
   */
  var AnimationController = /*#__PURE__*/function (_Component2) {
    (0, _inherits2["default"])(AnimationController, _Component2);

    var _super2 = _createSuper(AnimationController);

    function AnimationController() {
      var _this;

      (0, _classCallCheck2["default"])(this, AnimationController);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super2.call.apply(_super2, [this].concat(args));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "state", {
        isAnimating: false
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_timer", null);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_startTime", 0);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_animate", function (delay) {
        _this._startTime = new Date().getTime();

        var loop = function loop() {
          var current = new Date().getTime();
          var delta = current - _this._startTime;

          if (delta >= delay) {
            _this._nextFrame();

            _this._startTime = new Date().getTime();
          } else {
            _this._timer = (0, _window.requestAnimationFrame)(loop);
          }
        };

        _this._timer = (0, _window.requestAnimationFrame)(loop);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_resetAnimationByDomain", function () {
        var _this$props = _this.props,
            domain = _this$props.domain,
            value = _this$props.value,
            animationWindow = _this$props.animationWindow,
            updateAnimation = _this$props.updateAnimation;

        if (!domain) {
          return;
        } // interim solution while we fully migrate filter and layer controllers


        var setTimelineValue = updateAnimation || _this.props.setTimelineValue;

        if (Array.isArray(value)) {
          if (animationWindow === _constants.ANIMATION_WINDOW.incremental) {
            setTimelineValue([value[0], value[0] + 1]);
          } else {
            setTimelineValue([domain[0], domain[0] + value[1] - value[0]]);
          }
        } else {
          setTimelineValue(domain[0]);
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_resetAnimationByTimeStep", function () {
        var _this$props2 = _this.props,
            _this$props2$steps = _this$props2.steps,
            steps = _this$props2$steps === void 0 ? null : _this$props2$steps,
            updateAnimation = _this$props2.updateAnimation;
        if (!steps) return; // interim solution while we fully migrate filter and layer controllers

        var setTimelineValue = updateAnimation || _this.props.setTimelineValue; // go to the first steps

        setTimelineValue([steps[0], 0]);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_resetAnimation", function () {
        if (_this.props.animationWindow === _constants.ANIMATION_WINDOW.interval) {
          _this._resetAnimationByTimeStep();
        } else {
          _this._resetAnimationByDomain();
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_startAnimation", function () {
        var _this$props$speed = _this.props.speed,
            speed = _this$props$speed === void 0 ? 1 : _this$props$speed;

        _this._clearTimer();

        if (speed > 0) {
          if (_this.props.animationWindow === _constants.ANIMATION_WINDOW.interval) {
            // animate by interval
            // 30*600
            var steps = _this.props.steps;

            if (!Array.isArray(steps) || !steps.length) {
              _console["default"].warn('animation steps should be an array');

              return;
            } // when speed = 1, animation should loop through 600 frames at 60 FPS
            // calculate delay based on # steps


            var delay = _constants.BASE_SPEED * (1000 / _constants.FPS) / steps.length / (speed || 1);

            _this._animate(delay);
          } else {
            _this._timer = (0, _window.requestAnimationFrame)(_this._nextFrame);
          }
        }

        _this.setState({
          isAnimating: true
        });
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_clearTimer", function () {
        if (_this._timer) {
          (0, _window.cancelAnimationFrame)(_this._timer);
          _this._timer = null;
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_pauseAnimation", function () {
        _this._clearTimer();

        _this.setState({
          isAnimating: false
        });
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_nextFrame", function () {
        _this._timer = null;
        var nextValue = _this.props.animationWindow === _constants.ANIMATION_WINDOW.interval ? _this._nextFrameByTimeStep() : _this._nextFrameByDomain(); // interim solution while we fully migrate filter and layer controllers

        var setTimelineValue = _this.props.updateAnimation || _this.props.setTimelineValue;
        setTimelineValue(nextValue);
      });
      return _this;
    }

    (0, _createClass2["default"])(AnimationController, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._startOrPauseAnimation();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this._startOrPauseAnimation();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._timer) {
          (0, _window.cancelAnimationFrame)(this._timer);
        }
      }
    }, {
      key: "_startOrPauseAnimation",
      value: function _startOrPauseAnimation() {
        var _this$props3 = this.props,
            isAnimating = _this$props3.isAnimating,
            _this$props3$speed = _this$props3.speed,
            speed = _this$props3$speed === void 0 ? 1 : _this$props3$speed;

        if (!this._timer && isAnimating && speed > 0) {
          this._startAnimation();
        } else if (this._timer && !isAnimating) {
          this._pauseAnimation();
        }
      }
    }, {
      key: "_nextFrameByDomain",
      value: function _nextFrameByDomain() {
        var _this$props4 = this.props,
            domain = _this$props4.domain,
            value = _this$props4.value,
            _this$props4$speed = _this$props4.speed,
            speed = _this$props4$speed === void 0 ? 1 : _this$props4$speed,
            _this$props4$baseSpee = _this$props4.baseSpeed,
            baseSpeed = _this$props4$baseSpee === void 0 ? 600 : _this$props4$baseSpee,
            animationWindow = _this$props4.animationWindow;

        if (!domain) {
          return;
        }

        var delta = (domain[1] - domain[0]) / baseSpeed * speed; // loop when reaches the end
        // current time is a range

        if (Array.isArray(value)) {
          var value0;
          var value1;

          if (animationWindow === _constants.ANIMATION_WINDOW.incremental) {
            var lastFrame = value[1] + delta > domain[1];
            value0 = value[0];
            value1 = lastFrame ? value[0] + 1 : value[1] + delta;
          } else {
            // use value[0] to display the last item  duration as the first item
            var _lastFrame = value[0] + delta > domain[1];

            value0 = _lastFrame ? domain[0] : value[0] + delta;
            value1 = value0 + value[1] - value[0];
          }

          return [value0, value1];
        } // current time is a point


        return Number(value) + delta > domain[1] ? domain[0] : Number(value) + delta;
      }
    }, {
      key: "_nextFrameByTimeStep",
      value: function _nextFrameByTimeStep() {
        var _this$props5 = this.props,
            _this$props5$steps = _this$props5.steps,
            steps = _this$props5$steps === void 0 ? null : _this$props5$steps,
            value = _this$props5.value;
        if (!steps) return;
        var val = Array.isArray(value) ? value[0] : Number(value);
        var index = (0, _d3Array.bisectLeft)(steps, val);
        var nextIdx = index >= steps.length - 1 ? 0 : index + 1; // why do we need to pass an array of two objects? are we reading nextIdx at some point?
        // _nextFrameByDomain only returns one value

        return [steps[nextIdx], nextIdx];
      }
    }, {
      key: "render",
      value: function render() {
        var isAnimating = this.state.isAnimating;
        var children = this.props.children;
        return typeof children === 'function' ? children(isAnimating, this._startAnimation, this._pauseAnimation, this._resetAnimation, this.props.timeline, this.props.setTimelineValue) : null;
      }
    }]);
    return AnimationController;
  }(_react.Component);

  (0, _defineProperty2["default"])(AnimationController, "defaultProps", {
    baseSpeed: _constants.BASE_SPEED,
    speed: 1,
    steps: null,
    animationWindow: _constants.ANIMATION_WINDOW.free
  });
  return AnimationController;
}

var _default = AnimationControllerFactory;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vYW5pbWF0aW9uLWNvbnRyb2wvYW5pbWF0aW9uLWNvbnRyb2xsZXIudHMiXSwibmFtZXMiOlsiQW5pbWF0aW9uQ29udHJvbGxlclR5cGUiLCJDb21wb25lbnQiLCJBbmltYXRpb25Db250cm9sbGVyRmFjdG9yeSIsIkFuaW1hdGlvbkNvbnRyb2xsZXIiLCJpc0FuaW1hdGluZyIsImRlbGF5IiwiX3N0YXJ0VGltZSIsIkRhdGUiLCJnZXRUaW1lIiwibG9vcCIsImN1cnJlbnQiLCJkZWx0YSIsIl9uZXh0RnJhbWUiLCJfdGltZXIiLCJwcm9wcyIsImRvbWFpbiIsInZhbHVlIiwiYW5pbWF0aW9uV2luZG93IiwidXBkYXRlQW5pbWF0aW9uIiwic2V0VGltZWxpbmVWYWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsIkFOSU1BVElPTl9XSU5ET1ciLCJpbmNyZW1lbnRhbCIsInN0ZXBzIiwiaW50ZXJ2YWwiLCJfcmVzZXRBbmltYXRpb25CeVRpbWVTdGVwIiwiX3Jlc2V0QW5pbWF0aW9uQnlEb21haW4iLCJzcGVlZCIsIl9jbGVhclRpbWVyIiwibGVuZ3RoIiwiQ29uc29sZSIsIndhcm4iLCJCQVNFX1NQRUVEIiwiRlBTIiwiX2FuaW1hdGUiLCJzZXRTdGF0ZSIsIm5leHRWYWx1ZSIsIl9uZXh0RnJhbWVCeVRpbWVTdGVwIiwiX25leHRGcmFtZUJ5RG9tYWluIiwiX3N0YXJ0T3JQYXVzZUFuaW1hdGlvbiIsIl9zdGFydEFuaW1hdGlvbiIsIl9wYXVzZUFuaW1hdGlvbiIsImJhc2VTcGVlZCIsInZhbHVlMCIsInZhbHVlMSIsImxhc3RGcmFtZSIsIk51bWJlciIsInZhbCIsImluZGV4IiwibmV4dElkeCIsInN0YXRlIiwiY2hpbGRyZW4iLCJfcmVzZXRBbmltYXRpb24iLCJ0aW1lbGluZSIsImZyZWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztJQXdC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QSxHQUNlLEtBQUsrQyxLQURwQixDQUNBL0MsV0FEQTtBQUFBLFlBRUFnRCxRQUZBLEdBRVksS0FBS3RDLEtBRmpCLENBRUFzQyxRQUZBO0FBSVAsZUFBTyxPQUFPQSxRQUFQLEtBQW9CLFVBQXBCLEdBQ0hBLFFBQVEsQ0FDTmhELFdBRE0sRUFFTixLQUFLcUMsZUFGQyxFQUdOLEtBQUtDLGVBSEMsRUFJTixLQUFLVyxlQUpDLEVBS04sS0FBS3ZDLEtBQUwsQ0FBV3dDLFFBTEwsRUFNTixLQUFLeEMsS0FBTCxDQUFXSyxnQkFOTCxDQURMLEdBU0gsSUFUSjtBQVVEO0FBNU5pRTtBQUFBO0FBQUEsSUF1QkxsQixnQkF2Qks7O0FBQUEsbUNBdUI5REUsbUJBdkI4RCxrQkEwQjVDO0FBQ3BCd0MsSUFBQUEsU0FBUyxFQUFFVixxQkFEUztBQUVwQkwsSUFBQUEsS0FBSyxFQUFFLENBRmE7QUFHcEJKLElBQUFBLEtBQUssRUFBRSxJQUhhO0FBSXBCUCxJQUFBQSxlQUFlLEVBQUVLLDRCQUFpQmlDO0FBSmQsR0ExQjRDO0FBK05wRSxTQUFPcEQsbUJBQVA7QUFDRDs7ZUFFY0QsMEIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7YmlzZWN0TGVmdH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbEFuaW1hdGlvbkZyYW1lfSBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCBDb25zb2xlIGZyb20gJ2dsb2JhbC9jb25zb2xlJztcbmltcG9ydCB7QkFTRV9TUEVFRCwgRlBTLCBBTklNQVRJT05fV0lORE9XfSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge1RpbWVsaW5lfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcblxuaW50ZXJmYWNlIEFuaW1hdGlvbkNvbnRyb2xsZXJQcm9wczxUIGV4dGVuZHMgbnVtYmVyIHwgbnVtYmVyW10+IHtcbiAgaXNBbmltYXRpbmc/OiBib29sZWFuO1xuICBzcGVlZD86IG51bWJlcjtcbiAgdXBkYXRlQW5pbWF0aW9uPzogKHg6IFQpID0+IHZvaWQ7XG4gIHNldFRpbWVsaW5lVmFsdWU6ICh4OiBUKSA9PiB2b2lkO1xuICB0aW1lbGluZT86IFRpbWVsaW5lO1xuICBhbmltYXRpb25XaW5kb3c/OiBzdHJpbmc7XG4gIHN0ZXBzPzogbnVtYmVyW10gfCBudWxsO1xuICBkb21haW46IG51bWJlcltdIHwgbnVsbDtcbiAgdmFsdWU6IFQ7XG4gIGJhc2VTcGVlZD86IG51bWJlcjtcbiAgY2hpbGRyZW4/OiAoXG4gICAgaXNBbmltYXRpbmc6IGJvb2xlYW4gfCB1bmRlZmluZWQsXG4gICAgc3RhcnRBbmltYXRpb246ICgpID0+IHZvaWQsXG4gICAgcGF1c2VBbmltYXRpb246ICgpID0+IHZvaWQsXG4gICAgcmVzZXRBbmltYXRpb246ICgpID0+IHZvaWQsXG4gICAgdGltZWxpbmU6IFRpbWVsaW5lIHwgdW5kZWZpbmVkLFxuICAgIHNldFRpbWVsaW5lVmFsdWU6ICh4OiBhbnkpID0+IHZvaWRcbiAgKSA9PiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsO1xufVxuXG5jbGFzcyBBbmltYXRpb25Db250cm9sbGVyVHlwZTxUIGV4dGVuZHMgbnVtYmVyIHwgbnVtYmVyW10+IGV4dGVuZHMgQ29tcG9uZW50PFxuICBBbmltYXRpb25Db250cm9sbGVyUHJvcHM8VD5cbj4ge31cblxuZnVuY3Rpb24gQW5pbWF0aW9uQ29udHJvbGxlckZhY3RvcnkoKTogdHlwZW9mIEFuaW1hdGlvbkNvbnRyb2xsZXJUeXBlIHtcbiAgLyoqXG4gICAqIDQgQW5pbWF0aW9uIFdpbmRvdyBUeXBlc1xuICAgKiAxLiBmcmVlXG4gICAqICB8LT4gIHwtPlxuICAgKiBDdXJyZW50IHRpbWUgaXMgYSBmaXhlZCByYW5nZSwgYW5pbWF0ZSBhIG1vdmluZyB3aW5kb3cgdGhhdCBjYWxscyBuZXh0IGFuaW1hdGlvbiBmcmFtZXMgY29udGludW91c2x5XG4gICAqIFRoZSBpbmNyZW1lbnQgaWQgYmFzZWQgb24gZG9tYWluIC8gQkFTRV9TUEVFRCAqIFNQRUVEXG4gICAqXG4gICAqIDIuIGluY3JlbWVudGFsXG4gICAqIHwgICAgfC0+XG4gICAqIFNhbWUgYXMgZnJlZSwgY3VycmVudCB0aW1lIGlzIGEgZ3Jvd2luZyByYW5nZSwgb25seSB0aGUgbWF4IHZhbHVlIG9mIHJhbmdlIGluY3JlbWVudCBkdXJpbmcgYW5pbWF0aW9uLlxuICAgKiBUaGUgaW5jcmVtZW50IGlzIGFsc28gYmFzZWQgb24gZG9tYWluIC8gQkFTRV9TUEVFRCAqIFNQRUVEXG4gICAqXG4gICAqIDMuIHBvaW50XG4gICAqIG8gLT4gb1xuICAgKiBDdXJyZW50IHRpbWUgaXMgYSBwb2ludCwgYW5pbWF0ZSBhIG1vdmluZyBwb2ludCBjYWxscyBuZXh0IGFuaW1hdGlvbiBmcmFtZSBjb250aW51b3VzbHlcbiAgICogVGhlIGluY3JlbWVudCBpcyBiYXNlZCBvbiBkb21haW4gLyBCQVNFX1NQRUVEICogU1BFRURcbiAgICpcbiAgICogNC4gaW50ZXJ2YWxcbiAgICogbyB+PiBvXG4gICAqIEN1cnJlbnQgdGltZSBpcyBhIHBvaW50LiBBbiBhcnJheSBvZiBzb3J0ZWQgdGltZSBzdGVwcyBhcmUgcHJvdmlkZWQsXG4gICAqIGFuaW1hdGUgYSBtb3ZpbmcgcG9pbnQganVtcHMgdG8gdGhlIG5leHQgc3RlcFxuICAgKi9cbiAgY2xhc3MgQW5pbWF0aW9uQ29udHJvbGxlcjxUIGV4dGVuZHMgbnVtYmVyIHwgbnVtYmVyW10+IGV4dGVuZHMgQ29tcG9uZW50PFxuICAgIEFuaW1hdGlvbkNvbnRyb2xsZXJQcm9wczxUPlxuICA+IHtcbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgYmFzZVNwZWVkOiBCQVNFX1NQRUVELFxuICAgICAgc3BlZWQ6IDEsXG4gICAgICBzdGVwczogbnVsbCxcbiAgICAgIGFuaW1hdGlvbldpbmRvdzogQU5JTUFUSU9OX1dJTkRPVy5mcmVlXG4gICAgfTtcblxuICAgIHN0YXRlID0ge1xuICAgICAgaXNBbmltYXRpbmc6IGZhbHNlXG4gICAgfTtcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdGhpcy5fc3RhcnRPclBhdXNlQW5pbWF0aW9uKCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgdGhpcy5fc3RhcnRPclBhdXNlQW5pbWF0aW9uKCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5fdGltZXIpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fdGltZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aW1lciA9IG51bGw7XG4gICAgX3N0YXJ0VGltZTogbnVtYmVyID0gMDtcblxuICAgIF9zdGFydE9yUGF1c2VBbmltYXRpb24oKSB7XG4gICAgICBjb25zdCB7aXNBbmltYXRpbmcsIHNwZWVkID0gMX0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKCF0aGlzLl90aW1lciAmJiBpc0FuaW1hdGluZyAmJiBzcGVlZCA+IDApIHtcbiAgICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdGltZXIgJiYgIWlzQW5pbWF0aW5nKSB7XG4gICAgICAgIHRoaXMuX3BhdXNlQW5pbWF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2FuaW1hdGUgPSBkZWxheSA9PiB7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgY29uc3QgbG9vcCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGN1cnJlbnQgLSB0aGlzLl9zdGFydFRpbWU7XG5cbiAgICAgICAgaWYgKGRlbHRhID49IGRlbGF5KSB7XG4gICAgICAgICAgdGhpcy5fbmV4dEZyYW1lKCk7XG4gICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdGltZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3RpbWVyID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgIH07XG5cbiAgICBfcmVzZXRBbmltYXRpb25CeURvbWFpbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtkb21haW4sIHZhbHVlLCBhbmltYXRpb25XaW5kb3csIHVwZGF0ZUFuaW1hdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaW50ZXJpbSBzb2x1dGlvbiB3aGlsZSB3ZSBmdWxseSBtaWdyYXRlIGZpbHRlciBhbmQgbGF5ZXIgY29udHJvbGxlcnNcbiAgICAgIGNvbnN0IHNldFRpbWVsaW5lVmFsdWUgPSB1cGRhdGVBbmltYXRpb24gfHwgdGhpcy5wcm9wcy5zZXRUaW1lbGluZVZhbHVlO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbldpbmRvdyA9PT0gQU5JTUFUSU9OX1dJTkRPVy5pbmNyZW1lbnRhbCkge1xuICAgICAgICAgIHNldFRpbWVsaW5lVmFsdWUoW3ZhbHVlWzBdLCB2YWx1ZVswXSArIDFdIGFzIFQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFRpbWVsaW5lVmFsdWUoW2RvbWFpblswXSwgZG9tYWluWzBdICsgdmFsdWVbMV0gLSB2YWx1ZVswXV0gYXMgVCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVsaW5lVmFsdWUoZG9tYWluWzBdIGFzIFQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcmVzZXRBbmltYXRpb25CeVRpbWVTdGVwID0gKCkgPT4ge1xuICAgICAgY29uc3Qge3N0ZXBzID0gbnVsbCwgdXBkYXRlQW5pbWF0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIXN0ZXBzKSByZXR1cm47XG4gICAgICAvLyBpbnRlcmltIHNvbHV0aW9uIHdoaWxlIHdlIGZ1bGx5IG1pZ3JhdGUgZmlsdGVyIGFuZCBsYXllciBjb250cm9sbGVyc1xuICAgICAgY29uc3Qgc2V0VGltZWxpbmVWYWx1ZSA9IHVwZGF0ZUFuaW1hdGlvbiB8fCB0aGlzLnByb3BzLnNldFRpbWVsaW5lVmFsdWU7XG5cbiAgICAgIC8vIGdvIHRvIHRoZSBmaXJzdCBzdGVwc1xuICAgICAgc2V0VGltZWxpbmVWYWx1ZShbc3RlcHNbMF0sIDBdIGFzIFQpO1xuICAgIH07XG5cbiAgICBfcmVzZXRBbmltYXRpb24gPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5hbmltYXRpb25XaW5kb3cgPT09IEFOSU1BVElPTl9XSU5ET1cuaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRBbmltYXRpb25CeVRpbWVTdGVwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXNldEFuaW1hdGlvbkJ5RG9tYWluKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9zdGFydEFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtzcGVlZCA9IDF9ID0gdGhpcy5wcm9wcztcbiAgICAgIHRoaXMuX2NsZWFyVGltZXIoKTtcbiAgICAgIGlmIChzcGVlZCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYW5pbWF0aW9uV2luZG93ID09PSBBTklNQVRJT05fV0lORE9XLmludGVydmFsKSB7XG4gICAgICAgICAgLy8gYW5pbWF0ZSBieSBpbnRlcnZhbFxuICAgICAgICAgIC8vIDMwKjYwMFxuICAgICAgICAgIGNvbnN0IHtzdGVwc30gPSB0aGlzLnByb3BzO1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdGVwcykgfHwgIXN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgQ29uc29sZS53YXJuKCdhbmltYXRpb24gc3RlcHMgc2hvdWxkIGJlIGFuIGFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdoZW4gc3BlZWQgPSAxLCBhbmltYXRpb24gc2hvdWxkIGxvb3AgdGhyb3VnaCA2MDAgZnJhbWVzIGF0IDYwIEZQU1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSBkZWxheSBiYXNlZCBvbiAjIHN0ZXBzXG4gICAgICAgICAgY29uc3QgZGVsYXkgPSAoQkFTRV9TUEVFRCAqICgxMDAwIC8gRlBTKSkgLyBzdGVwcy5sZW5ndGggLyAoc3BlZWQgfHwgMSk7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZShkZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdGltZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fbmV4dEZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNBbmltYXRpbmc6IHRydWV9KTtcbiAgICB9O1xuXG4gICAgX2NsZWFyVGltZXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fdGltZXIpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fdGltZXIpO1xuICAgICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wYXVzZUFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2NsZWFyVGltZXIoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2lzQW5pbWF0aW5nOiBmYWxzZX0pO1xuICAgIH07XG5cbiAgICBfbmV4dEZyYW1lID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgY29uc3QgbmV4dFZhbHVlID1cbiAgICAgICAgdGhpcy5wcm9wcy5hbmltYXRpb25XaW5kb3cgPT09IEFOSU1BVElPTl9XSU5ET1cuaW50ZXJ2YWxcbiAgICAgICAgICA/IHRoaXMuX25leHRGcmFtZUJ5VGltZVN0ZXAoKVxuICAgICAgICAgIDogdGhpcy5fbmV4dEZyYW1lQnlEb21haW4oKTtcblxuICAgICAgLy8gaW50ZXJpbSBzb2x1dGlvbiB3aGlsZSB3ZSBmdWxseSBtaWdyYXRlIGZpbHRlciBhbmQgbGF5ZXIgY29udHJvbGxlcnNcbiAgICAgIGNvbnN0IHNldFRpbWVsaW5lVmFsdWUgPSB0aGlzLnByb3BzLnVwZGF0ZUFuaW1hdGlvbiB8fCB0aGlzLnByb3BzLnNldFRpbWVsaW5lVmFsdWU7XG4gICAgICBzZXRUaW1lbGluZVZhbHVlKG5leHRWYWx1ZSBhcyBUKTtcbiAgICB9O1xuXG4gICAgX25leHRGcmFtZUJ5RG9tYWluKCkge1xuICAgICAgY29uc3Qge2RvbWFpbiwgdmFsdWUsIHNwZWVkID0gMSwgYmFzZVNwZWVkID0gNjAwLCBhbmltYXRpb25XaW5kb3d9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICghZG9tYWluKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbHRhID0gKChkb21haW5bMV0gLSBkb21haW5bMF0pIC8gYmFzZVNwZWVkKSAqIHNwZWVkO1xuXG4gICAgICAvLyBsb29wIHdoZW4gcmVhY2hlcyB0aGUgZW5kXG4gICAgICAvLyBjdXJyZW50IHRpbWUgaXMgYSByYW5nZVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGxldCB2YWx1ZTA6IG51bWJlcjtcbiAgICAgICAgbGV0IHZhbHVlMTogbnVtYmVyO1xuICAgICAgICBpZiAoYW5pbWF0aW9uV2luZG93ID09PSBBTklNQVRJT05fV0lORE9XLmluY3JlbWVudGFsKSB7XG4gICAgICAgICAgY29uc3QgbGFzdEZyYW1lID0gdmFsdWVbMV0gKyBkZWx0YSA+IGRvbWFpblsxXTtcbiAgICAgICAgICB2YWx1ZTAgPSB2YWx1ZVswXTtcbiAgICAgICAgICB2YWx1ZTEgPSBsYXN0RnJhbWUgPyB2YWx1ZVswXSArIDEgOiB2YWx1ZVsxXSArIGRlbHRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSB2YWx1ZVswXSB0byBkaXNwbGF5IHRoZSBsYXN0IGl0ZW0gIGR1cmF0aW9uIGFzIHRoZSBmaXJzdCBpdGVtXG4gICAgICAgICAgY29uc3QgbGFzdEZyYW1lID0gdmFsdWVbMF0gKyBkZWx0YSA+IGRvbWFpblsxXTtcbiAgICAgICAgICB2YWx1ZTAgPSBsYXN0RnJhbWUgPyBkb21haW5bMF0gOiB2YWx1ZVswXSArIGRlbHRhO1xuICAgICAgICAgIHZhbHVlMSA9IHZhbHVlMCArIHZhbHVlWzFdIC0gdmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt2YWx1ZTAsIHZhbHVlMV07XG4gICAgICB9XG5cbiAgICAgIC8vIGN1cnJlbnQgdGltZSBpcyBhIHBvaW50XG4gICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKSArIGRlbHRhID4gZG9tYWluWzFdID8gZG9tYWluWzBdIDogTnVtYmVyKHZhbHVlKSArIGRlbHRhO1xuICAgIH1cblxuICAgIF9uZXh0RnJhbWVCeVRpbWVTdGVwKCkge1xuICAgICAgY29uc3Qge3N0ZXBzID0gbnVsbCwgdmFsdWV9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICghc3RlcHMpIHJldHVybjtcbiAgICAgIGNvbnN0IHZhbCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiBOdW1iZXIodmFsdWUpO1xuICAgICAgY29uc3QgaW5kZXggPSBiaXNlY3RMZWZ0KHN0ZXBzLCB2YWwpO1xuICAgICAgY29uc3QgbmV4dElkeCA9IGluZGV4ID49IHN0ZXBzLmxlbmd0aCAtIDEgPyAwIDogaW5kZXggKyAxO1xuXG4gICAgICAvLyB3aHkgZG8gd2UgbmVlZCB0byBwYXNzIGFuIGFycmF5IG9mIHR3byBvYmplY3RzPyBhcmUgd2UgcmVhZGluZyBuZXh0SWR4IGF0IHNvbWUgcG9pbnQ/XG4gICAgICAvLyBfbmV4dEZyYW1lQnlEb21haW4gb25seSByZXR1cm5zIG9uZSB2YWx1ZVxuICAgICAgcmV0dXJuIFtzdGVwc1tuZXh0SWR4XSwgbmV4dElkeF07XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3Qge2lzQW5pbWF0aW5nfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB7Y2hpbGRyZW59ID0gdGhpcy5wcm9wcztcblxuICAgICAgcmV0dXJuIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkcmVuKFxuICAgICAgICAgICAgaXNBbmltYXRpbmcsXG4gICAgICAgICAgICB0aGlzLl9zdGFydEFuaW1hdGlvbixcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlQW5pbWF0aW9uLFxuICAgICAgICAgICAgdGhpcy5fcmVzZXRBbmltYXRpb24sXG4gICAgICAgICAgICB0aGlzLnByb3BzLnRpbWVsaW5lLFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5zZXRUaW1lbGluZVZhbHVlXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEFuaW1hdGlvbkNvbnRyb2xsZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvbkNvbnRyb2xsZXJGYWN0b3J5O1xuIl19