"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.coordHasLength4 = coordHasLength4;
exports.containValidTime = containValidTime;
exports.isTripGeoJsonField = isTripGeoJsonField;
exports.parseTripGeoJsonTimestamp = parseTripGeoJsonTimestamp;
exports.getAnimationDomainFromTimestamps = getAnimationDomainFromTimestamps;

var _typeAnalyzer = require("type-analyzer");

var _geojsonUtils = require("../geojson-layer/geojson-utils");

var _utils = require("@kepler.gl/utils");

// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project

/**
 * Parse geojson from string
 * @param {array} samples feature object values
 * @returns whether the geometry coordinates has length of 4
 */
function coordHasLength4(samples) {
  var hasLength4 = true;

  for (var i = 0; i < samples.length; i += 1) {
    var _samples$i, _samples$i$geometry;

    hasLength4 = Array.isArray((_samples$i = samples[i]) === null || _samples$i === void 0 ? void 0 : (_samples$i$geometry = _samples$i.geometry) === null || _samples$i$geometry === void 0 ? void 0 : _samples$i$geometry.coordinates) && !samples[i].geometry.coordinates.find(function (c) {
      return c.length < 4;
    });

    if (!hasLength4) {
      break;
    }
  }

  return hasLength4;
}
/**
 * Check whether geojson linestring's 4th coordinate is 1) not timestamp 2) unix time stamp 3) real date time
 * @param timestamps array to be tested if its elements are timestamp
 * @returns the type of timestamp: unix/datetime/invalid(not timestamp)
 */


function containValidTime(timestamps) {
  var formattedTimeStamps = timestamps.map(function (ts) {
    return {
      ts: ts
    };
  });
  var ignoredDataTypes = Object.keys(_typeAnalyzer.DATA_TYPES).filter(function (type) {
    return ![_typeAnalyzer.DATA_TYPES.TIME, _typeAnalyzer.DATA_TYPES.DATETIME].includes(type);
  }); // ignore all types but TIME to improve performance

  var analyzedType = _typeAnalyzer.Analyzer.computeColMeta(formattedTimeStamps, [], {
    ignoredDataTypes: ignoredDataTypes
  })[0];

  if (!analyzedType || analyzedType.category !== 'TIME') {
    return null;
  }

  return analyzedType;
}
/**
 * Check if geojson features are trip layer animatable by meeting 3 conditions
 * @param dataContainer geojson feature objects container
 * @param {object} field array of geojson feature objects
 * @returns whether it is trip layer animatable
 */


function isTripGeoJsonField(dataContainer, field) {
  if (dataContainer.numRows() < 1) {
    return false;
  }

  var maxCount = 10000;
  var sampleRawFeatures = dataContainer.numRows() > maxCount ? (0, _utils.getSampleContainerData)(dataContainer, maxCount) : dataContainer;
  var features = sampleRawFeatures.mapIndex(field.valueAccessor).map(_geojsonUtils.parseGeoJsonRawFeature).filter(_utils.notNullorUndefined);
  var featureTypes = (0, _geojsonUtils.getGeojsonFeatureTypes)(features); // condition 1: contain line string

  if (!featureTypes.line) {
    return false;
  } // condition 2:sample line strings contain 4 coordinates


  if (!coordHasLength4(features)) {
    return false;
  } // condition 3:the 4th coordinate of the first feature line strings is valid time
  // @ts-expect-error


  var tsHolder = features[0].geometry.coordinates.map(function (coord) {
    return coord[3];
  });
  return Boolean(containValidTime(tsHolder));
}
/**
 * Get unix timestamp from animatable geojson for deck.gl trip layer
 * @param dataToFeature array of geojson feature objects, can be null
 * @returns
 */


function parseTripGeoJsonTimestamp(dataToFeature) {
  // Analyze type based on coordinates of the 1st lineString
  // select a sample trip to analyze time format
  var empty = {
    dataToTimeStamp: [],
    animationDomain: null
  };
  var sampleTrip = dataToFeature.find(function (f) {
    var _f$geometry, _f$geometry$coordinat, _f$geometry$coordinat2;

    return (f === null || f === void 0 ? void 0 : (_f$geometry = f.geometry) === null || _f$geometry === void 0 ? void 0 : (_f$geometry$coordinat = _f$geometry.coordinates) === null || _f$geometry$coordinat === void 0 ? void 0 : (_f$geometry$coordinat2 = _f$geometry$coordinat[0]) === null || _f$geometry$coordinat2 === void 0 ? void 0 : _f$geometry$coordinat2.length) > 3;
  }); // if no valid geometry

  if (!sampleTrip) {
    return empty;
  }

  var analyzedType = containValidTime(sampleTrip.geometry.coordinates.map(function (coord) {
    return coord[3];
  }));

  if (!analyzedType) {
    return empty;
  }

  var format = analyzedType.format;

  var getTimeValue = function getTimeValue(coord) {
    return coord && (0, _utils.notNullorUndefined)(coord[3]) ? (0, _utils.timeToUnixMilli)(coord[3], format) : null;
  };

  var dataToTimeStamp = dataToFeature.map(function (f) {
    return f && f.geometry && Array.isArray(f.geometry.coordinates) ? f.geometry.coordinates.map(getTimeValue) : null;
  });
  var animationDomain = getAnimationDomainFromTimestamps(dataToTimeStamp);
  return {
    dataToTimeStamp: dataToTimeStamp,
    animationDomain: animationDomain
  };
}

function findMinFromSorted(list) {
  // check if list is null since the default value [] will only be applied when the param is undefined
  return (list === null || list === void 0 ? void 0 : list.find(function (d) {
    return (0, _utils.notNullorUndefined)(d) && Number.isFinite(d);
  })) || null;
}

function findMaxFromSorted() {
  var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var i = list.length - 1;

  while (i > 0) {
    if ((0, _utils.notNullorUndefined)(list[i]) && Number.isFinite(list[i])) {
      return list[i];
    }

    i--;
  }

  return null;
}

function getAnimationDomainFromTimestamps() {
  var dataToTimeStamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return dataToTimeStamp.reduce(function (accu, tss) {
    var tsMin = findMinFromSorted(tss);
    var tsMax = findMaxFromSorted(tss);

    if ((0, _utils.notNullorUndefined)(tsMin) && (0, _utils.notNullorUndefined)(tsMax) && Number.isFinite(tsMin) && Number.isFinite(tsMax)) {
      accu[0] = Math.min(accu[0], tsMin);
      accu[1] = Math.max(accu[1], tsMax);
    }

    return accu;
  }, [Infinity, -Infinity]);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmlwLWxheWVyL3RyaXAtdXRpbHMudHMiXSwibmFtZXMiOlsiY29vcmRIYXNMZW5ndGg0Iiwic2FtcGxlcyIsImhhc0xlbmd0aDQiLCJpIiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsImZpbmQiLCJjIiwiY29udGFpblZhbGlkVGltZSIsInRpbWVzdGFtcHMiLCJmb3JtYXR0ZWRUaW1lU3RhbXBzIiwibWFwIiwidHMiLCJpZ25vcmVkRGF0YVR5cGVzIiwiT2JqZWN0Iiwia2V5cyIsIkRBVEFfVFlQRVMiLCJmaWx0ZXIiLCJ0eXBlIiwiVElNRSIsIkRBVEVUSU1FIiwiaW5jbHVkZXMiLCJhbmFseXplZFR5cGUiLCJBbmFseXplciIsImNvbXB1dGVDb2xNZXRhIiwiY2F0ZWdvcnkiLCJpc1RyaXBHZW9Kc29uRmllbGQiLCJkYXRhQ29udGFpbmVyIiwiZmllbGQiLCJudW1Sb3dzIiwibWF4Q291bnQiLCJzYW1wbGVSYXdGZWF0dXJlcyIsImZlYXR1cmVzIiwibWFwSW5kZXgiLCJ2YWx1ZUFjY2Vzc29yIiwicGFyc2VHZW9Kc29uUmF3RmVhdHVyZSIsIm5vdE51bGxvclVuZGVmaW5lZCIsImZlYXR1cmVUeXBlcyIsImxpbmUiLCJ0c0hvbGRlciIsImNvb3JkIiwiQm9vbGVhbiIsInBhcnNlVHJpcEdlb0pzb25UaW1lc3RhbXAiLCJkYXRhVG9GZWF0dXJlIiwiZW1wdHkiLCJkYXRhVG9UaW1lU3RhbXAiLCJhbmltYXRpb25Eb21haW4iLCJzYW1wbGVUcmlwIiwiZiIsImZvcm1hdCIsImdldFRpbWVWYWx1ZSIsImdldEFuaW1hdGlvbkRvbWFpbkZyb21UaW1lc3RhbXBzIiwiZmluZE1pbkZyb21Tb3J0ZWQiLCJsaXN0IiwiZCIsIk51bWJlciIsImlzRmluaXRlIiwiZmluZE1heEZyb21Tb3J0ZWQiLCJyZWR1Y2UiLCJhY2N1IiwidHNzIiwidHNNaW4iLCJ0c01heCIsIk1hdGgiLCJtaW4iLCJt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LFFBQUksK0JBQW1CcUQsSUFBSSxDQUFDckQsQ0FBRCxDQUF2QixLQUErQnVELE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkgsSUFBSSxDQUFDckQsQ0FBRCxDQUFwQixDQUFuQyxFQUE2RDtBQUMzRCxhQUFPcUQsSUFBSSxDQUFDckQsQ0FBRCxDQUFYO0FBQ0Q7O0FBQ0RBLElBQUFBLENBQUM7QUFDRjs7QUFDRCxTQUFPLElBQVA7QUFDRDs7QUFFTSxTQUFTbUQsZ0NBQVQsR0FBNEU7QUFBQSxNQUFsQ04sZUFBa0MsdUVBQUosRUFBSTtBQUNqRixTQUFPQSxlQUFlLENBQUNhLE1BQWhCLENBQ0wsVUFBQ0MsSUFBRCxFQUF5QkMsR0FBekIsRUFBaUM7QUFDL0IsUUFBTUMsS0FBSyxHQUFHVCxpQkFBaUIsQ0FBQ1EsR0FBRCxDQUEvQjtBQUNBLFFBQU1FLEtBQUssR0FBR0wsaUJBQWlCLENBQUNHLEdBQUQsQ0FBL0I7O0FBQ0EsUUFDRSwrQkFBbUJDLEtBQW5CLEtBQ0EsK0JBQW1CQyxLQUFuQixDQURBLElBRUFQLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkssS0FBaEIsQ0FGQSxJQUdBTixNQUFNLENBQUNDLFFBQVAsQ0FBZ0JNLEtBQWhCLENBSkYsRUFLRTtBQUNBSCxNQUFBQSxJQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVVJLElBQUksQ0FBQ0MsR0FBTCxDQUFTTCxJQUFJLENBQUMsQ0FBRCxDQUFiLEVBQWtCRSxLQUFsQixDQUFWO0FBQ0FGLE1BQUFBLElBQUksQ0FBQyxDQUFELENBQUosR0FBVUksSUFBSSxDQUFDRSxHQUFMLENBQVNOLElBQUksQ0FBQyxDQUFELENBQWIsRUFBa0JHLEtBQWxCLENBQVY7QUFDRDs7QUFDRCxXQUFPSCxJQUFQO0FBQ0QsR0FkSSxFQWVMLENBQUNPLFFBQUQsRUFBVyxDQUFDQSxRQUFaLENBZkssQ0FBUDtBQWlCRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCB7QW5hbHl6ZXIsIERBVEFfVFlQRVN9IGZyb20gJ3R5cGUtYW5hbHl6ZXInO1xuXG5pbXBvcnQge0ZpZWxkfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcblxuaW1wb3J0IHtwYXJzZUdlb0pzb25SYXdGZWF0dXJlLCBnZXRHZW9qc29uRmVhdHVyZVR5cGVzfSBmcm9tICcuLi9nZW9qc29uLWxheWVyL2dlb2pzb24tdXRpbHMnO1xuaW1wb3J0IHtcbiAgRGF0YUNvbnRhaW5lckludGVyZmFjZSxcbiAgZ2V0U2FtcGxlQ29udGFpbmVyRGF0YSxcbiAgbm90TnVsbG9yVW5kZWZpbmVkLFxuICB0aW1lVG9Vbml4TWlsbGlcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQge0ZlYXR1cmV9IGZyb20gJ0B0dXJmL2hlbHBlcnMnO1xuaW1wb3J0IHtHZW9Kc29uUHJvcGVydGllcywgR2VvbWV0cnl9IGZyb20gJ2dlb2pzb24nO1xuXG4vKipcbiAqIFBhcnNlIGdlb2pzb24gZnJvbSBzdHJpbmdcbiAqIEBwYXJhbSB7YXJyYXl9IHNhbXBsZXMgZmVhdHVyZSBvYmplY3QgdmFsdWVzXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnZW9tZXRyeSBjb29yZGluYXRlcyBoYXMgbGVuZ3RoIG9mIDRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvb3JkSGFzTGVuZ3RoNChzYW1wbGVzKTogYm9vbGVhbiB7XG4gIGxldCBoYXNMZW5ndGg0ID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaGFzTGVuZ3RoNCA9XG4gICAgICBBcnJheS5pc0FycmF5KHNhbXBsZXNbaV0/Lmdlb21ldHJ5Py5jb29yZGluYXRlcykgJiZcbiAgICAgICFzYW1wbGVzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmZpbmQoYyA9PiBjLmxlbmd0aCA8IDQpO1xuXG4gICAgaWYgKCFoYXNMZW5ndGg0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0xlbmd0aDQ7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBnZW9qc29uIGxpbmVzdHJpbmcncyA0dGggY29vcmRpbmF0ZSBpcyAxKSBub3QgdGltZXN0YW1wIDIpIHVuaXggdGltZSBzdGFtcCAzKSByZWFsIGRhdGUgdGltZVxuICogQHBhcmFtIHRpbWVzdGFtcHMgYXJyYXkgdG8gYmUgdGVzdGVkIGlmIGl0cyBlbGVtZW50cyBhcmUgdGltZXN0YW1wXG4gKiBAcmV0dXJucyB0aGUgdHlwZSBvZiB0aW1lc3RhbXA6IHVuaXgvZGF0ZXRpbWUvaW52YWxpZChub3QgdGltZXN0YW1wKVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpblZhbGlkVGltZSh0aW1lc3RhbXBzOiBzdHJpbmdbXSk6IEZpZWxkIHwgbnVsbCB7XG4gIGNvbnN0IGZvcm1hdHRlZFRpbWVTdGFtcHMgPSB0aW1lc3RhbXBzLm1hcCh0cyA9PiAoe3RzfSkpO1xuICBjb25zdCBpZ25vcmVkRGF0YVR5cGVzID0gT2JqZWN0LmtleXMoREFUQV9UWVBFUykuZmlsdGVyKFxuICAgIHR5cGUgPT4gIVtEQVRBX1RZUEVTLlRJTUUsIERBVEFfVFlQRVMuREFURVRJTUVdLmluY2x1ZGVzKHR5cGUpXG4gICk7XG5cbiAgLy8gaWdub3JlIGFsbCB0eXBlcyBidXQgVElNRSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG4gIGNvbnN0IGFuYWx5emVkVHlwZSA9IEFuYWx5emVyLmNvbXB1dGVDb2xNZXRhKGZvcm1hdHRlZFRpbWVTdGFtcHMsIFtdLCB7aWdub3JlZERhdGFUeXBlc30pWzBdO1xuXG4gIGlmICghYW5hbHl6ZWRUeXBlIHx8IGFuYWx5emVkVHlwZS5jYXRlZ29yeSAhPT0gJ1RJTUUnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGFuYWx5emVkVHlwZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBnZW9qc29uIGZlYXR1cmVzIGFyZSB0cmlwIGxheWVyIGFuaW1hdGFibGUgYnkgbWVldGluZyAzIGNvbmRpdGlvbnNcbiAqIEBwYXJhbSBkYXRhQ29udGFpbmVyIGdlb2pzb24gZmVhdHVyZSBvYmplY3RzIGNvbnRhaW5lclxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkIGFycmF5IG9mIGdlb2pzb24gZmVhdHVyZSBvYmplY3RzXG4gKiBAcmV0dXJucyB3aGV0aGVyIGl0IGlzIHRyaXAgbGF5ZXIgYW5pbWF0YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUcmlwR2VvSnNvbkZpZWxkKGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2UsIGZpZWxkKTogYm9vbGVhbiB7XG4gIGlmIChkYXRhQ29udGFpbmVyLm51bVJvd3MoKSA8IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBtYXhDb3VudCA9IDEwMDAwO1xuICBjb25zdCBzYW1wbGVSYXdGZWF0dXJlcyA9XG4gICAgZGF0YUNvbnRhaW5lci5udW1Sb3dzKCkgPiBtYXhDb3VudFxuICAgICAgPyBnZXRTYW1wbGVDb250YWluZXJEYXRhKGRhdGFDb250YWluZXIsIG1heENvdW50KVxuICAgICAgOiBkYXRhQ29udGFpbmVyO1xuXG4gIGNvbnN0IGZlYXR1cmVzOiBGZWF0dXJlPEdlb21ldHJ5LCBHZW9Kc29uUHJvcGVydGllcz5bXSA9IHNhbXBsZVJhd0ZlYXR1cmVzXG4gICAgLm1hcEluZGV4KGZpZWxkLnZhbHVlQWNjZXNzb3IpXG4gICAgLm1hcChwYXJzZUdlb0pzb25SYXdGZWF0dXJlKVxuICAgIC5maWx0ZXIobm90TnVsbG9yVW5kZWZpbmVkKTtcbiAgY29uc3QgZmVhdHVyZVR5cGVzID0gZ2V0R2VvanNvbkZlYXR1cmVUeXBlcyhmZWF0dXJlcyk7XG5cbiAgLy8gY29uZGl0aW9uIDE6IGNvbnRhaW4gbGluZSBzdHJpbmdcbiAgaWYgKCFmZWF0dXJlVHlwZXMubGluZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNvbmRpdGlvbiAyOnNhbXBsZSBsaW5lIHN0cmluZ3MgY29udGFpbiA0IGNvb3JkaW5hdGVzXG4gIGlmICghY29vcmRIYXNMZW5ndGg0KGZlYXR1cmVzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNvbmRpdGlvbiAzOnRoZSA0dGggY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgZmVhdHVyZSBsaW5lIHN0cmluZ3MgaXMgdmFsaWQgdGltZVxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGNvbnN0IHRzSG9sZGVyID0gZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMubWFwKGNvb3JkID0+IGNvb3JkWzNdKTtcblxuICByZXR1cm4gQm9vbGVhbihjb250YWluVmFsaWRUaW1lKHRzSG9sZGVyKSk7XG59XG5cbi8qKlxuICogR2V0IHVuaXggdGltZXN0YW1wIGZyb20gYW5pbWF0YWJsZSBnZW9qc29uIGZvciBkZWNrLmdsIHRyaXAgbGF5ZXJcbiAqIEBwYXJhbSBkYXRhVG9GZWF0dXJlIGFycmF5IG9mIGdlb2pzb24gZmVhdHVyZSBvYmplY3RzLCBjYW4gYmUgbnVsbFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVHJpcEdlb0pzb25UaW1lc3RhbXAoZGF0YVRvRmVhdHVyZTogYW55W10pIHtcbiAgLy8gQW5hbHl6ZSB0eXBlIGJhc2VkIG9uIGNvb3JkaW5hdGVzIG9mIHRoZSAxc3QgbGluZVN0cmluZ1xuICAvLyBzZWxlY3QgYSBzYW1wbGUgdHJpcCB0byBhbmFseXplIHRpbWUgZm9ybWF0XG4gIGNvbnN0IGVtcHR5ID0ge2RhdGFUb1RpbWVTdGFtcDogW10sIGFuaW1hdGlvbkRvbWFpbjogbnVsbH07XG4gIGNvbnN0IHNhbXBsZVRyaXAgPSBkYXRhVG9GZWF0dXJlLmZpbmQoZiA9PiBmPy5nZW9tZXRyeT8uY29vcmRpbmF0ZXM/LlswXT8ubGVuZ3RoID4gMyk7XG5cbiAgLy8gaWYgbm8gdmFsaWQgZ2VvbWV0cnlcbiAgaWYgKCFzYW1wbGVUcmlwKSB7XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgY29uc3QgYW5hbHl6ZWRUeXBlID0gY29udGFpblZhbGlkVGltZShzYW1wbGVUcmlwLmdlb21ldHJ5LmNvb3JkaW5hdGVzLm1hcChjb29yZCA9PiBjb29yZFszXSkpO1xuXG4gIGlmICghYW5hbHl6ZWRUeXBlKSB7XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgY29uc3Qge2Zvcm1hdH0gPSBhbmFseXplZFR5cGU7XG4gIGNvbnN0IGdldFRpbWVWYWx1ZSA9IGNvb3JkID0+XG4gICAgY29vcmQgJiYgbm90TnVsbG9yVW5kZWZpbmVkKGNvb3JkWzNdKSA/IHRpbWVUb1VuaXhNaWxsaShjb29yZFszXSwgZm9ybWF0KSA6IG51bGw7XG5cbiAgY29uc3QgZGF0YVRvVGltZVN0YW1wOiBudW1iZXJbXVtdID0gZGF0YVRvRmVhdHVyZS5tYXAoZiA9PlxuICAgIGYgJiYgZi5nZW9tZXRyeSAmJiBBcnJheS5pc0FycmF5KGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpXG4gICAgICA/IGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubWFwKGdldFRpbWVWYWx1ZSlcbiAgICAgIDogbnVsbFxuICApO1xuXG4gIGNvbnN0IGFuaW1hdGlvbkRvbWFpbiA9IGdldEFuaW1hdGlvbkRvbWFpbkZyb21UaW1lc3RhbXBzKGRhdGFUb1RpbWVTdGFtcCk7XG5cbiAgcmV0dXJuIHtkYXRhVG9UaW1lU3RhbXAsIGFuaW1hdGlvbkRvbWFpbn07XG59XG5cbmZ1bmN0aW9uIGZpbmRNaW5Gcm9tU29ydGVkKGxpc3Q6IG51bWJlcltdKSB7XG4gIC8vIGNoZWNrIGlmIGxpc3QgaXMgbnVsbCBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBbXSB3aWxsIG9ubHkgYmUgYXBwbGllZCB3aGVuIHRoZSBwYXJhbSBpcyB1bmRlZmluZWRcbiAgcmV0dXJuIGxpc3Q/LmZpbmQoZCA9PiBub3ROdWxsb3JVbmRlZmluZWQoZCkgJiYgTnVtYmVyLmlzRmluaXRlKGQpKSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kTWF4RnJvbVNvcnRlZChsaXN0OiBudW1iZXJbXSA9IFtdKSB7XG4gIGxldCBpID0gbGlzdC5sZW5ndGggLSAxO1xuICB3aGlsZSAoaSA+IDApIHtcbiAgICBpZiAobm90TnVsbG9yVW5kZWZpbmVkKGxpc3RbaV0pICYmIE51bWJlci5pc0Zpbml0ZShsaXN0W2ldKSkge1xuICAgICAgcmV0dXJuIGxpc3RbaV07XG4gICAgfVxuICAgIGktLTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuaW1hdGlvbkRvbWFpbkZyb21UaW1lc3RhbXBzKGRhdGFUb1RpbWVTdGFtcDogbnVtYmVyW11bXSA9IFtdKSB7XG4gIHJldHVybiBkYXRhVG9UaW1lU3RhbXAucmVkdWNlKFxuICAgIChhY2N1OiBbbnVtYmVyLCBudW1iZXJdLCB0c3MpID0+IHtcbiAgICAgIGNvbnN0IHRzTWluID0gZmluZE1pbkZyb21Tb3J0ZWQodHNzKTtcbiAgICAgIGNvbnN0IHRzTWF4ID0gZmluZE1heEZyb21Tb3J0ZWQodHNzKTtcbiAgICAgIGlmIChcbiAgICAgICAgbm90TnVsbG9yVW5kZWZpbmVkKHRzTWluKSAmJlxuICAgICAgICBub3ROdWxsb3JVbmRlZmluZWQodHNNYXgpICYmXG4gICAgICAgIE51bWJlci5pc0Zpbml0ZSh0c01pbikgJiZcbiAgICAgICAgTnVtYmVyLmlzRmluaXRlKHRzTWF4KVxuICAgICAgKSB7XG4gICAgICAgIGFjY3VbMF0gPSBNYXRoLm1pbihhY2N1WzBdLCB0c01pbik7XG4gICAgICAgIGFjY3VbMV0gPSBNYXRoLm1heChhY2N1WzFdLCB0c01heCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdTtcbiAgICB9LFxuICAgIFtJbmZpbml0eSwgLUluZmluaXR5XVxuICApO1xufVxuIl19