import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { PreviewEncoder } from '../encoders';
import { DeckScene } from '../scene';
import { VideoCapture } from '../capture/video-capture';
export default class DeckAdapter {
  constructor(sceneBuilder, glContext = undefined) {
    _defineProperty(this, "scene", void 0);

    _defineProperty(this, "sceneBuilder", void 0);

    _defineProperty(this, "shouldAnimate", void 0);

    _defineProperty(this, "enabled", void 0);

    _defineProperty(this, "glContext", void 0);

    this.sceneBuilder = sceneBuilder;
    this.glContext = glContext;
    this.videoCapture = new VideoCapture();
    this.shouldAnimate = true;
    this.enabled = false;
    this.getProps = this.getProps.bind(this);
    this.render = this.render.bind(this);
    this.stop = this.stop.bind(this);
    this._deckOnLoad = this._deckOnLoad.bind(this);
    this._getViewState = this._getViewState.bind(this);
    this._getLayers = this._getLayers.bind(this);
    this._applyScene = this._applyScene.bind(this);
  }

  getProps(deckRef, setReady, onNextFrame = undefined) {
    const props = {
      onLoad: () => this._deckOnLoad(deckRef.current.deck).then(() => {
        setReady(true);
      }),
      _animate: this.shouldAnimate
    };

    if (onNextFrame) {
      props.onAfterRender = () => this.onAfterRender(onNextFrame);
    }

    if (this.scene && this.scene.keyframes.camera && this.enabled) {
      props.controller = false;
      props.viewState = this._getViewState();
    }

    if (this.scene && this.scene.hasLayers()) {
      props.layers = this._getLayers();
    }

    if (this.scene) {
      props.width = this.scene.width;
      props.height = this.scene.height;
    }

    if (this.glContext) {
      props.gl = this.glContext;
    }

    return props;
  }

  render(Encoder = PreviewEncoder, encoderSettings = {}, onStop = undefined, updateCamera = undefined) {
    if (updateCamera) {
      this.scene.animationLoop.timeline.detachAnimation(this.scene.currentCamera);
      this.scene.keyframes.camera = updateCamera(this.scene.keyframes.camera);
      this.scene.currentCamera = this.scene.animationLoop.timeline.attachAnimation(this.scene.keyframes.camera);
    }

    const innerOnStop = () => {
      this.enabled = false;

      if (onStop) {
        onStop();
      }
    };

    this.shouldAnimate = true;
    this.videoCapture.render(Encoder, encoderSettings, this.scene.lengthMs, innerOnStop);
    this.scene.animationLoop.timeline.setTime(this.videoCapture.encoderSettings.startOffsetMs);
    this.enabled = true;
  }

  stop(callback) {
    this.enabled = false;
    this.shouldAnimate = false;
    this.videoCapture.stop(callback);
  }

  async _deckOnLoad(deck) {
    this.deck = deck;
    const animationLoop = deck.animationLoop;
    animationLoop.timeline.pause();
    animationLoop.timeline.setTime(0);
    await Promise.resolve(this.sceneBuilder(animationLoop)).then(scene => {
      this._applyScene(scene);
    });
  }

  _applyScene(scene) {
    this.scene = scene;
  }

  _getViewState() {
    if (!this.scene) {
      return null;
    }

    const frame = this.scene.keyframes.camera.getFrame();
    return frame;
  }

  _getLayers() {
    if (!this.scene) {
      return [];
    }

    return this.scene.renderLayers();
  }

  onAfterRender(proceedToNextFrame) {
    this.videoCapture.capture(this.deck.canvas, nextTimeMs => {
      this.scene.animationLoop.timeline.setTime(nextTimeMs);
      proceedToNextFrame(nextTimeMs);
    });
  }

}
//# sourceMappingURL=deck-adapter.js.map