{"version":3,"sources":["../../../src/capture/video-capture.js"],"names":["download","FrameEncoder","guid","VideoCapture","constructor","recording","capturing","timeMs","encoder","encoderSettings","_getNextTimeMs","bind","_step","_capture","capture","render","stop","save","parseEncoderSettings","sceneLengthMs","parsedSettings","startOffsetMs","durationMs","endTimeMs","Error","filename","isRecording","Encoder","onStop","undefined","console","time","log","start","canvas","proceedToNextFrame","then","data","kind","nextTimeMs","error","callback","timeEnd","blob","extension","mimeType","add","catch","reason","frameLengthMs","parseInt","framerate"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable no-console */\n/* global console */\nimport download from 'downloadjs';\n// eslint-disable-next-line no-unused-vars\nimport {FrameEncoder} from '../encoders';\nimport {guid} from './utils';\n\nexport class VideoCapture {\n  /** @type {boolean} */\n  recording;\n  /** @type {boolean} */\n  capturing;\n  /** @type {number} */\n  timeMs;\n  /** @type {number} */\n  endTimeMs;\n  /** @type {number} */\n  durationMs;\n  /** @type {number} */\n  framerate;\n  /** @type {FrameEncoder} */\n  encoder;\n  /** @type {string} */\n  filename;\n  /** @type {import('types').FrameEncoderSettings} */\n  encoderSettings;\n\n  constructor() {\n    this.recording = false;\n    this.capturing = false;\n    this.timeMs = 0;\n    this.encoder = null;\n    this.encoderSettings = null;\n\n    this._getNextTimeMs = this._getNextTimeMs.bind(this);\n    this._step = this._step.bind(this);\n    this._capture = this._capture.bind(this);\n    this.capture = this.capture.bind(this);\n    this.render = this.render.bind(this);\n    this.stop = this.stop.bind(this);\n    this.save = this.save.bind(this);\n  }\n\n  /**\n   * @param {import('types').FrameEncoderSettings} encoderSettings\n   * @param {number} sceneLengthMs\n   */\n  parseEncoderSettings(encoderSettings, sceneLengthMs) {\n    const parsedSettings = {...encoderSettings};\n\n    if (!parsedSettings.startOffsetMs) {\n      parsedSettings.startOffsetMs = 0;\n    }\n    this.timeMs = parsedSettings.startOffsetMs;\n\n    if (parsedSettings.durationMs) {\n      this.endTimeMs = parsedSettings.startOffsetMs + parsedSettings.durationMs;\n    } else {\n      parsedSettings.durationMs = sceneLengthMs - parsedSettings.startOffsetMs;\n      this.endTimeMs = sceneLengthMs;\n    }\n    if (this.endTimeMs > sceneLengthMs) {\n      throw new Error(\n        `Recording end time (${this.endTimeMs}) cannot be greater then scene length (${sceneLengthMs})`\n      );\n    }\n    if (parsedSettings.durationMs <= 0) {\n      throw new Error(\n        `Invalid recording length in ms (${parsedSettings.durationMs}).  Must be greater than 0.`\n      );\n    }\n    this.durationMs = parsedSettings.durationMs;\n\n    if (!parsedSettings.filename) {\n      parsedSettings.filename = guid();\n    }\n    this.filename = parsedSettings.filename;\n\n    return parsedSettings;\n  }\n\n  // True if recording, false otherwise.\n  isRecording() {\n    return this.recording;\n  }\n\n  /**\n   * Start recording.\n   * @param {typeof FrameEncoder} Encoder\n   * @param {import('types').FrameEncoderSettings} encoderSettings\n   * @param {number} sceneLengthMs\n   * @param {() => void} onStop\n   */\n  render(Encoder, encoderSettings, sceneLengthMs, onStop = undefined) {\n    if (!this.isRecording()) {\n      console.time('render');\n      this.encoderSettings = this.parseEncoderSettings(encoderSettings, sceneLengthMs);\n      console.log(`Starting recording for ${this.durationMs}ms.`);\n      this.onStop = onStop;\n      this.encoder = new Encoder(this.encoderSettings);\n      this.recording = true;\n      this.encoder.start();\n    }\n  }\n\n  /**\n   * Capture a frame of the canvas.\n   * @param {(nextTimeMs: number) => void} proceedToNextFrame\n   */\n  capture(canvas, proceedToNextFrame) {\n    // console.log(`outside-hubble-capture ${this.capturing} ${this.isRecording()}`);\n\n    if (!this.capturing && this.isRecording()) {\n      // console.log('hubble-capture');\n\n      this.capturing = true;\n      // capture current canvas, i.e.\n      // const can = document.getElementsByClassName('mapboxgl-canvas')[0];\n      // const can = document.getElementById('default-deckgl-overlay');\n      this._capture(canvas).then(data => {\n        this.capturing = false;\n        if (data.kind === 'step') {\n          console.log(`data.nextTimeMs: ${data.nextTimeMs}`);\n          proceedToNextFrame(data.nextTimeMs);\n        } else if (data.error === 'STOP') {\n          console.log('data.error: STOP');\n          this.stop(this.onStop);\n        } else {\n          console.log(data);\n        }\n      });\n    }\n  }\n\n  /**\n   * Stop and save recording. Execute callback if provided.\n   * @param {() => void} callback\n   */\n  stop(callback = undefined) {\n    if (this.isRecording()) {\n      console.log(`Stopping recording.  Recorded for ${this.durationMs}ms.`);\n      this.recording = false;\n      this.capturing = false; // Added to fix an intermittent bug\n      this.encoderSettings = null;\n      this.save();\n\n      if (callback) {\n        // eslint-disable-next-line callback-return\n        callback();\n      }\n    }\n  }\n\n  /**\n   * @param {{ (blob: Blob): boolean }} [callback]\n   */\n  save(callback) {\n    console.timeEnd('render');\n    if (!callback) {\n      /**\n       * @param {Blob} blob\n       */\n      callback = blob => {\n        console.timeEnd('save');\n        if (blob) {\n          download(blob, this.filename + this.encoder.extension, this.encoder.mimeType);\n        }\n        return false;\n      };\n    }\n    console.time('save');\n    this.encoder.save().then(callback);\n  }\n\n  /**\n   * Capture the current canvas.\n   * @param {HTMLCanvasElement} canvas\n   * @returns {Promise<import('types').CaptureStep>}\n   */\n  async _capture(canvas) {\n    // console.log('video-capture');\n    if (!this.isRecording()) {\n      return {kind: 'error', error: 'NOT_RECORDING'};\n    }\n    // getting blob from canvas\n    return await this.encoder\n      .add(canvas)\n      .then(this._step)\n      .catch(reason => ({kind: 'error', error: reason}));\n  }\n\n  /**\n   * @returns {import('types').CaptureStep}\n   */\n  _step() {\n    // generating next frame timestamp\n    this.timeMs = this._getNextTimeMs();\n    if (this.timeMs > this.endTimeMs) {\n      return {kind: 'error', error: 'STOP'};\n    }\n    return {kind: 'step', nextTimeMs: this.timeMs};\n  }\n\n  // Get next time MS based on current time MS and framerate\n  // @return time in milliseconds for next frame.\n  _getNextTimeMs() {\n    const frameLengthMs = parseInt(1000.0 / this.encoder.framerate, 10);\n    return this.timeMs + frameLengthMs;\n  }\n}\n"],"file":"video-capture.js"}