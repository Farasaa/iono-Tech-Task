"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.defaultRadius = exports.defaultLineWidth = exports.defaultElevation = exports.featureAccessor = exports.geoJsonRequiredColumns = exports.geojsonVisConfigs = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _helpers = require("@turf/helpers");

var _booleanWithin = _interopRequireDefault(require("@turf/boolean-within"));

var _lodash = _interopRequireDefault(require("lodash.uniq"));

var _typeAnalyzer = require("type-analyzer");

var _baseLayer = _interopRequireWildcard(require("../base-layer"));

var _layers = require("@deck.gl/layers");

var _geojsonUtils = require("./geojson-utils");

var _layerUtils = require("../layer-utils");

var _geojsonLayerIcon = _interopRequireDefault(require("./geojson-layer-icon"));

var _constants = require("@kepler.gl/constants");

var _utils = require("@kepler.gl/utils");

var _deckglLayers = require("@kepler.gl/deckgl-layers");

var _SUPPORTED_ANALYZER_T;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var SUPPORTED_ANALYZER_TYPES = (_SUPPORTED_ANALYZER_T = {}, (0, _defineProperty2["default"])(_SUPPORTED_ANALYZER_T, _typeAnalyzer.DATA_TYPES.GEOMETRY, true), (0, _defineProperty2["default"])(_SUPPORTED_ANALYZER_T, _typeAnalyzer.DATA_TYPES.GEOMETRY_FROM_STRING, true), (0, _defineProperty2["default"])(_SUPPORTED_ANALYZER_T, _typeAnalyzer.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING, true), _SUPPORTED_ANALYZER_T);
var geojsonVisConfigs = {
  opacity: 'opacity',
  strokeOpacity: _objectSpread(_objectSpread({}, _constants.LAYER_VIS_CONFIGS.opacity), {}, {
    property: 'strokeOpacity'
  }),
  thickness: _objectSpread(_objectSpread({}, _constants.LAYER_VIS_CONFIGS.thickness), {}, {
    defaultValue: 0.5
  }),
  strokeColor: 'strokeColor',
  colorRange: 'colorRange',
  strokeColorRange: 'strokeColorRange',
  radius: 'radius',
  sizeRange: 'strokeWidthRange',
  radiusRange: 'radiusRange',
  heightRange: 'elevationRange',
  elevationScale: 'elevationScale',
  enableElevationZoomFactor: 'enableElevationZoomFactor',
  stroked: 'stroked',
  filled: 'filled',
  enable3d: 'enable3d',
  wireframe: 'wireframe'
};
exports.geojsonVisConfigs = geojsonVisConfigs;
var geoJsonRequiredColumns = ['geojson'];
exports.geoJsonRequiredColumns = geoJsonRequiredColumns;

var featureAccessor = function featureAccessor(_ref) {
  var geojson = _ref.geojson;
  return function (dc) {
    return function (d) {
      return dc.valueAt(d.index, geojson.fieldIdx);
    };
  };
};

exports.featureAccessor = featureAccessor;

var geoColumnAccessor = function geoColumnAccessor(_ref2) {
  var geojson = _ref2.geojson;
  return function (dc) {
    var _dc$getColumn;

    return (_dc$getColumn = dc.getColumn) === null || _dc$getColumn === void 0 ? void 0 : _dc$getColumn.call(dc, geojson.fieldIdx);
  };
};

var geoFieldAccessor = function geoFieldAccessor(_ref3) {
  var geojson = _ref3.geojson;
  return function (dc) {
    return dc.getField ? dc.getField(geojson.fieldIdx) : null;
  };
}; // access feature properties from geojson sub layer


var defaultElevation = 500;
exports.defaultElevation = defaultElevation;
var defaultLineWidth = 1;
exports.defaultLineWidth = defaultLineWidth;
var defaultRadius = 1;
exports.defaultRadius = defaultRadius;

var GeoJsonLayer = /*#__PURE__*/function (_Layer) {
  (0, _inherits2["default"])(GeoJsonLayer, _Layer);

  var _super = _createSuper(GeoJsonLayer);

  function GeoJsonLayer(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, GeoJsonLayer);
    _this = _super.call(this, props);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "dataToFeature", []);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "dataContainer", null);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "filteredIndex", null);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "filteredIndexTrigger", null);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "centroids", []);

    _this.registerVisConfig(geojsonVisConfigs);

    _this.getPositionAccessor = function (dataContainer) {
      return featureAccessor(_this.config.columns)(dataContainer);
    };

    return _this;
  }

  (0, _createClass2["default"])(GeoJsonLayer, [{
    key: "type",
    get: function get() {
      return GeoJsonLayer.type;
    }
  }, {
    key: "name",
    get: function get() {
      return 'Polygon';
    }
  }, {
    key: "layerIcon",
    get: function get() {
      return _geojsonLayerIcon["default"];
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return geoJsonRequiredColumns;
    }
  }, {
    key: "visualChannels",
    get: function get() {
      var visualChannels = (0, _get2["default"])((0, _getPrototypeOf2["default"])(GeoJsonLayer.prototype), "visualChannels", this);
      return {
        color: _objectSpread(_objectSpread({}, visualChannels.color), {}, {
          accessor: 'getFillColor',
          condition: function condition(config) {
            return config.visConfig.filled;
          },
          nullValue: visualChannels.color.nullValue,
          getAttributeValue: function getAttributeValue(config) {
            return function (d) {
              return d.properties.fillColor || config.color;
            };
          },
          // used this to get updateTriggers
          defaultValue: function defaultValue(config) {
            return config.color;
          }
        }),
        strokeColor: {
          property: 'strokeColor',
          field: 'strokeColorField',
          scale: 'strokeColorScale',
          domain: 'strokeColorDomain',
          range: 'strokeColorRange',
          key: 'strokeColor',
          channelScaleType: _constants.CHANNEL_SCALES.color,
          accessor: 'getLineColor',
          condition: function condition(config) {
            return config.visConfig.stroked;
          },
          nullValue: visualChannels.color.nullValue,
          getAttributeValue: function getAttributeValue(config) {
            return function (d) {
              return d.properties.lineColor || config.visConfig.strokeColor || config.color;
            };
          },
          // used this to get updateTriggers
          defaultValue: function defaultValue(config) {
            return config.visConfig.strokeColor || config.color;
          }
        },
        size: _objectSpread(_objectSpread({}, visualChannels.size), {}, {
          property: 'stroke',
          accessor: 'getLineWidth',
          condition: function condition(config) {
            return config.visConfig.stroked;
          },
          nullValue: 0,
          getAttributeValue: function getAttributeValue() {
            return function (d) {
              return d.properties.lineWidth || defaultLineWidth;
            };
          }
        }),
        height: {
          property: 'height',
          field: 'heightField',
          scale: 'heightScale',
          domain: 'heightDomain',
          range: 'heightRange',
          key: 'height',
          channelScaleType: _constants.CHANNEL_SCALES.size,
          accessor: 'getElevation',
          condition: function condition(config) {
            return config.visConfig.enable3d;
          },
          nullValue: 0,
          getAttributeValue: function getAttributeValue() {
            return function (d) {
              return d.properties.elevation || defaultElevation;
            };
          }
        },
        radius: {
          property: 'radius',
          field: 'radiusField',
          scale: 'radiusScale',
          domain: 'radiusDomain',
          range: 'radiusRange',
          key: 'radius',
          channelScaleType: _constants.CHANNEL_SCALES.radius,
          accessor: 'getPointRadius',
          nullValue: 0,
          getAttributeValue: function getAttributeValue() {
            return function (d) {
              return d.properties.radius || defaultRadius;
            };
          }
        }
      };
    }
  }, {
    key: "getDefaultLayerConfig",
    value: function getDefaultLayerConfig(props) {
      return _objectSpread(_objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(GeoJsonLayer.prototype), "getDefaultLayerConfig", this).call(this, props)), {}, {
        // add height visual channel
        heightField: null,
        heightDomain: [0, 1],
        heightScale: 'linear',
        // add radius visual channel
        radiusField: null,
        radiusDomain: [0, 1],
        radiusScale: 'linear',
        // add stroke color visual channel
        strokeColorField: null,
        strokeColorDomain: [0, 1],
        strokeColorScale: 'quantile'
      });
    }
  }, {
    key: "getHoverData",
    value: function getHoverData(object, dataContainer) {
      var _object$properties;

      // index of dataContainer is saved to feature.properties
      // for arrow format, `object` is the index of the row returned from deck
      var index = dataContainer instanceof _utils.ArrowDataContainer ? object : object === null || object === void 0 ? void 0 : (_object$properties = object.properties) === null || _object$properties === void 0 ? void 0 : _object$properties.index;

      if (index >= 0) {
        return dataContainer.row(index);
      }

      return null;
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(_ref4, getPosition) {
      var _this2 = this;

      var dataContainer = _ref4.dataContainer,
          filteredIndex = _ref4.filteredIndex;

      if (dataContainer instanceof _utils.ArrowDataContainer) {
        // filter geojson/arrow table by values and make a partial copy of the raw table are expensive
        // so we will use filteredIndex to create an attribute e.g. filteredIndex [0|1] for GPU filtering
        // in deck.gl layer, see: FilterArrowExtension in @kepler.gl/deckgl-layers
        if (!this.filteredIndex || this.filteredIndex.length !== dataContainer.numRows()) {
          // for incremental data loading, we need to update filteredIndex
          this.filteredIndex = new Uint8ClampedArray(dataContainer.numRows());
          this.filteredIndex.fill(1);
        } // check if filteredIndex is a range from 0 to numRows if it is, we don't need to update it


        var isRange = filteredIndex && filteredIndex.length === dataContainer.numRows();

        if (!isRange || this.filteredIndexTrigger !== null) {
          this.filteredIndex.fill(0);

          for (var i = 0; i < filteredIndex.length; ++i) {
            this.filteredIndex[filteredIndex[i]] = 1;
          }

          this.filteredIndexTrigger = filteredIndex;
        } // for arrow, always return full dataToFeature instead of a filtered one, so there is no need to update attributes in GPU


        return this.dataToFeature;
      } // for geojson, this should work as well and more efficient. But we need to update some test cases e.g. #GeojsonLayer -> formatLayerData


      return filteredIndex.map(function (i) {
        return _this2.dataToFeature[i];
      }).filter(function (d) {
        return d;
      });
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData) {
      var _this3 = this;

      if (this.config.dataId === null) {
        return {};
      }

      var _datasets$this$config = datasets[this.config.dataId],
          gpuFilter = _datasets$this$config.gpuFilter,
          dataContainer = _datasets$this$config.dataContainer;

      var _this$updateData = this.updateData(datasets, oldLayerData),
          data = _this$updateData.data;

      var customFilterValueAccessor = function customFilterValueAccessor(dc, d, fieldIndex) {
        return dc.valueAt(d.properties.index, fieldIndex);
      };

      var indexAccessor = function indexAccessor(f) {
        return f.properties.index;
      };

      var dataAccessor = function dataAccessor(dc) {
        return function (d) {
          return {
            index: d.properties.index
          };
        };
      };

      var accessors = this.getAttributeAccessors({
        dataAccessor: dataAccessor,
        dataContainer: dataContainer
      });

      var isFilteredAccessor = function isFilteredAccessor(d) {
        return _this3.filteredIndex ? _this3.filteredIndex[d.properties.index] : 1;
      };

      return _objectSpread({
        data: data,
        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(indexAccessor, customFilterValueAccessor),
        getFiltered: isFilteredAccessor
      }, accessors);
    }
  }, {
    key: "isInPolygon",
    value: function isInPolygon(data, index, polygon) {
      var _polygon$properties, _polygon$properties2;

      if (this.centroids.length === 0 || !this.centroids[index]) {
        return false;
      }

      var isReactangleSearchBox = ((_polygon$properties = polygon.properties) === null || _polygon$properties === void 0 ? void 0 : _polygon$properties.shape) === 'Rectangle';
      var point = this.centroids[index]; // if no valid centroid, return false

      if (!point) return false; // quick check if centroid is within the query rectangle

      if (isReactangleSearchBox && (_polygon$properties2 = polygon.properties) !== null && _polygon$properties2 !== void 0 && _polygon$properties2.bbox) {
        var _polygon$properties3;

        var _polygon$properties$b = (_polygon$properties3 = polygon.properties) === null || _polygon$properties3 === void 0 ? void 0 : _polygon$properties3.bbox,
            _polygon$properties$b2 = (0, _slicedToArray2["default"])(_polygon$properties$b, 4),
            minX = _polygon$properties$b2[0],
            minY = _polygon$properties$b2[1],
            maxX = _polygon$properties$b2[2],
            maxY = _polygon$properties$b2[3];

        return point[0] >= minX && point[0] <= maxX && point[1] >= minY && point[1] <= maxY;
      } // use turf.js to check if centroid is within query polygon


      return (0, _booleanWithin["default"])((0, _helpers.point)(point), polygon);
    }
  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataContainer) {
      this.dataContainer = dataContainer;
      var getFeature = this.getPositionAccessor(dataContainer);
      var getGeoColumn = geoColumnAccessor(this.config.columns);
      var getGeoField = geoFieldAccessor(this.config.columns);

      if (dataContainer instanceof _utils.ArrowDataContainer) {
        // update the latest batch/chunk of geoarrow data when loading data incrementally
        if (this.dataToFeature.length < dataContainer.numChunks()) {
          // for incrementally loading data, we only load and render the latest batch; otherwise, we will load and render all batches
          var isIncrementalLoad = dataContainer.numChunks() - this.dataToFeature.length === 1;

          var _getGeojsonLayerMetaF = (0, _layerUtils.getGeojsonLayerMetaFromArrow)(_objectSpread({
            dataContainer: dataContainer,
            getGeoColumn: getGeoColumn,
            getGeoField: getGeoField
          }, isIncrementalLoad ? {
            chunkIndex: this.dataToFeature.length
          } : null)),
              dataToFeature = _getGeojsonLayerMetaF.dataToFeature,
              bounds = _getGeojsonLayerMetaF.bounds,
              fixedRadius = _getGeojsonLayerMetaF.fixedRadius,
              featureTypes = _getGeojsonLayerMetaF.featureTypes,
              centroids = _getGeojsonLayerMetaF.centroids;

          if (centroids) this.centroids = this.centroids.concat(centroids);
          this.updateMeta({
            bounds: bounds,
            fixedRadius: fixedRadius,
            featureTypes: featureTypes
          });
          this.dataToFeature = [].concat((0, _toConsumableArray2["default"])(this.dataToFeature), (0, _toConsumableArray2["default"])(dataToFeature));
        }
      } else {
        if (this.dataToFeature.length === 0) {
          var _getGeojsonLayerMeta = (0, _geojsonUtils.getGeojsonLayerMeta)({
            dataContainer: dataContainer,
            getFeature: getFeature
          }),
              _dataToFeature = _getGeojsonLayerMeta.dataToFeature,
              _bounds = _getGeojsonLayerMeta.bounds,
              _fixedRadius = _getGeojsonLayerMeta.fixedRadius,
              _featureTypes = _getGeojsonLayerMeta.featureTypes,
              _centroids = _getGeojsonLayerMeta.centroids;

          if (_centroids) this.centroids = _centroids;
          this.dataToFeature = _dataToFeature;
          this.updateMeta({
            bounds: _bounds,
            fixedRadius: _fixedRadius,
            featureTypes: _featureTypes
          });
        }
      }
    }
  }, {
    key: "setInitialLayerConfig",
    value: function setInitialLayerConfig(_ref5) {
      var dataContainer = _ref5.dataContainer;

      if (!dataContainer.numRows()) {
        return this;
      }

      this.updateLayerMeta(dataContainer);
      var featureTypes = this.meta.featureTypes; // default settings is stroke: true, filled: false

      if (featureTypes && featureTypes.polygon) {
        // set both fill and stroke to true
        return this.updateLayerVisConfig({
          filled: true,
          stroked: true,
          strokeColor: _baseLayer.colorMaker.next().value
        });
      } else if (featureTypes && featureTypes.point) {
        // set fill to true if detect point
        return this.updateLayerVisConfig({
          filled: true,
          stroked: false
        });
      }

      return this;
    }
  }, {
    key: "isLayerHovered",
    value: function isLayerHovered(objectInfo) {
      return this.dataContainer instanceof _utils.ArrowDataContainer ? (0, _layerUtils.isLayerHoveredFromArrow)(objectInfo, this.id) : (0, _get2["default"])((0, _getPrototypeOf2["default"])(GeoJsonLayer.prototype), "isLayerHovered", this).call(this, objectInfo);
    }
  }, {
    key: "hasHoveredObject",
    value: function hasHoveredObject(objectInfo) {
      return this.dataContainer instanceof _utils.ArrowDataContainer ? (0, _layerUtils.getHoveredObjectFromArrow)(objectInfo, this.dataContainer, this.id, geoColumnAccessor(this.config.columns), geoFieldAccessor(this.config.columns)) : (0, _get2["default"])((0, _getPrototypeOf2["default"])(GeoJsonLayer.prototype), "hasHoveredObject", this).call(this, objectInfo);
    }
  }, {
    key: "renderLayer",
    value: function renderLayer(opts) {
      var _this4 = this;

      var dataProps = opts.data,
          gpuFilter = opts.gpuFilter,
          objectHovered = opts.objectHovered,
          mapState = opts.mapState,
          interactionConfig = opts.interactionConfig;
      var _this$meta = this.meta,
          fixedRadius = _this$meta.fixedRadius,
          featureTypes = _this$meta.featureTypes;
      var radiusScale = this.getRadiusScaleByZoom(mapState, fixedRadius);
      var zoomFactor = this.getZoomFactor(mapState);
      var eleZoomFactor = this.getElevationZoomFactor(mapState);
      var visConfig = this.config.visConfig;
      var layerProps = {
        lineWidthScale: visConfig.thickness * zoomFactor * 8,
        elevationScale: visConfig.elevationScale * eleZoomFactor,
        pointRadiusScale: radiusScale,
        lineMiterLimit: 4
      };

      var updateTriggers = _objectSpread(_objectSpread({}, this.getVisualChannelUpdateTriggers()), {}, {
        getFilterValue: gpuFilter.filterValueUpdateTriggers,
        getFiltered: this.filteredIndexTrigger
      });

      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);
      var opaOverwrite = {
        opacity: visConfig.strokeOpacity
      };
      var pickable = interactionConfig.tooltip.enabled;
      var hoveredObject = this.hasHoveredObject(objectHovered);
      var data = dataProps.data,
          props = (0, _objectWithoutProperties2["default"])(dataProps, ["data"]); // arrow table can have multiple chunks, a deck.gl layer is created for each chunk

      var deckLayerData = this.dataContainer instanceof _utils.ArrowDataContainer ? data : [data];
      var deckLayers = deckLayerData.map(function (d, i) {
        return new _layers.GeoJsonLayer(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), layerProps), props), {}, {
          data: d,
          id: deckLayerData.length > 1 ? "".concat(_this4.id, "-").concat(i) : _this4.id,
          pickable: pickable,
          highlightColor: _constants.HIGHLIGH_COLOR_3D,
          autoHighlight: visConfig.enable3d && pickable,
          stroked: visConfig.stroked,
          filled: visConfig.filled,
          extruded: visConfig.enable3d,
          wireframe: visConfig.wireframe,
          wrapLongitude: false,
          lineMiterLimit: 2,
          capRounded: true,
          jointRounded: true,
          updateTriggers: updateTriggers,
          extensions: [].concat((0, _toConsumableArray2["default"])(defaultLayerProps.extensions), [new _deckglLayers.FilterArrowExtension()]),
          _subLayerProps: _objectSpread(_objectSpread(_objectSpread({}, featureTypes !== null && featureTypes !== void 0 && featureTypes.polygon ? {
            'polygons-stroke': opaOverwrite
          } : {}), featureTypes !== null && featureTypes !== void 0 && featureTypes.line ? {
            linestrings: opaOverwrite
          } : {}), featureTypes !== null && featureTypes !== void 0 && featureTypes.point ? {
            points: {
              lineOpacity: visConfig.strokeOpacity
            }
          } : {})
        }));
      });
      return [].concat((0, _toConsumableArray2["default"])(deckLayers), (0, _toConsumableArray2["default"])(hoveredObject && !visConfig.enable3d ? [new _layers.GeoJsonLayer(_objectSpread(_objectSpread(_objectSpread({}, this.getDefaultHoverLayerProps()), layerProps), {}, {
        visible: defaultLayerProps.visible,
        wrapLongitude: false,
        data: [hoveredObject],
        getLineWidth: props.getLineWidth,
        getPointRadius: props.getPointRadius,
        getElevation: props.getElevation,
        getLineColor: this.config.highlightColor,
        getFillColor: this.config.highlightColor,
        // always draw outline
        stroked: true,
        filled: false
      }))] : []));
    }
  }], [{
    key: "type",
    get: function get() {
      return 'geojson';
    }
  }, {
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(_ref6) {
      var _this5 = this;

      var label = _ref6.label,
          _ref6$fields = _ref6.fields,
          fields = _ref6$fields === void 0 ? [] : _ref6$fields;
      var geojsonColumns = fields.filter(function (f) {
        return (f.type === 'geojson' || f.type === 'geoarrow') && SUPPORTED_ANALYZER_TYPES[f.analyzerType];
      }).map(function (f) {
        return f.name;
      });
      var defaultColumns = {
        geojson: (0, _lodash["default"])([].concat((0, _toConsumableArray2["default"])(_constants.GEOJSON_FIELDS.geojson), (0, _toConsumableArray2["default"])(geojsonColumns)))
      };
      var foundColumns = this.findDefaultColumnField(defaultColumns, fields);

      if (!foundColumns || !foundColumns.length) {
        return {
          props: []
        };
      }

      return {
        props: foundColumns.map(function (columns) {
          return {
            label: typeof label === 'string' && label.replace(/\.[^/.]+$/, '') || _this5.type,
            columns: columns,
            isVisible: true
          };
        })
      };
    }
  }]);
  return GeoJsonLayer;
}(_baseLayer["default"]);

exports["default"] = GeoJsonLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9qc29uLWxheWVyL2dlb2pzb24tbGF5ZXIudHMiXSwibmFtZXMiOlsiU1VQUE9SVEVEX0FOQUxZWkVSX1RZUEVTIiwiREFUQV9UWVBFUyIsIkdFT01FVFJZIiwiR0VPTUVUUllfRlJPTV9TVFJJTkciLCJQQUlSX0dFT01FVFJZX0ZST01fU1RSSU5HIiwiZ2VvanNvblZpc0NvbmZpZ3MiLCJvcGFjaXR5Iiwic3Ryb2tlT3BhY2l0eSIsIkxBWUVSX1ZJU19DT05GSUdTIiwicHJvcGVydHkiLCJ0aGlja25lc3MiLCJkZWZhdWx0VmFsdWUiLCJzdHJva2VDb2xvciIsImNvbG9yUmFuZ2UiLCJzdHJva2VDb2xvclJhbmdlIiwicmFkaXVzIiwic2l6ZVJhbmdlIiwicmFkaXVzUmFuZ2UiLCJoZWlnaHRSYW5nZSIsImVsZXZhdGlvblNjYWxlIiwiZW5hYmxlRWxldmF0aW9uWm9vbUZhY3RvciIsInN0cm9rZWQiLCJmaWxsZWQiLCJlbmFibGUzZCIsIndpcmVmcmFtZSIsImdlb0pzb25SZXF1aXJlZENvbHVtbnMiLCJmZWF0dXJlQWNjZXNzb3IiLCJnZW9qc29uIiwiZGMiLCJkIiwidmFsdWVBdCIsImluZGV4IiwiZmllbGRJZHgiLCJnZW9Db2x1bW5BY2Nlc3NvciIsImdldENvbHVtbiIsImdlb0ZpZWxkQWNjZXNzb3IiLCJnZXRGaWVsZCIsImRlZmF1bHRFbGV2YXRpb24iLCJkZWZhdWx0TGluZVdpZHRoIiwiZGVmYXVsdFJhZGl1cyIsIkdlb0pzb25MYXllciIsInByb3BzIiwicmVnaXN0ZXJWaXNDb25maWciLCJnZXRQb3NpdGlvbkFjY2Vzc29yIiwiZGF0YUNvbnRhaW5lciIsImNvbmZpZyIsImNvbHVtbnMiLCJ0eXBlIiwiR2VvanNvbkxheWVySWNvbiIsInZpc3VhbENoYW5uZWxzIiwiY29sb3IiLCJhY2Nlc3NvciIsImNvbmRpdGlvbiIsInZpc0NvbmZpZyIsIm51bGxWYWx1ZSIsImdldEF0dHJpYnV0ZVZhbHVlIiwicHJvcGVydGllcyIsImZpbGxDb2xvciIsImZpZWxkIiwic2NhbGUiLCJkb21haW4iLCJyYW5nZSIsImtleSIsImNoYW5uZWxTY2FsZVR5cGUiLCJDSEFOTkVMX1NDQUxFUyIsImxpbmVDb2xvciIsInNpemUiLCJsaW5lV2lkdGgiLCJoZWlnaHQiLCJlbGV2YXRpb24iLCJoZWlnaHRGaWVsZCIsImhlaWdodERvbWFpbiIsImhlaWdodFNjYWxlIiwicmFkaXVzRmllbGQiLCJyYWRpdXNEb21haW4iLCJyYWRpdXNTY2FsZSIsInN0cm9rZUNvbG9yRmllbGQiLCJzdHJva2VDb2xvckRvbWFpbiIsInN0cm9rZUNvbG9yU2NhbGUiLCJvYmplY3QiLCJBcnJvd0RhdGFDb250YWluZXIiLCJyb3ciLCJnZXRQb3NpdGlvbiIsImZpbHRlcmVkSW5kZXgiLCJsZW5ndGgiLCJudW1Sb3dzIiwiVWludDhDbGFtcGVkQXJyYXkiLCJmaWxsIiwiaXNSYW5nZSIsImZpbHRlcmVkSW5kZXhUcmlnZ2VyIiwiaSIsImRhdGFUb0ZlYXR1cmUiLCJtYXAiLCJmaWx0ZXIiLCJkYXRhc2V0cyIsIm9sZExheWVyRGF0YSIsImRhdGFJZCIsImdwdUZpbHRlciIsInVwZGF0ZURhdGEiLCJkYXRhIiwiY3VzdG9tRmlsdGVyVmFsdWVBY2Nlc3NvciIsImZpZWxkSW5kZXgiLCJpbmRleEFjY2Vzc29yIiwiZiIsImRhdGFBY2Nlc3NvciIsImFjY2Vzc29ycyIsImdldEF0dHJpYnV0ZUFjY2Vzc29ycyIsImlzRmlsdGVyZWRBY2Nlc3NvciIsImdldEZpbHRlclZhbHVlIiwiZmlsdGVyVmFsdWVBY2Nlc3NvciIsImdldEZpbHRlcmVkIiwicG9seWdvbiIsImNlbnRyb2lkcyIsImlzUmVhY3RhbmdsZVNlYXJjaEJveCIsInNoYXBlIiwicG9pbnQiLCJiYm94IiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsImdldEZlYXR1cmUiLCJnZXRHZW9Db2x1bW4iLCJnZXRHZW9GaWVsZCIsIm51bUNodW5rcyIsImlzSW5jcmVtZW50YWxMb2FkIiwiY2h1bmtJbmRleCIsImJvdW5kcyIsImZpeGVkUmFkaXVzIiwiZmVhdHVyZVR5cGVzIiwiY29uY2F0IiwidXBkYXRlTWV0YSIsInVwZGF0ZUxheWVyTWV0YSIsIm1ldGEiLCJ1cGRhdGVMYXllclZpc0NvbmZpZyIsImNvbG9yTWFrZXIiLCJuZXh0IiwidmFsdWUiLCJvYmplY3RJbmZvIiwiaWQiLCJvcHRzIiwiZGF0YVByb3BzIiwib2JqZWN0SG92ZXJlZCIsIm1hcFN0YXRlIiwiaW50ZXJhY3Rpb25Db25maWciLCJnZXRSYWRpdXNTY2FsZUJ5Wm9vbSIsInpvb21GYWN0b3IiLCJnZXRab29tRmFjdG9yIiwiZWxlWm9vbUZhY3RvciIsImdldEVsZXZhdGlvblpvb21GYWN0b3IiLCJsYXllclByb3BzIiwibGluZVdpZHRoU2NhbGUiLCJwb2ludFJhZGl1c1NjYWxlIiwibGluZU1pdGVyTGltaXQiLCJ1cGRhdGVUcmlnZ2VycyIsImdldFZpc3VhbENoYW5uZWxVcGRhdGVUcmlnZ2VycyIsImZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnMiLCJkZWZhdWx0TGF5ZXJQcm9wcyIsImdldERlZmF1bHREZWNrTGF5ZXJQcm9wcyIsIm9wYU92ZXJ3cml0ZSIsInBpY2thYmxlIiwidG9vbHRpcCIsImVuYWJsZWQiLCJob3ZlcmVkT2JqZWN0IiwiaGFzSG92ZXJlZE9iamVjdCIsImRlY2tMYXllckRhdGEiLCJkZWNrTGF5ZXJzIiwiRGVja0dMR2VvSnNvbkxheWVyIiwiaGlnaGxpZ2h0Q29sb3IiLCJISUdITElHSF9DT0xPUl8zRCIsImF1dG9IaWdobGlnaHQiLCJleHRydWRlZCIsIndyYXBMb25naXR1ZGUiLCJjYXBSb3VuZGVkIiwiam9pbnRSb3VuZGVkIiwiZXh0ZW5zaW9ucyIsIkZpbHRlckFycm93RXh0ZW5zaW9uIiwiX3N1YkxheWVyUHJvcHMiLCJsaW5lIiwibGluZXN0cmluZ3MiLCJwb2ludHMiLCJsaW5lT3BhY2l0eSIsImdldERlZmF1bHRIb3ZlckxheWVyUHJvcHMiLCJ2aXNpYmxlIiwiZ2V0TGluZVdpZHRoIiwiZ2V0UG9pbnRSYWRpdXMiLCJnZXRFbGV2YXRpb24iLCJnZXRMaW5lQ29sb3IiLCJnZXRGaWxsQ29sb3IiLCJsYWJlbCIsImZpZWxkcyIsImdlb2pzb25Db2x1bW5zIiwiYW5hbHl6ZXJUeXBlIiwibmFtZSIsImRlZmF1bHRDb2x1bW5zIiwiR0VPSlNPTl9GSUVMRFMiLCJmb3VuZENvbHVtbnMiLCJmaW5kRGVmYXVsdENvbHVtbkZpZWxkIiwicmVwbGFjZSIsImlzVmlzaWJsZSIsIkxheWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFXQTs7QUFDQTs7QUFDQTs7QUFLQTs7QUFDQTs7QUFrQkE7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLHdCQUF3Qix3RkFDM0JDLHlCQUFXQyxRQURnQixFQUNMLElBREssMkRBRTNCRCx5QkFBV0Usb0JBRmdCLEVBRU8sSUFGUCwyREFHM0JGLHlCQUFXRyx5QkFIZ0IsRUFHWSxJQUhaLHlCQUE5QjtBQU1PLElBQU1DLGlCQWtCWixHQUFHO0FBQ0ZDLEVBQUFBLE9BQU8sRUFBRSxTQURQO0FBRUZDLEVBQUFBLGFBQWEsa0NBQ1JDLDZCQUFrQkYsT0FEVjtBQUVYRyxJQUFBQSxRQUFRLEVBQUU7QUFGQyxJQUZYO0FBTUZDLEVBQUFBLFNBQVMsa0NBQ0pGLDZCQUFrQkUsU0FEZDtBQUVQQyxJQUFBQSxZQUFZLEVBQUU7QUFGUCxJQU5QO0FBVUZDLEVBQUFBLFdBQVcsRUFBRSxhQVZYO0FBV0ZDLEVBQUFBLFVBQVUsRUFBRSxZQVhWO0FBWUZDLEVBQUFBLGdCQUFnQixFQUFFLGtCQVpoQjtBQWFGQyxFQUFBQSxNQUFNLEVBQUUsUUFiTjtBQWVGQyxFQUFBQSxTQUFTLEVBQUUsa0JBZlQ7QUFnQkZDLEVBQUFBLFdBQVcsRUFBRSxhQWhCWDtBQWlCRkMsRUFBQUEsV0FBVyxFQUFFLGdCQWpCWDtBQWtCRkMsRUFBQUEsY0FBYyxFQUFFLGdCQWxCZDtBQW1CRkMsRUFBQUEseUJB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T0FBdkI7QUFJQSxVQUFNSyxZQUFZLEdBQUcsS0FBS0Msc0JBQUwsQ0FBNEJILGNBQTVCLEVBQTRDSixNQUE1QyxDQUFyQjs7QUFDQSxVQUFJLENBQUNNLFlBQUQsSUFBaUIsQ0FBQ0EsWUFBWSxDQUFDaEgsTUFBbkMsRUFBMkM7QUFDekMsZUFBTztBQUFDM0MsVUFBQUEsS0FBSyxFQUFFO0FBQVIsU0FBUDtBQUNEOztBQUVELGFBQU87QUFDTEEsUUFBQUEsS0FBSyxFQUFFMkosWUFBWSxDQUFDeEcsR0FBYixDQUFpQixVQUFBOUMsT0FBTztBQUFBLGlCQUFLO0FBQ2xDK0ksWUFBQUEsS0FBSyxFQUFHLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLEtBQUssQ0FBQ1MsT0FBTixDQUFjLFdBQWQsRUFBMkIsRUFBM0IsQ0FBOUIsSUFBaUUsTUFBSSxDQUFDdkosSUFEM0M7QUFFbENELFlBQUFBLE9BQU8sRUFBUEEsT0FGa0M7QUFHbEN5SixZQUFBQSxTQUFTLEVBQUU7QUFIdUIsV0FBTDtBQUFBLFNBQXhCO0FBREYsT0FBUDtBQU9EOzs7RUEvSHVDQyxxQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XG5pbXBvcnQge3BvaW50IGFzIHR1cmZQb2ludH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5pbXBvcnQgYm9vbGVhbldpdGhpbiBmcm9tICdAdHVyZi9ib29sZWFuLXdpdGhpbic7XG5pbXBvcnQge0ZlYXR1cmUsIFBvbHlnb259IGZyb20gJ2dlb2pzb24nO1xuaW1wb3J0IHVuaXEgZnJvbSAnbG9kYXNoLnVuaXEnO1xuaW1wb3J0IHtEQVRBX1RZUEVTfSBmcm9tICd0eXBlLWFuYWx5emVyJztcbmltcG9ydCBMYXllciwge1xuICBjb2xvck1ha2VyLFxuICBMYXllckJhc2VDb25maWcsXG4gIExheWVyQmFzZUNvbmZpZ1BhcnRpYWwsXG4gIExheWVyQ29sb3JDb25maWcsXG4gIExheWVyQ29sdW1uLFxuICBMYXllckhlaWdodENvbmZpZyxcbiAgTGF5ZXJSYWRpdXNDb25maWcsXG4gIExheWVyU2l6ZUNvbmZpZyxcbiAgTGF5ZXJTdHJva2VDb2xvckNvbmZpZ1xufSBmcm9tICcuLi9iYXNlLWxheWVyJztcbmltcG9ydCB7R2VvSnNvbkxheWVyIGFzIERlY2tHTEdlb0pzb25MYXllcn0gZnJvbSAnQGRlY2suZ2wvbGF5ZXJzJztcbmltcG9ydCB7Z2V0R2VvanNvbkxheWVyTWV0YSwgR2VvanNvbkRhdGFNYXBzLCBEZWNrR2xHZW9UeXBlc30gZnJvbSAnLi9nZW9qc29uLXV0aWxzJztcbmltcG9ydCB7XG4gIGdldEdlb2pzb25MYXllck1ldGFGcm9tQXJyb3csXG4gIGlzTGF5ZXJIb3ZlcmVkRnJvbUFycm93LFxuICBnZXRIb3ZlcmVkT2JqZWN0RnJvbUFycm93XG59IGZyb20gJy4uL2xheWVyLXV0aWxzJztcbmltcG9ydCBHZW9qc29uTGF5ZXJJY29uIGZyb20gJy4vZ2VvanNvbi1sYXllci1pY29uJztcbmltcG9ydCB7XG4gIEdFT0pTT05fRklFTERTLFxuICBISUdITElHSF9DT0xPUl8zRCxcbiAgQ0hBTk5FTF9TQ0FMRVMsXG4gIENvbG9yUmFuZ2UsXG4gIExBWUVSX1ZJU19DT05GSUdTXG59IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIFZpc0NvbmZpZ051bWJlcixcbiAgVmlzQ29uZmlnQ29sb3JTZWxlY3QsXG4gIFZpc0NvbmZpZ0NvbG9yUmFuZ2UsXG4gIFZpc0NvbmZpZ1JhbmdlLFxuICBWaXNDb25maWdCb29sZWFuLFxuICBNZXJnZSxcbiAgUkdCQ29sb3IsXG4gIEZpZWxkXG59IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuaW1wb3J0IHtLZXBsZXJUYWJsZX0gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5pbXBvcnQge0RhdGFDb250YWluZXJJbnRlcmZhY2UsIEFycm93RGF0YUNvbnRhaW5lcn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQge0ZpbHRlckFycm93RXh0ZW5zaW9ufSBmcm9tICdAa2VwbGVyLmdsL2RlY2tnbC1sYXllcnMnO1xuXG5jb25zdCBTVVBQT1JURURfQU5BTFlaRVJfVFlQRVMgPSB7XG4gIFtEQVRBX1RZUEVTLkdFT01FVFJZXTogdHJ1ZSxcbiAgW0RBVEFfVFlQRVMuR0VPTUVUUllfRlJPTV9TVFJJTkddOiB0cnVlLFxuICBbREFUQV9UWVBFUy5QQUlSX0dFT01FVFJZX0ZST01fU1RSSU5HXTogdHJ1ZVxufTtcblxuZXhwb3J0IGNvbnN0IGdlb2pzb25WaXNDb25maWdzOiB7XG4gIG9wYWNpdHk6ICdvcGFjaXR5JztcbiAgc3Ryb2tlT3BhY2l0eTogVmlzQ29uZmlnTnVtYmVyO1xuICB0aGlja25lc3M6IFZpc0NvbmZpZ051bWJlcjtcbiAgc3Ryb2tlQ29sb3I6ICdzdHJva2VDb2xvcic7XG4gIGNvbG9yUmFuZ2U6ICdjb2xvclJhbmdlJztcbiAgc3Ryb2tlQ29sb3JSYW5nZTogJ3N0cm9rZUNvbG9yUmFuZ2UnO1xuICByYWRpdXM6ICdyYWRpdXMnO1xuXG4gIHNpemVSYW5nZTogJ3N0cm9rZVdpZHRoUmFuZ2UnO1xuICByYWRpdXNSYW5nZTogJ3JhZGl1c1JhbmdlJztcbiAgaGVpZ2h0UmFuZ2U6ICdlbGV2YXRpb25SYW5nZSc7XG4gIGVsZXZhdGlvblNjYWxlOiAnZWxldmF0aW9uU2NhbGUnO1xuICBlbmFibGVFbGV2YXRpb25ab29tRmFjdG9yOiAnZW5hYmxlRWxldmF0aW9uWm9vbUZhY3Rvcic7XG4gIHN0cm9rZWQ6ICdzdHJva2VkJztcbiAgZmlsbGVkOiAnZmlsbGVkJztcbiAgZW5hYmxlM2Q6ICdlbmFibGUzZCc7XG4gIHdpcmVmcmFtZTogJ3dpcmVmcmFtZSc7XG59ID0ge1xuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIHN0cm9rZU9wYWNpdHk6IHtcbiAgICAuLi5MQVlFUl9WSVNfQ09ORklHUy5vcGFjaXR5LFxuICAgIHByb3BlcnR5OiAnc3Ryb2tlT3BhY2l0eSdcbiAgfSxcbiAgdGhpY2tuZXNzOiB7XG4gICAgLi4uTEFZRVJfVklTX0NPTkZJR1MudGhpY2tuZXNzLFxuICAgIGRlZmF1bHRWYWx1ZTogMC41XG4gIH0sXG4gIHN0cm9rZUNvbG9yOiAnc3Ryb2tlQ29sb3InLFxuICBjb2xvclJhbmdlOiAnY29sb3JSYW5nZScsXG4gIHN0cm9rZUNvbG9yUmFuZ2U6ICdzdHJva2VDb2xvclJhbmdlJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcblxuICBzaXplUmFuZ2U6ICdzdHJva2VXaWR0aFJhbmdlJyxcbiAgcmFkaXVzUmFuZ2U6ICdyYWRpdXNSYW5nZScsXG4gIGhlaWdodFJhbmdlOiAnZWxldmF0aW9uUmFuZ2UnLFxuICBlbGV2YXRpb25TY2FsZTogJ2VsZXZhdGlvblNjYWxlJyxcbiAgZW5hYmxlRWxldmF0aW9uWm9vbUZhY3RvcjogJ2VuYWJsZUVsZXZhdGlvblpvb21GYWN0b3InLFxuICBzdHJva2VkOiAnc3Ryb2tlZCcsXG4gIGZpbGxlZDogJ2ZpbGxlZCcsXG4gIGVuYWJsZTNkOiAnZW5hYmxlM2QnLFxuICB3aXJlZnJhbWU6ICd3aXJlZnJhbWUnXG59O1xuXG5leHBvcnQgdHlwZSBHZW9Kc29uVmlzQ29uZmlnU2V0dGluZ3MgPSB7XG4gIG9wYWNpdHk6IFZpc0NvbmZpZ051bWJlcjtcbiAgc3Ryb2tlT3BhY2l0eTogVmlzQ29uZmlnTnVtYmVyO1xuICB0aGlja25lc3M6IFZpc0NvbmZpZ051bWJlcjtcbiAgc3Ryb2tlQ29sb3I6IFZpc0NvbmZpZ0NvbG9yU2VsZWN0O1xuICBjb2xvclJhbmdlOiBWaXNDb25maWdDb2xvclJhbmdlO1xuICBzdHJva2VDb2xvclJhbmdlOiBWaXNDb25maWdDb2xvclJhbmdlO1xuICByYWRpdXM6IFZpc0NvbmZpZ051bWJlcjtcblxuICBzaXplUmFuZ2U6IFZpc0NvbmZpZ1JhbmdlO1xuICByYWRpdXNSYW5nZTogVmlzQ29uZmlnUmFuZ2U7XG4gIGhlaWdodFJhbmdlOiBWaXNDb25maWdSYW5nZTtcbiAgZWxldmF0aW9uU2NhbGU6IFZpc0NvbmZpZ051bWJlcjtcbiAgZW5hYmxlRWxldmF0aW9uWm9vbUZhY3RvcjogVmlzQ29uZmlnQm9vbGVhbjtcbiAgc3Ryb2tlZDogVmlzQ29uZmlnQm9vbGVhbjtcbiAgZmlsbGVkOiBWaXNDb25maWdCb29sZWFuO1xuICBlbmFibGUzZDogVmlzQ29uZmlnQm9vbGVhbjtcbiAgd2lyZWZyYW1lOiBWaXNDb25maWdCb29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgR2VvSnNvbkxheWVyQ29sdW1uc0NvbmZpZyA9IHtcbiAgZ2VvanNvbjogTGF5ZXJDb2x1bW47XG59O1xuXG5leHBvcnQgdHlwZSBHZW9Kc29uTGF5ZXJWaXNDb25maWcgPSB7XG4gIG9wYWNpdHk6IG51bWJlcjtcbiAgc3Ryb2tlT3BhY2l0eTogbnVtYmVyO1xuICB0aGlja25lc3M6IG51bWJlcjtcbiAgc3Ryb2tlQ29sb3I6IFJHQkNvbG9yO1xuICBjb2xvclJhbmdlOiBDb2xvclJhbmdlO1xuICBzdHJva2VDb2xvclJhbmdlOiBDb2xvclJhbmdlO1xuICByYWRpdXM6IG51bWJlcjtcblxuICBzaXplUmFuZ2U6IFtudW1iZXIsIG51bWJlcl07XG4gIHJhZGl1c1JhbmdlOiBbbnVtYmVyLCBudW1iZXJdO1xuICBoZWlnaHRSYW5nZTogW251bWJlciwgbnVtYmVyXTtcbiAgZWxldmF0aW9uU2NhbGU6IG51bWJlcjtcbiAgZW5hYmxlRWxldmF0aW9uWm9vbUZhY3RvcjogYm9vbGVhbjtcbiAgc3Ryb2tlZDogYm9vbGVhbjtcbiAgZmlsbGVkOiBib29sZWFuO1xuICBlbmFibGUzZDogYm9vbGVhbjtcbiAgd2lyZWZyYW1lOiBib29sZWFuO1xufTtcblxudHlwZSBHZW9Kc29uTGF5ZXJWaXN1YWxDaGFubmVsQ29uZmlnID0gTGF5ZXJDb2xvckNvbmZpZyAmXG4gIExheWVyU3Ryb2tlQ29sb3JDb25maWcgJlxuICBMYXllclNpemVDb25maWcgJlxuICBMYXllckhlaWdodENvbmZpZyAmXG4gIExheWVyUmFkaXVzQ29uZmlnO1xuZXhwb3J0IHR5cGUgR2VvSnNvbkxheWVyQ29uZmlnID0gTWVyZ2U8XG4gIExheWVyQmFzZUNvbmZpZyxcbiAge2NvbHVtbnM6IEdlb0pzb25MYXllckNvbHVtbnNDb25maWc7IHZpc0NvbmZpZzogR2VvSnNvbkxheWVyVmlzQ29uZmlnfVxuPiAmXG4gIEdlb0pzb25MYXllclZpc3VhbENoYW5uZWxDb25maWc7XG5cbmV4cG9ydCB0eXBlIEdlb0pzb25MYXllck1ldGEgPSB7XG4gIGZlYXR1cmVUeXBlcz86IERlY2tHbEdlb1R5cGVzO1xuICBmaXhlZFJhZGl1cz86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgY29uc3QgZ2VvSnNvblJlcXVpcmVkQ29sdW1uczogWydnZW9qc29uJ10gPSBbJ2dlb2pzb24nXTtcblxudHlwZSBPYmplY3RJbmZvID0ge1xuICBpbmRleDogbnVtYmVyO1xuICBvYmplY3Q/OiBGZWF0dXJlIHwgdW5kZWZpbmVkO1xuICBwaWNrZWQ6IGJvb2xlYW47XG4gIGxheWVyOiBMYXllcjtcbiAgcmFkaXVzPzogbnVtYmVyO1xuICBpZD86IHN0cmluZztcbn07XG5cbmV4cG9ydCBjb25zdCBmZWF0dXJlQWNjZXNzb3IgPSAoe2dlb2pzb259OiBHZW9Kc29uTGF5ZXJDb2x1bW5zQ29uZmlnKSA9PiAoXG4gIGRjOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlXG4pID0+IGQgPT4gZGMudmFsdWVBdChkLmluZGV4LCBnZW9qc29uLmZpZWxkSWR4KTtcblxuY29uc3QgZ2VvQ29sdW1uQWNjZXNzb3IgPSAoe2dlb2pzb259OiBHZW9Kc29uTGF5ZXJDb2x1bW5zQ29uZmlnKSA9PiAoXG4gIGRjOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlXG4pOiBhcnJvdy5WZWN0b3IgfCBudWxsID0+IGRjLmdldENvbHVtbj8uKGdlb2pzb24uZmllbGRJZHgpIGFzIGFycm93LlZlY3RvcjtcblxuY29uc3QgZ2VvRmllbGRBY2Nlc3NvciA9ICh7Z2VvanNvbn06IEdlb0pzb25MYXllckNvbHVtbnNDb25maWcpID0+IChcbiAgZGM6IERhdGFDb250YWluZXJJbnRlcmZhY2Vcbik6IEZpZWxkIHwgbnVsbCA9PiAoZGMuZ2V0RmllbGQgPyBkYy5nZXRGaWVsZChnZW9qc29uLmZpZWxkSWR4KSA6IG51bGwpO1xuXG4vLyBhY2Nlc3MgZmVhdHVyZSBwcm9wZXJ0aWVzIGZyb20gZ2VvanNvbiBzdWIgbGF5ZXJcbmV4cG9ydCBjb25zdCBkZWZhdWx0RWxldmF0aW9uID0gNTAwO1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRMaW5lV2lkdGggPSAxO1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRSYWRpdXMgPSAxO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHZW9Kc29uTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGRlY2xhcmUgY29uZmlnOiBHZW9Kc29uTGF5ZXJDb25maWc7XG4gIGRlY2xhcmUgdmlzQ29uZmlnU2V0dGluZ3M6IEdlb0pzb25WaXNDb25maWdTZXR0aW5ncztcbiAgZGVjbGFyZSBtZXRhOiBHZW9Kc29uTGF5ZXJNZXRhO1xuXG4gIGRhdGFUb0ZlYXR1cmU6IEdlb2pzb25EYXRhTWFwcyA9IFtdO1xuICBkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlIHwgbnVsbCA9IG51bGw7XG4gIGZpbHRlcmVkSW5kZXg6IFVpbnQ4Q2xhbXBlZEFycmF5IHwgbnVsbCA9IG51bGw7XG4gIGZpbHRlcmVkSW5kZXhUcmlnZ2VyOiBudW1iZXJbXSB8IG51bGwgPSBudWxsO1xuICBjZW50cm9pZHM6IEFycmF5PG51bWJlcltdIHwgbnVsbD4gPSBbXTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMucmVnaXN0ZXJWaXNDb25maWcoZ2VvanNvblZpc0NvbmZpZ3MpO1xuICAgIHRoaXMuZ2V0UG9zaXRpb25BY2Nlc3NvciA9IChkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlKSA9PlxuICAgICAgZmVhdHVyZUFjY2Vzc29yKHRoaXMuY29uZmlnLmNvbHVtbnMpKGRhdGFDb250YWluZXIpO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIEdlb0pzb25MYXllci50eXBlO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpOiAnZ2VvanNvbicge1xuICAgIHJldHVybiAnZ2VvanNvbic7XG4gIH1cblxuICBnZXQgbmFtZSgpOiAnUG9seWdvbicge1xuICAgIHJldHVybiAnUG9seWdvbic7XG4gIH1cblxuICBnZXQgbGF5ZXJJY29uKCkge1xuICAgIHJldHVybiBHZW9qc29uTGF5ZXJJY29uO1xuICB9XG5cbiAgZ2V0IHJlcXVpcmVkTGF5ZXJDb2x1bW5zKCkge1xuICAgIHJldHVybiBnZW9Kc29uUmVxdWlyZWRDb2x1bW5zO1xuICB9XG5cbiAgZ2V0IHZpc3VhbENoYW5uZWxzKCkge1xuICAgIGNvbnN0IHZpc3VhbENoYW5uZWxzID0gc3VwZXIudmlzdWFsQ2hhbm5lbHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIC4uLnZpc3VhbENoYW5uZWxzLmNvbG9yLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldEZpbGxDb2xvcicsXG4gICAgICAgIGNvbmRpdGlvbjogY29uZmlnID0+IGNvbmZpZy52aXNDb25maWcuZmlsbGVkLFxuICAgICAgICBudWxsVmFsdWU6IHZpc3VhbENoYW5uZWxzLmNvbG9yLm51bGxWYWx1ZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlVmFsdWU6IGNvbmZpZyA9PiBkID0+IGQucHJvcGVydGllcy5maWxsQ29sb3IgfHwgY29uZmlnLmNvbG9yLFxuICAgICAgICAvLyB1c2VkIHRoaXMgdG8gZ2V0IHVwZGF0ZVRyaWdnZXJzXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogY29uZmlnID0+IGNvbmZpZy5jb2xvclxuICAgICAgfSxcbiAgICAgIHN0cm9rZUNvbG9yOiB7XG4gICAgICAgIHByb3BlcnR5OiAnc3Ryb2tlQ29sb3InLFxuICAgICAgICBmaWVsZDogJ3N0cm9rZUNvbG9yRmllbGQnLFxuICAgICAgICBzY2FsZTogJ3N0cm9rZUNvbG9yU2NhbGUnLFxuICAgICAgICBkb21haW46ICdzdHJva2VDb2xvckRvbWFpbicsXG4gICAgICAgIHJhbmdlOiAnc3Ryb2tlQ29sb3JSYW5nZScsXG4gICAgICAgIGtleTogJ3N0cm9rZUNvbG9yJyxcbiAgICAgICAgY2hhbm5lbFNjYWxlVHlwZTogQ0hBTk5FTF9TQ0FMRVMuY29sb3IsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0TGluZUNvbG9yJyxcbiAgICAgICAgY29uZGl0aW9uOiBjb25maWcgPT4gY29uZmlnLnZpc0NvbmZpZy5zdHJva2VkLFxuICAgICAgICBudWxsVmFsdWU6IHZpc3VhbENoYW5uZWxzLmNvbG9yLm51bGxWYWx1ZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlVmFsdWU6IGNvbmZpZyA9PiBkID0+XG4gICAgICAgICAgZC5wcm9wZXJ0aWVzLmxpbmVDb2xvciB8fCBjb25maWcudmlzQ29uZmlnLnN0cm9rZUNvbG9yIHx8IGNvbmZpZy5jb2xvcixcbiAgICAgICAgLy8gdXNlZCB0aGlzIHRvIGdldCB1cGRhdGVUcmlnZ2Vyc1xuICAgICAgICBkZWZhdWx0VmFsdWU6IGNvbmZpZyA9PiBjb25maWcudmlzQ29uZmlnLnN0cm9rZUNvbG9yIHx8IGNvbmZpZy5jb2xvclxuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4udmlzdWFsQ2hhbm5lbHMuc2l6ZSxcbiAgICAgICAgcHJvcGVydHk6ICdzdHJva2UnLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldExpbmVXaWR0aCcsXG4gICAgICAgIGNvbmRpdGlvbjogY29uZmlnID0+IGNvbmZpZy52aXNDb25maWcuc3Ryb2tlZCxcbiAgICAgICAgbnVsbFZhbHVlOiAwLFxuICAgICAgICBnZXRBdHRyaWJ1dGVWYWx1ZTogKCkgPT4gZCA9PiBkLnByb3BlcnRpZXMubGluZVdpZHRoIHx8IGRlZmF1bHRMaW5lV2lkdGhcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgcHJvcGVydHk6ICdoZWlnaHQnLFxuICAgICAgICBmaWVsZDogJ2hlaWdodEZpZWxkJyxcbiAgICAgICAgc2NhbGU6ICdoZWlnaHRTY2FsZScsXG4gICAgICAgIGRvbWFpbjogJ2hlaWdodERvbWFpbicsXG4gICAgICAgIHJhbmdlOiAnaGVpZ2h0UmFuZ2UnLFxuICAgICAgICBrZXk6ICdoZWlnaHQnLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlOiBDSEFOTkVMX1NDQUxFUy5zaXplLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldEVsZXZhdGlvbicsXG4gICAgICAgIGNvbmRpdGlvbjogY29uZmlnID0+IGNvbmZpZy52aXNDb25maWcuZW5hYmxlM2QsXG4gICAgICAgIG51bGxWYWx1ZTogMCxcbiAgICAgICAgZ2V0QXR0cmlidXRlVmFsdWU6ICgpID0+IGQgPT4gZC5wcm9wZXJ0aWVzLmVsZXZhdGlvbiB8fCBkZWZhdWx0RWxldmF0aW9uXG4gICAgICB9LFxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHByb3BlcnR5OiAncmFkaXVzJyxcbiAgICAgICAgZmllbGQ6ICdyYWRpdXNGaWVsZCcsXG4gICAgICAgIHNjYWxlOiAncmFkaXVzU2NhbGUnLFxuICAgICAgICBkb21haW46ICdyYWRpdXNEb21haW4nLFxuICAgICAgICByYW5nZTogJ3JhZGl1c1JhbmdlJyxcbiAgICAgICAga2V5OiAncmFkaXVzJyxcbiAgICAgICAgY2hhbm5lbFNjYWxlVHlwZTogQ0hBTk5FTF9TQ0FMRVMucmFkaXVzLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldFBvaW50UmFkaXVzJyxcbiAgICAgICAgbnVsbFZhbHVlOiAwLFxuICAgICAgICBnZXRBdHRyaWJ1dGVWYWx1ZTogKCkgPT4gZCA9PiBkLnByb3BlcnRpZXMucmFkaXVzIHx8IGRlZmF1bHRSYWRpdXNcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGZpbmREZWZhdWx0TGF5ZXJQcm9wcyh7bGFiZWwsIGZpZWxkcyA9IFtdfTogS2VwbGVyVGFibGUpIHtcbiAgICBjb25zdCBnZW9qc29uQ29sdW1ucyA9IGZpZWxkc1xuICAgICAgLmZpbHRlcihcbiAgICAgICAgZiA9PlxuICAgICAgICAgIChmLnR5cGUgPT09ICdnZW9qc29uJyB8fCBmLnR5cGUgPT09ICdnZW9hcnJvdycpICYmXG4gICAgICAgICAgU1VQUE9SVEVEX0FOQUxZWkVSX1RZUEVTW2YuYW5hbHl6ZXJUeXBlXVxuICAgICAgKVxuICAgICAgLm1hcChmID0+IGYubmFtZSk7XG5cbiAgICBjb25zdCBkZWZhdWx0Q29sdW1ucyA9IHtcbiAgICAgIGdlb2pzb246IHVuaXEoWy4uLkdFT0pTT05fRklFTERTLmdlb2pzb24sIC4uLmdlb2pzb25Db2x1bW5zXSlcbiAgICB9O1xuXG4gICAgY29uc3QgZm91bmRDb2x1bW5zID0gdGhpcy5maW5kRGVmYXVsdENvbHVtbkZpZWxkKGRlZmF1bHRDb2x1bW5zLCBmaWVsZHMpO1xuICAgIGlmICghZm91bmRDb2x1bW5zIHx8ICFmb3VuZENvbHVtbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge3Byb3BzOiBbXX07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BzOiBmb3VuZENvbHVtbnMubWFwKGNvbHVtbnMgPT4gKHtcbiAgICAgICAgbGFiZWw6ICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnICYmIGxhYmVsLnJlcGxhY2UoL1xcLlteLy5dKyQvLCAnJykpIHx8IHRoaXMudHlwZSxcbiAgICAgICAgY29sdW1ucyxcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlXG4gICAgICB9KSlcbiAgICB9O1xuICB9XG5cbiAgZ2V0RGVmYXVsdExheWVyQ29uZmlnKHByb3BzOiBMYXllckJhc2VDb25maWdQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmdldERlZmF1bHRMYXllckNvbmZpZyhwcm9wcyksXG5cbiAgICAgIC8vIGFkZCBoZWlnaHQgdmlzdWFsIGNoYW5uZWxcbiAgICAgIGhlaWdodEZpZWxkOiBudWxsLFxuICAgICAgaGVpZ2h0RG9tYWluOiBbMCwgMV0sXG4gICAgICBoZWlnaHRTY2FsZTogJ2xpbmVhcicsXG5cbiAgICAgIC8vIGFkZCByYWRpdXMgdmlzdWFsIGNoYW5uZWxcbiAgICAgIHJhZGl1c0ZpZWxkOiBudWxsLFxuICAgICAgcmFkaXVzRG9tYWluOiBbMCwgMV0sXG4gICAgICByYWRpdXNTY2FsZTogJ2xpbmVhcicsXG5cbiAgICAgIC8vIGFkZCBzdHJva2UgY29sb3IgdmlzdWFsIGNoYW5uZWxcbiAgICAgIHN0cm9rZUNvbG9yRmllbGQ6IG51bGwsXG4gICAgICBzdHJva2VDb2xvckRvbWFpbjogWzAsIDFdLFxuICAgICAgc3Ryb2tlQ29sb3JTY2FsZTogJ3F1YW50aWxlJ1xuICAgIH07XG4gIH1cblxuICBnZXRIb3ZlckRhdGEob2JqZWN0LCBkYXRhQ29udGFpbmVyKSB7XG4gICAgLy8gaW5kZXggb2YgZGF0YUNvbnRhaW5lciBpcyBzYXZlZCB0byBmZWF0dXJlLnByb3BlcnRpZXNcbiAgICAvLyBmb3IgYXJyb3cgZm9ybWF0LCBgb2JqZWN0YCBpcyB0aGUgaW5kZXggb2YgdGhlIHJvdyByZXR1cm5lZCBmcm9tIGRlY2tcbiAgICBjb25zdCBpbmRleCA9IGRhdGFDb250YWluZXIgaW5zdGFuY2VvZiBBcnJvd0RhdGFDb250YWluZXIgPyBvYmplY3QgOiBvYmplY3Q/LnByb3BlcnRpZXM/LmluZGV4O1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZXR1cm4gZGF0YUNvbnRhaW5lci5yb3coaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNhbGN1bGF0ZURhdGFBdHRyaWJ1dGUoe2RhdGFDb250YWluZXIsIGZpbHRlcmVkSW5kZXh9LCBnZXRQb3NpdGlvbikge1xuICAgIGlmIChkYXRhQ29udGFpbmVyIGluc3RhbmNlb2YgQXJyb3dEYXRhQ29udGFpbmVyKSB7XG4gICAgICAvLyBmaWx0ZXIgZ2VvanNvbi9hcnJvdyB0YWJsZSBieSB2YWx1ZXMgYW5kIG1ha2UgYSBwYXJ0aWFsIGNvcHkgb2YgdGhlIHJhdyB0YWJsZSBhcmUgZXhwZW5zaXZlXG4gICAgICAvLyBzbyB3ZSB3aWxsIHVzZSBmaWx0ZXJlZEluZGV4IHRvIGNyZWF0ZSBhbiBhdHRyaWJ1dGUgZS5nLiBmaWx0ZXJlZEluZGV4IFswfDFdIGZvciBHUFUgZmlsdGVyaW5nXG4gICAgICAvLyBpbiBkZWNrLmdsIGxheWVyLCBzZWU6IEZpbHRlckFycm93RXh0ZW5zaW9uIGluIEBrZXBsZXIuZ2wvZGVja2dsLWxheWVyc1xuICAgICAgaWYgKCF0aGlzLmZpbHRlcmVkSW5kZXggfHwgdGhpcy5maWx0ZXJlZEluZGV4Lmxlbmd0aCAhPT0gZGF0YUNvbnRhaW5lci5udW1Sb3dzKCkpIHtcbiAgICAgICAgLy8gZm9yIGluY3JlbWVudGFsIGRhdGEgbG9hZGluZywgd2UgbmVlZCB0byB1cGRhdGUgZmlsdGVyZWRJbmRleFxuICAgICAgICB0aGlzLmZpbHRlcmVkSW5kZXggPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoZGF0YUNvbnRhaW5lci5udW1Sb3dzKCkpO1xuICAgICAgICB0aGlzLmZpbHRlcmVkSW5kZXguZmlsbCgxKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgZmlsdGVyZWRJbmRleCBpcyBhIHJhbmdlIGZyb20gMCB0byBudW1Sb3dzIGlmIGl0IGlzLCB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSBpdFxuICAgICAgY29uc3QgaXNSYW5nZSA9IGZpbHRlcmVkSW5kZXggJiYgZmlsdGVyZWRJbmRleC5sZW5ndGggPT09IGRhdGFDb250YWluZXIubnVtUm93cygpO1xuICAgICAgaWYgKCFpc1JhbmdlIHx8IHRoaXMuZmlsdGVyZWRJbmRleFRyaWdnZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJlZEluZGV4LmZpbGwoMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyZWRJbmRleC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRoaXMuZmlsdGVyZWRJbmRleFtmaWx0ZXJlZEluZGV4W2ldXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWx0ZXJlZEluZGV4VHJpZ2dlciA9IGZpbHRlcmVkSW5kZXg7XG4gICAgICB9XG4gICAgICAvLyBmb3IgYXJyb3csIGFsd2F5cyByZXR1cm4gZnVsbCBkYXRhVG9GZWF0dXJlIGluc3RlYWQgb2YgYSBmaWx0ZXJlZCBvbmUsIHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gdXBkYXRlIGF0dHJpYnV0ZXMgaW4gR1BVXG4gICAgICByZXR1cm4gdGhpcy5kYXRhVG9GZWF0dXJlO1xuICAgIH1cblxuICAgIC8vIGZvciBnZW9qc29uLCB0aGlzIHNob3VsZCB3b3JrIGFzIHdlbGwgYW5kIG1vcmUgZWZmaWNpZW50LiBCdXQgd2UgbmVlZCB0byB1cGRhdGUgc29tZSB0ZXN0IGNhc2VzIGUuZy4gI0dlb2pzb25MYXllciAtPiBmb3JtYXRMYXllckRhdGFcbiAgICByZXR1cm4gZmlsdGVyZWRJbmRleC5tYXAoaSA9PiB0aGlzLmRhdGFUb0ZlYXR1cmVbaV0pLmZpbHRlcihkID0+IGQpO1xuICB9XG5cbiAgZm9ybWF0TGF5ZXJEYXRhKGRhdGFzZXRzLCBvbGRMYXllckRhdGEpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZGF0YUlkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHtncHVGaWx0ZXIsIGRhdGFDb250YWluZXJ9ID0gZGF0YXNldHNbdGhpcy5jb25maWcuZGF0YUlkXTtcbiAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnVwZGF0ZURhdGEoZGF0YXNldHMsIG9sZExheWVyRGF0YSk7XG5cbiAgICBjb25zdCBjdXN0b21GaWx0ZXJWYWx1ZUFjY2Vzc29yID0gKGRjLCBkLCBmaWVsZEluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gZGMudmFsdWVBdChkLnByb3BlcnRpZXMuaW5kZXgsIGZpZWxkSW5kZXgpO1xuICAgIH07XG4gICAgY29uc3QgaW5kZXhBY2Nlc3NvciA9IGYgPT4gZi5wcm9wZXJ0aWVzLmluZGV4O1xuXG4gICAgY29uc3QgZGF0YUFjY2Vzc29yID0gZGMgPT4gZCA9PiAoe2luZGV4OiBkLnByb3BlcnRpZXMuaW5kZXh9KTtcbiAgICBjb25zdCBhY2Nlc3NvcnMgPSB0aGlzLmdldEF0dHJpYnV0ZUFjY2Vzc29ycyh7ZGF0YUFjY2Vzc29yLCBkYXRhQ29udGFpbmVyfSk7XG5cbiAgICBjb25zdCBpc0ZpbHRlcmVkQWNjZXNzb3IgPSBkID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkSW5kZXggPyB0aGlzLmZpbHRlcmVkSW5kZXhbZC5wcm9wZXJ0aWVzLmluZGV4XSA6IDE7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgZ2V0RmlsdGVyVmFsdWU6IGdwdUZpbHRlci5maWx0ZXJWYWx1ZUFjY2Vzc29yKGRhdGFDb250YWluZXIpKFxuICAgICAgICBpbmRleEFjY2Vzc29yLFxuICAgICAgICBjdXN0b21GaWx0ZXJWYWx1ZUFjY2Vzc29yXG4gICAgICApLFxuICAgICAgZ2V0RmlsdGVyZWQ6IGlzRmlsdGVyZWRBY2Nlc3NvcixcbiAgICAgIC4uLmFjY2Vzc29yc1xuICAgIH07XG4gIH1cblxuICBpc0luUG9seWdvbihkYXRhOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlLCBpbmRleDogbnVtYmVyLCBwb2x5Z29uOiBGZWF0dXJlPFBvbHlnb24+KTogQm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuY2VudHJvaWRzLmxlbmd0aCA9PT0gMCB8fCAhdGhpcy5jZW50cm9pZHNbaW5kZXhdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGlzUmVhY3RhbmdsZVNlYXJjaEJveCA9IHBvbHlnb24ucHJvcGVydGllcz8uc2hhcGUgPT09ICdSZWN0YW5nbGUnO1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5jZW50cm9pZHNbaW5kZXhdO1xuICAgIC8vIGlmIG5vIHZhbGlkIGNlbnRyb2lkLCByZXR1cm4gZmFsc2VcbiAgICBpZiAoIXBvaW50KSByZXR1cm4gZmFsc2U7XG4gICAgLy8gcXVpY2sgY2hlY2sgaWYgY2VudHJvaWQgaXMgd2l0aGluIHRoZSBxdWVyeSByZWN0YW5nbGVcbiAgICBpZiAoaXNSZWFjdGFuZ2xlU2VhcmNoQm94ICYmIHBvbHlnb24ucHJvcGVydGllcz8uYmJveCkge1xuICAgICAgY29uc3QgW21pblgsIG1pblksIG1heFgsIG1heFldID0gcG9seWdvbi5wcm9wZXJ0aWVzPy5iYm94O1xuICAgICAgcmV0dXJuIHBvaW50WzBdID49IG1pblggJiYgcG9pbnRbMF0gPD0gbWF4WCAmJiBwb2ludFsxXSA+PSBtaW5ZICYmIHBvaW50WzFdIDw9IG1heFk7XG4gICAgfVxuICAgIC8vIHVzZSB0dXJmLmpzIHRvIGNoZWNrIGlmIGNlbnRyb2lkIGlzIHdpdGhpbiBxdWVyeSBwb2x5Z29uXG4gICAgcmV0dXJuIGJvb2xlYW5XaXRoaW4odHVyZlBvaW50KHBvaW50KSwgcG9seWdvbik7XG4gIH1cblxuICB1cGRhdGVMYXllck1ldGEoZGF0YUNvbnRhaW5lcikge1xuICAgIHRoaXMuZGF0YUNvbnRhaW5lciA9IGRhdGFDb250YWluZXI7XG5cbiAgICBjb25zdCBnZXRGZWF0dXJlID0gdGhpcy5nZXRQb3NpdGlvbkFjY2Vzc29yKGRhdGFDb250YWluZXIpO1xuICAgIGNvbnN0IGdldEdlb0NvbHVtbiA9IGdlb0NvbHVtbkFjY2Vzc29yKHRoaXMuY29uZmlnLmNvbHVtbnMpO1xuICAgIGNvbnN0IGdldEdlb0ZpZWxkID0gZ2VvRmllbGRBY2Nlc3Nvcih0aGlzLmNvbmZpZy5jb2x1bW5zKTtcblxuICAgIGlmIChkYXRhQ29udGFpbmVyIGluc3RhbmNlb2YgQXJyb3dEYXRhQ29udGFpbmVyKSB7XG4gICAgICAvLyB1cGRhdGUgdGhlIGxhdGVzdCBiYXRjaC9jaHVuayBvZiBnZW9hcnJvdyBkYXRhIHdoZW4gbG9hZGluZyBkYXRhIGluY3JlbWVudGFsbHlcbiAgICAgIGlmICh0aGlzLmRhdGFUb0ZlYXR1cmUubGVuZ3RoIDwgZGF0YUNvbnRhaW5lci5udW1DaHVua3MoKSkge1xuICAgICAgICAvLyBmb3IgaW5jcmVtZW50YWxseSBsb2FkaW5nIGRhdGEsIHdlIG9ubHkgbG9hZCBhbmQgcmVuZGVyIHRoZSBsYXRlc3QgYmF0Y2g7IG90aGVyd2lzZSwgd2Ugd2lsbCBsb2FkIGFuZCByZW5kZXIgYWxsIGJhdGNoZXNcbiAgICAgICAgY29uc3QgaXNJbmNyZW1lbnRhbExvYWQgPSBkYXRhQ29udGFpbmVyLm51bUNodW5rcygpIC0gdGhpcy5kYXRhVG9GZWF0dXJlLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgY29uc3Qge2RhdGFUb0ZlYXR1cmUsIGJvdW5kcywgZml4ZWRSYWRpdXMsIGZlYXR1cmVUeXBlcywgY2VudHJvaWRzfSA9IGdldEdlb2pzb25MYXllck1ldGFGcm9tQXJyb3coe1xuICAgICAgICAgIGRhdGFDb250YWluZXIsXG4gICAgICAgICAgZ2V0R2VvQ29sdW1uLFxuICAgICAgICAgIGdldEdlb0ZpZWxkLFxuICAgICAgICAgIC4uLihpc0luY3JlbWVudGFsTG9hZCA/IHtjaHVua0luZGV4OiB0aGlzLmRhdGFUb0ZlYXR1cmUubGVuZ3RofSA6IG51bGwpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2VudHJvaWRzKSB0aGlzLmNlbnRyb2lkcyA9IHRoaXMuY2VudHJvaWRzLmNvbmNhdChjZW50cm9pZHMpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1ldGEoe2JvdW5kcywgZml4ZWRSYWRpdXMsIGZlYXR1cmVUeXBlc30pO1xuICAgICAgICB0aGlzLmRhdGFUb0ZlYXR1cmUgPSBbLi4udGhpcy5kYXRhVG9GZWF0dXJlLCAuLi5kYXRhVG9GZWF0dXJlXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZGF0YVRvRmVhdHVyZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3Qge2RhdGFUb0ZlYXR1cmUsIGJvdW5kcywgZml4ZWRSYWRpdXMsIGZlYXR1cmVUeXBlcywgY2VudHJvaWRzfSA9IGdldEdlb2pzb25MYXllck1ldGEoe1xuICAgICAgICAgIGRhdGFDb250YWluZXIsXG4gICAgICAgICAgZ2V0RmVhdHVyZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNlbnRyb2lkcykgdGhpcy5jZW50cm9pZHMgPSBjZW50cm9pZHM7XG4gICAgICAgIHRoaXMuZGF0YVRvRmVhdHVyZSA9IGRhdGFUb0ZlYXR1cmU7XG4gICAgICAgIHRoaXMudXBkYXRlTWV0YSh7Ym91bmRzLCBmaXhlZFJhZGl1cywgZmVhdHVyZVR5cGVzfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0SW5pdGlhbExheWVyQ29uZmlnKHtkYXRhQ29udGFpbmVyfSkge1xuICAgIGlmICghZGF0YUNvbnRhaW5lci5udW1Sb3dzKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUxheWVyTWV0YShkYXRhQ29udGFpbmVyKTtcblxuICAgIGNvbnN0IHtmZWF0dXJlVHlwZXN9ID0gdGhpcy5tZXRhO1xuICAgIC8vIGRlZmF1bHQgc2V0dGluZ3MgaXMgc3Ryb2tlOiB0cnVlLCBmaWxsZWQ6IGZhbHNlXG4gICAgaWYgKGZlYXR1cmVUeXBlcyAmJiBmZWF0dXJlVHlwZXMucG9seWdvbikge1xuICAgICAgLy8gc2V0IGJvdGggZmlsbCBhbmQgc3Ryb2tlIHRvIHRydWVcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUxheWVyVmlzQ29uZmlnKHtcbiAgICAgICAgZmlsbGVkOiB0cnVlLFxuICAgICAgICBzdHJva2VkOiB0cnVlLFxuICAgICAgICBzdHJva2VDb2xvcjogY29sb3JNYWtlci5uZXh0KCkudmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZmVhdHVyZVR5cGVzICYmIGZlYXR1cmVUeXBlcy5wb2ludCkge1xuICAgICAgLy8gc2V0IGZpbGwgdG8gdHJ1ZSBpZiBkZXRlY3QgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUxheWVyVmlzQ29uZmlnKHtmaWxsZWQ6IHRydWUsIHN0cm9rZWQ6IGZhbHNlfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpc0xheWVySG92ZXJlZChvYmplY3RJbmZvOiBPYmplY3RJbmZvKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YUNvbnRhaW5lciBpbnN0YW5jZW9mIEFycm93RGF0YUNvbnRhaW5lclxuICAgICAgPyBpc0xheWVySG92ZXJlZEZyb21BcnJvdyhvYmplY3RJbmZvLCB0aGlzLmlkKVxuICAgICAgOiBzdXBlci5pc0xheWVySG92ZXJlZChvYmplY3RJbmZvKTtcbiAgfVxuXG4gIGhhc0hvdmVyZWRPYmplY3Qob2JqZWN0SW5mbzogT2JqZWN0SW5mbyk6IEZlYXR1cmUgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhQ29udGFpbmVyIGluc3RhbmNlb2YgQXJyb3dEYXRhQ29udGFpbmVyXG4gICAgICA/IGdldEhvdmVyZWRPYmplY3RGcm9tQXJyb3coXG4gICAgICAgICAgb2JqZWN0SW5mbyxcbiAgICAgICAgICB0aGlzLmRhdGFDb250YWluZXIsXG4gICAgICAgICAgdGhpcy5pZCxcbiAgICAgICAgICBnZW9Db2x1bW5BY2Nlc3Nvcih0aGlzLmNvbmZpZy5jb2x1bW5zKSxcbiAgICAgICAgICBnZW9GaWVsZEFjY2Vzc29yKHRoaXMuY29uZmlnLmNvbHVtbnMpXG4gICAgICAgIClcbiAgICAgIDogc3VwZXIuaGFzSG92ZXJlZE9iamVjdChvYmplY3RJbmZvKTtcbiAgfVxuXG4gIHJlbmRlckxheWVyKG9wdHMpIHtcbiAgICBjb25zdCB7ZGF0YTogZGF0YVByb3BzLCBncHVGaWx0ZXIsIG9iamVjdEhvdmVyZWQsIG1hcFN0YXRlLCBpbnRlcmFjdGlvbkNvbmZpZ30gPSBvcHRzO1xuXG4gICAgY29uc3Qge2ZpeGVkUmFkaXVzLCBmZWF0dXJlVHlwZXN9ID0gdGhpcy5tZXRhO1xuICAgIGNvbnN0IHJhZGl1c1NjYWxlID0gdGhpcy5nZXRSYWRpdXNTY2FsZUJ5Wm9vbShtYXBTdGF0ZSwgZml4ZWRSYWRpdXMpO1xuICAgIGNvbnN0IHpvb21GYWN0b3IgPSB0aGlzLmdldFpvb21GYWN0b3IobWFwU3RhdGUpO1xuICAgIGNvbnN0IGVsZVpvb21GYWN0b3IgPSB0aGlzLmdldEVsZXZhdGlvblpvb21GYWN0b3IobWFwU3RhdGUpO1xuXG4gICAgY29uc3Qge3Zpc0NvbmZpZ30gPSB0aGlzLmNvbmZpZztcblxuICAgIGNvbnN0IGxheWVyUHJvcHMgPSB7XG4gICAgICBsaW5lV2lkdGhTY2FsZTogdmlzQ29uZmlnLnRoaWNrbmVzcyAqIHpvb21GYWN0b3IgKiA4LFxuICAgICAgZWxldmF0aW9uU2NhbGU6IHZpc0NvbmZpZy5lbGV2YXRpb25TY2FsZSAqIGVsZVpvb21GYWN0b3IsXG4gICAgICBwb2ludFJhZGl1c1NjYWxlOiByYWRpdXNTY2FsZSxcbiAgICAgIGxpbmVNaXRlckxpbWl0OiA0XG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZVRyaWdnZXJzID0ge1xuICAgICAgLi4udGhpcy5nZXRWaXN1YWxDaGFubmVsVXBkYXRlVHJpZ2dlcnMoKSxcbiAgICAgIGdldEZpbHRlclZhbHVlOiBncHVGaWx0ZXIuZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VycyxcbiAgICAgIGdldEZpbHRlcmVkOiB0aGlzLmZpbHRlcmVkSW5kZXhUcmlnZ2VyXG4gICAgfTtcblxuICAgIGNvbnN0IGRlZmF1bHRMYXllclByb3BzID0gdGhpcy5nZXREZWZhdWx0RGVja0xheWVyUHJvcHMob3B0cyk7XG4gICAgY29uc3Qgb3BhT3ZlcndyaXRlID0ge1xuICAgICAgb3BhY2l0eTogdmlzQ29uZmlnLnN0cm9rZU9wYWNpdHlcbiAgICB9O1xuXG4gICAgY29uc3QgcGlja2FibGUgPSBpbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLmVuYWJsZWQ7XG4gICAgY29uc3QgaG92ZXJlZE9iamVjdCA9IHRoaXMuaGFzSG92ZXJlZE9iamVjdChvYmplY3RIb3ZlcmVkKTtcblxuICAgIGNvbnN0IHtkYXRhLCAuLi5wcm9wc30gPSBkYXRhUHJvcHM7XG5cbiAgICAvLyBhcnJvdyB0YWJsZSBjYW4gaGF2ZSBtdWx0aXBsZSBjaHVua3MsIGEgZGVjay5nbCBsYXllciBpcyBjcmVhdGVkIGZvciBlYWNoIGNodW5rXG4gICAgY29uc3QgZGVja0xheWVyRGF0YSA9IHRoaXMuZGF0YUNvbnRhaW5lciBpbnN0YW5jZW9mIEFycm93RGF0YUNvbnRhaW5lciA/IGRhdGEgOiBbZGF0YV07XG4gICAgY29uc3QgZGVja0xheWVycyA9IGRlY2tMYXllckRhdGEubWFwKChkLCBpKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IERlY2tHTEdlb0pzb25MYXllcih7XG4gICAgICAgIC4uLmRlZmF1bHRMYXllclByb3BzLFxuICAgICAgICAuLi5sYXllclByb3BzLFxuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgZGF0YTogZCxcbiAgICAgICAgaWQ6IGRlY2tMYXllckRhdGEubGVuZ3RoID4gMSA/IGAke3RoaXMuaWR9LSR7aX1gIDogdGhpcy5pZCxcbiAgICAgICAgcGlja2FibGUsXG4gICAgICAgIGhpZ2hsaWdodENvbG9yOiBISUdITElHSF9DT0xPUl8zRCxcbiAgICAgICAgYXV0b0hpZ2hsaWdodDogdmlzQ29uZmlnLmVuYWJsZTNkICYmIHBpY2thYmxlLFxuICAgICAgICBzdHJva2VkOiB2aXNDb25maWcuc3Ryb2tlZCxcbiAgICAgICAgZmlsbGVkOiB2aXNDb25maWcuZmlsbGVkLFxuICAgICAgICBleHRydWRlZDogdmlzQ29uZmlnLmVuYWJsZTNkLFxuICAgICAgICB3aXJlZnJhbWU6IHZpc0NvbmZpZy53aXJlZnJhbWUsXG4gICAgICAgIHdyYXBMb25naXR1ZGU6IGZhbHNlLFxuICAgICAgICBsaW5lTWl0ZXJMaW1pdDogMixcbiAgICAgICAgY2FwUm91bmRlZDogdHJ1ZSxcbiAgICAgICAgam9pbnRSb3VuZGVkOiB0cnVlLFxuICAgICAgICB1cGRhdGVUcmlnZ2VycyxcbiAgICAgICAgZXh0ZW5zaW9uczogWy4uLmRlZmF1bHRMYXllclByb3BzLmV4dGVuc2lvbnMsIG5ldyBGaWx0ZXJBcnJvd0V4dGVuc2lvbigpXSxcbiAgICAgICAgX3N1YkxheWVyUHJvcHM6IHtcbiAgICAgICAgICAuLi4oZmVhdHVyZVR5cGVzPy5wb2x5Z29uID8geydwb2x5Z29ucy1zdHJva2UnOiBvcGFPdmVyd3JpdGV9IDoge30pLFxuICAgICAgICAgIC4uLihmZWF0dXJlVHlwZXM/LmxpbmUgPyB7bGluZXN0cmluZ3M6IG9wYU92ZXJ3cml0ZX0gOiB7fSksXG4gICAgICAgICAgLi4uKGZlYXR1cmVUeXBlcz8ucG9pbnRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHBvaW50czoge1xuICAgICAgICAgICAgICAgICAgbGluZU9wYWNpdHk6IHZpc0NvbmZpZy5zdHJva2VPcGFjaXR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAuLi5kZWNrTGF5ZXJzLFxuICAgICAgLy8gaG92ZXIgbGF5ZXJcbiAgICAgIC4uLihob3ZlcmVkT2JqZWN0ICYmICF2aXNDb25maWcuZW5hYmxlM2RcbiAgICAgICAgPyBbXG4gICAgICAgICAgICBuZXcgRGVja0dMR2VvSnNvbkxheWVyKHtcbiAgICAgICAgICAgICAgLi4udGhpcy5nZXREZWZhdWx0SG92ZXJMYXllclByb3BzKCksXG4gICAgICAgICAgICAgIC4uLmxheWVyUHJvcHMsXG4gICAgICAgICAgICAgIHZpc2libGU6IGRlZmF1bHRMYXllclByb3BzLnZpc2libGUsXG4gICAgICAgICAgICAgIHdyYXBMb25naXR1ZGU6IGZhbHNlLFxuICAgICAgICAgICAgICBkYXRhOiBbaG92ZXJlZE9iamVjdF0sXG4gICAgICAgICAgICAgIGdldExpbmVXaWR0aDogcHJvcHMuZ2V0TGluZVdpZHRoLFxuICAgICAgICAgICAgICBnZXRQb2ludFJhZGl1czogcHJvcHMuZ2V0UG9pbnRSYWRpdXMsXG4gICAgICAgICAgICAgIGdldEVsZXZhdGlvbjogcHJvcHMuZ2V0RWxldmF0aW9uLFxuICAgICAgICAgICAgICBnZXRMaW5lQ29sb3I6IHRoaXMuY29uZmlnLmhpZ2hsaWdodENvbG9yLFxuICAgICAgICAgICAgICBnZXRGaWxsQ29sb3I6IHRoaXMuY29uZmlnLmhpZ2hsaWdodENvbG9yLFxuICAgICAgICAgICAgICAvLyBhbHdheXMgZHJhdyBvdXRsaW5lXG4gICAgICAgICAgICAgIHN0cm9rZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGZpbGxlZDogZmFsc2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXVxuICAgICAgICA6IFtdKVxuICAgIF07XG4gIH1cbn1cbiJdfQ==