"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.maybeToDate = maybeToDate;
exports.findPointFieldPairs = findPointFieldPairs;
exports.sortDatasetByColumn = sortDatasetByColumn;
exports.pinTableColumns = pinTableColumns;
exports.copyTable = copyTable;
exports.copyTableAndUpdate = copyTableAndUpdate;
exports.getFieldValueAccessor = getFieldValueAccessor;
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _console = require("global/console");

var _d3Array = require("d3-array");

var _constants = require("@kepler.gl/constants");

var _gpuFilterUtils = require("./gpu-filter-utils");

var _utils = require("@kepler.gl/utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Unique identifier of each field
var FID_KEY = 'name';

function maybeToDate(isTime, fieldIdx, format, dc, d) {
  if (isTime) {
    return (0, _utils.timeToUnixMilli)(dc.valueAt(d.index, fieldIdx), format);
  }

  return dc.valueAt(d.index, fieldIdx);
}

var KeplerTable = /*#__PURE__*/function () {
  // fields and data
  // table-injected metadata
  // table-injected metadata
  function KeplerTable(_ref) {
    var info = _ref.info,
        data = _ref.data,
        color = _ref.color,
        metadata = _ref.metadata,
        _ref$supportedFilterT = _ref.supportedFilterTypes,
        supportedFilterTypes = _ref$supportedFilterT === void 0 ? null : _ref$supportedFilterT,
        _ref$disableDataOpera = _ref.disableDataOperation,
        disableDataOperation = _ref$disableDataOpera === void 0 ? false : _ref$disableDataOpera;
    (0, _classCallCheck2["default"])(this, KeplerTable);
    (0, _defineProperty2["default"])(this, "id", void 0);
    (0, _defineProperty2["default"])(this, "type", void 0);
    (0, _defineProperty2["default"])(this, "label", void 0);
    (0, _defineProperty2["default"])(this, "color", void 0);
    (0, _defineProperty2["default"])(this, "fields", void 0);
    (0, _defineProperty2["default"])(this, "dataContainer", void 0);
    (0, _defineProperty2["default"])(this, "allIndexes", void 0);
    (0, _defineProperty2["default"])(this, "filteredIndex", void 0);
    (0, _defineProperty2["default"])(this, "filteredIdxCPU", void 0);
    (0, _defineProperty2["default"])(this, "filteredIndexForDomain", void 0);
    (0, _defineProperty2["default"])(this, "fieldPairs", void 0);
    (0, _defineProperty2["default"])(this, "gpuFilter", void 0);
    (0, _defineProperty2["default"])(this, "filterRecord", void 0);
    (0, _defineProperty2["default"])(this, "filterRecordCPU", void 0);
    (0, _defineProperty2["default"])(this, "changedFilters", void 0);
    (0, _defineProperty2["default"])(this, "sortColumn", void 0);
    (0, _defineProperty2["default"])(this, "sortOrder", void 0);
    (0, _defineProperty2["default"])(this, "pinnedColumns", void 0);
    (0, _defineProperty2["default"])(this, "supportedFilterTypes", void 0);
    (0, _defineProperty2["default"])(this, "disableDataOperation", void 0);
    (0, _defineProperty2["default"])(this, "metadata", void 0);
    // TODO - what to do if validation fails? Can kepler handle exceptions?
    // const validatedData = validateInputData(data);
    // if (!validatedData) {
    //   return this;
    // }
    var dataContainerData = data.cols ? data.cols : data.rows;
    var inputDataFormat = data.cols ? _utils.DataForm.COLS_ARRAY : _utils.DataForm.ROWS_ARRAY;
    var dataContainer = (0, _utils.createDataContainer)(dataContainerData, {
      // @ts-expect-error ProtoDataset field missing property fieldIdx, valueAccessor
      fields: data.fields,
      inputDataFormat: inputDataFormat
    });

    var datasetInfo = _objectSpread({
      id: (0, _utils.generateHashId)(4),
      label: 'new dataset',
      type: ''
    }, info);

    var dataId = datasetInfo.id; // @ts-expect-error

    var fields = data.fields.map(function (f, i) {
      return _objectSpread(_objectSpread({}, f), {}, {
        fieldIdx: i,
        id: f.name,
        displayName: f.displayName || f.name,
        valueAccessor: getFieldValueAccessor(f, i, dataContainer)
      });
    });
    var allIndexes = dataContainer.getPlainIndex();
    var defaultMetadata = {
      id: datasetInfo.id,
      // @ts-ignore
      format: datasetInfo.format || '',
      label: datasetInfo.label || ''
    };
    this.id = datasetInfo.id;
    this.type = datasetInfo.type;
    this.label = datasetInfo.label;
    this.color = color;
    this.metadata = _objectSpread(_objectSpread({}, defaultMetadata), metadata);
    this.dataContainer = dataContainer;
    this.allIndexes = allIndexes;
    this.filteredIndex = allIndexes;
    this.filteredIndexForDomain = allIndexes;
    this.fieldPairs = findPointFieldPairs(fields);
    this.fields = fields;
    this.gpuFilter = (0, _gpuFilterUtils.getGpuFilterProps)([], dataId, fields);
    this.supportedFilterTypes = supportedFilterTypes;
    this.disableDataOperation = disableDataOperation;
  }
  /**
   * update table with new data
   * @param data - new data e.g. the arrow data with new batches loaded
   */


  (0, _createClass2["default"])(KeplerTable, [{
    key: "update",
    value: function update(data) {
      var _this$dataContainer$u, _this$dataContainer;

      var dataContainerData = data.cols ? data.cols : data.rows;
      (_this$dataContainer$u = (_this$dataContainer = this.dataContainer).update) === null || _this$dataContainer$u === void 0 ? void 0 : _this$dataContainer$u.call(_this$dataContainer, dataContainerData);
      this.allIndexes = this.dataContainer.getPlainIndex();
      this.filteredIndex = this.allIndexes;
      this.filteredIndexForDomain = this.allIndexes;
    }
  }, {
    key: "length",
    get: function get() {
      return this.dataContainer.numRows();
    }
    /**
     * Get field
     * @param columnName
     */

  }, {
    key: "getColumnField",
    value: function getColumnField(columnName) {
      var field = this.fields.find(function (fd) {
        return fd[FID_KEY] === columnName;
      });

      this._assetField(columnName, field);

      return field;
    }
    /**
     * Get fieldIdx
     * @param columnName
     */

  }, {
    key: "getColumnFieldIdx",
    value: function getColumnFieldIdx(columnName) {
      var fieldIdx = this.fields.findIndex(function (fd) {
        return fd[FID_KEY] === columnName;
      });

      this._assetField(columnName, Boolean(fieldIdx > -1));

      return fieldIdx;
    }
    /**
     * Get displayFormat
     * @param columnName
     */

  }, {
    key: "getColumnDisplayFormat",
    value: function getColumnDisplayFormat(columnName) {
      var field = this.fields.find(function (fd) {
        return fd[FID_KEY] === columnName;
      });

      this._assetField(columnName, field);

      return field === null || field === void 0 ? void 0 : field.displayFormat;
    }
    /**
     * Get the value of a cell
     */

  }, {
    key: "getValue",
    value: function getValue(columnName, rowIdx) {
      var field = this.getColumnField(columnName);
      return field ? field.valueAccessor({
        index: rowIdx
      }) : null;
    }
    /**
     * Updates existing field with a new object
     * @param fieldIdx
     * @param newField
     */

  }, {
    key: "updateColumnField",
    value: function updateColumnField(fieldIdx, newField) {
      this.fields = Object.assign((0, _toConsumableArray2["default"])(this.fields), (0, _defineProperty2["default"])({}, fieldIdx, newField));
    }
    /**
     * Update dataset color by custom color
     * @param newColor
     */

  }, {
    key: "updateTableColor",
    value: function updateTableColor(newColor) {
      this.color = newColor;
    }
    /**
     * Save filterProps to field and retrieve it
     * @param columnName
     */

  }, {
    key: "getColumnFilterProps",
    value: function getColumnFilterProps(columnName) {
      var fieldIdx = this.getColumnFieldIdx(columnName);

      if (fieldIdx < 0) {
        return null;
      }

      var field = this.fields[fieldIdx];

      if (field.hasOwnProperty('filterProps')) {
        return field.filterProps;
      }

      var fieldDomain = this.getColumnFilterDomain(field);

      if (!fieldDomain) {
        return null;
      }

      var filterProps = (0, _utils.getFilterProps)(field, fieldDomain);

      var newField = _objectSpread(_objectSpread({}, field), {}, {
        filterProps: filterProps
      });

      this.updateColumnField(fieldIdx, newField);
      return filterProps;
    }
    /**
     * Apply filters to dataset, return the filtered dataset with updated `gpuFilter`, `filterRecord`, `filteredIndex`, `filteredIndexForDomain`
     * @param filters
     * @param layers
     * @param opt
     */

  }, {
    key: "filterTable",
    value: function filterTable(filters, layers, opt) {
      var _this = this;

      var dataContainer = this.dataContainer,
          dataId = this.id,
          oldFilterRecord = this.filterRecord,
          fields = this.fields; // if there is no filters

      var filterRecord = (0, _utils.getFilterRecord)(dataId, filters, opt || {});
      this.filterRecord = filterRecord;
      this.gpuFilter = (0, _gpuFilterUtils.getGpuFilterProps)(filters, dataId, fields); // const newDataset = set(['filterRecord'], filterRecord, dataset);

      if (!filters.length) {
        this.filteredIndex = this.allIndexes;
        this.filteredIndexForDomain = this.allIndexes;
        return this;
      }

      this.changedFilters = (0, _utils.diffFilters)(filterRecord, oldFilterRecord); // generate 2 sets of filter result
      // filteredIndex used to calculate layer data
      // filteredIndexForDomain used to calculate layer Domain

      var shouldCalDomain = Boolean(this.changedFilters.dynamicDomain);
      var shouldCalIndex = Boolean(this.changedFilters.cpu);
      var filterResult = {};

      if (shouldCalDomain || shouldCalIndex) {
        var dynamicDomainFilters = shouldCalDomain ? filterRecord.dynamicDomain : null;
        var cpuFilters = shouldCalIndex ? filterRecord.cpu : null;
        var filterFuncs = filters.reduce(function (acc, filter) {
          var fieldIndex = (0, _gpuFilterUtils.getDatasetFieldIndexForFilter)(_this.id, filter);
          var field = fieldIndex !== -1 ? fields[fieldIndex] : null;
          return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, filter.id, (0, _utils.getFilterFunction)(field, _this.id, filter, layers, dataContainer)));
        }, {});
        filterResult = (0, _utils.filterDataByFilterTypes)({
          dynamicDomainFilters: dynamicDomainFilters,
          cpuFilters: cpuFilters,
          filterFuncs: filterFuncs
        }, dataContainer);
      }

      this.filteredIndex = filterResult.filteredIndex || this.filteredIndex;
      this.filteredIndexForDomain = filterResult.filteredIndexForDomain || this.filteredIndexForDomain;
      return this;
    }
    /**
     * Apply filters to a dataset all on CPU, assign to `filteredIdxCPU`, `filterRecordCPU`
     * @param filters
     * @param layers
     */

  }, {
    key: "filterTableCPU",
    value: function filterTableCPU(filters, layers) {
      var opt = {
        cpuOnly: true,
        ignoreDomain: true
      }; // no filter

      if (!filters.length) {
        this.filteredIdxCPU = this.allIndexes;
        this.filterRecordCPU = (0, _utils.getFilterRecord)(this.id, filters, opt);
        return this;
      } // no gpu filter


      if (!filters.find(function (f) {
        return f.gpu;
      })) {
        this.filteredIdxCPU = this.filteredIndex;
        this.filterRecordCPU = (0, _utils.getFilterRecord)(this.id, filters, opt);
        return this;
      } // make a copy for cpu filtering


      var copied = copyTable(this);
      copied.filterRecord = this.filterRecordCPU;
      copied.filteredIndex = this.filteredIdxCPU || [];
      var filtered = copied.filterTable(filters, layers, opt);
      this.filteredIdxCPU = filtered.filteredIndex;
      this.filterRecordCPU = filtered.filterRecord;
      return this;
    }
    /**
     * Calculate field domain based on field type and data
     * for Filter
     */

  }, {
    key: "getColumnFilterDomain",
    value: function getColumnFilterDomain(field) {
      var dataContainer = this.dataContainer;
      var valueAccessor = field.valueAccessor;
      var domain;

      switch (field.type) {
        case _constants.ALL_FIELD_TYPES.real:
        case _constants.ALL_FIELD_TYPES.integer:
          // calculate domain and step
          return (0, _utils.getNumericFieldDomain)(dataContainer, valueAccessor);

        case _constants.ALL_FIELD_TYPES["boolean"]:
          return {
            domain: [true, false]
          };

        case _constants.ALL_FIELD_TYPES.string:
        case _constants.ALL_FIELD_TYPES.date:
          domain = (0, _utils.getOrdinalDomain)(dataContainer, valueAccessor);
          return {
            domain: domain
          };

        case _constants.ALL_FIELD_TYPES.timestamp:
          return (0, _utils.getTimestampFieldDomain)(dataContainer, valueAccessor);

        default:
          return {
            domain: (0, _utils.getOrdinalDomain)(dataContainer, valueAccessor)
          };
      }
    }
    /**
     *  Get the domain of this column based on scale type
     */

  }, {
    key: "getColumnLayerDomain",
    value: function getColumnLayerDomain(field, scaleType) {
      var dataContainer = this.dataContainer,
          filteredIndexForDomain = this.filteredIndexForDomain;

      if (!_constants.SCALE_TYPES[scaleType]) {
        _console.console.error("scale type ".concat(scaleType, " not supported"));

        return null;
      }

      var valueAccessor = field.valueAccessor;

      var indexValueAccessor = function indexValueAccessor(i) {
        return valueAccessor({
          index: i
        });
      };

      var sortFunction = (0, _utils.getSortingFunction)(field.type);

      switch (scaleType) {
        case _constants.SCALE_TYPES.ordinal:
        case _constants.SCALE_TYPES.point:
          // do not recalculate ordinal domain based on filtered data
          // don't need to update ordinal domain every time
          return (0, _utils.getOrdinalDomain)(dataContainer, valueAccessor);

        case _constants.SCALE_TYPES.quantile:
          return (0, _utils.getQuantileDomain)(filteredIndexForDomain, indexValueAccessor, sortFunction);

        case _constants.SCALE_TYPES.log:
          return (0, _utils.getLogDomain)(filteredIndexForDomain, indexValueAccessor);

        case _constants.SCALE_TYPES.quantize:
        case _constants.SCALE_TYPES.linear:
        case _constants.SCALE_TYPES.sqrt:
        default:
          return (0, _utils.getLinearDomain)(filteredIndexForDomain, indexValueAccessor);
      }
    }
    /**
     * Get a sample of rows to calculate layer boundaries
     */
    // getSampleData(rows)

    /**
     * Parse cell value based on column type and return a string representation
     * Value the field value, type the field type
     */
    // parseFieldValue(value, type)
    // sortDatasetByColumn()

    /**
     * Assert whether field exist
     * @param fieldName
     * @param condition
     */

  }, {
    key: "_assetField",
    value: function _assetField(fieldName, condition) {
      if (!condition) {
        _console.console.error("".concat(fieldName, " doesnt exist in dataset ").concat(this.id));
      }
    }
  }]);
  return KeplerTable;
}();

// HELPER FUNCTIONS (MAINLY EXPORTED FOR TEST...)
// have to double excape
var specialCharacterSet = "[#_&@\\.\\-\\ ]";

function foundMatchingFields(re, suffixPair, allNames, fieldName) {
  var partnerIdx = allNames.findIndex(function (d) {
    return d === fieldName.replace(re, function (match) {
      return match.replace(suffixPair[0], suffixPair[1]);
    });
  });
  var altIdx = -1;

  if (partnerIdx > -1) {
    // if found partner, go on and look for altitude
    _constants.ALTITUDE_FIELDS.some(function (alt) {
      altIdx = allNames.findIndex(function (d) {
        return d === fieldName.replace(re, function (match) {
          return match.replace(suffixPair[0], alt);
        });
      });
      return altIdx > -1;
    });
  }

  return {
    partnerIdx: partnerIdx,
    altIdx: altIdx
  };
}
/**
 * Find point fields pairs from fields
 *
 * @param fields
 * @returns found point fields
 */


function findPointFieldPairs(fields) {
  var allNames = fields.map(function (f) {
    return f.name.toLowerCase();
  }); // get list of all fields with matching suffixes

  var acc = [];
  return allNames.reduce(function (carry, fieldName, idx) {
    // This search for pairs will early exit if found.
    var _iterator = _createForOfIteratorHelper(_constants.TRIP_POINT_FIELDS),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var suffixPair = _step.value;
        // match first suffix
        // (^|[#_&@\.\-\ ])lat([#_&@\.\-\ ]|$)
        var re = new RegExp("(^|".concat(specialCharacterSet, ")").concat(suffixPair[0], "(").concat(specialCharacterSet, "|$)"));

        if (re.test(fieldName)) {
          var _foundMatchingFields = foundMatchingFields(re, suffixPair, allNames, fieldName),
              partnerIdx = _foundMatchingFields.partnerIdx,
              altIdx = _foundMatchingFields.altIdx;

          if (partnerIdx > -1) {
            var trimName = fieldName.replace(re, '').trim();
            carry.push({
              defaultName: trimName || 'point',
              pair: _objectSpread({
                lat: {
                  fieldIdx: idx,
                  value: fields[idx].name
                },
                lng: {
                  fieldIdx: partnerIdx,
                  value: fields[partnerIdx].name
                }
              }, altIdx > -1 ? {
                alt: {
                  fieldIdx: altIdx,
                  value: fields[altIdx].name
                }
              } : {}),
              suffix: suffixPair
            });
            return carry;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return carry;
  }, acc);
}
/**
 *
 * @param dataset
 * @param column
 * @param mode
 * @type
 */


function sortDatasetByColumn(dataset, column, mode) {
  var allIndexes = dataset.allIndexes,
      fields = dataset.fields,
      dataContainer = dataset.dataContainer;
  var fieldIndex = fields.findIndex(function (f) {
    return f.name === column;
  });

  if (fieldIndex < 0) {
    return dataset;
  }

  var sortBy = _constants.SORT_ORDER[mode || ''] || _constants.SORT_ORDER.ASCENDING;

  if (sortBy === _constants.SORT_ORDER.UNSORT) {
    dataset.sortColumn = {};
    dataset.sortOrder = null;
    return dataset;
  }

  var sortFunction = sortBy === _constants.SORT_ORDER.ASCENDING ? _d3Array.ascending : _d3Array.descending;
  var sortOrder = allIndexes.slice().sort(function (a, b) {
    var value1 = dataContainer.valueAt(a, fieldIndex);
    var value2 = dataContainer.valueAt(b, fieldIndex);

    if (!(0, _utils.notNullorUndefined)(value1) && (0, _utils.notNullorUndefined)(value2)) {
      return 1;
    } else if ((0, _utils.notNullorUndefined)(value1) && !(0, _utils.notNullorUndefined)(value2)) {
      return -1;
    }

    return sortFunction(value1, value2);
  });
  dataset.sortColumn = (0, _defineProperty2["default"])({}, column, sortBy);
  dataset.sortOrder = sortOrder;
  return dataset;
}

function pinTableColumns(dataset, column) {
  var field = dataset.getColumnField(column);

  if (!field) {
    return dataset;
  }

  var pinnedColumns;

  if (Array.isArray(dataset.pinnedColumns) && dataset.pinnedColumns.includes(field.name)) {
    // unpin it
    pinnedColumns = dataset.pinnedColumns.filter(function (co) {
      return co !== field.name;
    });
  } else {
    pinnedColumns = (dataset.pinnedColumns || []).concat(field.name);
  } // @ts-ignore


  return copyTableAndUpdate(dataset, {
    pinnedColumns: pinnedColumns
  });
}

function copyTable(original) {
  return Object.assign(Object.create(Object.getPrototypeOf(original)), original);
}
/**
 * @type
 * @returns
 */


function copyTableAndUpdate(original) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Object.entries(options).reduce(function (acc, entry) {
    acc[entry[0]] = entry[1];
    return acc;
  }, copyTable(original));
}

function getFieldValueAccessor(f, i, dc) {
  return maybeToDate.bind(null, // is time
  f.type === _constants.ALL_FIELD_TYPES.timestamp, i, f.format || '', dc);
}

var _default = KeplerTable;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9rZXBsZXItdGFibGUudHMiXSwibmFtZXMiOlsiRklEX0tFWSIsIm1heWJlVG9EYXRlIiwiaXNUaW1lIiwiZmllbGRJZHgiLCJmb3JtYXQiLCJkYyIsImQiLCJ2YWx1ZUF0IiwiaW5kZXgiLCJLZXBsZXJUYWJsZSIsImluZm8iLCJkYXRhIiwiY29sb3IiLCJtZXRhZGF0YSIsInN1cHBvcnRlZEZpbHRlclR5cGVzIiwiZGlzYWJsZURhdGFPcGVyYXRpb24iLCJkYXRhQ29udGFpbmVyRGF0YSIsImNvbHMiLCJyb3dzIiwiaW5wdXREYXRhRm9ybWF0IiwiRGF0YUZvcm0iLCJDT0xTX0FSUkFZIiwiUk9XU19BUlJBWSIsImRhdGFDb250YWluZXIiLCJmaWVsZHMiLCJkYXRhc2V0SW5mbyIsImlkIiwibGFiZWwiLCJ0eXBlIiwiZGF0YUlkIiwibWFwIiwiZiIsImkiLCJuYW1lIiwiZGlzcGxheU5hbWUiLCJ2YWx1ZUFjY2Vzc29yIiwiZ2V0RmllbGRWYWx1ZUFjY2Vzc29yIiwiYWxsSW5kZXhlcyIsImdldFBsYWluSW5kZXgiLCJkZWZhdWx0TWV0YWRhdGEiLCJmaWx0ZXJlZEluZGV4IiwiZmlsdGVyZWRJbmRleEZvckRvbWFpbiIsImZpZWxkUGFpcnMiLCJmaW5kUG9pbnRGaWVsZFBhaXJzIiwiZ3B1RmlsdGVyIiwidXBkYXRlIiwibnVtUm93cyIsImNvbHVtbk5hbWUiLCJmaWVsZCIsImZpbmQiLCJmZCIsIl9hc3NldEZpZWxkIiwiZmluZEluZGV4IiwiQm9vbGVhbiIsImRpc3BsYXlGb3JtYXQiLCJyb3dJZHgiLCJnZXRDb2x1bW5GaWVsZCIsIm5ld0ZpZWxkIiwiT2JqZWN0IiwiYXNzaWduIiwibmV3Q29sb3IiLCJnZXRDb2x1bW5GaWVsZElkeCIsImhhc093blByb3BlcnR5IiwiZmlsdGVyUHJvcHMiLCJmaWVsZERvbWFpbiIsImdldENvbHVtbkZpbHRlckRvbWFpbiIsInVwZGF0ZUNvbHVtbkZpZWxkIiwiZmlsdGVycyIsImxheWVycyIsIm9wdCIsIm9sZEZpbHRlclJlY29yZCIsImZpbHRlclJlY29yZCIsImxlbmd0aCIsImNoYW5nZWRGaWx0ZXJzIiwic2hvdWxkQ2FsRG9tYWluIiwiZHluYW1pY0RvbWFpbiIsInNob3VsZENhbEluZGV4IiwiY3B1IiwiZmlsdGVyUmVzdWx0IiwiZHluYW1pY0RvbWFpbkZpbHRlcnMiLCJjcHVGaWx0ZXJzIiwiZmlsdGVyRnVuY3MiLCJyZWR1Y2UiLCJhY2MiLCJmaWx0ZXIiLCJmaWVsZEluZGV4IiwiY3B1T25seSIsImlnbm9yZURvbWFpbiIsImZpbHRlcmVkSWR4Q1BVIiwiZmlsdGVyUmVjb3JkQ1BVIiwiZ3B1IiwiY29waWVkIiwiY29weVRhYmxlIiwiZmlsdGVyZWQiLCJmaWx0ZXJUYWJsZSIsImRvbWFpbiIsIkFMTF9GSUVMRF9UWVBFUyIsInJlYWwiLCJpbnRlZ2VyIiwic3RyaW5nIiwiZGF0ZSIsInRpbWVzdGFtcCIsInNjYWxlVHlwZSIsIlNDQUxFX1RZUEVTIiwiQ29uc29sZSIsImVycm9yIiwiaW5kZXhWYWx1ZUFjY2Vzc29yIiwic29ydEZ1bmN0aW9uIiwib3JkaW5hbCIsInBvaW50IiwicXVhbnRpbGUiLCJsb2ciLCJxdWFudGl6ZSIsImxpbmVhciIsInNxcnQiLCJmaWVsZE5hbWUiLCJjb25kaXRpb24iLCJzcGVjaWFsQ2hhcmFjdGVyU2V0IiwiZm91bmRNYXRjaGluZ0ZpZWxkcyIsInJlIiwic3VmZml4UGFpciIsImFsbE5hbWVzIiwicGFydG5lcklkeCIsInJlcGxhY2UiLCJtYXRjaCIsImFsdElkeCIsIkFMVElUVURFX0ZJRUxEUyIsInNvbWUiLCJhbHQiLCJ0b0xvd2VyQ2FzZSIsImNhcnJ5IiwiaWR4IiwiVFJJUF9QT0lOVF9GSUVMRFMiLCJSZWdFeHAiLCJ0ZXN0IiwidHJpbU5hbWUiLCJ0cmltIiwicHVzaCIsImRlZmF1bHROYW1lIiwicGFpciIsImxhdCIsInZhbHVlIiwibG5nIiwic3VmZml4Iiwic29ydERhdGFzZXRCeUNvbHVtbiIsImRhdGFzZXQiLCJjb2x1bW4iLCJtb2RlIiwic29ydEJ5IiwiU09SVF9PUkRFUiIsIkFTQ0VORElORyIsIlVOU09SVCIsInNvcnRDb2x1bW4iLCJzb3J0T3JkZXIiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwic2xpY2UiLCJzb3J0IiwiYSIsImIiLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJwaW5UYWJsZUNvbHVtbnMiLCJwaW5uZWRDb2x1bW5zIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5jbHVkZXMiLCJjbyIsImNvbmNhdCIsImNvcHlUYWJsZUFuZFVwZGF0ZSIsIm9yaWdpbmFsIiwiY3JlYXRlIiwiZ2V0UHJvdG90eXBlT2YiLCJvcHRpb25zIiwiZW50cmllcyIsImVudHJ5IiwiYmluZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7O0FBQ0E7O0FBRUE7O0FBa0JBOztBQUdBOzs7Ozs7Ozs7Ozs7QUFpQ0E7QUFDQSxJQUFNQSxPQUFPLEdBQUcsTUFBaEI7O0FBRU8sU0FBU0MsV0FBVCxDQUNMQyxNQURLLEVBRUxDLFFBRkssRUFHTEMsTUFISyxFQUlMQyxFQUpLLEVBS0xDLENBTEssRUFNTDtBQUNBLE1BQUlKLE1BQUosRUFBWTtBQUNWLFdBQU8sNEJBQWdCRyxFQUFFLENBQUNFLE9BQUgsQ0FBV0QsQ0FBQyxDQUFDRSxLQUFiLEVBQW9CTCxRQUFwQixDQUFoQixFQUErQ0MsTUFBL0MsQ0FBUDtBQUNEOztBQUVELFNBQU9DLEVBQUUsQ0FBQ0UsT0FBSCxDQUFXRCxDQUFDLENBQUNFLEtBQWIsRUFBb0JMLFFBQXBCLENBQVA7QUFDRDs7SUFFS00sVztBQU9KO0FBZUE7QUFXQTtBQUdBLDZCQWNHO0FBQUEsUUFiREMsSUFhQyxRQWJEQSxJQWFDO0FBQUEsUUFaREMsSUFZQyxRQVpEQSxJQVlDO0FBQUEsUUFYREMsS0FXQyxRQVhEQSxLQVdDO0FBQUEsUUFWREMsUUFVQyxRQVZEQSxRQVVDO0FBQUEscUNBVERDLG9CQVNDO0FBQUEsUUFUREEsb0JBU0Msc0NBVHNCLElBU3RCO0FBQUEscUNBUkRDLG9CQVFDO0FBQUEs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Q0FBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVNELGtCQUFULENBQ0xDLFFBREssRUFHUTtBQUFBLE1BRGJHLE9BQ2EsdUVBRG1CLEVBQ25CO0FBQ2IsU0FBT25ILE1BQU0sQ0FBQ29ILE9BQVAsQ0FBZUQsT0FBZixFQUF3QjNGLE1BQXhCLENBQStCLFVBQUNDLEdBQUQsRUFBTTRGLEtBQU4sRUFBZ0I7QUFDcEQ1RixJQUFBQSxHQUFHLENBQUM0RixLQUFLLENBQUMsQ0FBRCxDQUFOLENBQUgsR0FBZ0JBLEtBQUssQ0FBQyxDQUFELENBQXJCO0FBQ0EsV0FBTzVGLEdBQVA7QUFDRCxHQUhNLEVBR0pTLFNBQVMsQ0FBQzhFLFFBQUQsQ0FITCxDQUFQO0FBSUQ7O0FBRU0sU0FBU3RJLHFCQUFULENBS0xMLENBTEssRUFLQ0MsQ0FMRCxFQUtZM0IsRUFMWixFQUt3QztBQUM3QyxTQUFPSixXQUFXLENBQUMrSyxJQUFaLENBQ0wsSUFESyxFQUVMO0FBQ0FqSixFQUFBQSxDQUFDLENBQUNILElBQUYsS0FBV29FLDJCQUFnQkssU0FIdEIsRUFJTHJFLENBSkssRUFLTEQsQ0FBQyxDQUFDM0IsTUFBRixJQUFZLEVBTFAsRUFNTEMsRUFOSyxDQUFQO0FBUUQ7O2VBRWNJLFciLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQge2NvbnNvbGUgYXMgQ29uc29sZX0gZnJvbSAnZ2xvYmFsL2NvbnNvbGUnO1xuaW1wb3J0IHthc2NlbmRpbmcsIGRlc2NlbmRpbmd9IGZyb20gJ2QzLWFycmF5JztcblxuaW1wb3J0IHtcbiAgVFJJUF9QT0lOVF9GSUVMRFMsXG4gIFNPUlRfT1JERVIsXG4gIEFMTF9GSUVMRF9UWVBFUyxcbiAgQUxUSVRVREVfRklFTERTLFxuICBTQ0FMRV9UWVBFU1xufSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBSR0JDb2xvcixcbiAgRmllbGQsXG4gIEZpZWxkUGFpcixcbiAgRmllbGREb21haW4sXG4gIEZpbHRlcixcbiAgUHJvdG9EYXRhc2V0LFxuICBGaWx0ZXJSZWNvcmQsXG4gIEZpbHRlckRhdGFzZXRPcHRcbn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5cbmltcG9ydCB7Z2V0R3B1RmlsdGVyUHJvcHMsIGdldERhdGFzZXRGaWVsZEluZGV4Rm9yRmlsdGVyfSBmcm9tICcuL2dwdS1maWx0ZXItdXRpbHMnO1xuXG5pbXBvcnQge0xheWVyfSBmcm9tICdAa2VwbGVyLmdsL2xheWVycyc7XG5pbXBvcnQge1xuICBnZW5lcmF0ZUhhc2hJZCxcbiAgZ2V0U29ydGluZ0Z1bmN0aW9uLFxuICB0aW1lVG9Vbml4TWlsbGksXG4gIGNyZWF0ZURhdGFDb250YWluZXIsXG4gIERhdGFGb3JtLFxuICBkaWZmRmlsdGVycyxcbiAgZmlsdGVyRGF0YUJ5RmlsdGVyVHlwZXMsXG4gIEZpbHRlclJlc3VsdCxcbiAgZ2V0RmlsdGVyRnVuY3Rpb24sXG4gIGdldEZpbHRlclByb3BzLFxuICBnZXRGaWx0ZXJSZWNvcmQsXG4gIGdldE51bWVyaWNGaWVsZERvbWFpbixcbiAgZ2V0VGltZXN0YW1wRmllbGREb21haW4sXG4gIGdldExpbmVhckRvbWFpbixcbiAgZ2V0TG9nRG9tYWluLFxuICBnZXRPcmRpbmFsRG9tYWluLFxuICBnZXRRdWFudGlsZURvbWFpbixcbiAgRGF0YUNvbnRhaW5lckludGVyZmFjZSxcbiAgbm90TnVsbG9yVW5kZWZpbmVkXG59IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBHcHVGaWx0ZXIgPSB7XG4gIGZpbHRlclJhbmdlOiBudW1iZXJbXVtdO1xuICBmaWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzOiBhbnk7XG4gIGZpbHRlclZhbHVlQWNjZXNzb3I6IChcbiAgICBkYzogRGF0YUNvbnRhaW5lckludGVyZmFjZVxuICApID0+IChcbiAgICBnZXRJbmRleD86IChhbnkpID0+IG51bWJlcixcbiAgICBnZXREYXRhPzogKGRjXzogRGF0YUNvbnRhaW5lckludGVyZmFjZSwgZDogYW55LCBmaWVsZEluZGV4OiBudW1iZXIpID0+IGFueVxuICApID0+IChkOiBhbnkpID0+IG51bWJlcltdO1xufTtcblxuLy8gVW5pcXVlIGlkZW50aWZpZXIgb2YgZWFjaCBmaWVsZFxuY29uc3QgRklEX0tFWSA9ICduYW1lJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlVG9EYXRlKFxuICBpc1RpbWU6IGJvb2xlYW4sXG4gIGZpZWxkSWR4OiBudW1iZXIsXG4gIGZvcm1hdDogc3RyaW5nLFxuICBkYzogRGF0YUNvbnRhaW5lckludGVyZmFjZSxcbiAgZDoge2luZGV4OiBudW1iZXJ9XG4pIHtcbiAgaWYgKGlzVGltZSkge1xuICAgIHJldHVybiB0aW1lVG9Vbml4TWlsbGkoZGMudmFsdWVBdChkLmluZGV4LCBmaWVsZElkeCksIGZvcm1hdCk7XG4gIH1cblxuICByZXR1cm4gZGMudmFsdWVBdChkLmluZGV4LCBmaWVsZElkeCk7XG59XG5cbmNsYXNzIEtlcGxlclRhYmxlIHtcbiAgcmVhZG9ubHkgaWQ6IHN0cmluZztcblxuICB0eXBlPzogc3RyaW5nO1xuICBsYWJlbDogc3RyaW5nO1xuICBjb2xvcjogUkdCQ29sb3I7XG5cbiAgLy8gZmllbGRzIGFuZCBkYXRhXG4gIGZpZWxkczogRmllbGRbXTtcblxuICBkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlO1xuXG4gIGFsbEluZGV4ZXM6IG51bWJlcltdO1xuICBmaWx0ZXJlZEluZGV4OiBudW1iZXJbXTtcbiAgZmlsdGVyZWRJZHhDUFU/OiBudW1iZXJbXTtcbiAgZmlsdGVyZWRJbmRleEZvckRvbWFpbjogbnVtYmVyW107XG4gIGZpZWxkUGFpcnM6IEZpZWxkUGFpcltdO1xuICBncHVGaWx0ZXI6IEdwdUZpbHRlcjtcbiAgZmlsdGVyUmVjb3JkPzogRmlsdGVyUmVjb3JkO1xuICBmaWx0ZXJSZWNvcmRDUFU/OiBGaWx0ZXJSZWNvcmQ7XG4gIGNoYW5nZWRGaWx0ZXJzPzogYW55O1xuXG4gIC8vIHRhYmxlLWluamVjdGVkIG1ldGFkYXRhXG4gIHNvcnRDb2x1bW4/OiB7XG4gICAgLy8gY29sdW1uIG5hbWU6IHNvcnRlZCBpZHhcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7IC8vIEFTQ0VORElORyB8IERFU0NFTkRJTkcgfCBVTlNPUlRcbiAgfTtcbiAgc29ydE9yZGVyPzogbnVtYmVyW10gfCBudWxsO1xuXG4gIHBpbm5lZENvbHVtbnM/OiBzdHJpbmdbXTtcbiAgc3VwcG9ydGVkRmlsdGVyVHlwZXM/OiBzdHJpbmdbXSB8IG51bGw7XG4gIGRpc2FibGVEYXRhT3BlcmF0aW9uPzogYm9vbGVhbjtcblxuICAvLyB0YWJsZS1pbmplY3RlZCBtZXRhZGF0YVxuICBtZXRhZGF0YTogb2JqZWN0O1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpbmZvLFxuICAgIGRhdGEsXG4gICAgY29sb3IsXG4gICAgbWV0YWRhdGEsXG4gICAgc3VwcG9ydGVkRmlsdGVyVHlwZXMgPSBudWxsLFxuICAgIGRpc2FibGVEYXRhT3BlcmF0aW9uID0gZmFsc2VcbiAgfToge1xuICAgIGluZm8/OiBQcm90b0RhdGFzZXRbJ2luZm8nXTtcbiAgICBkYXRhOiBQcm90b0RhdGFzZXRbJ2RhdGEnXTtcbiAgICBjb2xvcjogUkdCQ29sb3I7XG4gICAgbWV0YWRhdGE/OiBQcm90b0RhdGFzZXRbJ21ldGFkYXRhJ107XG4gICAgc3VwcG9ydGVkRmlsdGVyVHlwZXM/OiBQcm90b0RhdGFzZXRbJ3N1cHBvcnRlZEZpbHRlclR5cGVzJ107XG4gICAgZGlzYWJsZURhdGFPcGVyYXRpb24/OiBQcm90b0RhdGFzZXRbJ2Rpc2FibGVEYXRhT3BlcmF0aW9uJ107XG4gIH0pIHtcbiAgICAvLyBUT0RPIC0gd2hhdCB0byBkbyBpZiB2YWxpZGF0aW9uIGZhaWxzPyBDYW4ga2VwbGVyIGhhbmRsZSBleGNlcHRpb25zP1xuICAgIC8vIGNvbnN0IHZhbGlkYXRlZERhdGEgPSB2YWxpZGF0ZUlucHV0RGF0YShkYXRhKTtcbiAgICAvLyBpZiAoIXZhbGlkYXRlZERhdGEpIHtcbiAgICAvLyAgIHJldHVybiB0aGlzO1xuICAgIC8vIH1cblxuICAgIGNvbnN0IGRhdGFDb250YWluZXJEYXRhID0gZGF0YS5jb2xzID8gZGF0YS5jb2xzIDogZGF0YS5yb3dzO1xuICAgIGNvbnN0IGlucHV0RGF0YUZvcm1hdCA9IGRhdGEuY29scyA/IERhdGFGb3JtLkNPTFNfQVJSQVkgOiBEYXRhRm9ybS5ST1dTX0FSUkFZO1xuXG4gICAgY29uc3QgZGF0YUNvbnRhaW5lciA9IGNyZWF0ZURhdGFDb250YWluZXIoZGF0YUNvbnRhaW5lckRhdGEsIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgUHJvdG9EYXRhc2V0IGZpZWxkIG1pc3NpbmcgcHJvcGVydHkgZmllbGRJZHgsIHZhbHVlQWNjZXNzb3JcbiAgICAgIGZpZWxkczogZGF0YS5maWVsZHMsXG4gICAgICBpbnB1dERhdGFGb3JtYXRcbiAgICB9KTtcblxuICAgIGNvbnN0IGRhdGFzZXRJbmZvID0ge1xuICAgICAgaWQ6IGdlbmVyYXRlSGFzaElkKDQpLFxuICAgICAgbGFiZWw6ICduZXcgZGF0YXNldCcsXG4gICAgICB0eXBlOiAnJyxcbiAgICAgIC4uLmluZm9cbiAgICB9O1xuICAgIGNvbnN0IGRhdGFJZCA9IGRhdGFzZXRJbmZvLmlkO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBmaWVsZHM6IEZpZWxkW10gPSBkYXRhLmZpZWxkcy5tYXAoKGYsIGkpID0+ICh7XG4gICAgICAuLi5mLFxuICAgICAgZmllbGRJZHg6IGksXG4gICAgICBpZDogZi5uYW1lLFxuICAgICAgZGlzcGxheU5hbWU6IGYuZGlzcGxheU5hbWUgfHwgZi5uYW1lLFxuICAgICAgdmFsdWVBY2Nlc3NvcjogZ2V0RmllbGRWYWx1ZUFjY2Vzc29yKGYsIGksIGRhdGFDb250YWluZXIpXG4gICAgfSkpO1xuXG4gICAgY29uc3QgYWxsSW5kZXhlcyA9IGRhdGFDb250YWluZXIuZ2V0UGxhaW5JbmRleCgpO1xuICAgIGNvbnN0IGRlZmF1bHRNZXRhZGF0YSA9IHtcbiAgICAgIGlkOiBkYXRhc2V0SW5mby5pZCxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGZvcm1hdDogZGF0YXNldEluZm8uZm9ybWF0IHx8ICcnLFxuICAgICAgbGFiZWw6IGRhdGFzZXRJbmZvLmxhYmVsIHx8ICcnXG4gICAgfTtcblxuICAgIHRoaXMuaWQgPSBkYXRhc2V0SW5mby5pZDtcbiAgICB0aGlzLnR5cGUgPSBkYXRhc2V0SW5mby50eXBlO1xuICAgIHRoaXMubGFiZWwgPSBkYXRhc2V0SW5mby5sYWJlbDtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5tZXRhZGF0YSA9IHtcbiAgICAgIC4uLmRlZmF1bHRNZXRhZGF0YSxcbiAgICAgIC4uLm1ldGFkYXRhXG4gICAgfTtcblxuICAgIHRoaXMuZGF0YUNvbnRhaW5lciA9IGRhdGFDb250YWluZXI7XG4gICAgdGhpcy5hbGxJbmRleGVzID0gYWxsSW5kZXhlcztcbiAgICB0aGlzLmZpbHRlcmVkSW5kZXggPSBhbGxJbmRleGVzO1xuICAgIHRoaXMuZmlsdGVyZWRJbmRleEZvckRvbWFpbiA9IGFsbEluZGV4ZXM7XG4gICAgdGhpcy5maWVsZFBhaXJzID0gZmluZFBvaW50RmllbGRQYWlycyhmaWVsZHMpO1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgIHRoaXMuZ3B1RmlsdGVyID0gZ2V0R3B1RmlsdGVyUHJvcHMoW10sIGRhdGFJZCwgZmllbGRzKTtcbiAgICB0aGlzLnN1cHBvcnRlZEZpbHRlclR5cGVzID0gc3VwcG9ydGVkRmlsdGVyVHlwZXM7XG4gICAgdGhpcy5kaXNhYmxlRGF0YU9wZXJhdGlvbiA9IGRpc2FibGVEYXRhT3BlcmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZSB0YWJsZSB3aXRoIG5ldyBkYXRhXG4gICAqIEBwYXJhbSBkYXRhIC0gbmV3IGRhdGEgZS5nLiB0aGUgYXJyb3cgZGF0YSB3aXRoIG5ldyBiYXRjaGVzIGxvYWRlZFxuICAgKi9cbiAgdXBkYXRlKGRhdGE6IFByb3RvRGF0YXNldFsnZGF0YSddKSB7XG4gICAgY29uc3QgZGF0YUNvbnRhaW5lckRhdGEgPSBkYXRhLmNvbHMgPyBkYXRhLmNvbHMgOiBkYXRhLnJvd3M7XG4gICAgdGhpcy5kYXRhQ29udGFpbmVyLnVwZGF0ZT8uKGRhdGFDb250YWluZXJEYXRhKTtcbiAgICB0aGlzLmFsbEluZGV4ZXMgPSB0aGlzLmRhdGFDb250YWluZXIuZ2V0UGxhaW5JbmRleCgpO1xuICAgIHRoaXMuZmlsdGVyZWRJbmRleCA9IHRoaXMuYWxsSW5kZXhlcztcbiAgICB0aGlzLmZpbHRlcmVkSW5kZXhGb3JEb21haW4gPSB0aGlzLmFsbEluZGV4ZXM7XG4gIH1cblxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFDb250YWluZXIubnVtUm93cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmaWVsZFxuICAgKiBAcGFyYW0gY29sdW1uTmFtZVxuICAgKi9cbiAgZ2V0Q29sdW1uRmllbGQoY29sdW1uTmFtZTogc3RyaW5nKTogRmllbGQgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZHMuZmluZChmZCA9PiBmZFtGSURfS0VZXSA9PT0gY29sdW1uTmFtZSk7XG4gICAgdGhpcy5fYXNzZXRGaWVsZChjb2x1bW5OYW1lLCBmaWVsZCk7XG4gICAgcmV0dXJuIGZpZWxkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmaWVsZElkeFxuICAgKiBAcGFyYW0gY29sdW1uTmFtZVxuICAgKi9cbiAgZ2V0Q29sdW1uRmllbGRJZHgoY29sdW1uTmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBmaWVsZElkeCA9IHRoaXMuZmllbGRzLmZpbmRJbmRleChmZCA9PiBmZFtGSURfS0VZXSA9PT0gY29sdW1uTmFtZSk7XG4gICAgdGhpcy5fYXNzZXRGaWVsZChjb2x1bW5OYW1lLCBCb29sZWFuKGZpZWxkSWR4ID4gLTEpKTtcbiAgICByZXR1cm4gZmllbGRJZHg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRpc3BsYXlGb3JtYXRcbiAgICogQHBhcmFtIGNvbHVtbk5hbWVcbiAgICovXG4gIGdldENvbHVtbkRpc3BsYXlGb3JtYXQoY29sdW1uTmFtZSkge1xuICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZHMuZmluZChmZCA9PiBmZFtGSURfS0VZXSA9PT0gY29sdW1uTmFtZSk7XG4gICAgdGhpcy5fYXNzZXRGaWVsZChjb2x1bW5OYW1lLCBmaWVsZCk7XG4gICAgcmV0dXJuIGZpZWxkPy5kaXNwbGF5Rm9ybWF0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgYSBjZWxsXG4gICAqL1xuICBnZXRWYWx1ZShjb2x1bW5OYW1lOiBzdHJpbmcsIHJvd0lkeDogbnVtYmVyKTogYW55IHtcbiAgICBjb25zdCBmaWVsZCA9IHRoaXMuZ2V0Q29sdW1uRmllbGQoY29sdW1uTmFtZSk7XG4gICAgcmV0dXJuIGZpZWxkID8gZmllbGQudmFsdWVBY2Nlc3Nvcih7aW5kZXg6IHJvd0lkeH0pIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGV4aXN0aW5nIGZpZWxkIHdpdGggYSBuZXcgb2JqZWN0XG4gICAqIEBwYXJhbSBmaWVsZElkeFxuICAgKiBAcGFyYW0gbmV3RmllbGRcbiAgICovXG4gIHVwZGF0ZUNvbHVtbkZpZWxkKGZpZWxkSWR4OiBudW1iZXIsIG5ld0ZpZWxkOiBGaWVsZCk6IHZvaWQge1xuICAgIHRoaXMuZmllbGRzID0gT2JqZWN0LmFzc2lnbihbLi4udGhpcy5maWVsZHNdLCB7W2ZpZWxkSWR4XTogbmV3RmllbGR9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZGF0YXNldCBjb2xvciBieSBjdXN0b20gY29sb3JcbiAgICogQHBhcmFtIG5ld0NvbG9yXG4gICAqL1xuICB1cGRhdGVUYWJsZUNvbG9yKG5ld0NvbG9yOiBSR0JDb2xvcik6IHZvaWQge1xuICAgIHRoaXMuY29sb3IgPSBuZXdDb2xvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlIGZpbHRlclByb3BzIHRvIGZpZWxkIGFuZCByZXRyaWV2ZSBpdFxuICAgKiBAcGFyYW0gY29sdW1uTmFtZVxuICAgKi9cbiAgZ2V0Q29sdW1uRmlsdGVyUHJvcHMoY29sdW1uTmFtZTogc3RyaW5nKTogRmllbGRbJ2ZpbHRlclByb3BzJ10gfCBudWxsIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBmaWVsZElkeCA9IHRoaXMuZ2V0Q29sdW1uRmllbGRJZHgoY29sdW1uTmFtZSk7XG4gICAgaWYgKGZpZWxkSWR4IDwgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZHNbZmllbGRJZHhdO1xuICAgIGlmIChmaWVsZC5oYXNPd25Qcm9wZXJ0eSgnZmlsdGVyUHJvcHMnKSkge1xuICAgICAgcmV0dXJuIGZpZWxkLmZpbHRlclByb3BzO1xuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkRG9tYWluID0gdGhpcy5nZXRDb2x1bW5GaWx0ZXJEb21haW4oZmllbGQpO1xuICAgIGlmICghZmllbGREb21haW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbHRlclByb3BzID0gZ2V0RmlsdGVyUHJvcHMoZmllbGQsIGZpZWxkRG9tYWluKTtcbiAgICBjb25zdCBuZXdGaWVsZCA9IHtcbiAgICAgIC4uLmZpZWxkLFxuICAgICAgZmlsdGVyUHJvcHNcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVDb2x1bW5GaWVsZChmaWVsZElkeCwgbmV3RmllbGQpO1xuXG4gICAgcmV0dXJuIGZpbHRlclByb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGZpbHRlcnMgdG8gZGF0YXNldCwgcmV0dXJuIHRoZSBmaWx0ZXJlZCBkYXRhc2V0IHdpdGggdXBkYXRlZCBgZ3B1RmlsdGVyYCwgYGZpbHRlclJlY29yZGAsIGBmaWx0ZXJlZEluZGV4YCwgYGZpbHRlcmVkSW5kZXhGb3JEb21haW5gXG4gICAqIEBwYXJhbSBmaWx0ZXJzXG4gICAqIEBwYXJhbSBsYXllcnNcbiAgICogQHBhcmFtIG9wdFxuICAgKi9cbiAgZmlsdGVyVGFibGUoZmlsdGVyczogRmlsdGVyW10sIGxheWVyczogTGF5ZXJbXSwgb3B0PzogRmlsdGVyRGF0YXNldE9wdCk6IEtlcGxlclRhYmxlIHtcbiAgICBjb25zdCB7ZGF0YUNvbnRhaW5lciwgaWQ6IGRhdGFJZCwgZmlsdGVyUmVjb3JkOiBvbGRGaWx0ZXJSZWNvcmQsIGZpZWxkc30gPSB0aGlzO1xuXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gZmlsdGVyc1xuICAgIGNvbnN0IGZpbHRlclJlY29yZCA9IGdldEZpbHRlclJlY29yZChkYXRhSWQsIGZpbHRlcnMsIG9wdCB8fCB7fSk7XG5cbiAgICB0aGlzLmZpbHRlclJlY29yZCA9IGZpbHRlclJlY29yZDtcbiAgICB0aGlzLmdwdUZpbHRlciA9IGdldEdwdUZpbHRlclByb3BzKGZpbHRlcnMsIGRhdGFJZCwgZmllbGRzKTtcblxuICAgIC8vIGNvbnN0IG5ld0RhdGFzZXQgPSBzZXQoWydmaWx0ZXJSZWNvcmQnXSwgZmlsdGVyUmVjb3JkLCBkYXRhc2V0KTtcblxuICAgIGlmICghZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZmlsdGVyZWRJbmRleCA9IHRoaXMuYWxsSW5kZXhlcztcbiAgICAgIHRoaXMuZmlsdGVyZWRJbmRleEZvckRvbWFpbiA9IHRoaXMuYWxsSW5kZXhlcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlZEZpbHRlcnMgPSBkaWZmRmlsdGVycyhmaWx0ZXJSZWNvcmQsIG9sZEZpbHRlclJlY29yZCk7XG5cbiAgICAvLyBnZW5lcmF0ZSAyIHNldHMgb2YgZmlsdGVyIHJlc3VsdFxuICAgIC8vIGZpbHRlcmVkSW5kZXggdXNlZCB0byBjYWxjdWxhdGUgbGF5ZXIgZGF0YVxuICAgIC8vIGZpbHRlcmVkSW5kZXhGb3JEb21haW4gdXNlZCB0byBjYWxjdWxhdGUgbGF5ZXIgRG9tYWluXG4gICAgY29uc3Qgc2hvdWxkQ2FsRG9tYWluID0gQm9vbGVhbih0aGlzLmNoYW5nZWRGaWx0ZXJzLmR5bmFtaWNEb21haW4pO1xuICAgIGNvbnN0IHNob3VsZENhbEluZGV4ID0gQm9vbGVhbih0aGlzLmNoYW5nZWRGaWx0ZXJzLmNwdSk7XG5cbiAgICBsZXQgZmlsdGVyUmVzdWx0OiBGaWx0ZXJSZXN1bHQgPSB7fTtcbiAgICBpZiAoc2hvdWxkQ2FsRG9tYWluIHx8IHNob3VsZENhbEluZGV4KSB7XG4gICAgICBjb25zdCBkeW5hbWljRG9tYWluRmlsdGVycyA9IHNob3VsZENhbERvbWFpbiA/IGZpbHRlclJlY29yZC5keW5hbWljRG9tYWluIDogbnVsbDtcbiAgICAgIGNvbnN0IGNwdUZpbHRlcnMgPSBzaG91bGRDYWxJbmRleCA/IGZpbHRlclJlY29yZC5jcHUgOiBudWxsO1xuXG4gICAgICBjb25zdCBmaWx0ZXJGdW5jcyA9IGZpbHRlcnMucmVkdWNlKChhY2MsIGZpbHRlcikgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZEluZGV4ID0gZ2V0RGF0YXNldEZpZWxkSW5kZXhGb3JGaWx0ZXIodGhpcy5pZCwgZmlsdGVyKTtcbiAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZEluZGV4ICE9PSAtMSA/IGZpZWxkc1tmaWVsZEluZGV4XSA6IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgW2ZpbHRlci5pZF06IGdldEZpbHRlckZ1bmN0aW9uKGZpZWxkLCB0aGlzLmlkLCBmaWx0ZXIsIGxheWVycywgZGF0YUNvbnRhaW5lcilcbiAgICAgICAgfTtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgZmlsdGVyUmVzdWx0ID0gZmlsdGVyRGF0YUJ5RmlsdGVyVHlwZXMoXG4gICAgICAgIHtkeW5hbWljRG9tYWluRmlsdGVycywgY3B1RmlsdGVycywgZmlsdGVyRnVuY3N9LFxuICAgICAgICBkYXRhQ29udGFpbmVyXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuZmlsdGVyZWRJbmRleCA9IGZpbHRlclJlc3VsdC5maWx0ZXJlZEluZGV4IHx8IHRoaXMuZmlsdGVyZWRJbmRleDtcbiAgICB0aGlzLmZpbHRlcmVkSW5kZXhGb3JEb21haW4gPVxuICAgICAgZmlsdGVyUmVzdWx0LmZpbHRlcmVkSW5kZXhGb3JEb21haW4gfHwgdGhpcy5maWx0ZXJlZEluZGV4Rm9yRG9tYWluO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgZmlsdGVycyB0byBhIGRhdGFzZXQgYWxsIG9uIENQVSwgYXNzaWduIHRvIGBmaWx0ZXJlZElkeENQVWAsIGBmaWx0ZXJSZWNvcmRDUFVgXG4gICAqIEBwYXJhbSBmaWx0ZXJzXG4gICAqIEBwYXJhbSBsYXllcnNcbiAgICovXG4gIGZpbHRlclRhYmxlQ1BVKGZpbHRlcnM6IEZpbHRlcltdLCBsYXllcnM6IExheWVyW10pOiBLZXBsZXJUYWJsZSB7XG4gICAgY29uc3Qgb3B0ID0ge1xuICAgICAgY3B1T25seTogdHJ1ZSxcbiAgICAgIGlnbm9yZURvbWFpbjogdHJ1ZVxuICAgIH07XG5cbiAgICAvLyBubyBmaWx0ZXJcbiAgICBpZiAoIWZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmZpbHRlcmVkSWR4Q1BVID0gdGhpcy5hbGxJbmRleGVzO1xuICAgICAgdGhpcy5maWx0ZXJSZWNvcmRDUFUgPSBnZXRGaWx0ZXJSZWNvcmQodGhpcy5pZCwgZmlsdGVycywgb3B0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIG5vIGdwdSBmaWx0ZXJcbiAgICBpZiAoIWZpbHRlcnMuZmluZChmID0+IGYuZ3B1KSkge1xuICAgICAgdGhpcy5maWx0ZXJlZElkeENQVSA9IHRoaXMuZmlsdGVyZWRJbmRleDtcbiAgICAgIHRoaXMuZmlsdGVyUmVjb3JkQ1BVID0gZ2V0RmlsdGVyUmVjb3JkKHRoaXMuaWQsIGZpbHRlcnMsIG9wdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBtYWtlIGEgY29weSBmb3IgY3B1IGZpbHRlcmluZ1xuICAgIGNvbnN0IGNvcGllZCA9IGNvcHlUYWJsZSh0aGlzKTtcblxuICAgIGNvcGllZC5maWx0ZXJSZWNvcmQgPSB0aGlzLmZpbHRlclJlY29yZENQVTtcbiAgICBjb3BpZWQuZmlsdGVyZWRJbmRleCA9IHRoaXMuZmlsdGVyZWRJZHhDUFUgfHwgW107XG5cbiAgICBjb25zdCBmaWx0ZXJlZCA9IGNvcGllZC5maWx0ZXJUYWJsZShmaWx0ZXJzLCBsYXllcnMsIG9wdCk7XG5cbiAgICB0aGlzLmZpbHRlcmVkSWR4Q1BVID0gZmlsdGVyZWQuZmlsdGVyZWRJbmRleDtcbiAgICB0aGlzLmZpbHRlclJlY29yZENQVSA9IGZpbHRlcmVkLmZpbHRlclJlY29yZDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBmaWVsZCBkb21haW4gYmFzZWQgb24gZmllbGQgdHlwZSBhbmQgZGF0YVxuICAgKiBmb3IgRmlsdGVyXG4gICAqL1xuICBnZXRDb2x1bW5GaWx0ZXJEb21haW4oZmllbGQ6IEZpZWxkKTogRmllbGREb21haW4ge1xuICAgIGNvbnN0IHtkYXRhQ29udGFpbmVyfSA9IHRoaXM7XG4gICAgY29uc3Qge3ZhbHVlQWNjZXNzb3J9ID0gZmllbGQ7XG5cbiAgICBsZXQgZG9tYWluO1xuXG4gICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5yZWFsOlxuICAgICAgY2FzZSBBTExfRklFTERfVFlQRVMuaW50ZWdlcjpcbiAgICAgICAgLy8gY2FsY3VsYXRlIGRvbWFpbiBhbmQgc3RlcFxuICAgICAgICByZXR1cm4gZ2V0TnVtZXJpY0ZpZWxkRG9tYWluKGRhdGFDb250YWluZXIsIHZhbHVlQWNjZXNzb3IpO1xuXG4gICAgICBjYXNlIEFMTF9GSUVMRF9UWVBFUy5ib29sZWFuOlxuICAgICAgICByZXR1cm4ge2RvbWFpbjogW3RydWUsIGZhbHNlXX07XG5cbiAgICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLnN0cmluZzpcbiAgICAgIGNhc2UgQUxMX0ZJRUxEX1RZUEVTLmRhdGU6XG4gICAgICAgIGRvbWFpbiA9IGdldE9yZGluYWxEb21haW4oZGF0YUNvbnRhaW5lciwgdmFsdWVBY2Nlc3Nvcik7XG4gICAgICAgIHJldHVybiB7ZG9tYWlufTtcblxuICAgICAgY2FzZSBBTExfRklFTERfVFlQRVMudGltZXN0YW1wOlxuICAgICAgICByZXR1cm4gZ2V0VGltZXN0YW1wRmllbGREb21haW4oZGF0YUNvbnRhaW5lciwgdmFsdWVBY2Nlc3Nvcik7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7ZG9tYWluOiBnZXRPcmRpbmFsRG9tYWluKGRhdGFDb250YWluZXIsIHZhbHVlQWNjZXNzb3IpfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogIEdldCB0aGUgZG9tYWluIG9mIHRoaXMgY29sdW1uIGJhc2VkIG9uIHNjYWxlIHR5cGVcbiAgICovXG4gIGdldENvbHVtbkxheWVyRG9tYWluKFxuICAgIGZpZWxkOiBGaWVsZCxcbiAgICBzY2FsZVR5cGU6IHN0cmluZ1xuICApOiBudW1iZXJbXSB8IHN0cmluZ1tdIHwgW251bWJlciwgbnVtYmVyXSB8IG51bGwge1xuICAgIGNvbnN0IHtkYXRhQ29udGFpbmVyLCBmaWx0ZXJlZEluZGV4Rm9yRG9tYWlufSA9IHRoaXM7XG5cbiAgICBpZiAoIVNDQUxFX1RZUEVTW3NjYWxlVHlwZV0pIHtcbiAgICAgIENvbnNvbGUuZXJyb3IoYHNjYWxlIHR5cGUgJHtzY2FsZVR5cGV9IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHt2YWx1ZUFjY2Vzc29yfSA9IGZpZWxkO1xuICAgIGNvbnN0IGluZGV4VmFsdWVBY2Nlc3NvciA9IGkgPT4gdmFsdWVBY2Nlc3Nvcih7aW5kZXg6IGl9KTtcbiAgICBjb25zdCBzb3J0RnVuY3Rpb24gPSBnZXRTb3J0aW5nRnVuY3Rpb24oZmllbGQudHlwZSk7XG5cbiAgICBzd2l0Y2ggKHNjYWxlVHlwZSkge1xuICAgICAgY2FzZSBTQ0FMRV9UWVBFUy5vcmRpbmFsOlxuICAgICAgY2FzZSBTQ0FMRV9UWVBFUy5wb2ludDpcbiAgICAgICAgLy8gZG8gbm90IHJlY2FsY3VsYXRlIG9yZGluYWwgZG9tYWluIGJhc2VkIG9uIGZpbHRlcmVkIGRhdGFcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byB1cGRhdGUgb3JkaW5hbCBkb21haW4gZXZlcnkgdGltZVxuICAgICAgICByZXR1cm4gZ2V0T3JkaW5hbERvbWFpbihkYXRhQ29udGFpbmVyLCB2YWx1ZUFjY2Vzc29yKTtcblxuICAgICAgY2FzZSBTQ0FMRV9UWVBFUy5xdWFudGlsZTpcbiAgICAgICAgcmV0dXJuIGdldFF1YW50aWxlRG9tYWluKGZpbHRlcmVkSW5kZXhGb3JEb21haW4sIGluZGV4VmFsdWVBY2Nlc3Nvciwgc29ydEZ1bmN0aW9uKTtcblxuICAgICAgY2FzZSBTQ0FMRV9UWVBFUy5sb2c6XG4gICAgICAgIHJldHVybiBnZXRMb2dEb21haW4oZmlsdGVyZWRJbmRleEZvckRvbWFpbiwgaW5kZXhWYWx1ZUFjY2Vzc29yKTtcblxuICAgICAgY2FzZSBTQ0FMRV9UWVBFUy5xdWFudGl6ZTpcbiAgICAgIGNhc2UgU0NBTEVfVFlQRVMubGluZWFyOlxuICAgICAgY2FzZSBTQ0FMRV9UWVBFUy5zcXJ0OlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGdldExpbmVhckRvbWFpbihmaWx0ZXJlZEluZGV4Rm9yRG9tYWluLCBpbmRleFZhbHVlQWNjZXNzb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzYW1wbGUgb2Ygcm93cyB0byBjYWxjdWxhdGUgbGF5ZXIgYm91bmRhcmllc1xuICAgKi9cbiAgLy8gZ2V0U2FtcGxlRGF0YShyb3dzKVxuXG4gIC8qKlxuICAgKiBQYXJzZSBjZWxsIHZhbHVlIGJhc2VkIG9uIGNvbHVtbiB0eXBlIGFuZCByZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICogVmFsdWUgdGhlIGZpZWxkIHZhbHVlLCB0eXBlIHRoZSBmaWVsZCB0eXBlXG4gICAqL1xuICAvLyBwYXJzZUZpZWxkVmFsdWUodmFsdWUsIHR5cGUpXG5cbiAgLy8gc29ydERhdGFzZXRCeUNvbHVtbigpXG5cbiAgLyoqXG4gICAqIEFzc2VydCB3aGV0aGVyIGZpZWxkIGV4aXN0XG4gICAqIEBwYXJhbSBmaWVsZE5hbWVcbiAgICogQHBhcmFtIGNvbmRpdGlvblxuICAgKi9cbiAgX2Fzc2V0RmllbGQoZmllbGROYW1lOiBzdHJpbmcsIGNvbmRpdGlvbjogYW55KTogdm9pZCB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIENvbnNvbGUuZXJyb3IoYCR7ZmllbGROYW1lfSBkb2VzbnQgZXhpc3QgaW4gZGF0YXNldCAke3RoaXMuaWR9YCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIERhdGFzZXRzID0ge1xuICBba2V5OiBzdHJpbmddOiBLZXBsZXJUYWJsZTtcbn07XG5cbi8vIEhFTFBFUiBGVU5DVElPTlMgKE1BSU5MWSBFWFBPUlRFRCBGT1IgVEVTVC4uLilcbi8vIGhhdmUgdG8gZG91YmxlIGV4Y2FwZVxuY29uc3Qgc3BlY2lhbENoYXJhY3RlclNldCA9IGBbI18mQFxcXFwuXFxcXC1cXFxcIF1gO1xuXG5mdW5jdGlvbiBmb3VuZE1hdGNoaW5nRmllbGRzKHJlLCBzdWZmaXhQYWlyLCBhbGxOYW1lcywgZmllbGROYW1lKSB7XG4gIGNvbnN0IHBhcnRuZXJJZHggPSBhbGxOYW1lcy5maW5kSW5kZXgoXG4gICAgZCA9PiBkID09PSBmaWVsZE5hbWUucmVwbGFjZShyZSwgbWF0Y2ggPT4gbWF0Y2gucmVwbGFjZShzdWZmaXhQYWlyWzBdLCBzdWZmaXhQYWlyWzFdKSlcbiAgKTtcbiAgbGV0IGFsdElkeCA9IC0xO1xuICBpZiAocGFydG5lcklkeCA+IC0xKSB7XG4gICAgLy8gaWYgZm91bmQgcGFydG5lciwgZ28gb24gYW5kIGxvb2sgZm9yIGFsdGl0dWRlXG4gICAgQUxUSVRVREVfRklFTERTLnNvbWUoYWx0ID0+IHtcbiAgICAgIGFsdElkeCA9IGFsbE5hbWVzLmZpbmRJbmRleChcbiAgICAgICAgZCA9PiBkID09PSBmaWVsZE5hbWUucmVwbGFjZShyZSwgbWF0Y2ggPT4gbWF0Y2gucmVwbGFjZShzdWZmaXhQYWlyWzBdLCBhbHQpKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBhbHRJZHggPiAtMTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge3BhcnRuZXJJZHgsIGFsdElkeH07XG59XG4vKipcbiAqIEZpbmQgcG9pbnQgZmllbGRzIHBhaXJzIGZyb20gZmllbGRzXG4gKlxuICogQHBhcmFtIGZpZWxkc1xuICogQHJldHVybnMgZm91bmQgcG9pbnQgZmllbGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUG9pbnRGaWVsZFBhaXJzKGZpZWxkczogRmllbGRbXSk6IEZpZWxkUGFpcltdIHtcbiAgY29uc3QgYWxsTmFtZXMgPSBmaWVsZHMubWFwKGYgPT4gZi5uYW1lLnRvTG93ZXJDYXNlKCkpO1xuXG4gIC8vIGdldCBsaXN0IG9mIGFsbCBmaWVsZHMgd2l0aCBtYXRjaGluZyBzdWZmaXhlc1xuICBjb25zdCBhY2M6IEZpZWxkUGFpcltdID0gW107XG4gIHJldHVybiBhbGxOYW1lcy5yZWR1Y2UoKGNhcnJ5LCBmaWVsZE5hbWUsIGlkeCkgPT4ge1xuICAgIC8vIFRoaXMgc2VhcmNoIGZvciBwYWlycyB3aWxsIGVhcmx5IGV4aXQgaWYgZm91bmQuXG4gICAgZm9yIChjb25zdCBzdWZmaXhQYWlyIG9mIFRSSVBfUE9JTlRfRklFTERTKSB7XG4gICAgICAvLyBtYXRjaCBmaXJzdCBzdWZmaXhcbiAgICAgIC8vIChefFsjXyZAXFwuXFwtXFwgXSlsYXQoWyNfJkBcXC5cXC1cXCBdfCQpXG4gICAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAoYChefCR7c3BlY2lhbENoYXJhY3RlclNldH0pJHtzdWZmaXhQYWlyWzBdfSgke3NwZWNpYWxDaGFyYWN0ZXJTZXR9fCQpYCk7XG5cbiAgICAgIGlmIChyZS50ZXN0KGZpZWxkTmFtZSkpIHtcbiAgICAgICAgY29uc3Qge3BhcnRuZXJJZHgsIGFsdElkeH0gPSBmb3VuZE1hdGNoaW5nRmllbGRzKHJlLCBzdWZmaXhQYWlyLCBhbGxOYW1lcywgZmllbGROYW1lKTtcblxuICAgICAgICBpZiAocGFydG5lcklkeCA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgdHJpbU5hbWUgPSBmaWVsZE5hbWUucmVwbGFjZShyZSwgJycpLnRyaW0oKTtcblxuICAgICAgICAgIGNhcnJ5LnB1c2goe1xuICAgICAgICAgICAgZGVmYXVsdE5hbWU6IHRyaW1OYW1lIHx8ICdwb2ludCcsXG4gICAgICAgICAgICBwYWlyOiB7XG4gICAgICAgICAgICAgIGxhdDoge1xuICAgICAgICAgICAgICAgIGZpZWxkSWR4OiBpZHgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZpZWxkc1tpZHhdLm5hbWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbG5nOiB7XG4gICAgICAgICAgICAgICAgZmllbGRJZHg6IHBhcnRuZXJJZHgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZpZWxkc1twYXJ0bmVySWR4XS5uYW1lXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIC4uLihhbHRJZHggPiAtMVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBhbHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBmaWVsZElkeDogYWx0SWR4LFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmaWVsZHNbYWx0SWR4XS5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1ZmZpeDogc3VmZml4UGFpclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBjYXJyeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2Fycnk7XG4gIH0sIGFjYyk7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkYXRhc2V0XG4gKiBAcGFyYW0gY29sdW1uXG4gKiBAcGFyYW0gbW9kZVxuICogQHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvcnREYXRhc2V0QnlDb2x1bW4oXG4gIGRhdGFzZXQ6IEtlcGxlclRhYmxlLFxuICBjb2x1bW46IHN0cmluZyxcbiAgbW9kZT86IHN0cmluZ1xuKTogS2VwbGVyVGFibGUge1xuICBjb25zdCB7YWxsSW5kZXhlcywgZmllbGRzLCBkYXRhQ29udGFpbmVyfSA9IGRhdGFzZXQ7XG4gIGNvbnN0IGZpZWxkSW5kZXggPSBmaWVsZHMuZmluZEluZGV4KGYgPT4gZi5uYW1lID09PSBjb2x1bW4pO1xuICBpZiAoZmllbGRJbmRleCA8IDApIHtcbiAgICByZXR1cm4gZGF0YXNldDtcbiAgfVxuXG4gIGNvbnN0IHNvcnRCeSA9IFNPUlRfT1JERVJbbW9kZSB8fCAnJ10gfHwgU09SVF9PUkRFUi5BU0NFTkRJTkc7XG5cbiAgaWYgKHNvcnRCeSA9PT0gU09SVF9PUkRFUi5VTlNPUlQpIHtcbiAgICBkYXRhc2V0LnNvcnRDb2x1bW4gPSB7fTtcbiAgICBkYXRhc2V0LnNvcnRPcmRlciA9IG51bGw7XG5cbiAgICByZXR1cm4gZGF0YXNldDtcbiAgfVxuXG4gIGNvbnN0IHNvcnRGdW5jdGlvbiA9IHNvcnRCeSA9PT0gU09SVF9PUkRFUi5BU0NFTkRJTkcgPyBhc2NlbmRpbmcgOiBkZXNjZW5kaW5nO1xuICBjb25zdCBzb3J0T3JkZXIgPSBhbGxJbmRleGVzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHZhbHVlMSA9IGRhdGFDb250YWluZXIudmFsdWVBdChhLCBmaWVsZEluZGV4KTtcbiAgICBjb25zdCB2YWx1ZTIgPSBkYXRhQ29udGFpbmVyLnZhbHVlQXQoYiwgZmllbGRJbmRleCk7XG4gICAgaWYgKCFub3ROdWxsb3JVbmRlZmluZWQodmFsdWUxKSAmJiBub3ROdWxsb3JVbmRlZmluZWQodmFsdWUyKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChub3ROdWxsb3JVbmRlZmluZWQodmFsdWUxKSAmJiAhbm90TnVsbG9yVW5kZWZpbmVkKHZhbHVlMikpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHNvcnRGdW5jdGlvbih2YWx1ZTEsIHZhbHVlMik7XG4gIH0pO1xuXG4gIGRhdGFzZXQuc29ydENvbHVtbiA9IHtcbiAgICBbY29sdW1uXTogc29ydEJ5XG4gIH07XG4gIGRhdGFzZXQuc29ydE9yZGVyID0gc29ydE9yZGVyO1xuXG4gIHJldHVybiBkYXRhc2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGluVGFibGVDb2x1bW5zKGRhdGFzZXQ6IEtlcGxlclRhYmxlLCBjb2x1bW46IHN0cmluZyk6IEtlcGxlclRhYmxlIHtcbiAgY29uc3QgZmllbGQgPSBkYXRhc2V0LmdldENvbHVtbkZpZWxkKGNvbHVtbik7XG4gIGlmICghZmllbGQpIHtcbiAgICByZXR1cm4gZGF0YXNldDtcbiAgfVxuXG4gIGxldCBwaW5uZWRDb2x1bW5zO1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhc2V0LnBpbm5lZENvbHVtbnMpICYmIGRhdGFzZXQucGlubmVkQ29sdW1ucy5pbmNsdWRlcyhmaWVsZC5uYW1lKSkge1xuICAgIC8vIHVucGluIGl0XG4gICAgcGlubmVkQ29sdW1ucyA9IGRhdGFzZXQucGlubmVkQ29sdW1ucy5maWx0ZXIoY28gPT4gY28gIT09IGZpZWxkLm5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHBpbm5lZENvbHVtbnMgPSAoZGF0YXNldC5waW5uZWRDb2x1bW5zIHx8IFtdKS5jb25jYXQoZmllbGQubmFtZSk7XG4gIH1cblxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBjb3B5VGFibGVBbmRVcGRhdGUoZGF0YXNldCwge3Bpbm5lZENvbHVtbnN9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlUYWJsZShvcmlnaW5hbDogS2VwbGVyVGFibGUpOiBLZXBsZXJUYWJsZSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSksIG9yaWdpbmFsKTtcbn1cblxuLyoqXG4gKiBAdHlwZVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlUYWJsZUFuZFVwZGF0ZShcbiAgb3JpZ2luYWw6IEtlcGxlclRhYmxlLFxuICBvcHRpb25zOiBQYXJ0aWFsPEtlcGxlclRhYmxlPiA9IHt9XG4pOiBLZXBsZXJUYWJsZSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvcHRpb25zKS5yZWR1Y2UoKGFjYywgZW50cnkpID0+IHtcbiAgICBhY2NbZW50cnlbMF1dID0gZW50cnlbMV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgY29weVRhYmxlKG9yaWdpbmFsKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZFZhbHVlQWNjZXNzb3I8XG4gIEYgZXh0ZW5kcyB7XG4gICAgdHlwZT86IEZpZWxkWyd0eXBlJ107XG4gICAgZm9ybWF0PzogRmllbGRbJ2Zvcm1hdCddO1xuICB9XG4+KGY6IEYsIGk6IG51bWJlciwgZGM6IERhdGFDb250YWluZXJJbnRlcmZhY2UpIHtcbiAgcmV0dXJuIG1heWJlVG9EYXRlLmJpbmQoXG4gICAgbnVsbCxcbiAgICAvLyBpcyB0aW1lXG4gICAgZi50eXBlID09PSBBTExfRklFTERfVFlQRVMudGltZXN0YW1wLFxuICAgIGksXG4gICAgZi5mb3JtYXQgfHwgJycsXG4gICAgZGNcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgS2VwbGVyVGFibGU7XG4iXX0=