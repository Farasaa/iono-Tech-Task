"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.KeplerGLSchema = exports.reducerSchema = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _window = require("global/window");

var _datasetSchema = _interopRequireDefault(require("./dataset-schema"));

var _mapStyleSchema = _interopRequireDefault(require("./map-style-schema"));

var _mapStateSchema = _interopRequireDefault(require("./map-state-schema"));

var _visStateSchema = require("./vis-state-schema");

var _versions = require("./versions");

var _utils = require("@kepler.gl/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var reducerSchema = {
  visState: _visStateSchema.visStateSchema,
  mapState: _mapStateSchema["default"],
  mapStyle: _mapStyleSchema["default"]
};
exports.reducerSchema = reducerSchema;

var KeplerGLSchema = /*#__PURE__*/function () {
  function KeplerGLSchema() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$reducers = _ref.reducers,
        reducers = _ref$reducers === void 0 ? reducerSchema : _ref$reducers,
        _ref$datasets = _ref.datasets,
        datasets = _ref$datasets === void 0 ? _datasetSchema["default"] : _ref$datasets,
        _ref$validVersions = _ref.validVersions,
        validVersions = _ref$validVersions === void 0 ? _versions.VERSIONS : _ref$validVersions,
        _ref$version = _ref.version,
        version = _ref$version === void 0 ? _versions.CURRENT_VERSION : _ref$version;

    (0, _classCallCheck2["default"])(this, KeplerGLSchema);
    (0, _defineProperty2["default"])(this, "_validVersions", void 0);
    (0, _defineProperty2["default"])(this, "_version", void 0);
    (0, _defineProperty2["default"])(this, "_reducerSchemas", void 0);
    (0, _defineProperty2["default"])(this, "_datasetSchema", void 0);
    (0, _defineProperty2["default"])(this, "_datasetLastSaved", void 0);
    (0, _defineProperty2["default"])(this, "_savedDataset", void 0);
    this._validVersions = validVersions;
    this._version = version;
    this._reducerSchemas = reducers;
    this._datasetSchema = datasets;
    this._datasetLastSaved = null;
    this._savedDataset = null;
  }
  /**
   * stateToSave = {
   *   datasets: [
   *     {
   *       version: 'v0',
   *       data: {id, label, color, allData, fields}
   *     },
   *     {
   *       version: 'v0',
   *       data: {id, label, color, allData, fields}
   *     }
   *   ],
   *   config: {
   *     version: 'v0',
   *     config: {}
   *   },
   *   info: {
   *     app: 'kepler.gl',
   *     create_at: 'Mon May 28 2018 21:04:46 GMT-0700 (PDT)'
   *   }
   * }
   *
   * Get config and data of current map to save
   * @param state
   * @returns app state to save
   */


  (0, _createClass2["default"])(KeplerGLSchema, [{
    key: "save",
    value: function save(state) {
      return {
        datasets: this.getDatasetToSave(state),
        config: this.getConfigToSave(state),
        info: _objectSpread({
          app: 'kepler.gl',
          created_at: new Date().toString()
        }, this.getMapInfo(state))
      };
    }
  }, {
    key: "getMapInfo",
    value: function getMapInfo(state) {
      return state.visState.mapInfo;
    }
    /**
     *  Load saved map, argument can be (datasets, config) or ({datasets, config})
     * @param savedDatasets
     * @param savedConfig
     */

  }, {
    key: "load",
    value: function load(savedDatasets, savedConfig) {
      // if pass dataset and config in as a single object
      if (arguments.length === 1 && (0, _utils.isPlainObject)(arguments[0]) && (Array.isArray(arguments[0].datasets) || (0, _utils.isPlainObject)(arguments[0].config))) {
        return this.load(arguments[0].datasets, arguments[0].config);
      }

      return _objectSpread(_objectSpread({}, Array.isArray(savedDatasets) ? {
        datasets: this.parseSavedData(savedDatasets)
      } : {}), savedConfig ? {
        config: this.parseSavedConfig(savedConfig)
      } : {});
    }
    /**
     * Get data to save
     * @param state - app state
     * @returns - dataset to save
     */

  }, {
    key: "getDatasetToSave",
    value: function getDatasetToSave(state) {
      var _this = this;

      var dataChangedSinceLastSave = this.hasDataChanged(state);

      if (!dataChangedSinceLastSave) {
        // @ts-expect-error
        return this._savedDataset;
      }

      var visState = state.visState;
      var datasets = Object.values(visState.datasets).map(function (ds) {
        return {
          version: _this._version,
          data: _this._datasetSchema[_this._version].save(ds)
        };
      }); // keep a copy of formatted datasets to save

      this._datasetLastSaved = visState.datasets;
      this._savedDataset = datasets;
      return datasets;
    }
    /**
     * Get App config to save
     * @param {Object} state - app state
     * @returns {{version: String, config: Object}} - config to save
     */

  }, {
    key: "getConfigToSave",
    value: function getConfigToSave(state) {
      var _this2 = this;

      var config = Object.keys(this._reducerSchemas).reduce(function (accu, key) {
        return _objectSpread(_objectSpread({}, accu), state[key] ? _this2._reducerSchemas[key][_this2._version].save(state[key]) : {});
      }, {});
      return {
        version: this._version,
        // @ts-expect-error
        config: config
      };
    }
    /**
     * Parse saved data
     * @param datasets
     * @returns - dataset to pass to addDataToMap
     */

  }, {
    key: "parseSavedData",
    value: function parseSavedData(datasets) {
      var _this3 = this;

      return datasets.reduce(function (accu, ds) {
        var validVersion = _this3.validateVersion(ds.version);

        if (!validVersion) {
          return accu;
        }

        accu.push(_this3._datasetSchema[validVersion].load(ds.data));
        return accu;
      }, []);
    }
    /**
     * Parse saved App config
     */

  }, {
    key: "parseSavedConfig",
    value: function parseSavedConfig(_ref2) {
      var _this4 = this;

      var version = _ref2.version,
          config = _ref2.config;
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var validVersion = this.validateVersion(version);

      if (!validVersion) {
        return null;
      }

      return Object.keys(config).reduce(function (accu, key) {
        return _objectSpread(_objectSpread({}, accu), key in _this4._reducerSchemas ? _this4._reducerSchemas[key][validVersion].load(config[key]) : {});
      }, {});
    }
    /**
     * Validate version
     * @param version
     * @returns validVersion
     */

  }, {
    key: "validateVersion",
    value: function validateVersion(version) {
      if (!version) {
        _window.console.error('There is no version number associated with this saved map');

        return null;
      }

      if (!this._validVersions[version]) {
        _window.console.error("".concat(version, " is not a valid version"));

        return null;
      }

      return version;
    }
    /**
     * Check if data has changed since last save
     * @param state
     * @returns - whether data has changed or not
     */

  }, {
    key: "hasDataChanged",
    value: function hasDataChanged(state) {
      return true; // return this._datasetLastSaved !== state.visState.datasets;
    }
  }]);
  return KeplerGLSchema;
}();

exports.KeplerGLSchema = KeplerGLSchema;
var KeplerGLSchemaManager = new KeplerGLSchema();
var _default = KeplerGLSchemaManager;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zY2hlbWEtbWFuYWdlci50cyJdLCJuYW1lcyI6WyJyZWR1Y2VyU2NoZW1hIiwidmlzU3RhdGUiLCJ2aXNTdGF0ZVNjaGVtYSIsIm1hcFN0YXRlIiwibWFwU3RhdGVTY2hlbWEiLCJtYXBTdHlsZSIsIm1hcFN0eWxlU2NoZW1hIiwiS2VwbGVyR0xTY2hlbWEiLCJyZWR1Y2VycyIsImRhdGFzZXRzIiwiZGF0YXNldFNjaGVtYSIsInZhbGlkVmVyc2lvbnMiLCJWRVJTSU9OUyIsInZlcnNpb24iLCJDVVJSRU5UX1ZFUlNJT04iLCJfdmFsaWRWZXJzaW9ucyIsIl92ZXJzaW9uIiwiX3JlZHVjZXJTY2hlbWFzIiwiX2RhdGFzZXRTY2hlbWEiLCJfZGF0YXNldExhc3RTYXZlZCIsIl9zYXZlZERhdGFzZXQiLCJzdGF0ZSIsImdldERhdGFzZXRUb1NhdmUiLCJjb25maWciLCJnZXRDb25maWdUb1NhdmUiLCJpbmZvIiwiYXBwIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b1N0cmluZyIsImdldE1hcEluZm8iLCJtYXBJbmZvIiwic2F2ZWREYXRhc2V0cyIsInNhdmVkQ29uZmlnIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwibG9hZCIsInBhcnNlU2F2ZWREYXRhIiwicGFyc2VTYXZlZENvbmZpZyIsImRhdGFDaGFuZ2VkU2luY2VMYXN0U2F2ZSIsImhhc0RhdGFDaGFuZ2VkIiwiT2JqZWN0IiwidmFsdWVzIiwibWFwIiwiZHMiLCJkYXRhIiwic2F2ZSIsImtleXMiLCJyZWR1Y2UiLCJhY2N1Iiwia2V5IiwidmFsaWRWZXJzaW9uIiwidmFsaWRhdGVWZXJzaW9uIiwicHVzaCIsIkNvbnNvbGUiLCJlcnJvciIsIktlcGxlckdMU2NoZW1hTWFuYWdlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7Ozs7OztBQXVETyxJQUFNQSxhQUVaLEdBQUc7QUFD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QUFDWjJDLHdCQUFRQyxLQUFSLENBQWMsMkRBQWQ7O0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDLEtBQUsxQyxjQUFMLENBQW9CRixPQUFwQixDQUFMLEVBQW1DO0FBQ2pDMkMsd0JBQVFDLEtBQVIsV0FBaUI1QyxPQUFqQjs7QUFDQSxlQUFPLElBQVA7QUFDRDs7QUFFRCxhQUFPQSxPQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7O1dBQ0Usd0JBQWVRLEtBQWYsRUFBb0M7QUFDbEMsYUFBTyxJQUFQLENBRGtDLENBRWxDO0FBQ0Q7Ozs7OztBQUdILElBQU1xQyxxQkFBcUIsR0FBRyxJQUFJbkQsY0FBSixFQUE5QjtlQUVlbUQscUIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQge2NvbnNvbGUgYXMgQ29uc29sZX0gZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbmltcG9ydCB7RGF0YXNldHN9IGZyb20gJ0BrZXBsZXIuZ2wvdGFibGUnO1xuaW1wb3J0IGRhdGFzZXRTY2hlbWEgZnJvbSAnLi9kYXRhc2V0LXNjaGVtYSc7XG5pbXBvcnQgbWFwU3R5bGVTY2hlbWEgZnJvbSAnLi9tYXAtc3R5bGUtc2NoZW1hJztcbmltcG9ydCBtYXBTdGF0ZVNjaGVtYSBmcm9tICcuL21hcC1zdGF0ZS1zY2hlbWEnO1xuaW1wb3J0IHtTYXZlZERhdGFzZXRWMSwgUGFyc2VkRGF0YXNldH0gZnJvbSAnLi9kYXRhc2V0LXNjaGVtYSc7XG5pbXBvcnQge3Zpc1N0YXRlU2NoZW1hfSBmcm9tICcuL3Zpcy1zdGF0ZS1zY2hlbWEnO1xuXG5pbXBvcnQge0NVUlJFTlRfVkVSU0lPTiwgVkVSU0lPTlN9IGZyb20gJy4vdmVyc2lvbnMnO1xuaW1wb3J0IHtpc1BsYWluT2JqZWN0fSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcblxuaW1wb3J0IHtNYXBJbmZvLCBTYXZlZFZpc1N0YXRlLCBTYXZlZE1hcFN0eWxlLCBQYXJzZWRDb25maWcsIEJhc2VNYXBTdHlsZX0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIFNhdmVkTWFwU3RhdGUgPSB7XG4gIGJlYXJpbmc6IG51bWJlcjtcbiAgZHJhZ1JvdGF0ZTogYm9vbGVhbjtcbiAgbGF0aXR1ZGU6IG51bWJlcjtcbiAgbG9uZ2l0dWRlOiBudW1iZXI7XG4gIHBpdGNoOiBudW1iZXI7XG4gIHpvb206IG51bWJlcjtcbiAgaXNTcGxpdDogYm9vbGVhbjtcbiAgaXNWaWV3cG9ydFN5bmNlZD86IHRydWU7XG4gIGlzWm9vbUxvY2tlZD86IGZhbHNlO1xuICBzcGxpdE1hcFZpZXdwb3J0cz86IFtdO1xufTtcblxuZXhwb3J0IHR5cGUgU2F2ZWRMYXllckdyb3VwcyA9IHtcbiAgW2tleTogc3RyaW5nXTogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIFNhdmVkQ3VzdG9tTWFwU3R5bGUgPSB7XG4gIFtrZXk6IHN0cmluZ106IHtcbiAgICBhY2Nlc3NUb2tlbj86IHN0cmluZztcbiAgICBjdXN0b206IEJhc2VNYXBTdHlsZVsnY3VzdG9tJ107XG4gICAgaWNvbjogc3RyaW5nO1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICB1cmw6IHN0cmluZztcbiAgfTtcbn07XG5cbi8qKiBTY2hlbWEgZm9yIHYxIHNhdmVkIGNvbmZpZ3VyYXRpb24gKi9cbmV4cG9ydCB0eXBlIFNhdmVkQ29uZmlnVjEgPSB7XG4gIHZlcnNpb246ICd2MSc7XG4gIGNvbmZpZzoge1xuICAgIHZpc1N0YXRlOiBTYXZlZFZpc1N0YXRlO1xuICAgIG1hcFN0YXRlOiBTYXZlZE1hcFN0YXRlO1xuICAgIG1hcFN0eWxlOiBTYXZlZE1hcFN0eWxlO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgU2F2ZWRNYXAgPSB7XG4gIGRhdGFzZXRzOiBTYXZlZERhdGFzZXRWMVtdO1xuICBjb25maWc6IFNhdmVkQ29uZmlnVjE7XG4gIGluZm86IHtcbiAgICBhcHA6IHN0cmluZztcbiAgICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgTG9hZGVkTWFwID0ge2RhdGFzZXRzPzogUGFyc2VkRGF0YXNldFtdIHwgbnVsbDsgY29uZmlnPzogUGFyc2VkQ29uZmlnIHwgbnVsbH07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VyU2NoZW1hOiB7XG4gIFtrZXk6IHN0cmluZ106IHR5cGVvZiBtYXBTdGF0ZVNjaGVtYSB8IHR5cGVvZiB2aXNTdGF0ZVNjaGVtYSB8IHR5cGVvZiBtYXBTdHlsZVNjaGVtYTtcbn0gPSB7XG4gIHZpc1N0YXRlOiB2aXNTdGF0ZVNjaGVtYSxcbiAgbWFwU3RhdGU6IG1hcFN0YXRlU2NoZW1hLFxuICBtYXBTdHlsZTogbWFwU3R5bGVTY2hlbWFcbn07XG5cbmV4cG9ydCBjbGFzcyBLZXBsZXJHTFNjaGVtYSB7XG4gIF92YWxpZFZlcnNpb25zOiB0eXBlb2YgVkVSU0lPTlM7XG4gIF92ZXJzaW9uOiAndjEnO1xuICBfcmVkdWNlclNjaGVtYXM6IHR5cGVvZiByZWR1Y2VyU2NoZW1hO1xuICBfZGF0YXNldFNjaGVtYTogdHlwZW9mIGRhdGFzZXRTY2hlbWE7XG4gIF9kYXRhc2V0TGFzdFNhdmVkOiBTYXZlZERhdGFzZXRWMVtdIHwgbnVsbDtcbiAgX3NhdmVkRGF0YXNldDogU2F2ZWREYXRhc2V0VjFbXSB8IG51bGw7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHJlZHVjZXJzID0gcmVkdWNlclNjaGVtYSxcbiAgICBkYXRhc2V0cyA9IGRhdGFzZXRTY2hlbWEsXG4gICAgdmFsaWRWZXJzaW9ucyA9IFZFUlNJT05TLFxuICAgIHZlcnNpb24gPSBDVVJSRU5UX1ZFUlNJT05cbiAgfToge1xuICAgIHJlZHVjZXJzPzogdHlwZW9mIHJlZHVjZXJTY2hlbWE7XG4gICAgZGF0YXNldHM/OiB0eXBlb2YgZGF0YXNldFNjaGVtYTtcbiAgICB2YWxpZFZlcnNpb25zPzogdHlwZW9mIFZFUlNJT05TO1xuICAgIHZlcnNpb24/OiAndjEnO1xuICB9ID0ge30pIHtcbiAgICB0aGlzLl92YWxpZFZlcnNpb25zID0gdmFsaWRWZXJzaW9ucztcbiAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0aGlzLl9yZWR1Y2VyU2NoZW1hcyA9IHJlZHVjZXJzO1xuICAgIHRoaXMuX2RhdGFzZXRTY2hlbWEgPSBkYXRhc2V0cztcblxuICAgIHRoaXMuX2RhdGFzZXRMYXN0U2F2ZWQgPSBudWxsO1xuICAgIHRoaXMuX3NhdmVkRGF0YXNldCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogc3RhdGVUb1NhdmUgPSB7XG4gICAqICAgZGF0YXNldHM6IFtcbiAgICogICAgIHtcbiAgICogICAgICAgdmVyc2lvbjogJ3YwJyxcbiAgICogICAgICAgZGF0YToge2lkLCBsYWJlbCwgY29sb3IsIGFsbERhdGEsIGZpZWxkc31cbiAgICogICAgIH0sXG4gICAqICAgICB7XG4gICAqICAgICAgIHZlcnNpb246ICd2MCcsXG4gICAqICAgICAgIGRhdGE6IHtpZCwgbGFiZWwsIGNvbG9yLCBhbGxEYXRhLCBmaWVsZHN9XG4gICAqICAgICB9XG4gICAqICAgXSxcbiAgICogICBjb25maWc6IHtcbiAgICogICAgIHZlcnNpb246ICd2MCcsXG4gICAqICAgICBjb25maWc6IHt9XG4gICAqICAgfSxcbiAgICogICBpbmZvOiB7XG4gICAqICAgICBhcHA6ICdrZXBsZXIuZ2wnLFxuICAgKiAgICAgY3JlYXRlX2F0OiAnTW9uIE1heSAyOCAyMDE4IDIxOjA0OjQ2IEdNVC0wNzAwIChQRFQpJ1xuICAgKiAgIH1cbiAgICogfVxuICAgKlxuICAgKiBHZXQgY29uZmlnIGFuZCBkYXRhIG9mIGN1cnJlbnQgbWFwIHRvIHNhdmVcbiAgICogQHBhcmFtIHN0YXRlXG4gICAqIEByZXR1cm5zIGFwcCBzdGF0ZSB0byBzYXZlXG4gICAqL1xuICBzYXZlKHN0YXRlOiBhbnkpOiBTYXZlZE1hcCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGFzZXRzOiB0aGlzLmdldERhdGFzZXRUb1NhdmUoc3RhdGUpLFxuICAgICAgY29uZmlnOiB0aGlzLmdldENvbmZpZ1RvU2F2ZShzdGF0ZSksXG4gICAgICBpbmZvOiB7XG4gICAgICAgIGFwcDogJ2tlcGxlci5nbCcsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9TdHJpbmcoKSxcbiAgICAgICAgLi4udGhpcy5nZXRNYXBJbmZvKHN0YXRlKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBnZXRNYXBJbmZvKHN0YXRlOiBhbnkpOiBNYXBJbmZvIHtcbiAgICByZXR1cm4gc3RhdGUudmlzU3RhdGUubWFwSW5mbztcbiAgfVxuICAvKipcbiAgICogIExvYWQgc2F2ZWQgbWFwLCBhcmd1bWVudCBjYW4gYmUgKGRhdGFzZXRzLCBjb25maWcpIG9yICh7ZGF0YXNldHMsIGNvbmZpZ30pXG4gICAqIEBwYXJhbSBzYXZlZERhdGFzZXRzXG4gICAqIEBwYXJhbSBzYXZlZENvbmZpZ1xuICAgKi9cbiAgbG9hZChcbiAgICBzYXZlZERhdGFzZXRzOiBTYXZlZE1hcCB8IFNhdmVkTWFwWydkYXRhc2V0cyddIHwgYW55LFxuICAgIHNhdmVkQ29uZmlnOiBTYXZlZE1hcFsnY29uZmlnJ10gfCBhbnlcbiAgKTogTG9hZGVkTWFwIHtcbiAgICAvLyBpZiBwYXNzIGRhdGFzZXQgYW5kIGNvbmZpZyBpbiBhcyBhIHNpbmdsZSBvYmplY3RcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICBpc1BsYWluT2JqZWN0KGFyZ3VtZW50c1swXSkgJiZcbiAgICAgIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXS5kYXRhc2V0cykgfHwgaXNQbGFpbk9iamVjdChhcmd1bWVudHNbMF0uY29uZmlnKSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWQoYXJndW1lbnRzWzBdLmRhdGFzZXRzLCBhcmd1bWVudHNbMF0uY29uZmlnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uKEFycmF5LmlzQXJyYXkoc2F2ZWREYXRhc2V0cykgPyB7ZGF0YXNldHM6IHRoaXMucGFyc2VTYXZlZERhdGEoc2F2ZWREYXRhc2V0cyl9IDoge30pLFxuICAgICAgLi4uKHNhdmVkQ29uZmlnID8ge2NvbmZpZzogdGhpcy5wYXJzZVNhdmVkQ29uZmlnKHNhdmVkQ29uZmlnKX0gOiB7fSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBkYXRhIHRvIHNhdmVcbiAgICogQHBhcmFtIHN0YXRlIC0gYXBwIHN0YXRlXG4gICAqIEByZXR1cm5zIC0gZGF0YXNldCB0byBzYXZlXG4gICAqL1xuICBnZXREYXRhc2V0VG9TYXZlKHN0YXRlOiBhbnkpOiBTYXZlZERhdGFzZXRWMVtdIHtcbiAgICBjb25zdCBkYXRhQ2hhbmdlZFNpbmNlTGFzdFNhdmUgPSB0aGlzLmhhc0RhdGFDaGFuZ2VkKHN0YXRlKTtcbiAgICBpZiAoIWRhdGFDaGFuZ2VkU2luY2VMYXN0U2F2ZSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkRGF0YXNldDtcbiAgICB9XG5cbiAgICBjb25zdCB7dmlzU3RhdGV9ID0gc3RhdGU7XG5cbiAgICBjb25zdCBkYXRhc2V0cyA9IE9iamVjdC52YWx1ZXModmlzU3RhdGUuZGF0YXNldHMgYXMgRGF0YXNldHMpLm1hcChkcyA9PiAoe1xuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIGRhdGE6IHRoaXMuX2RhdGFzZXRTY2hlbWFbdGhpcy5fdmVyc2lvbl0uc2F2ZShkcylcbiAgICB9KSk7XG5cbiAgICAvLyBrZWVwIGEgY29weSBvZiBmb3JtYXR0ZWQgZGF0YXNldHMgdG8gc2F2ZVxuICAgIHRoaXMuX2RhdGFzZXRMYXN0U2F2ZWQgPSB2aXNTdGF0ZS5kYXRhc2V0cztcbiAgICB0aGlzLl9zYXZlZERhdGFzZXQgPSBkYXRhc2V0cztcblxuICAgIHJldHVybiBkYXRhc2V0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQXBwIGNvbmZpZyB0byBzYXZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIGFwcCBzdGF0ZVxuICAgKiBAcmV0dXJucyB7e3ZlcnNpb246IFN0cmluZywgY29uZmlnOiBPYmplY3R9fSAtIGNvbmZpZyB0byBzYXZlXG4gICAqL1xuICBnZXRDb25maWdUb1NhdmUoc3RhdGU6IGFueSk6IFNhdmVkQ29uZmlnVjEge1xuICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5rZXlzKHRoaXMuX3JlZHVjZXJTY2hlbWFzKS5yZWR1Y2UoXG4gICAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICAuLi4oc3RhdGVba2V5XSA/IHRoaXMuX3JlZHVjZXJTY2hlbWFzW2tleV1bdGhpcy5fdmVyc2lvbl0uc2F2ZShzdGF0ZVtrZXldKSA6IHt9KVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGNvbmZpZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugc2F2ZWQgZGF0YVxuICAgKiBAcGFyYW0gZGF0YXNldHNcbiAgICogQHJldHVybnMgLSBkYXRhc2V0IHRvIHBhc3MgdG8gYWRkRGF0YVRvTWFwXG4gICAqL1xuICBwYXJzZVNhdmVkRGF0YShkYXRhc2V0czogYW55KTogUGFyc2VkRGF0YXNldFtdIHwgbnVsbCB7XG4gICAgcmV0dXJuIGRhdGFzZXRzLnJlZHVjZSgoYWNjdSwgZHMpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkVmVyc2lvbiA9IHRoaXMudmFsaWRhdGVWZXJzaW9uKGRzLnZlcnNpb24pO1xuICAgICAgaWYgKCF2YWxpZFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjY3U7XG4gICAgICB9XG4gICAgICBhY2N1LnB1c2godGhpcy5fZGF0YXNldFNjaGVtYVt2YWxpZFZlcnNpb25dLmxvYWQoZHMuZGF0YSkpO1xuICAgICAgcmV0dXJuIGFjY3U7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHNhdmVkIEFwcCBjb25maWdcbiAgICovXG4gIHBhcnNlU2F2ZWRDb25maWcoe3ZlcnNpb24sIGNvbmZpZ30sIHN0YXRlID0ge30pOiBQYXJzZWRDb25maWcgfCBudWxsIHtcbiAgICBjb25zdCB2YWxpZFZlcnNpb24gPSB0aGlzLnZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uKTtcbiAgICBpZiAoIXZhbGlkVmVyc2lvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbmZpZykucmVkdWNlKFxuICAgICAgKGFjY3UsIGtleSkgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgLi4uKGtleSBpbiB0aGlzLl9yZWR1Y2VyU2NoZW1hc1xuICAgICAgICAgID8gdGhpcy5fcmVkdWNlclNjaGVtYXNba2V5XVt2YWxpZFZlcnNpb25dLmxvYWQoY29uZmlnW2tleV0pXG4gICAgICAgICAgOiB7fSlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHZlcnNpb25cbiAgICogQHBhcmFtIHZlcnNpb25cbiAgICogQHJldHVybnMgdmFsaWRWZXJzaW9uXG4gICAqL1xuICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbjogYW55KTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICBDb25zb2xlLmVycm9yKCdUaGVyZSBpcyBubyB2ZXJzaW9uIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBzYXZlZCBtYXAnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdmFsaWRWZXJzaW9uc1t2ZXJzaW9uXSkge1xuICAgICAgQ29uc29sZS5lcnJvcihgJHt2ZXJzaW9ufSBpcyBub3QgYSB2YWxpZCB2ZXJzaW9uYCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBkYXRhIGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3Qgc2F2ZVxuICAgKiBAcGFyYW0gc3RhdGVcbiAgICogQHJldHVybnMgLSB3aGV0aGVyIGRhdGEgaGFzIGNoYW5nZWQgb3Igbm90XG4gICAqL1xuICBoYXNEYXRhQ2hhbmdlZChzdGF0ZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gICAgLy8gcmV0dXJuIHRoaXMuX2RhdGFzZXRMYXN0U2F2ZWQgIT09IHN0YXRlLnZpc1N0YXRlLmRhdGFzZXRzO1xuICB9XG59XG5cbmNvbnN0IEtlcGxlckdMU2NoZW1hTWFuYWdlciA9IG5ldyBLZXBsZXJHTFNjaGVtYSgpO1xuXG5leHBvcnQgZGVmYXVsdCBLZXBsZXJHTFNjaGVtYU1hbmFnZXI7XG4iXX0=