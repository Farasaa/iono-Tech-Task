"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMapStyles = getMapStyles;
exports.getInitialInputStyle = getInitialInputStyle;
exports.setBackgroundColorUpdater = exports.set3dBuildingColorUpdater = exports.removeCustomMapStyleUpdater = exports.editCustomMapStyleUpdater = exports.addCustomMapStyleUpdater = exports.inputMapStyleUpdater = exports.loadCustomMapStyleUpdater = exports.resetMapConfigMapStyleUpdater = exports.receiveMapConfigUpdater = exports.loadMapStyleErrUpdater = exports.loadMapStylesUpdater = exports.mapStyleChangeUpdater = exports.mapConfigChangeUpdater = exports.initMapStyleUpdater = exports.requestMapStylesUpdater = exports.INITIAL_MAP_STYLE = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _tasks = _interopRequireWildcard(require("react-palm/tasks"));

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _console = _interopRequireDefault(require("global/console"));

var _utils = require("@kepler.gl/utils");

var _constants = require("@kepler.gl/constants");

var _tasks2 = require("@kepler.gl/tasks");

var _d3Color = require("d3-color");

var _actions = require("@kepler.gl/actions");

function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var getDefaultState = function getDefaultState() {
  var visibleLayerGroups = {};
  var styleType = 'dark-matter';
  var topLayerGroups = {};
  return {
    styleType: styleType,
    visibleLayerGroups: visibleLayerGroups,
    topLayerGroups: topLayerGroups,
    mapStyles: _constants.DEFAULT_MAP_STYLES.reduce(function (accu, curr) {
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, curr.id, curr));
    }, {}),
    // save mapbox access token
    mapboxApiAccessToken: null,
    mapboxApiUrl: _constants.DEFAULT_MAPBOX_API_URL,
    mapStylesReplaceDefault: false,
    inputStyle: getInitialInputStyle(),
    threeDBuildingColor: (0, _utils.hexToRgb)(_constants.DEFAULT_BLDG_COLOR),
    custom3DBuildingColor: false,
    backgroundColor: (0, _utils.hexToRgb)(_constants.DEFAULT_BACKGROUND_COLOR),
    isLoading: {},
    bottomMapStyle: undefined,
    topMapStyle: undefined
  };
};
/**
 * Updaters for `mapStyle`. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {mapStyleUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // click button to hide label from background map
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             mapStyle: mapStyleUpdaters.mapConfigChangeUpdater(
 *               mapStyle,
 *               {payload: {visibleLayerGroups: {label: false, road: true, background: true}}}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */
// @ts-ignore


var mapStyleUpdaters = null;
/* eslint-enable no-unused-vars */

/**
 * Default initial `mapStyle`
 * @memberof mapStyleUpdaters
 * @constant
 * @property styleType - Default: `'dark'`
 * @property visibleLayerGroups - Default: `{}`
 * @property topLayerGroups - Default: `{}`
 * @property mapStyles - mapping from style key to style object
 * @property mapboxApiAccessToken - Default: `null`
 * @Property mapboxApiUrl - Default null
 * @Property mapStylesReplaceDefault - Default: `false`
 * @property inputStyle - Default: `{}`
 * @property threeDBuildingColor - Default: `[r, g, b]`
 * @property backgroundColor - Default: `[r, g, b]`
 * @public
 */

var INITIAL_MAP_STYLE = getDefaultState();
exports.INITIAL_MAP_STYLE = INITIAL_MAP_STYLE;

/**
 * Create two map styles from preset map style, one for top map one for bottom
 *
 * @param {string} styleType - current map style
 * @param {Object} visibleLayerGroups - visible layers of bottom map
 * @param {Object} topLayerGroups - visible layers of top map
 * @param {Object} mapStyles - a dictionary of all map styles
 * @returns {Object} bottomMapStyle | topMapStyle | isRaster
 */
function getMapStyles(_ref) {
  var styleType = _ref.styleType,
      visibleLayerGroups = _ref.visibleLayerGroups,
      topLayerGroups = _ref.topLayerGroups,
      mapStyles = _ref.mapStyles;
  var mapStyle = mapStyles[styleType]; // style might not be loaded yet

  if (!mapStyle || !mapStyle.style) {
    return {};
  }

  var editable = Object.keys(visibleLayerGroups).length;
  var bottomMapStyle = !editable ? mapStyle.style : (0, _utils.editBottomMapStyle)({
    id: styleType,
    mapStyle: mapStyle,
    visibleLayerGroups: visibleLayerGroups
  });
  var hasTopLayer = editable > 0 && Object.values(topLayerGroups).some(function (v) {
    return v;
  }); // mute top layer if not visible in bottom layer

  var topLayers = hasTopLayer && Object.keys(topLayerGroups).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, topLayerGroups[key] && visibleLayerGroups[key]));
  }, {});
  var topMapStyle = hasTopLayer ? (0, _utils.editTopMapStyle)({
    id: styleType,
    mapStyle: mapStyle,
    visibleLayerGroups: topLayers
  }) : null;
  return {
    bottomMapStyle: bottomMapStyle,
    topMapStyle: topMapStyle,
    editable: editable
  };
}

function findLayerFillColor(layer) {
  return layer && layer.paint && layer.paint['background-color'];
} // need to be careful because some basemap layer.paint['background-color'] values may be an interpolate array expression instead of a color string
// https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#paint-background-background-color
// https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/#interpolate


function getPaintColor(color) {
  if (Array.isArray(color) && color[0] === 'interpolate') {
    // get color of first zoom break
    // ["interpolate", ["linear"], ["zoom"], 11, "hsl(35, 32%, 91%)", 13, "hsl(35, 12%, 89%)"]
    return color[4];
  }

  return color;
}

function get3DBuildingColor(style) {
  // set building color to be the same as the background color.
  if (!style.style) {
    return (0, _utils.hexToRgb)(_constants.DEFAULT_BLDG_COLOR);
  }

  var backgroundLayer = (style.style.layers || []).find(function (_ref2) {
    var id = _ref2.id;
    return id === 'background';
  });
  var buildingLayer = (style.style.layers || []).find(function (_ref3) {
    var id = _ref3.id;
    return id.match(/building/);
  });

  var buildingColor = findLayerFillColor(buildingLayer) || findLayerFillColor(backgroundLayer) || _constants.DEFAULT_BLDG_COLOR; // brighten or darken building based on style


  var operation = style.id.match(/(?=(dark|night))/) ? 'brighter' : 'darker';
  var alpha = 0.2;
  var rgbObj = (0, _d3Color.rgb)(buildingColor)[operation]([alpha]);
  return [rgbObj.r, rgbObj.g, rgbObj.b];
}

function getBackgroundColorFromStyleBaseLayer(style, backupBackgroundColor) {
  var _colorMaybeToRGB;

  if (!style.style) {
    return (0, _utils.colorMaybeToRGB)(backupBackgroundColor) || backupBackgroundColor;
  } // @ts-expect-error style.style not typed


  var baseLayer = (style.style.layers || []).find(function (_ref4) {
    var id = _ref4.id;
    return _constants.BASE_MAP_BACKGROUND_LAYER_IDS.includes(id);
  });
  var backgroundColorOfBaseLayer = getPaintColor(findLayerFillColor(baseLayer));
  var newBackgroundColor = typeof backgroundColorOfBaseLayer === 'string' ? backgroundColorOfBaseLayer : backupBackgroundColor;
  var newBackgroundColorAsRGBArray = (_colorMaybeToRGB = (0, _utils.colorMaybeToRGB)(newBackgroundColor) // if newBackgroundColor was in string HSL format it can introduce RGB numbers with decimals,
  // which may render the background-color CSS of the <StyledMap> container incorrectly when using our own color utils `rgbToHex()`
  // so we attempt to round to nearest integer here
  ) === null || _colorMaybeToRGB === void 0 ? void 0 : _colorMaybeToRGB.map(function (channelNumber) {
    return Math.round(channelNumber);
  });
  return newBackgroundColorAsRGBArray || backupBackgroundColor;
} // determine new backgroundColor from either previous state basemap style, previous state backgroundColor, or the DEFAULT_BACKGROUND_COLOR


function getBackgroundColor(previousState, styleType) {
  var previousStateMapStyle = previousState.mapStyles[previousState.styleType];
  var backupBackgroundColor = previousState.backgroundColor || _constants.DEFAULT_BACKGROUND_COLOR;
  var backgroundColor = styleType === _constants.NO_MAP_ID ? // if the style has switched to the "no basemap" style,
  // attempt to detect backgroundColor of the previous basemap if it was a mapbox basemap
  // and set it as the "no basemap" backgroundColor
  getBackgroundColorFromStyleBaseLayer(previousStateMapStyle, backupBackgroundColor) : // otherwise leave it alone and rely on the previous state's preexisting backgroundColor
  // or DEFAULT_BACKGROUND_COLOR as a last resort
  backupBackgroundColor;
  return backgroundColor;
}

function getLayerGroupsFromStyle(style) {
  return Array.isArray(style === null || style === void 0 ? void 0 : style.layers) ? _constants.DEFAULT_LAYER_GROUPS.filter(function (lg) {
    return style.layers.filter(lg.filter).length;
  }) : [];
} // Updaters

/**
 * @memberof mapStyleUpdaters
 * @public
 */


var requestMapStylesUpdater = function requestMapStylesUpdater(state, _ref5) {
  var _ref5$payload = _ref5.payload,
      mapStyles = _ref5$payload.mapStyles,
      onSuccess = _ref5$payload.onSuccess;
  var toLoad = Object.keys(mapStyles).reduce(function (accu, id) {
    return _objectSpread(_objectSpread({}, accu), !state.isLoading[id] ? (0, _defineProperty2["default"])({}, id, mapStyles[id]) : {});
  }, {});
  var loadMapStyleTasks = getLoadMapStyleTasks(toLoad, state.mapboxApiAccessToken, state.mapboxApiUrl, onSuccess);
  var isLoading = Object.keys(toLoad).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, true));
  }, {});

  var nextState = _objectSpread(_objectSpread({}, state), {}, {
    isLoading: isLoading
  });

  return (0, _tasks.withTask)(nextState, loadMapStyleTasks);
};
/**
 * Propagate `mapStyle` reducer with `mapboxApiAccessToken` and `mapStylesReplaceDefault`.
 * if mapStylesReplaceDefault is true mapStyles is emptied; loadMapStylesUpdater() will
 * populate mapStyles.
 *
 * @memberof mapStyleUpdaters
 * @public
 */


exports.requestMapStylesUpdater = requestMapStylesUpdater;

var initMapStyleUpdater = function initMapStyleUpdater(state, _ref7) {
  var _ref7$payload = _ref7.payload,
      payload = _ref7$payload === void 0 ? {} : _ref7$payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    // save mapbox access token to map style state
    mapboxApiAccessToken: payload.mapboxApiAccessToken || state.mapboxApiAccessToken,
    mapboxApiUrl: payload.mapboxApiUrl || state.mapboxApiUrl,
    mapStyles: !payload.mapStylesReplaceDefault ? state.mapStyles : {},
    mapStylesReplaceDefault: payload.mapStylesReplaceDefault || false
  });
}; // });

/**
 * Update `visibleLayerGroups`to change layer group visibility
 * @memberof mapStyleUpdaters
 * @public
 */


exports.initMapStyleUpdater = initMapStyleUpdater;

var mapConfigChangeUpdater = function mapConfigChangeUpdater(state, action) {
  return _objectSpread(_objectSpread(_objectSpread({}, state), action.payload), getMapStyles(_objectSpread(_objectSpread({}, state), action.payload)));
};

exports.mapConfigChangeUpdater = mapConfigChangeUpdater;

var hasStyleObject = function hasStyleObject(style) {
  return (0, _utils.isPlainObject)(style === null || style === void 0 ? void 0 : style.style);
};
/**
 * Change to another map style. The selected style should already been loaded into `mapStyle.mapStyles`
 * @memberof mapStyleUpdaters
 * @public
 */


var mapStyleChangeUpdater = function mapStyleChangeUpdater(state, _ref8) {
  var _state$mapStyles$styl, _state$mapStyles$styl2;

  var _ref8$payload = _ref8.payload,
      styleType = _ref8$payload.styleType,
      onSuccess = _ref8$payload.onSuccess;

  if ( // we might not have received the style yet
  !state.mapStyles[styleType] || // or if it is a managed custom style asset
  // and if it has not been hydrated with URL info yet (during app first initialization)
  // and it does not have a style object (during adding a custom style)
  ((_state$mapStyles$styl = state.mapStyles[styleType]) === null || _state$mapStyles$styl === void 0 ? void 0 : _state$mapStyles$styl.custom) === 'MANAGED' && !((_state$mapStyles$styl2 = state.mapStyles[styleType]) !== null && _state$mapStyles$styl2 !== void 0 && _state$mapStyles$styl2.url) && !hasStyleObject(state.mapStyles[styleType])) {
    return state;
  }

  if (!hasStyleObject(state.mapStyles[styleType])) {
    // style hasn't loaded yet
    return requestMapStylesUpdater(_objectSpread(_objectSpread({}, state), {}, {
      styleType: styleType
    }), {
      payload: {
        mapStyles: (0, _defineProperty2["default"])({}, styleType, state.mapStyles[styleType]),
        onSuccess: onSuccess
      }
    });
  }

  var defaultLGVisibility = (0, _utils.getDefaultLayerGroupVisibility)(state.mapStyles[styleType]);
  var visibleLayerGroups = (0, _utils.mergeLayerGroupVisibility)(defaultLGVisibility, state.visibleLayerGroups);
  var threeDBuildingColor = state.custom3DBuildingColor ? state.threeDBuildingColor : get3DBuildingColor(state.mapStyles[styleType]); // determine new backgroundColor from either previous state basemap style, previous state backgroundColor, or the DEFAULT_BACKGROUND_COLOR

  var backgroundColor = getBackgroundColor(state, styleType);
  return _objectSpread(_objectSpread({}, state), {}, {
    styleType: styleType,
    visibleLayerGroups: visibleLayerGroups,
    threeDBuildingColor: threeDBuildingColor,
    backgroundColor: backgroundColor
  }, getMapStyles(_objectSpread(_objectSpread({}, state), {}, {
    visibleLayerGroups: visibleLayerGroups,
    styleType: styleType
  })));
};
/**
 * Callback when load map style success
 * @memberof mapStyleUpdaters
 * @public
 */


exports.mapStyleChangeUpdater = mapStyleChangeUpdater;

var loadMapStylesUpdater = function loadMapStylesUpdater(state, action) {
  var _ref9 = action.payload || {},
      newStyles = _ref9.newStyles,
      onSuccess = _ref9.onSuccess;

  var addLayerGroups = Object.keys(newStyles).reduce(function (accu, id) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, id, _objectSpread(_objectSpread({}, newStyles[id]), {}, {
      layerGroups: newStyles[id].layerGroups || getLayerGroupsFromStyle(newStyles[id].style)
    })));
  }, {}); // reset isLoading

  var isLoading = Object.keys(state.isLoading).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), state.isLoading[key] && hasStyleObject(newStyles[key]) ? (0, _defineProperty2["default"])({}, key, false) : (0, _defineProperty2["default"])({}, key, state.isLoading[key]));
  }, {}); // add new styles to state

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    isLoading: isLoading,
    mapStyles: _objectSpread(_objectSpread({}, state.mapStyles), addLayerGroups)
  });

  var tasks = createActionTask(onSuccess, {
    styleType: state.styleType
  });
  var nextState = newStyles[state.styleType] ? mapStyleChangeUpdater(newState, {
    payload: {
      styleType: state.styleType
    }
  }) : newState;
  return tasks ? (0, _tasks.withTask)(nextState, tasks) : nextState;
};

exports.loadMapStylesUpdater = loadMapStylesUpdater;

function createActionTask(action, payload) {
  if (typeof action === 'function') {
    return (0, _tasks2.ACTION_TASK)().map(function (_) {
      return action(payload);
    });
  }

  return null;
}
/**
 * Callback when load map style error
 * @memberof mapStyleUpdaters
 * @public
 */
// do nothing for now, if didn't load, skip it


var loadMapStyleErrUpdater = function loadMapStyleErrUpdater(state, _ref12) {
  var _ref12$payload = _ref12.payload,
      ids = _ref12$payload.ids,
      error = _ref12$payload.error;

  _console["default"].error(error); // reset isLoading


  var isLoading = Object.keys(state.isLoading).reduce(function (accu, key) {
    return _objectSpread(_objectSpread({}, accu), state.isLoading[key] && (ids || []).includes(key) ? (0, _defineProperty2["default"])({}, key, false) : (0, _defineProperty2["default"])({}, key, state.isLoading[key]));
  }, {});
  return _objectSpread(_objectSpread({}, state), {}, {
    isLoading: isLoading
  });
};
/**
 * Load map style object when pass in saved map config
 * @memberof mapStyleUpdaters
 * @param state `mapStyle`
 * @param action
 * @param action.payload saved map config `{mapStyle, visState, mapState}`
 * @returns nextState or `react-pam` tasks to load map style object
 */


exports.loadMapStyleErrUpdater = loadMapStyleErrUpdater;

var receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref15) {
  var config = _ref15.payload.config;

  var _ref16 = config || {},
      mapStyle = _ref16.mapStyle;

  if (!mapStyle) {
    return state;
  } // merge default mapStyles


  var merged = mapStyle.mapStyles ? _objectSpread(_objectSpread({}, mapStyle), {}, {
    mapStyles: _objectSpread(_objectSpread({}, mapStyle.mapStyles), state.mapStyles)
  }) : mapStyle; // set custom3DBuildingColor: true if mapStyle contains threeDBuildingColor
  // @ts-expect-error

  merged.custom3DBuildingColor = // @ts-expect-error
  Boolean(mapStyle.threeDBuildingColor) || merged.custom3DBuildingColor;
  var newState = mapConfigChangeUpdater(state, {
    payload: merged
  });
  return mapStyleChangeUpdater(newState, {
    payload: {
      styleType: newState.styleType
    }
  });
};

exports.receiveMapConfigUpdater = receiveMapConfigUpdater;

function getLoadMapStyleTasks(mapStyles, mapboxApiAccessToken, mapboxApiUrl, onSuccess) {
  return [_tasks["default"].all(Object.values(mapStyles) // @ts-expect-error
  .map(function (_ref17) {
    var id = _ref17.id,
        url = _ref17.url,
        accessToken = _ref17.accessToken;
    return {
      id: id,
      url: (0, _utils.isValidStyleUrl)(url) ? (0, _utils.getStyleDownloadUrl)(url, accessToken || mapboxApiAccessToken, mapboxApiUrl) : url
    };
  }).map(_tasks2.LOAD_MAP_STYLE_TASK)).bimap( // success
  function (results) {
    return (0, _actions.loadMapStyles)(results.reduce(function (accu, _ref18) {
      var id = _ref18.id,
          style = _ref18.style;
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, id, _objectSpread(_objectSpread({}, mapStyles[id]), {}, {
        style: style
      })));
    }, {}), onSuccess);
  }, // error
  function (err) {
    return (0, _actions.loadMapStyleErr)(Object.keys(mapStyles), err);
  })];
}
/**
 * Reset map style config to initial state
 * @memberof mapStyleUpdaters
 * @param state `mapStyle`
 * @returns nextState
 * @public
 */


var resetMapConfigMapStyleUpdater = function resetMapConfigMapStyleUpdater(state) {
  var emptyConfig = _objectSpread(_objectSpread(_objectSpread({}, INITIAL_MAP_STYLE), {}, {
    mapboxApiAccessToken: state.mapboxApiAccessToken,
    mapboxApiUrl: state.mapboxApiUrl,
    mapStylesReplaceDefault: state.mapStylesReplaceDefault
  }, state.initialState), {}, {
    mapStyles: state.mapStyles,
    initialState: state.initialState
  });

  return mapStyleChangeUpdater(emptyConfig, {
    payload: {
      styleType: emptyConfig.styleType
    }
  });
};
/**
 * Callback when a custom map style object is received
 * @memberof mapStyleUpdaters
 * @public
 */


exports.resetMapConfigMapStyleUpdater = resetMapConfigMapStyleUpdater;

var loadCustomMapStyleUpdater = function loadCustomMapStyleUpdater(state, _ref19) {
  var _ref19$payload = _ref19.payload,
      icon = _ref19$payload.icon,
      style = _ref19$payload.style,
      error = _ref19$payload.error;
  return _objectSpread(_objectSpread({}, state), {}, {
    // @ts-expect-error
    inputStyle: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, state.inputStyle), style ? {
      id: state.inputStyle.custom === 'MANAGED' ? state.inputStyle.id // custom MANAGED type
      : // @ts-expect-error
      style.id || (0, _utils.generateHashId)(),
      // custom LOCAL type
      // make a copy of the style object
      style: (0, _lodash["default"])(style),
      // @ts-expect-error
      label: state.inputStyle.label || style.name,
      // gathering layer group info from style json
      layerGroups: getLayerGroupsFromStyle(style)
    } : {}), icon ? {
      icon: icon
    } : {}), error ? {
      error: error
    } : {})
  });
};
/**
 * Input a custom map style object
 * @memberof mapStyleUpdaters
 * @public
 */


exports.loadCustomMapStyleUpdater = loadCustomMapStyleUpdater;

var inputMapStyleUpdater = function inputMapStyleUpdater(state, _ref20) {
  var _updated$icon;

  var _ref20$payload = _ref20.payload,
      inputStyle = _ref20$payload.inputStyle,
      mapState = _ref20$payload.mapState;

  var updated = _objectSpread(_objectSpread({}, state.inputStyle), inputStyle); // differentiate between either a url to hosted style json that needs an icon url,
  // or an icon already available client-side as a data uri


  var isValidUrl = (0, _utils.isValidStyleUrl)(updated.url);
  var isUpdatedIconDataUri = (_updated$icon = updated.icon) === null || _updated$icon === void 0 ? void 0 : _updated$icon.startsWith('data:image');
  var isValid = isValidUrl || Boolean(updated.uploadedFile);
  var icon = isValidUrl && !isUpdatedIconDataUri ? (0, _utils.getStyleImageIcon)({
    mapState: mapState,
    styleUrl: updated.url || '',
    mapboxApiAccessToken: updated.accessToken || state.mapboxApiAccessToken || '',
    mapboxApiUrl: state.mapboxApiUrl || _constants.DEFAULT_MAPBOX_API_URL
  }) : updated.icon;
  return _objectSpread(_objectSpread({}, state), {}, {
    inputStyle: _objectSpread(_objectSpread({}, updated), {}, {
      isValid: isValid,
      icon: icon
    })
  });
};
/**
 * Add map style from user input to reducer and set it to current style
 * This action is called when user click confirm after putting in a valid style url in the custom map style dialog.
 * It should not be called from outside kepler.gl without a valid `inputStyle` in the `mapStyle` reducer.
 * @memberof mapStyleUpdaters
 */


exports.inputMapStyleUpdater = inputMapStyleUpdater;

var addCustomMapStyleUpdater = function addCustomMapStyleUpdater(state) {
  var styleId = state.inputStyle.id;
  if (!styleId) return state;
  var newState = getNewStateWithCustomMapStyle(state); // set new style

  return mapStyleChangeUpdater(newState, {
    payload: {
      styleType: styleId
    }
  });
};
/**
 * Edit map style from user input to reducer.
 * This action is called when user clicks confirm after editing an existing custom style in the custom map style dialog.
 * It should not be called from outside kepler.gl without a valid `inputStyle` in the `mapStyle` reducer.
 * @memberof mapStyleUpdaters
 */


exports.addCustomMapStyleUpdater = addCustomMapStyleUpdater;

var editCustomMapStyleUpdater = function editCustomMapStyleUpdater(state) {
  return getNewStateWithCustomMapStyle(state);
};

exports.editCustomMapStyleUpdater = editCustomMapStyleUpdater;

function getNewStateWithCustomMapStyle(state) {
  var styleId = state.inputStyle.id;
  if (!styleId) return state;
  return _objectSpread(_objectSpread({}, state), {}, {
    // @ts-expect-error Property 'layerGroups' is missing in type 'InputStyle' but required in type 'BaseMapStyle'. Legacy case?
    mapStyles: _objectSpread(_objectSpread({}, state.mapStyles), {}, (0, _defineProperty2["default"])({}, styleId, _objectSpread(_objectSpread({}, state.mapStyles[styleId]), state.inputStyle))),
    // set to default
    inputStyle: getInitialInputStyle()
  });
}
/**
 * Remove a custom map style from `state.mapStyle.mapStyles`.
 * @memberof mapStyleUpdaters
 */


var removeCustomMapStyleUpdater = function removeCustomMapStyleUpdater(state, action) {
  var id = action.payload.id; // eslint-disable-next-line no-unused-vars

  var _state$mapStyles = state.mapStyles,
      _ = _state$mapStyles[id],
      restOfMapStyles = (0, _objectWithoutProperties2["default"])(_state$mapStyles, [id].map(_toPropertyKey));

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    mapStyles: restOfMapStyles
  });

  if (state.styleType === id) {
    // if removing a custom style that is also the current active base map,
    // then reset to the default active base map (`mapStyle.styleType`)
    return mapStyleChangeUpdater(newState, {
      payload: {
        styleType: getDefaultState().styleType
      }
    });
  }

  return newState;
};
/**
 * Updates 3d building color
 * @memberof mapStyleUpdaters
 */


exports.removeCustomMapStyleUpdater = removeCustomMapStyleUpdater;

var set3dBuildingColorUpdater = function set3dBuildingColorUpdater(state, _ref21) {
  var color = _ref21.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    threeDBuildingColor: color,
    custom3DBuildingColor: true
  });
};
/**
 * Updates background color
 * @memberof mapStyleUpdaters
 */


exports.set3dBuildingColorUpdater = set3dBuildingColorUpdater;

var setBackgroundColorUpdater = function setBackgroundColorUpdater(state, _ref22) {
  var color = _ref22.payload;
  return _objectSpread(_objectSpread({}, state), {}, {
    backgroundColor: color
  });
};
/**
 * Return the initial input style
 * @return Object
 */


exports.setBackgroundColorUpdater = setBackgroundColorUpdater;

function getInitialInputStyle() {
  return {
    id: null,
    accessToken: null,
    error: false,
    isValid: false,
    label: null,
    style: null,
    url: null,
    icon: null,
    custom: 'LOCAL',
    uploadedFile: null
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYXAtc3R5bGUtdXBkYXRlcnMudHMiXSwibmFtZXMiOlsiZ2V0RGVmYXVsdFN0YXRlIiwidmlzaWJsZUxheWVyR3JvdXBzIiwic3R5bGVUeXBlIiwidG9wTGF5ZXJHcm91cHMiLCJtYXBTdHlsZXMiLCJERUZBVUxUX01BUF9TVFlMRVMiLCJyZWR1Y2UiLCJhY2N1IiwiY3VyciIsImlkIiwibWFwYm94QXBpQWNjZXNzVG9rZW4iLCJtYXBib3hBcGlVcmwiLCJERUZBVUxUX01BUEJPWF9BUElfVVJMIiwibWFwU3R5bGVzUmVwbGFjZURlZmF1bHQiLCJpbnB1dFN0eWxlIiwiZ2V0SW5pdGlhbElucHV0U3R5bGUiLCJ0aHJlZURCdWlsZGluZ0NvbG9yIiwiREVGQVVMVF9CTERHX0NPTE9SIiwiY3VzdG9tM0RCdWlsZGluZ0NvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9SIiwiaXNMb2FkaW5nIiwiYm90dG9tTWFwU3R5bGUiLCJ1bmRlZmluZWQiLCJ0b3BNYXBTdHlsZSIsIm1hcFN0eWxlVXBkYXRlcnMiLCJJTklUSUFMX01BUF9TVFlMRSIsImdldE1hcFN0eWxlcyIsIm1hcFN0eWxlIiwic3R5bGUiLCJlZGl0YWJsZSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJoYXNUb3BMYXllciIsInZhbHVlcyIsInNvbWUiLCJ2IiwidG9wTGF5ZXJzIiwia2V5IiwiZmluZExheWVyRmlsbENvbG9yIiwibGF5ZXIiLCJwYWludCIsImdldFBhaW50Q29sb3IiLCJjb2xvciIsIkFycmF5IiwiaXNBcnJheSIsImdldDNEQnVpbGRpbmdDb2xvciIsImJhY2tncm91bmRMYXllciIsImxheWVycyIsImZpbmQiLCJidWlsZGluZ0xheWVyIiwibWF0Y2giLCJidWlsZGluZ0NvbG9yIiwib3BlcmF0aW9uIiwiYWxwaGEiLCJyZ2JPYmoiLCJyIiwiZyIsImIiLCJnZXRCYWNrZ3JvdW5kQ29sb3JGcm9tU3R5bGVCYXNlTGF5ZXIiLCJiYWNrdXBCYWNrZ3JvdW5kQ29sb3IiLCJiYXNlTGF5ZXIiLCJCQVNFX01BUF9CQUNLR1JPVU5EX0xBWUVSX0lEUyIsImluY2x1ZGVzIiwiYmFja2dyb3VuZENvbG9yT2ZCYXNlTGF5ZXIiLCJuZXdCYWNrZ3JvdW5kQ29sb3IiLCJuZXdCYWNrZ3JvdW5kQ29sb3JBc1JHQkFycmF5IiwibWFwIiwiY2hhbm5lbE51bWJlciIsIk1hdGgiLCJyb3VuZCIsImdldEJhY2tncm91bmRDb2xvciIsInByZXZpb3VzU3RhdGUiLCJwcmV2aW91c1N0YXRlTWFwU3R5bGUiLCJOT19NQVBfSUQiLCJnZXRMYXllckdyb3Vwc0Zyb21TdHlsZSIsIkRFRkFVTFRfTEFZRVJfR1JPVVBTIiwiZmlsdGVyIiwibGciLCJyZXF1ZXN0TWFwU3R5bGVzVXBkYXRlciIsInN0YXRlIiwicGF5bG9hZCIsIm9uU3VjY2VzcyIsInRvTG9hZCIsImxvYWRNYXBTdHlsZVRhc2tzIiwiZ2V0TG9hZE1hcFN0eWxlVGFza3MiLCJuZXh0U3RhdGUiLCJpbml0TWFwU3R5bGVVcGRhdGVyIiwibWFwQ29uZmlnQ2hhbmdlVXBkYXRlciIsImFjdGlvbiIsImhhc1N0eWxlT2JqZWN0IiwibWFwU3R5bGVDaGFuZ2VVcGRhdGVyIiwiY3VzdG9tIiwidXJsIiwiZGVmYXVsdExHVmlzaWJpbGl0eSIsImxvYWRNYXBTdHlsZXNVcGRhdGVyIiwibmV3U3R5bGVzIiwiYWRkTGF5ZXJHcm91cHMiLCJsYXllckdyb3VwcyIsIm5ld1N0YXRlIiwidGFza3MiLCJjcmVhdGVBY3Rpb25UYXNrIiwiXyIsImxvYWRNYXBTdHlsZUVyclVwZGF0ZXIiLCJpZHMiLCJlcnJvciIsIkNvbnNvbGUiLCJyZWNlaXZlTWFwQ29uZmlnVXBkYXRlciIsImNvbmZpZyIsIm1lcmdlZCIsIkJvb2xlYW4iLCJUYXNrIiwiYWxsIiwiYWNjZXNzVG9rZW4iLCJMT0FEX01BUF9TVFlMRV9UQVNLIiwiYmltYXAiLCJyZXN1bHRzIiwiZXJyIiwicmVzZXRNYXBDb25maWdNYXBTdHlsZVVwZGF0ZXIiLCJlbXB0eUNvbmZpZyIsImluaXRpYWxTdGF0ZSIsImxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXIiLCJpY29uIiwibGFiZWwiLCJuYW1lIiwiaW5wdXRNYXBTdHlsZVVwZGF0ZXIiLCJtYXBTdGF0ZSIsInVwZGF0ZWQiLCJpc1ZhbGlkVXJsIiwiaXNVcGRhdGVkSWNvbkRhdGFVcmkiLCJzdGFydHNXaXRoIiwiaXNWYWxpZCIsInVwbG9hZGVkRmlsZSIsInN0eWxlVXJsIiwiYWRkQ3VzdG9tTWFwU3R5bGVVcGRhdGVyIiwic3R5bGVJZCIsImdldE5ld1N0YXRlV2l0aEN1c3RvbU1hcFN0eWxlIiwiZWRpdEN1c3RvbU1hcFN0eWxlVXBkYXRlciIsInJlbW92ZUN1c3RvbU1hcFN0eWxlVXBkYXRlciIsInJlc3RPZk1hcFN0eWxlcyIsInNldDNkQnVpbGRpbmdDb2xvclVwZGF0ZXIiLCJzZXRCYWNrZ3JvdW5kQ29sb3JVcGRhdGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBYUE7O0FBU0E7O0FBQ0E7O0FBVUE7Ozs7Ozs7Ozs7QUFnQ0EsSUFBTUEsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixHQUFnQjtBQUN0QyxNQUFNQyxrQkFBa0IsR0FBRyxFQUEzQjtBQUNBLE1BQU1DLFNBQVMsR0FBRyxhQUFsQjtBQUNBLE1BQU1DLGNBQWMsR0FBRyxFQUF2QjtBQUVBLFNBQU87QUFDTEQsSUFBQUEsU0FBUyxFQUFUQSxTQURLO0FBRUxELElBQUFBLGtCQUFrQixFQUFsQkEsa0JBRks7QUFHTEUsSUFBQUEsY0FBYyxFQUFkQSxjQUhLO0FBSUxDLElBQUFBLFNBQVMsRUFBRUMsOEJBQW1CQyxNQUFuQixDQUNULFVBQUNDLElBQUQsRUFBT0MsSUFBUDtBQUFBLDZDQUNLRCxJQURMLDRDQUVHQyxJQUFJLENBQUNDLEVBRlIsRUFFYUQsSUFGYjtBQUFBLEtBRFMsRUFLVCxFQUxTLENBSk47QUFXTDtBQUNBRSxJQUFBQSxvQkFBb0IsRUFBRSxJQVpqQjtB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bnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IFRhc2ssIHt3aXRoVGFza30gZnJvbSAncmVhY3QtcGFsbS90YXNrcyc7XG5pbXBvcnQgY2xvbmVEZWVwIGZyb20gJ2xvZGFzaC5jbG9uZWRlZXAnO1xuaW1wb3J0IENvbnNvbGUgZnJvbSAnZ2xvYmFsL2NvbnNvbGUnO1xuXG4vLyBVdGlsc1xuaW1wb3J0IHtcbiAgZ2V0RGVmYXVsdExheWVyR3JvdXBWaXNpYmlsaXR5LFxuICBpc1ZhbGlkU3R5bGVVcmwsXG4gIGdldFN0eWxlRG93bmxvYWRVcmwsXG4gIG1lcmdlTGF5ZXJHcm91cFZpc2liaWxpdHksXG4gIGVkaXRUb3BNYXBTdHlsZSxcbiAgZWRpdEJvdHRvbU1hcFN0eWxlLFxuICBnZXRTdHlsZUltYWdlSWNvbixcbiAgZ2VuZXJhdGVIYXNoSWQsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGhleFRvUmdiLFxuICBjb2xvck1heWJlVG9SR0Jcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQge1xuICBERUZBVUxUX01BUF9TVFlMRVMsXG4gIERFRkFVTFRfTEFZRVJfR1JPVVBTLFxuICBERUZBVUxUX01BUEJPWF9BUElfVVJMLFxuICBOT19NQVBfSUQsXG4gIERFRkFVTFRfQkxER19DT0xPUixcbiAgREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9SLFxuICBCQVNFX01BUF9CQUNLR1JPVU5EX0xBWUVSX0lEU1xufSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge0FDVElPTl9UQVNLLCBMT0FEX01BUF9TVFlMRV9UQVNLfSBmcm9tICdAa2VwbGVyLmdsL3Rhc2tzJztcbmltcG9ydCB7cmdifSBmcm9tICdkMy1jb2xvcic7XG5cbmltcG9ydCB7XG4gIFJHQkNvbG9yLFxuICBMYXllckdyb3VwLFxuICBCYXNlTWFwU3R5bGUsXG4gIE1hcFN0eWxlcyxcbiAgSW5wdXRTdHlsZSxcbiAgVmlzaWJsZUxheWVyR3JvdXBzXG59IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuaW1wb3J0IHtcbiAgQWN0aW9uVHlwZXMsXG4gIFJlY2VpdmVNYXBDb25maWdQYXlsb2FkLFxuICBLZXBsZXJHbEluaXRQYXlsb2FkLFxuICBNYXBTdHlsZUFjdGlvbnMsXG4gIGxvYWRNYXBTdHlsZXMsXG4gIGxvYWRNYXBTdHlsZUVyclxufSBmcm9tICdAa2VwbGVyLmdsL2FjdGlvbnMnO1xuXG5leHBvcnQgdHlwZSBNYXBib3hTdHlsZVVybCA9IHN0cmluZztcblxuZXhwb3J0IHR5cGUgTWFwU3R5bGUgPSB7XG4gIHN0eWxlVHlwZTogc3RyaW5nO1xuICB2aXNpYmxlTGF5ZXJHcm91cHM6IFZpc2libGVMYXllckdyb3VwcztcbiAgdG9wTGF5ZXJHcm91cHM6IFZpc2libGVMYXllckdyb3VwcztcbiAgbWFwU3R5bGVzOiBNYXBTdHlsZXM7XG4gIC8vIHNhdmUgbWFwYm94IGFjY2VzcyB0b2tlblxuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogc3RyaW5nIHwgbnVsbDtcbiAgbWFwYm94QXBpVXJsOiBzdHJpbmc7XG4gIG1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0OiBib29sZWFuO1xuICBpbnB1dFN0eWxlOiBJbnB1dFN0eWxlO1xuICB0aHJlZURCdWlsZGluZ0NvbG9yOiBSR0JDb2xvcjtcbiAgYmFja2dyb3VuZENvbG9yOiBSR0JDb2xvcjtcbiAgY3VzdG9tM0RCdWlsZGluZ0NvbG9yOiBib29sZWFuO1xuICBib3R0b21NYXBTdHlsZTogYW55O1xuICB0b3BNYXBTdHlsZTogYW55O1xuICBpbml0aWFsU3RhdGU/OiBNYXBTdHlsZTtcbiAgaXNMb2FkaW5nOiB7XG4gICAgW2tleTogc3RyaW5nXTogYm9vbGVhbjtcbiAgfTtcbn07XG5cbmNvbnN0IGdldERlZmF1bHRTdGF0ZSA9ICgpOiBNYXBTdHlsZSA9PiB7XG4gIGNvbnN0IHZpc2libGVMYXllckdyb3VwcyA9IHt9O1xuICBjb25zdCBzdHlsZVR5cGUgPSAnZGFyay1tYXR0ZXInO1xuICBjb25zdCB0b3BMYXllckdyb3VwcyA9IHt9O1xuXG4gIHJldHVybiB7XG4gICAgc3R5bGVUeXBlLFxuICAgIHZpc2libGVMYXllckdyb3VwcyxcbiAgICB0b3BMYXllckdyb3VwcyxcbiAgICBtYXBTdHlsZXM6IERFRkFVTFRfTUFQX1NUWUxFUy5yZWR1Y2UoXG4gICAgICAoYWNjdSwgY3VycikgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgW2N1cnIuaWRdOiBjdXJyXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICAvLyBzYXZlIG1hcGJveCBhY2Nlc3MgdG9rZW5cbiAgICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogbnVsbCxcbiAgICBtYXBib3hBcGlVcmw6IERFRkFVTFRfTUFQQk9YX0FQSV9VUkwsXG4gICAgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQ6IGZhbHNlLFxuICAgIGlucHV0U3R5bGU6IGdldEluaXRpYWxJbnB1dFN0eWxlKCksXG4gICAgdGhyZWVEQnVpbGRpbmdDb2xvcjogaGV4VG9SZ2IoREVGQVVMVF9CTERHX0NPTE9SKSxcbiAgICBjdXN0b20zREJ1aWxkaW5nQ29sb3I6IGZhbHNlLFxuICAgIGJhY2tncm91bmRDb2xvcjogaGV4VG9SZ2IoREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9SKSxcbiAgICBpc0xvYWRpbmc6IHt9LFxuICAgIGJvdHRvbU1hcFN0eWxlOiB1bmRlZmluZWQsXG4gICAgdG9wTWFwU3R5bGU6IHVuZGVmaW5lZFxuICB9O1xufTtcblxuLyoqXG4gKiBVcGRhdGVycyBmb3IgYG1hcFN0eWxlYC4gQ2FuIGJlIHVzZWQgaW4geW91ciByb290IHJlZHVjZXIgdG8gZGlyZWN0bHkgbW9kaWZ5IGtlcGxlci5nbCdzIHN0YXRlLlxuICogUmVhZCBtb3JlIGFib3V0IFtVc2luZyB1cGRhdGVyc10oLi4vYWR2YW5jZWQtdXNhZ2UvdXNpbmctdXBkYXRlcnMubWQpXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBrZXBsZXJHbFJlZHVjZXIsIHttYXBTdHlsZVVwZGF0ZXJzfSBmcm9tICdrZXBsZXIuZ2wvcmVkdWNlcnMnO1xuICogLy8gUm9vdCBSZWR1Y2VyXG4gKiBjb25zdCByZWR1Y2VycyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gKiAga2VwbGVyR2w6IGtlcGxlckdsUmVkdWNlcixcbiAqICBhcHA6IGFwcFJlZHVjZXJcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGNvbXBvc2VkUmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gKiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICogICAgLy8gY2xpY2sgYnV0dG9uIHRvIGhpZGUgbGFiZWwgZnJvbSBiYWNrZ3JvdW5kIG1hcFxuICogICAgY2FzZSAnQ0xJQ0tfQlVUVE9OJzpcbiAqICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAuLi5zdGF0ZSxcbiAqICAgICAgICBrZXBsZXJHbDoge1xuICogICAgICAgICAgLi4uc3RhdGUua2VwbGVyR2wsXG4gKiAgICAgICAgICBmb286IHtcbiAqICAgICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLmZvbyxcbiAqICAgICAgICAgICAgIG1hcFN0eWxlOiBtYXBTdHlsZVVwZGF0ZXJzLm1hcENvbmZpZ0NoYW5nZVVwZGF0ZXIoXG4gKiAgICAgICAgICAgICAgIG1hcFN0eWxlLFxuICogICAgICAgICAgICAgICB7cGF5bG9hZDoge3Zpc2libGVMYXllckdyb3Vwczoge2xhYmVsOiBmYWxzZSwgcm9hZDogdHJ1ZSwgYmFja2dyb3VuZDogdHJ1ZX19fVxuICogICAgICAgICAgICAgKVxuICogICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgICAgfTtcbiAqICB9XG4gKiAgcmV0dXJuIHJlZHVjZXJzKHN0YXRlLCBhY3Rpb24pO1xuICogfTtcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjb21wb3NlZFJlZHVjZXI7XG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBtYXBTdHlsZVVwZGF0ZXJzID0gbnVsbDtcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKlxuICogRGVmYXVsdCBpbml0aWFsIGBtYXBTdHlsZWBcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAY29uc3RhbnRcbiAqIEBwcm9wZXJ0eSBzdHlsZVR5cGUgLSBEZWZhdWx0OiBgJ2RhcmsnYFxuICogQHByb3BlcnR5IHZpc2libGVMYXllckdyb3VwcyAtIERlZmF1bHQ6IGB7fWBcbiAqIEBwcm9wZXJ0eSB0b3BMYXllckdyb3VwcyAtIERlZmF1bHQ6IGB7fWBcbiAqIEBwcm9wZXJ0eSBtYXBTdHlsZXMgLSBtYXBwaW5nIGZyb20gc3R5bGUga2V5IHRvIHN0eWxlIG9iamVjdFxuICogQHByb3BlcnR5IG1hcGJveEFwaUFjY2Vzc1Rva2VuIC0gRGVmYXVsdDogYG51bGxgXG4gKiBAUHJvcGVydHkgbWFwYm94QXBpVXJsIC0gRGVmYXVsdCBudWxsXG4gKiBAUHJvcGVydHkgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQgLSBEZWZhdWx0OiBgZmFsc2VgXG4gKiBAcHJvcGVydHkgaW5wdXRTdHlsZSAtIERlZmF1bHQ6IGB7fWBcbiAqIEBwcm9wZXJ0eSB0aHJlZURCdWlsZGluZ0NvbG9yIC0gRGVmYXVsdDogYFtyLCBnLCBiXWBcbiAqIEBwcm9wZXJ0eSBiYWNrZ3JvdW5kQ29sb3IgLSBEZWZhdWx0OiBgW3IsIGcsIGJdYFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgSU5JVElBTF9NQVBfU1RZTEU6IE1hcFN0eWxlID0gZ2V0RGVmYXVsdFN0YXRlKCk7XG5cbmludGVyZmFjZSBHZXRNYXBTdHlsZXNQYXJhbSB7XG4gIHN0eWxlVHlwZTogc3RyaW5nO1xuICB2aXNpYmxlTGF5ZXJHcm91cHM6IHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufTtcbiAgdG9wTGF5ZXJHcm91cHM6IHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufTtcbiAgbWFwU3R5bGVzOiB7W2lkOiBzdHJpbmddOiBhbnl9O1xufVxuXG4vKipcbiAqIENyZWF0ZSB0d28gbWFwIHN0eWxlcyBmcm9tIHByZXNldCBtYXAgc3R5bGUsIG9uZSBmb3IgdG9wIG1hcCBvbmUgZm9yIGJvdHRvbVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVR5cGUgLSBjdXJyZW50IG1hcCBzdHlsZVxuICogQHBhcmFtIHtPYmplY3R9IHZpc2libGVMYXllckdyb3VwcyAtIHZpc2libGUgbGF5ZXJzIG9mIGJvdHRvbSBtYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b3BMYXllckdyb3VwcyAtIHZpc2libGUgbGF5ZXJzIG9mIHRvcCBtYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXBTdHlsZXMgLSBhIGRpY3Rpb25hcnkgb2YgYWxsIG1hcCBzdHlsZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGJvdHRvbU1hcFN0eWxlIHwgdG9wTWFwU3R5bGUgfCBpc1Jhc3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFwU3R5bGVzKHtcbiAgc3R5bGVUeXBlLFxuICB2aXNpYmxlTGF5ZXJHcm91cHMsXG4gIHRvcExheWVyR3JvdXBzLFxuICBtYXBTdHlsZXNcbn06IEdldE1hcFN0eWxlc1BhcmFtKSB7XG4gIGNvbnN0IG1hcFN0eWxlID0gbWFwU3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgLy8gc3R5bGUgbWlnaHQgbm90IGJlIGxvYWRlZCB5ZXRcbiAgaWYgKCFtYXBTdHlsZSB8fCAhbWFwU3R5bGUuc3R5bGUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCBlZGl0YWJsZSA9IE9iamVjdC5rZXlzKHZpc2libGVMYXllckdyb3VwcykubGVuZ3RoO1xuXG4gIGNvbnN0IGJvdHRvbU1hcFN0eWxlID0gIWVkaXRhYmxlXG4gICAgPyBtYXBTdHlsZS5zdHlsZVxuICAgIDogZWRpdEJvdHRvbU1hcFN0eWxlKHtcbiAgICAgICAgaWQ6IHN0eWxlVHlwZSxcbiAgICAgICAgbWFwU3R5bGUsXG4gICAgICAgIHZpc2libGVMYXllckdyb3Vwc1xuICAgICAgfSk7XG5cbiAgY29uc3QgaGFzVG9wTGF5ZXIgPSBlZGl0YWJsZSA+IDAgJiYgT2JqZWN0LnZhbHVlcyh0b3BMYXllckdyb3Vwcykuc29tZSh2ID0+IHYpO1xuXG4gIC8vIG11dGUgdG9wIGxheWVyIGlmIG5vdCB2aXNpYmxlIGluIGJvdHRvbSBsYXllclxuICBjb25zdCB0b3BMYXllcnMgPVxuICAgIGhhc1RvcExheWVyICYmXG4gICAgT2JqZWN0LmtleXModG9wTGF5ZXJHcm91cHMpLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiB0b3BMYXllckdyb3Vwc1trZXldICYmIHZpc2libGVMYXllckdyb3Vwc1trZXldXG4gICAgICB9KSxcbiAgICAgIHt9IGFzIHtbaWQ6IHN0cmluZ106IExheWVyR3JvdXAgfCBib29sZWFufVxuICAgICk7XG5cbiAgY29uc3QgdG9wTWFwU3R5bGUgPSBoYXNUb3BMYXllclxuICAgID8gZWRpdFRvcE1hcFN0eWxlKHtcbiAgICAgICAgaWQ6IHN0eWxlVHlwZSxcbiAgICAgICAgbWFwU3R5bGUsXG4gICAgICAgIHZpc2libGVMYXllckdyb3VwczogdG9wTGF5ZXJzXG4gICAgICB9KVxuICAgIDogbnVsbDtcblxuICByZXR1cm4ge2JvdHRvbU1hcFN0eWxlLCB0b3BNYXBTdHlsZSwgZWRpdGFibGV9O1xufVxuXG5mdW5jdGlvbiBmaW5kTGF5ZXJGaWxsQ29sb3IobGF5ZXIpIHtcbiAgcmV0dXJuIGxheWVyICYmIGxheWVyLnBhaW50ICYmIGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLWNvbG9yJ107XG59XG5cbi8vIG5lZWQgdG8gYmUgY2FyZWZ1bCBiZWNhdXNlIHNvbWUgYmFzZW1hcCBsYXllci5wYWludFsnYmFja2dyb3VuZC1jb2xvciddIHZhbHVlcyBtYXkgYmUgYW4gaW50ZXJwb2xhdGUgYXJyYXkgZXhwcmVzc2lvbiBpbnN0ZWFkIG9mIGEgY29sb3Igc3RyaW5nXG4vLyBodHRwczovL2RvY3MubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvc3R5bGUtc3BlYy9sYXllcnMvI3BhaW50LWJhY2tncm91bmQtYmFja2dyb3VuZC1jb2xvclxuLy8gaHR0cHM6Ly9kb2NzLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL3N0eWxlLXNwZWMvZXhwcmVzc2lvbnMvI2ludGVycG9sYXRlXG5mdW5jdGlvbiBnZXRQYWludENvbG9yKGNvbG9yKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSAmJiBjb2xvclswXSA9PT0gJ2ludGVycG9sYXRlJykge1xuICAgIC8vIGdldCBjb2xvciBvZiBmaXJzdCB6b29tIGJyZWFrXG4gICAgLy8gW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJ6b29tXCJdLCAxMSwgXCJoc2woMzUsIDMyJSwgOTElKVwiLCAxMywgXCJoc2woMzUsIDEyJSwgODklKVwiXVxuICAgIHJldHVybiBjb2xvcls0XTtcbiAgfVxuICByZXR1cm4gY29sb3I7XG59XG5cbmZ1bmN0aW9uIGdldDNEQnVpbGRpbmdDb2xvcihzdHlsZSk6IFJHQkNvbG9yIHtcbiAgLy8gc2V0IGJ1aWxkaW5nIGNvbG9yIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICBpZiAoIXN0eWxlLnN0eWxlKSB7XG4gICAgcmV0dXJuIGhleFRvUmdiKERFRkFVTFRfQkxER19DT0xPUik7XG4gIH1cblxuICBjb25zdCBiYWNrZ3JvdW5kTGF5ZXIgPSAoc3R5bGUuc3R5bGUubGF5ZXJzIHx8IFtdKS5maW5kKCh7aWR9KSA9PiBpZCA9PT0gJ2JhY2tncm91bmQnKTtcblxuICBjb25zdCBidWlsZGluZ0xheWVyID0gKHN0eWxlLnN0eWxlLmxheWVycyB8fCBbXSkuZmluZCgoe2lkfSkgPT4gaWQubWF0Y2goL2J1aWxkaW5nLykpO1xuXG4gIGNvbnN0IGJ1aWxkaW5nQ29sb3IgPVxuICAgIGZpbmRMYXllckZpbGxDb2xvcihidWlsZGluZ0xheWVyKSB8fCBmaW5kTGF5ZXJGaWxsQ29sb3IoYmFja2dyb3VuZExheWVyKSB8fCBERUZBVUxUX0JMREdfQ09MT1I7XG5cbiAgLy8gYnJpZ2h0ZW4gb3IgZGFya2VuIGJ1aWxkaW5nIGJhc2VkIG9uIHN0eWxlXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHN0eWxlLmlkLm1hdGNoKC8oPz0oZGFya3xuaWdodCkpLykgPyAnYnJpZ2h0ZXInIDogJ2Rhcmtlcic7XG5cbiAgY29uc3QgYWxwaGEgPSAwLjI7XG4gIGNvbnN0IHJnYk9iaiA9IHJnYihidWlsZGluZ0NvbG9yKVtvcGVyYXRpb25dKFthbHBoYV0pO1xuICByZXR1cm4gW3JnYk9iai5yLCByZ2JPYmouZywgcmdiT2JqLmJdO1xufVxuXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kQ29sb3JGcm9tU3R5bGVCYXNlTGF5ZXIoXG4gIHN0eWxlOiBCYXNlTWFwU3R5bGUsXG4gIGJhY2t1cEJhY2tncm91bmRDb2xvcjogUkdCQ29sb3Jcbik6IFJHQkNvbG9yIHtcbiAgaWYgKCFzdHlsZS5zdHlsZSkge1xuICAgIHJldHVybiBjb2xvck1heWJlVG9SR0IoYmFja3VwQmFja2dyb3VuZENvbG9yKSB8fCBiYWNrdXBCYWNrZ3JvdW5kQ29sb3I7XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yIHN0eWxlLnN0eWxlIG5vdCB0eXBlZFxuICBjb25zdCBiYXNlTGF5ZXIgPSAoc3R5bGUuc3R5bGUubGF5ZXJzIHx8IFtdKS5maW5kKCh7aWR9KSA9PlxuICAgIEJBU0VfTUFQX0JBQ0tHUk9VTkRfTEFZRVJfSURTLmluY2x1ZGVzKGlkKVxuICApO1xuXG4gIGNvbnN0IGJhY2tncm91bmRDb2xvck9mQmFzZUxheWVyID0gZ2V0UGFpbnRDb2xvcihmaW5kTGF5ZXJGaWxsQ29sb3IoYmFzZUxheWVyKSk7XG5cbiAgY29uc3QgbmV3QmFja2dyb3VuZENvbG9yID1cbiAgICB0eXBlb2YgYmFja2dyb3VuZENvbG9yT2ZCYXNlTGF5ZXIgPT09ICdzdHJpbmcnXG4gICAgICA/IGJhY2tncm91bmRDb2xvck9mQmFzZUxheWVyXG4gICAgICA6IGJhY2t1cEJhY2tncm91bmRDb2xvcjtcblxuICBjb25zdCBuZXdCYWNrZ3JvdW5kQ29sb3JBc1JHQkFycmF5ID0gY29sb3JNYXliZVRvUkdCKG5ld0JhY2tncm91bmRDb2xvcilcbiAgICAvLyBpZiBuZXdCYWNrZ3JvdW5kQ29sb3Igd2FzIGluIHN0cmluZyBIU0wgZm9ybWF0IGl0IGNhbiBpbnRyb2R1Y2UgUkdCIG51bWJlcnMgd2l0aCBkZWNpbWFscyxcbiAgICAvLyB3aGljaCBtYXkgcmVuZGVyIHRoZSBiYWNrZ3JvdW5kLWNvbG9yIENTUyBvZiB0aGUgPFN0eWxlZE1hcD4gY29udGFpbmVyIGluY29ycmVjdGx5IHdoZW4gdXNpbmcgb3VyIG93biBjb2xvciB1dGlscyBgcmdiVG9IZXgoKWBcbiAgICAvLyBzbyB3ZSBhdHRlbXB0IHRvIHJvdW5kIHRvIG5lYXJlc3QgaW50ZWdlciBoZXJlXG4gICAgPy5tYXAoY2hhbm5lbE51bWJlciA9PiBNYXRoLnJvdW5kKGNoYW5uZWxOdW1iZXIpKSBhcyBSR0JDb2xvciB8IG51bGw7XG5cbiAgcmV0dXJuIG5ld0JhY2tncm91bmRDb2xvckFzUkdCQXJyYXkgfHwgYmFja3VwQmFja2dyb3VuZENvbG9yO1xufVxuXG4vLyBkZXRlcm1pbmUgbmV3IGJhY2tncm91bmRDb2xvciBmcm9tIGVpdGhlciBwcmV2aW91cyBzdGF0ZSBiYXNlbWFwIHN0eWxlLCBwcmV2aW91cyBzdGF0ZSBiYWNrZ3JvdW5kQ29sb3IsIG9yIHRoZSBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1JcbmZ1bmN0aW9uIGdldEJhY2tncm91bmRDb2xvcihwcmV2aW91c1N0YXRlOiBNYXBTdHlsZSwgc3R5bGVUeXBlOiBzdHJpbmcpIHtcbiAgY29uc3QgcHJldmlvdXNTdGF0ZU1hcFN0eWxlID0gcHJldmlvdXNTdGF0ZS5tYXBTdHlsZXNbcHJldmlvdXNTdGF0ZS5zdHlsZVR5cGVdO1xuICBjb25zdCBiYWNrdXBCYWNrZ3JvdW5kQ29sb3IgPSBwcmV2aW91c1N0YXRlLmJhY2tncm91bmRDb2xvciB8fCBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1I7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9XG4gICAgc3R5bGVUeXBlID09PSBOT19NQVBfSURcbiAgICAgID8gLy8gaWYgdGhlIHN0eWxlIGhhcyBzd2l0Y2hlZCB0byB0aGUgXCJubyBiYXNlbWFwXCIgc3R5bGUsXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gZGV0ZWN0IGJhY2tncm91bmRDb2xvciBvZiB0aGUgcHJldmlvdXMgYmFzZW1hcCBpZiBpdCB3YXMgYSBtYXBib3ggYmFzZW1hcFxuICAgICAgICAvLyBhbmQgc2V0IGl0IGFzIHRoZSBcIm5vIGJhc2VtYXBcIiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgZ2V0QmFja2dyb3VuZENvbG9yRnJvbVN0eWxlQmFzZUxheWVyKHByZXZpb3VzU3RhdGVNYXBTdHlsZSwgYmFja3VwQmFja2dyb3VuZENvbG9yKVxuICAgICAgOiAvLyBvdGhlcndpc2UgbGVhdmUgaXQgYWxvbmUgYW5kIHJlbHkgb24gdGhlIHByZXZpb3VzIHN0YXRlJ3MgcHJlZXhpc3RpbmcgYmFja2dyb3VuZENvbG9yXG4gICAgICAgIC8vIG9yIERFRkFVTFRfQkFDS0dST1VORF9DT0xPUiBhcyBhIGxhc3QgcmVzb3J0XG4gICAgICAgIGJhY2t1cEJhY2tncm91bmRDb2xvcjtcblxuICByZXR1cm4gYmFja2dyb3VuZENvbG9yO1xufVxuXG5mdW5jdGlvbiBnZXRMYXllckdyb3Vwc0Zyb21TdHlsZShzdHlsZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdHlsZT8ubGF5ZXJzKVxuICAgID8gREVGQVVMVF9MQVlFUl9HUk9VUFMuZmlsdGVyKGxnID0+IHN0eWxlLmxheWVycy5maWx0ZXIobGcuZmlsdGVyKS5sZW5ndGgpXG4gICAgOiBbXTtcbn1cblxuLy8gVXBkYXRlcnNcblxuLyoqXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVxdWVzdE1hcFN0eWxlc1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHttYXBTdHlsZXMsIG9uU3VjY2Vzc319OiBNYXBTdHlsZUFjdGlvbnMuUmVxdWVzdE1hcFN0eWxlc1VwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+IHtcbiAgY29uc3QgdG9Mb2FkID0gT2JqZWN0LmtleXMobWFwU3R5bGVzKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGlkKSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIC4uLighc3RhdGUuaXNMb2FkaW5nW2lkXSA/IHtbaWRdOiBtYXBTdHlsZXNbaWRdfSA6IHt9KVxuICAgIH0pLFxuICAgIHt9XG4gICk7XG4gIGNvbnN0IGxvYWRNYXBTdHlsZVRhc2tzID0gZ2V0TG9hZE1hcFN0eWxlVGFza3MoXG4gICAgdG9Mb2FkLFxuICAgIHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgIHN0YXRlLm1hcGJveEFwaVVybCxcbiAgICBvblN1Y2Nlc3NcbiAgKTtcblxuICBjb25zdCBpc0xvYWRpbmcgPSBPYmplY3Qua2V5cyh0b0xvYWQpLnJlZHVjZShcbiAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIFtrZXldOiB0cnVlXG4gICAgfSksXG4gICAge31cbiAgKTtcbiAgY29uc3QgbmV4dFN0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGlzTG9hZGluZ1xuICB9O1xuICByZXR1cm4gd2l0aFRhc2sobmV4dFN0YXRlLCBsb2FkTWFwU3R5bGVUYXNrcyk7XG59O1xuXG4vKipcbiAqIFByb3BhZ2F0ZSBgbWFwU3R5bGVgIHJlZHVjZXIgd2l0aCBgbWFwYm94QXBpQWNjZXNzVG9rZW5gIGFuZCBgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHRgLlxuICogaWYgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQgaXMgdHJ1ZSBtYXBTdHlsZXMgaXMgZW1wdGllZDsgbG9hZE1hcFN0eWxlc1VwZGF0ZXIoKSB3aWxsXG4gKiBwb3B1bGF0ZSBtYXBTdHlsZXMuXG4gKlxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRNYXBTdHlsZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge1xuICAgIHBheWxvYWQgPSB7fVxuICB9OiB7XG4gICAgdHlwZT86IHR5cGVvZiBBY3Rpb25UeXBlcy5JTklUO1xuICAgIHBheWxvYWQ6IEtlcGxlckdsSW5pdFBheWxvYWQ7XG4gIH1cbik6IE1hcFN0eWxlID0+ICh7XG4gIC4uLnN0YXRlLFxuICAvLyBzYXZlIG1hcGJveCBhY2Nlc3MgdG9rZW4gdG8gbWFwIHN0eWxlIHN0YXRlXG4gIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBwYXlsb2FkLm1hcGJveEFwaUFjY2Vzc1Rva2VuIHx8IHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICBtYXBib3hBcGlVcmw6IHBheWxvYWQubWFwYm94QXBpVXJsIHx8IHN0YXRlLm1hcGJveEFwaVVybCxcbiAgbWFwU3R5bGVzOiAhcGF5bG9hZC5tYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCA/IHN0YXRlLm1hcFN0eWxlcyA6IHt9LFxuICBtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdDogcGF5bG9hZC5tYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCB8fCBmYWxzZVxufSk7XG4vLyB9KTtcblxuLyoqXG4gKiBVcGRhdGUgYHZpc2libGVMYXllckdyb3Vwc2B0byBjaGFuZ2UgbGF5ZXIgZ3JvdXAgdmlzaWJpbGl0eVxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcENvbmZpZ0NoYW5nZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAgYWN0aW9uOiBNYXBTdHlsZUFjdGlvbnMuTWFwQ29uZmlnQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogTWFwU3R5bGUgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIC4uLmFjdGlvbi5wYXlsb2FkLFxuICAgIC4uLmdldE1hcFN0eWxlcyh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLmFjdGlvbi5wYXlsb2FkXG4gICAgfSlcbiAgfTtcbn07XG5cbmNvbnN0IGhhc1N0eWxlT2JqZWN0ID0gc3R5bGUgPT4gaXNQbGFpbk9iamVjdChzdHlsZT8uc3R5bGUpO1xuXG4vKipcbiAqIENoYW5nZSB0byBhbm90aGVyIG1hcCBzdHlsZS4gVGhlIHNlbGVjdGVkIHN0eWxlIHNob3VsZCBhbHJlYWR5IGJlZW4gbG9hZGVkIGludG8gYG1hcFN0eWxlLm1hcFN0eWxlc2BcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHtzdHlsZVR5cGUsIG9uU3VjY2Vzc319OiBNYXBTdHlsZUFjdGlvbnMuTWFwU3R5bGVDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIGlmIChcbiAgICAvLyB3ZSBtaWdodCBub3QgaGF2ZSByZWNlaXZlZCB0aGUgc3R5bGUgeWV0XG4gICAgIXN0YXRlLm1hcFN0eWxlc1tzdHlsZVR5cGVdIHx8XG4gICAgLy8gb3IgaWYgaXQgaXMgYSBtYW5hZ2VkIGN1c3RvbSBzdHlsZSBhc3NldFxuICAgIC8vIGFuZCBpZiBpdCBoYXMgbm90IGJlZW4gaHlkcmF0ZWQgd2l0aCBVUkwgaW5mbyB5ZXQgKGR1cmluZyBhcHAgZmlyc3QgaW5pdGlhbGl6YXRpb24pXG4gICAgLy8gYW5kIGl0IGRvZXMgbm90IGhhdmUgYSBzdHlsZSBvYmplY3QgKGR1cmluZyBhZGRpbmcgYSBjdXN0b20gc3R5bGUpXG4gICAgKHN0YXRlLm1hcFN0eWxlc1tzdHlsZVR5cGVdPy5jdXN0b20gPT09ICdNQU5BR0VEJyAmJlxuICAgICAgIXN0YXRlLm1hcFN0eWxlc1tzdHlsZVR5cGVdPy51cmwgJiZcbiAgICAgICFoYXNTdHlsZU9iamVjdChzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXSkpXG4gICkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGlmICghaGFzU3R5bGVPYmplY3Qoc3RhdGUubWFwU3R5bGVzW3N0eWxlVHlwZV0pKSB7XG4gICAgLy8gc3R5bGUgaGFzbid0IGxvYWRlZCB5ZXRcbiAgICByZXR1cm4gcmVxdWVzdE1hcFN0eWxlc1VwZGF0ZXIoXG4gICAgICB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBzdHlsZVR5cGVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBtYXBTdHlsZXM6IHtcbiAgICAgICAgICAgIFtzdHlsZVR5cGVdOiBzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25TdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgY29uc3QgZGVmYXVsdExHVmlzaWJpbGl0eSA9IGdldERlZmF1bHRMYXllckdyb3VwVmlzaWJpbGl0eShzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXSk7XG5cbiAgY29uc3QgdmlzaWJsZUxheWVyR3JvdXBzID0gbWVyZ2VMYXllckdyb3VwVmlzaWJpbGl0eShcbiAgICBkZWZhdWx0TEdWaXNpYmlsaXR5LFxuICAgIHN0YXRlLnZpc2libGVMYXllckdyb3Vwc1xuICApO1xuXG4gIGNvbnN0IHRocmVlREJ1aWxkaW5nQ29sb3I6IFJHQkNvbG9yID0gc3RhdGUuY3VzdG9tM0RCdWlsZGluZ0NvbG9yXG4gICAgPyBzdGF0ZS50aHJlZURCdWlsZGluZ0NvbG9yXG4gICAgOiBnZXQzREJ1aWxkaW5nQ29sb3Ioc3RhdGUubWFwU3R5bGVzW3N0eWxlVHlwZV0pO1xuXG4gIC8vIGRldGVybWluZSBuZXcgYmFja2dyb3VuZENvbG9yIGZyb20gZWl0aGVyIHByZXZpb3VzIHN0YXRlIGJhc2VtYXAgc3R5bGUsIHByZXZpb3VzIHN0YXRlIGJhY2tncm91bmRDb2xvciwgb3IgdGhlIERFRkFVTFRfQkFDS0dST1VORF9DT0xPUlxuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrZ3JvdW5kQ29sb3Ioc3RhdGUsIHN0eWxlVHlwZSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBzdHlsZVR5cGUsXG4gICAgdmlzaWJsZUxheWVyR3JvdXBzLFxuICAgIHRocmVlREJ1aWxkaW5nQ29sb3IsXG4gICAgYmFja2dyb3VuZENvbG9yLFxuICAgIC4uLmdldE1hcFN0eWxlcyh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHZpc2libGVMYXllckdyb3VwcyxcbiAgICAgIHN0eWxlVHlwZVxuICAgIH0pXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIHdoZW4gbG9hZCBtYXAgc3R5bGUgc3VjY2Vzc1xuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRNYXBTdHlsZXNVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIGFjdGlvbjogTWFwU3R5bGVBY3Rpb25zLkxvYWRNYXBTdHlsZXNVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIGNvbnN0IHtuZXdTdHlsZXMsIG9uU3VjY2Vzc30gPSBhY3Rpb24ucGF5bG9hZCB8fCB7fTtcblxuICBjb25zdCBhZGRMYXllckdyb3VwcyA9IE9iamVjdC5rZXlzKG5ld1N0eWxlcykucmVkdWNlKFxuICAgIChhY2N1LCBpZCkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICBbaWRdOiB7XG4gICAgICAgIC4uLm5ld1N0eWxlc1tpZF0sXG4gICAgICAgIGxheWVyR3JvdXBzOiBuZXdTdHlsZXNbaWRdLmxheWVyR3JvdXBzIHx8IGdldExheWVyR3JvdXBzRnJvbVN0eWxlKG5ld1N0eWxlc1tpZF0uc3R5bGUpXG4gICAgICB9XG4gICAgfSksXG4gICAge31cbiAgKTtcbiAgLy8gcmVzZXQgaXNMb2FkaW5nXG4gIGNvbnN0IGlzTG9hZGluZyA9IE9iamVjdC5rZXlzKHN0YXRlLmlzTG9hZGluZykucmVkdWNlKFxuICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2N1LFxuICAgICAgLi4uKHN0YXRlLmlzTG9hZGluZ1trZXldICYmIGhhc1N0eWxlT2JqZWN0KG5ld1N0eWxlc1trZXldKVxuICAgICAgICA/IHtba2V5XTogZmFsc2V9XG4gICAgICAgIDoge1trZXldOiBzdGF0ZS5pc0xvYWRpbmdba2V5XX0pXG4gICAgfSksXG4gICAge31cbiAgKTtcbiAgLy8gYWRkIG5ldyBzdHlsZXMgdG8gc3RhdGVcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgaXNMb2FkaW5nLFxuICAgIG1hcFN0eWxlczoge1xuICAgICAgLi4uc3RhdGUubWFwU3R5bGVzLFxuICAgICAgLi4uYWRkTGF5ZXJHcm91cHNcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdGFza3MgPSBjcmVhdGVBY3Rpb25UYXNrKG9uU3VjY2Vzcywge3N0eWxlVHlwZTogc3RhdGUuc3R5bGVUeXBlfSk7XG5cbiAgY29uc3QgbmV4dFN0YXRlID0gbmV3U3R5bGVzW3N0YXRlLnN0eWxlVHlwZV1cbiAgICA/IG1hcFN0eWxlQ2hhbmdlVXBkYXRlcihuZXdTdGF0ZSwge3BheWxvYWQ6IHtzdHlsZVR5cGU6IHN0YXRlLnN0eWxlVHlwZX19KVxuICAgIDogbmV3U3RhdGU7XG5cbiAgcmV0dXJuIHRhc2tzID8gd2l0aFRhc2sobmV4dFN0YXRlLCB0YXNrcykgOiBuZXh0U3RhdGU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25UYXNrKGFjdGlvbiwgcGF5bG9hZCkge1xuICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBQ1RJT05fVEFTSygpLm1hcChfID0+IGFjdGlvbihwYXlsb2FkKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayB3aGVuIGxvYWQgbWFwIHN0eWxlIGVycm9yXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG4vLyBkbyBub3RoaW5nIGZvciBub3csIGlmIGRpZG4ndCBsb2FkLCBza2lwIGl0XG5leHBvcnQgY29uc3QgbG9hZE1hcFN0eWxlRXJyVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0eWxlLFxuICB7cGF5bG9hZDoge2lkcywgZXJyb3J9fTogTWFwU3R5bGVBY3Rpb25zLkxvYWRNYXBTdHlsZUVyclVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+IHtcbiAgQ29uc29sZS5lcnJvcihlcnJvcik7XG4gIC8vIHJlc2V0IGlzTG9hZGluZ1xuICBjb25zdCBpc0xvYWRpbmcgPSBPYmplY3Qua2V5cyhzdGF0ZS5pc0xvYWRpbmcpLnJlZHVjZShcbiAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIC4uLihzdGF0ZS5pc0xvYWRpbmdba2V5XSAmJiAoaWRzIHx8IFtdKS5pbmNsdWRlcyhrZXkpXG4gICAgICAgID8ge1trZXldOiBmYWxzZX1cbiAgICAgICAgOiB7W2tleV06IHN0YXRlLmlzTG9hZGluZ1trZXldfSlcbiAgICB9KSxcbiAgICB7fVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgaXNMb2FkaW5nXG4gIH07XG59O1xuXG4vKipcbiAqIExvYWQgbWFwIHN0eWxlIG9iamVjdCB3aGVuIHBhc3MgaW4gc2F2ZWQgbWFwIGNvbmZpZ1xuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwYXJhbSBzdGF0ZSBgbWFwU3R5bGVgXG4gKiBAcGFyYW0gYWN0aW9uXG4gKiBAcGFyYW0gYWN0aW9uLnBheWxvYWQgc2F2ZWQgbWFwIGNvbmZpZyBge21hcFN0eWxlLCB2aXNTdGF0ZSwgbWFwU3RhdGV9YFxuICogQHJldHVybnMgbmV4dFN0YXRlIG9yIGByZWFjdC1wYW1gIHRhc2tzIHRvIGxvYWQgbWFwIHN0eWxlIG9iamVjdFxuICovXG5leHBvcnQgY29uc3QgcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge1xuICAgIHBheWxvYWQ6IHtjb25maWd9XG4gIH06IHtcbiAgICB0eXBlPzogdHlwZW9mIEFjdGlvblR5cGVzLlJFQ0VJVkVfTUFQX0NPTkZJRztcbiAgICBwYXlsb2FkOiBSZWNlaXZlTWFwQ29uZmlnUGF5bG9hZDtcbiAgfVxuKTogTWFwU3R5bGUgPT4ge1xuICBjb25zdCB7bWFwU3R5bGV9ID0gY29uZmlnIHx8IHt9O1xuXG4gIGlmICghbWFwU3R5bGUpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvLyBtZXJnZSBkZWZhdWx0IG1hcFN0eWxlc1xuICBjb25zdCBtZXJnZWQgPSBtYXBTdHlsZS5tYXBTdHlsZXNcbiAgICA/IHtcbiAgICAgICAgLi4ubWFwU3R5bGUsXG4gICAgICAgIG1hcFN0eWxlczoge1xuICAgICAgICAgIC4uLm1hcFN0eWxlLm1hcFN0eWxlcyxcbiAgICAgICAgICAuLi5zdGF0ZS5tYXBTdHlsZXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIDogbWFwU3R5bGU7XG5cbiAgLy8gc2V0IGN1c3RvbTNEQnVpbGRpbmdDb2xvcjogdHJ1ZSBpZiBtYXBTdHlsZSBjb250YWlucyB0aHJlZURCdWlsZGluZ0NvbG9yXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgbWVyZ2VkLmN1c3RvbTNEQnVpbGRpbmdDb2xvciA9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIEJvb2xlYW4obWFwU3R5bGUudGhyZWVEQnVpbGRpbmdDb2xvcikgfHwgbWVyZ2VkLmN1c3RvbTNEQnVpbGRpbmdDb2xvcjtcbiAgY29uc3QgbmV3U3RhdGUgPSBtYXBDb25maWdDaGFuZ2VVcGRhdGVyKHN0YXRlLCB7cGF5bG9hZDogbWVyZ2VkfSk7XG5cbiAgcmV0dXJuIG1hcFN0eWxlQ2hhbmdlVXBkYXRlcihuZXdTdGF0ZSwge3BheWxvYWQ6IHtzdHlsZVR5cGU6IG5ld1N0YXRlLnN0eWxlVHlwZX19KTtcbn07XG5cbmZ1bmN0aW9uIGdldExvYWRNYXBTdHlsZVRhc2tzKG1hcFN0eWxlcywgbWFwYm94QXBpQWNjZXNzVG9rZW4sIG1hcGJveEFwaVVybCwgb25TdWNjZXNzKSB7XG4gIHJldHVybiBbXG4gICAgVGFzay5hbGwoXG4gICAgICBPYmplY3QudmFsdWVzKG1hcFN0eWxlcylcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAubWFwKCh7aWQsIHVybCwgYWNjZXNzVG9rZW59KSA9PiAoe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHVybDogaXNWYWxpZFN0eWxlVXJsKHVybClcbiAgICAgICAgICAgID8gZ2V0U3R5bGVEb3dubG9hZFVybCh1cmwsIGFjY2Vzc1Rva2VuIHx8IG1hcGJveEFwaUFjY2Vzc1Rva2VuLCBtYXBib3hBcGlVcmwpXG4gICAgICAgICAgICA6IHVybFxuICAgICAgICB9KSlcbiAgICAgICAgLm1hcChMT0FEX01BUF9TVFlMRV9UQVNLKVxuICAgICkuYmltYXAoXG4gICAgICAvLyBzdWNjZXNzXG4gICAgICByZXN1bHRzID0+XG4gICAgICAgIGxvYWRNYXBTdHlsZXMoXG4gICAgICAgICAgcmVzdWx0cy5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjdSwge2lkLCBzdHlsZX0pID0+ICh7XG4gICAgICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgICAgIFtpZF06IHtcbiAgICAgICAgICAgICAgICAuLi5tYXBTdHlsZXNbaWRdLFxuICAgICAgICAgICAgICAgIHN0eWxlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAge31cbiAgICAgICAgICApLFxuICAgICAgICAgIG9uU3VjY2Vzc1xuICAgICAgICApLFxuICAgICAgLy8gZXJyb3JcbiAgICAgIGVyciA9PiBsb2FkTWFwU3R5bGVFcnIoT2JqZWN0LmtleXMobWFwU3R5bGVzKSwgZXJyKVxuICAgIClcbiAgXTtcbn1cbi8qKlxuICogUmVzZXQgbWFwIHN0eWxlIGNvbmZpZyB0byBpbml0aWFsIHN0YXRlXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHBhcmFtIHN0YXRlIGBtYXBTdHlsZWBcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVzZXRNYXBDb25maWdNYXBTdHlsZVVwZGF0ZXIgPSAoc3RhdGU6IE1hcFN0eWxlKTogTWFwU3R5bGUgPT4ge1xuICBjb25zdCBlbXB0eUNvbmZpZyA9IHtcbiAgICAuLi5JTklUSUFMX01BUF9TVFlMRSxcbiAgICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogc3RhdGUubWFwYm94QXBpQWNjZXNzVG9rZW4sXG4gICAgbWFwYm94QXBpVXJsOiBzdGF0ZS5tYXBib3hBcGlVcmwsXG4gICAgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQ6IHN0YXRlLm1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0LFxuICAgIC4uLnN0YXRlLmluaXRpYWxTdGF0ZSxcbiAgICBtYXBTdHlsZXM6IHN0YXRlLm1hcFN0eWxlcyxcbiAgICBpbml0aWFsU3RhdGU6IHN0YXRlLmluaXRpYWxTdGF0ZVxuICB9O1xuXG4gIHJldHVybiBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIoZW1wdHlDb25maWcsIHtwYXlsb2FkOiB7c3R5bGVUeXBlOiBlbXB0eUNvbmZpZy5zdHlsZVR5cGV9fSk7XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIHdoZW4gYSBjdXN0b20gbWFwIHN0eWxlIG9iamVjdCBpcyByZWNlaXZlZFxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAge3BheWxvYWQ6IHtpY29uLCBzdHlsZSwgZXJyb3J9fTogTWFwU3R5bGVBY3Rpb25zLkxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXJBY3Rpb25cbik6IE1hcFN0eWxlID0+ICh7XG4gIC4uLnN0YXRlLFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGlucHV0U3R5bGU6IHtcbiAgICAuLi5zdGF0ZS5pbnB1dFN0eWxlLFxuICAgIC8vIHN0eWxlIGpzb24gYW5kIGljb24gd2lsbCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgLi4uKHN0eWxlXG4gICAgICA/IHtcbiAgICAgICAgICBpZDpcbiAgICAgICAgICAgIHN0YXRlLmlucHV0U3R5bGUuY3VzdG9tID09PSAnTUFOQUdFRCdcbiAgICAgICAgICAgICAgPyBzdGF0ZS5pbnB1dFN0eWxlLmlkIC8vIGN1c3RvbSBNQU5BR0VEIHR5cGVcbiAgICAgICAgICAgICAgOiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgc3R5bGUuaWQgfHwgZ2VuZXJhdGVIYXNoSWQoKSwgLy8gY3VzdG9tIExPQ0FMIHR5cGVcbiAgICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICAgICAgc3R5bGU6IGNsb25lRGVlcChzdHlsZSksXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGxhYmVsOiBzdGF0ZS5pbnB1dFN0eWxlLmxhYmVsIHx8IHN0eWxlLm5hbWUsXG4gICAgICAgICAgLy8gZ2F0aGVyaW5nIGxheWVyIGdyb3VwIGluZm8gZnJvbSBzdHlsZSBqc29uXG4gICAgICAgICAgbGF5ZXJHcm91cHM6IGdldExheWVyR3JvdXBzRnJvbVN0eWxlKHN0eWxlKVxuICAgICAgICB9XG4gICAgICA6IHt9KSxcbiAgICAuLi4oaWNvbiA/IHtpY29ufSA6IHt9KSxcbiAgICAuLi4oZXJyb3IgPyB7ZXJyb3J9IDoge30pXG4gIH1cbn0pO1xuXG4vKipcbiAqIElucHV0IGEgY3VzdG9tIG1hcCBzdHlsZSBvYmplY3RcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBpbnB1dE1hcFN0eWxlVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0eWxlLFxuICB7cGF5bG9hZDoge2lucHV0U3R5bGUsIG1hcFN0YXRlfX06IE1hcFN0eWxlQWN0aW9ucy5JbnB1dE1hcFN0eWxlVXBkYXRlckFjdGlvblxuKTogTWFwU3R5bGUgPT4ge1xuICBjb25zdCB1cGRhdGVkID0ge1xuICAgIC4uLnN0YXRlLmlucHV0U3R5bGUsXG4gICAgLi4uaW5wdXRTdHlsZVxuICB9O1xuXG4gIC8vIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBlaXRoZXIgYSB1cmwgdG8gaG9zdGVkIHN0eWxlIGpzb24gdGhhdCBuZWVkcyBhbiBpY29uIHVybCxcbiAgLy8gb3IgYW4gaWNvbiBhbHJlYWR5IGF2YWlsYWJsZSBjbGllbnQtc2lkZSBhcyBhIGRhdGEgdXJpXG4gIGNvbnN0IGlzVmFsaWRVcmwgPSBpc1ZhbGlkU3R5bGVVcmwodXBkYXRlZC51cmwpO1xuICBjb25zdCBpc1VwZGF0ZWRJY29uRGF0YVVyaSA9IHVwZGF0ZWQuaWNvbj8uc3RhcnRzV2l0aCgnZGF0YTppbWFnZScpO1xuICBjb25zdCBpc1ZhbGlkID0gaXNWYWxpZFVybCB8fCBCb29sZWFuKHVwZGF0ZWQudXBsb2FkZWRGaWxlKTtcblxuICBjb25zdCBpY29uID1cbiAgICBpc1ZhbGlkVXJsICYmICFpc1VwZGF0ZWRJY29uRGF0YVVyaVxuICAgICAgPyBnZXRTdHlsZUltYWdlSWNvbih7XG4gICAgICAgICAgbWFwU3RhdGUsXG4gICAgICAgICAgc3R5bGVVcmw6IHVwZGF0ZWQudXJsIHx8ICcnLFxuICAgICAgICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiB1cGRhdGVkLmFjY2Vzc1Rva2VuIHx8IHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuIHx8ICcnLFxuICAgICAgICAgIG1hcGJveEFwaVVybDogc3RhdGUubWFwYm94QXBpVXJsIHx8IERFRkFVTFRfTUFQQk9YX0FQSV9VUkxcbiAgICAgICAgfSlcbiAgICAgIDogdXBkYXRlZC5pY29uO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgaW5wdXRTdHlsZToge1xuICAgICAgLi4udXBkYXRlZCxcbiAgICAgIGlzVmFsaWQsXG4gICAgICBpY29uXG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBBZGQgbWFwIHN0eWxlIGZyb20gdXNlciBpbnB1dCB0byByZWR1Y2VyIGFuZCBzZXQgaXQgdG8gY3VycmVudCBzdHlsZVxuICogVGhpcyBhY3Rpb24gaXMgY2FsbGVkIHdoZW4gdXNlciBjbGljayBjb25maXJtIGFmdGVyIHB1dHRpbmcgaW4gYSB2YWxpZCBzdHlsZSB1cmwgaW4gdGhlIGN1c3RvbSBtYXAgc3R5bGUgZGlhbG9nLlxuICogSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZnJvbSBvdXRzaWRlIGtlcGxlci5nbCB3aXRob3V0IGEgdmFsaWQgYGlucHV0U3R5bGVgIGluIHRoZSBgbWFwU3R5bGVgIHJlZHVjZXIuXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICovXG5leHBvcnQgY29uc3QgYWRkQ3VzdG9tTWFwU3R5bGVVcGRhdGVyID0gKHN0YXRlOiBNYXBTdHlsZSk6IE1hcFN0eWxlID0+IHtcbiAgY29uc3Qgc3R5bGVJZCA9IHN0YXRlLmlucHV0U3R5bGUuaWQ7XG4gIGlmICghc3R5bGVJZCkgcmV0dXJuIHN0YXRlO1xuXG4gIGNvbnN0IG5ld1N0YXRlID0gZ2V0TmV3U3RhdGVXaXRoQ3VzdG9tTWFwU3R5bGUoc3RhdGUpO1xuICAvLyBzZXQgbmV3IHN0eWxlXG4gIHJldHVybiBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIobmV3U3RhdGUsIHtwYXlsb2FkOiB7c3R5bGVUeXBlOiBzdHlsZUlkfX0pO1xufTtcblxuLyoqXG4gKiBFZGl0IG1hcCBzdHlsZSBmcm9tIHVzZXIgaW5wdXQgdG8gcmVkdWNlci5cbiAqIFRoaXMgYWN0aW9uIGlzIGNhbGxlZCB3aGVuIHVzZXIgY2xpY2tzIGNvbmZpcm0gYWZ0ZXIgZWRpdGluZyBhbiBleGlzdGluZyBjdXN0b20gc3R5bGUgaW4gdGhlIGN1c3RvbSBtYXAgc3R5bGUgZGlhbG9nLlxuICogSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZnJvbSBvdXRzaWRlIGtlcGxlci5nbCB3aXRob3V0IGEgdmFsaWQgYGlucHV0U3R5bGVgIGluIHRoZSBgbWFwU3R5bGVgIHJlZHVjZXIuXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICovXG5leHBvcnQgY29uc3QgZWRpdEN1c3RvbU1hcFN0eWxlVXBkYXRlciA9IChzdGF0ZTogTWFwU3R5bGUpOiBNYXBTdHlsZSA9PiB7XG4gIHJldHVybiBnZXROZXdTdGF0ZVdpdGhDdXN0b21NYXBTdHlsZShzdGF0ZSk7XG59O1xuXG5mdW5jdGlvbiBnZXROZXdTdGF0ZVdpdGhDdXN0b21NYXBTdHlsZShzdGF0ZTogTWFwU3R5bGUpOiBNYXBTdHlsZSB7XG4gIGNvbnN0IHN0eWxlSWQgPSBzdGF0ZS5pbnB1dFN0eWxlLmlkO1xuICBpZiAoIXN0eWxlSWQpIHJldHVybiBzdGF0ZTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgUHJvcGVydHkgJ2xheWVyR3JvdXBzJyBpcyBtaXNzaW5nIGluIHR5cGUgJ0lucHV0U3R5bGUnIGJ1dCByZXF1aXJlZCBpbiB0eXBlICdCYXNlTWFwU3R5bGUnLiBMZWdhY3kgY2FzZT9cbiAgICBtYXBTdHlsZXM6IHtcbiAgICAgIC4uLnN0YXRlLm1hcFN0eWxlcyxcbiAgICAgIFtzdHlsZUlkXToge1xuICAgICAgICAuLi5zdGF0ZS5tYXBTdHlsZXNbc3R5bGVJZF0sIC8vIGRvIG5vdCB1bmludGVudGlvbmFsbHkgZHJvcCBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gICAgICAgIC4uLnN0YXRlLmlucHV0U3R5bGVcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIHNldCB0byBkZWZhdWx0XG4gICAgaW5wdXRTdHlsZTogZ2V0SW5pdGlhbElucHV0U3R5bGUoKVxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGN1c3RvbSBtYXAgc3R5bGUgZnJvbSBgc3RhdGUubWFwU3R5bGUubWFwU3R5bGVzYC5cbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVDdXN0b21NYXBTdHlsZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdHlsZSxcbiAgYWN0aW9uOiBNYXBTdHlsZUFjdGlvbnMuUmVtb3ZlQ3VzdG9tTWFwU3R5bGVVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiB7XG4gIGNvbnN0IHtpZH0gPSBhY3Rpb24ucGF5bG9hZDtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgY29uc3Qge1tpZF06IF8sIC4uLnJlc3RPZk1hcFN0eWxlc30gPSBzdGF0ZS5tYXBTdHlsZXM7XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgbWFwU3R5bGVzOiByZXN0T2ZNYXBTdHlsZXNcbiAgfTtcblxuICBpZiAoc3RhdGUuc3R5bGVUeXBlID09PSBpZCkge1xuICAgIC8vIGlmIHJlbW92aW5nIGEgY3VzdG9tIHN0eWxlIHRoYXQgaXMgYWxzbyB0aGUgY3VycmVudCBhY3RpdmUgYmFzZSBtYXAsXG4gICAgLy8gdGhlbiByZXNldCB0byB0aGUgZGVmYXVsdCBhY3RpdmUgYmFzZSBtYXAgKGBtYXBTdHlsZS5zdHlsZVR5cGVgKVxuICAgIHJldHVybiBtYXBTdHlsZUNoYW5nZVVwZGF0ZXIobmV3U3RhdGUsIHtwYXlsb2FkOiB7c3R5bGVUeXBlOiBnZXREZWZhdWx0U3RhdGUoKS5zdHlsZVR5cGV9fSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgM2QgYnVpbGRpbmcgY29sb3JcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBzZXQzZEJ1aWxkaW5nQ29sb3JVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3R5bGUsXG4gIHtwYXlsb2FkOiBjb2xvcn06IE1hcFN0eWxlQWN0aW9ucy5TZXQzZEJ1aWxkaW5nQ29sb3JVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdHlsZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgdGhyZWVEQnVpbGRpbmdDb2xvcjogY29sb3IsXG4gIGN1c3RvbTNEQnVpbGRpbmdDb2xvcjogdHJ1ZVxufSk7XG5cbi8qKlxuICogVXBkYXRlcyBiYWNrZ3JvdW5kIGNvbG9yXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICovXG5leHBvcnQgY29uc3Qgc2V0QmFja2dyb3VuZENvbG9yVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0eWxlLFxuICB7cGF5bG9hZDogY29sb3J9OiBNYXBTdHlsZUFjdGlvbnMuU2V0QmFja2dyb3VuZENvbG9yVXBkYXRlckFjdGlvblxuKTogTWFwU3R5bGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGJhY2tncm91bmRDb2xvcjogY29sb3Jcbn0pO1xuXG4vKipcbiAqIFJldHVybiB0aGUgaW5pdGlhbCBpbnB1dCBzdHlsZVxuICogQHJldHVybiBPYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluaXRpYWxJbnB1dFN0eWxlKCk6IElucHV0U3R5bGUge1xuICByZXR1cm4ge1xuICAgIGlkOiBudWxsLFxuICAgIGFjY2Vzc1Rva2VuOiBudWxsLFxuICAgIGVycm9yOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICBsYWJlbDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICB1cmw6IG51bGwsXG4gICAgaWNvbjogbnVsbCxcbiAgICBjdXN0b206ICdMT0NBTCcsXG4gICAgdXBsb2FkZWRGaWxlOiBudWxsXG4gIH07XG59XG4iXX0=