"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var utils = _interopRequireWildcard(require("./utils"));

var header = _interopRequireWildcard(require("./header"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var blockSize;
var recordSize = 512;

var Tar = function () {
  function Tar(recordsPerBlock) {
    (0, _classCallCheck2.default)(this, Tar);
    (0, _defineProperty2.default)(this, "blocks", void 0);
    this.written = 0;
    blockSize = (recordsPerBlock || 20) * recordSize;
    this.out = utils.clean(blockSize);
    this.blocks = [];
    this.length = 0;
    this.save = this.save.bind(this);
    this.clear = this.clear.bind(this);
    this.append = this.append.bind(this);
  }

  (0, _createClass2.default)(Tar, [{
    key: "append",
    value: function append(filepath, input, opts) {
      var checksum;

      if (typeof input === 'string') {
        input = utils.stringToUint8(input);
      } else if (input.constructor !== Uint8Array.prototype.constructor) {
        var errorInput = input.constructor.toString().match(/function\s*([$A-Za-z_][0-9A-Za-z_]*)\s*\(/)[1];
        var errorMessage = "Invalid input type. You gave me: ".concat(errorInput);
        throw errorMessage;
      }

      opts = opts || {};
      var mode = opts.mode || parseInt('777', 8) & 0xfff;
      var mtime = opts.mtime || Math.floor(Number(new Date()) / 1000);
      var uid = opts.uid || 0;
      var gid = opts.gid || 0;
      var data = {
        fileName: filepath,
        fileMode: utils.pad(mode, 7),
        uid: utils.pad(uid, 7),
        gid: utils.pad(gid, 7),
        fileSize: utils.pad(input.length, 11),
        mtime: utils.pad(mtime, 11),
        checksum: '        ',
        type: '0',
        ustar: 'ustar  ',
        owner: opts.owner || '',
        group: opts.group || ''
      };
      checksum = 0;
      Object.keys(data).forEach(function (key) {
        var i;
        var value = data[key];
        var length;

        for (i = 0, length = value.length; i < length; i += 1) {
          checksum += value.charCodeAt(i);
        }
      });
      data.checksum = "".concat(utils.pad(checksum, 6), "\0 ");
      var headerArr = header.format(data);
      var headerLength = Math.ceil(headerArr.length / recordSize) * recordSize;
      var inputLength = Math.ceil(input.length / recordSize) * recordSize;
      this.blocks.push({
        header: headerArr,
        input: input,
        headerLength: headerLength,
        inputLength: inputLength
      });
    }
  }, {
    key: "save",
    value: function save() {
      var buffers = [];
      var chunks = [];
      var length = 0;
      var max = Math.pow(2, 20);
      var chunk = [];
      this.blocks.forEach(function (b) {
        if (length + b.headerLength + b.inputLength > max) {
          chunks.push({
            blocks: chunk,
            length: length
          });
          chunk = [];
          length = 0;
        }

        chunk.push(b);
        length += b.headerLength + b.inputLength;
      });
      chunks.push({
        blocks: chunk,
        length: length
      });
      chunks.forEach(function (c) {
        var buffer = new Uint8Array(c.length);
        var written = 0;
        c.blocks.forEach(function (b) {
          buffer.set(b.header, written);
          written += b.headerLength;
          buffer.set(b.input, written);
          written += b.inputLength;
        });
        buffers.push(buffer);
      });
      buffers.push(new Uint8Array(2 * recordSize));
      return new Blob(buffers, {
        type: 'octet/stream'
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      this.written = 0;
      this.out = utils.clean(blockSize);
    }
  }]);
  return Tar;
}();

var _default = Tar;
exports.default = _default;
//# sourceMappingURL=tar.js.map