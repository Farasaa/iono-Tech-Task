"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseGeoJsonRawFeature = parseGeoJsonRawFeature;
exports.getGeojsonLayerMeta = getGeojsonLayerMeta;
exports.getGeojsonDataMaps = getGeojsonDataMaps;
exports.parseGeometryFromString = parseGeometryFromString;
exports.getGeojsonBounds = getGeojsonBounds;
exports.getGeojsonFeatureTypes = getGeojsonFeatureTypes;
exports.featureToDeckGlGeoType = exports.FeatureTypes = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _geojsonNormalize = _interopRequireDefault(require("@mapbox/geojson-normalize"));

var _bbox = _interopRequireDefault(require("@turf/bbox"));

var _center = _interopRequireDefault(require("@turf/center"));

var _core = require("@loaders.gl/core");

var _wkt = require("@loaders.gl/wkt");

var _gis = require("@loaders.gl/gis");

var _utils = require("@kepler.gl/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* eslint-disable */
// TODO: Re-enable eslint when we upgrade to handle enums and type maps
var FeatureTypes;
/* eslint-enable */

exports.FeatureTypes = FeatureTypes;

(function (FeatureTypes) {
  FeatureTypes["Point"] = "Point";
  FeatureTypes["MultiPoint"] = "MultiPoint";
  FeatureTypes["LineString"] = "LineString";
  FeatureTypes["MultiLineString"] = "MultiLineString";
  FeatureTypes["Polygon"] = "Polygon";
  FeatureTypes["MultiPolygon"] = "MultiPolygon";
})(FeatureTypes || (exports.FeatureTypes = FeatureTypes = {}));

function parseGeoJsonRawFeature(rawFeature) {
  if ((0, _typeof2["default"])(rawFeature) === 'object') {
    // Support GeoJson feature as object
    // probably need to normalize it as well
    var normalized = (0, _geojsonNormalize["default"])(rawFeature);

    if (!normalized || !Array.isArray(normalized.features)) {
      // fail to normalize GeoJson
      return null;
    }

    return normalized.features[0];
  } else if (typeof rawFeature === 'string') {
    return parseGeometryFromString(rawFeature);
  } else if (Array.isArray(rawFeature)) {
    // Support GeoJson  LineString as an array of points
    return {
      type: 'Feature',
      geometry: {
        // why do we need to flip it...
        coordinates: rawFeature.map(function (pts) {
          return [pts[1], pts[0]];
        }),
        type: 'LineString'
      },
      properties: {}
    };
  }

  return null;
}

function getGeojsonLayerMeta(_ref) {
  var dataContainer = _ref.dataContainer,
      getFeature = _ref.getFeature;
  var dataToFeature = getGeojsonDataMaps(dataContainer, getFeature); // get bounds from features

  var bounds = getGeojsonBounds(dataToFeature); // if any of the feature has properties.radius set to be true

  var fixedRadius = Boolean(dataToFeature.find(function (d) {
    var _d$properties;

    return d && 'properties' in d && ((_d$properties = d.properties) === null || _d$properties === void 0 ? void 0 : _d$properties.radius);
  })); // keep a record of what type of geometry the collection has

  var featureTypes = getGeojsonFeatureTypes(dataToFeature);
  var meanCenters = [];

  for (var i = 0; i < dataToFeature.length; i++) {
    var feature = dataToFeature[i];

    if (feature) {
      try {
        // TODO: use line interpolate to get center of line for LineString
        var cent = (0, _center["default"])(feature);
        meanCenters.push(cent.geometry.coordinates);
      } catch (e) {
        meanCenters.push(null);
      }
    }
  }

  return {
    dataToFeature: dataToFeature,
    bounds: bounds,
    fixedRadius: fixedRadius,
    featureTypes: featureTypes,
    centroids: meanCenters
  };
}
/**
 * Parse raw data to GeoJson feature
 * @param dataContainer
 * @param getFeature
 * @returns {{}}
 */


function getGeojsonDataMaps(dataContainer, getFeature) {
  var acceptableTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon', 'GeometryCollection'];
  var dataToFeature = [];

  for (var index = 0; index < dataContainer.numRows(); index++) {
    var feature = parseGeoJsonRawFeature(getFeature({
      index: index
    }));

    if (feature && feature.geometry && acceptableTypes.includes(feature.geometry.type)) {
      var cleaned = _objectSpread(_objectSpread({}, feature), {}, {
        // store index of the data in feature properties
        properties: _objectSpread(_objectSpread({}, feature.properties), {}, {
          index: index
        })
      });

      dataToFeature[index] = cleaned;
    } else {
      dataToFeature[index] = null;
    }
  }

  return dataToFeature;
}
/**
 * Parse geojson from string
 * @param {String} geoString
 * @returns {null | Object} geojson object or null if failed
 */


function parseGeometryFromString(geoString) {
  var parsedGeo; // try parse as geojson string
  // {"type":"Polygon","coordinates":[[[-74.158491,40.83594]]]}

  try {
    parsedGeo = JSON.parse(geoString);
  } catch (e) {// keep trying to parse
  } // try parse as wkt using loaders.gl WKTLoader


  if (!parsedGeo) {
    try {
      parsedGeo = (0, _core.parseSync)(geoString, _wkt.WKTLoader);
    } catch (e) {
      return null;
    }
  } // try parse as wkb using loaders.gl WKBLoader


  if (!parsedGeo) {
    try {
      var buffer = Buffer.from(geoString, 'hex');
      var binaryGeo = (0, _core.parseSync)(buffer, _wkt.WKBLoader); // @ts-expect-error

      parsedGeo = (0, _gis.binaryToGeometry)(binaryGeo);
    } catch (e) {
      return null;
    }
  }

  if (!parsedGeo) {
    return null;
  }

  var normalized = (0, _geojsonNormalize["default"])(parsedGeo);

  if (!normalized || !Array.isArray(normalized.features)) {
    // fail to normalize geojson
    return null;
  }

  return normalized.features[0];
}

function getGeojsonBounds() {
  var features = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  // 70 ms for 10,000 polygons
  // here we only pick couple
  var maxCount = 10000;
  var samples = features.length > maxCount ? (0, _utils.getSampleData)(features, maxCount) : features;
  var nonEmpty = samples.filter(function (d) {
    return d && d.geometry && d.geometry.coordinates && d.geometry.coordinates.length;
  });

  try {
    return (0, _bbox["default"])({
      type: 'FeatureCollection',
      features: nonEmpty
    });
  } catch (e) {
    return null;
  }
}

var featureToDeckGlGeoType = {
  Point: 'point',
  MultiPoint: 'point',
  LineString: 'line',
  MultiLineString: 'line',
  Polygon: 'polygon',
  MultiPolygon: 'polygon'
};
exports.featureToDeckGlGeoType = featureToDeckGlGeoType;

/**
 * Parse geojson from string
 * @param {Array<Object>} allFeatures
 * @returns {Object} mapping of feature type existence
 */
function getGeojsonFeatureTypes(allFeatures) {
  // @ts-expect-error some test cases only have 1 geotype
  var featureTypes = {};

  for (var f = 0; f < allFeatures.length; f++) {
    var feature = allFeatures[f];

    if (feature && 'geometry' in feature) {
      var geoType = featureToDeckGlGeoType[feature.geometry && feature.geometry.type];

      if (geoType) {
        featureTypes[geoType] = true;
      }
    }
  }

  return featureTypes;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZW9qc29uLWxheWVyL2dlb2pzb24tdXRpbHMudHMiXSwibmFtZXMiOlsiRmVhdHVyZVR5cGVzIiwicGFyc2VHZW9Kc29uUmF3RmVhdHVyZSIsInJhd0ZlYXR1cmUiLCJub3JtYWxpemVkIiwiQXJyYXkiLCJpc0FycmF5IiwiZmVhdHVyZXMiLCJwYXJzZUdlb21ldHJ5RnJvbVN0cmluZyIsInR5cGUiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwibWFwIiwicHRzIiwicHJvcGVydGllcyIsImdldEdlb2pzb25MYXllck1ldGEiLCJkYXRhQ29udGFpbmVyIiwiZ2V0RmVhdHVyZSIsImRhdGFUb0ZlYXR1cmUiLCJnZXRHZW9qc29uRGF0YU1hcHMiLCJib3VuZHMiLCJnZXRHZW9qc29uQm91bmRzIiwiZml4ZWRSYWRpdXMiLCJCb29sZWFuIiwiZmluZCIsImQiLCJyYWRpdXMiLCJmZWF0dXJlVHlwZXMiLCJnZXRHZW9qc29uRmVhdHVyZVR5cGVzIiwibWVhbkNlbnRlcnMiLCJpIiwibGVuZ3RoIiwiZmVhdHVyZSIsImNlbnQiLCJwdXNoIiwiZSIsImNlbnRyb2lkcyIsImFjY2VwdGFibGVUeXBlcyIsImluZGV4IiwibnVtUm93cyIsImluY2x1ZGVzIiwiY2xlYW5lZCIsImdlb1N0cmluZyIsInBhcnNlZEdlbyIsIkpTT04iLCJwYXJzZSIsIldLVExvYWRlciIsImJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJiaW5hcnlHZW8iLCJXS0JMb2FkZXIiLCJtYXhDb3VudCIsInNhbXBsZXMiLCJub25FbXB0eSIsImZpbHRlciIsImZlYXR1cmVUb0RlY2tHbEdlb1R5cGUiLCJQb2ludCIsIk11bHRpUG9pbnQiLCJMaW5lU3RyaW5nIiwiTXVsdGlMaW5lU3RyaW5nIiwiUG9seWdvbiIsIk11bHRpUG9seWdvbiIsImFsbEZlYXR1cmVzIiwiZiIsImdlb1R5cGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQTs7QUFDQTs7QUFDQTs7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aEMsRUFBd0NpQyxDQUFDLEVBQXpDLEVBQTZDO0FBQzNDLFFBQU1oQyxPQUFPLEdBQUcrQixXQUFXLENBQUNDLENBQUQsQ0FBM0I7O0FBQ0EsUUFBSWhDLE9BQU8sSUFBSSxjQUFjQSxPQUE3QixFQUFzQztBQUNwQyxVQUFNaUMsT0FBTyxHQUFHVCxzQkFBc0IsQ0FBQ3hCLE9BQU8sQ0FBQ3RCLFFBQVIsSUFBb0JzQixPQUFPLENBQUN0QixRQUFSLENBQWlCRCxJQUF0QyxDQUF0Qzs7QUFDQSxVQUFJd0QsT0FBSixFQUFhO0FBQ1h0QyxRQUFBQSxZQUFZLENBQUNzQyxPQUFELENBQVosR0FBd0IsSUFBeEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBT3RDLFlBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCB7RmVhdHVyZSwgQkJveH0gZnJvbSAnZ2VvanNvbic7XG5pbXBvcnQgbm9ybWFsaXplIGZyb20gJ0BtYXBib3gvZ2VvanNvbi1ub3JtYWxpemUnO1xuaW1wb3J0IGJib3ggZnJvbSAnQHR1cmYvYmJveCc7XG5pbXBvcnQgY2VudGVyIGZyb20gJ0B0dXJmL2NlbnRlcic7XG5pbXBvcnQge0FsbEdlb0pTT059IGZyb20gJ0B0dXJmL2hlbHBlcnMnXG5pbXBvcnQge3BhcnNlU3luY30gZnJvbSAnQGxvYWRlcnMuZ2wvY29yZSc7XG5pbXBvcnQge1dLQkxvYWRlciwgV0tUTG9hZGVyfSBmcm9tICdAbG9hZGVycy5nbC93a3QnO1xuaW1wb3J0IHtiaW5hcnlUb0dlb21ldHJ5fSBmcm9tICdAbG9hZGVycy5nbC9naXMnO1xuaW1wb3J0IHtCaW5hcnlGZWF0dXJlQ29sbGVjdGlvbn0gZnJvbSAnQGxvYWRlcnMuZ2wvc2NoZW1hJztcbmltcG9ydCB7RGF0YUNvbnRhaW5lckludGVyZmFjZSwgZ2V0U2FtcGxlRGF0YX0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5cbmltcG9ydCB7R2VvanNvbkxheWVyTWV0YVByb3BzfSBmcm9tICcuLi9sYXllci11dGlscyc7XG5cbmV4cG9ydCB0eXBlIEdldEZlYXR1cmUgPSAoZDogYW55KSA9PiBGZWF0dXJlO1xuZXhwb3J0IHR5cGUgR2VvanNvbkRhdGFNYXBzID0gQXJyYXk8RmVhdHVyZSB8IEJpbmFyeUZlYXR1cmVDb2xsZWN0aW9uIHwgbnVsbD47XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBUT0RPOiBSZS1lbmFibGUgZXNsaW50IHdoZW4gd2UgdXBncmFkZSB0byBoYW5kbGUgZW51bXMgYW5kIHR5cGUgbWFwc1xuZXhwb3J0IGVudW0gRmVhdHVyZVR5cGVzIHtcbiAgUG9pbnQgPSAnUG9pbnQnLFxuICBNdWx0aVBvaW50ID0gJ011bHRpUG9pbnQnLFxuICBMaW5lU3RyaW5nID0gJ0xpbmVTdHJpbmcnLFxuICBNdWx0aUxpbmVTdHJpbmcgPSAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgUG9seWdvbiA9ICdQb2x5Z29uJyxcbiAgTXVsdGlQb2x5Z29uID0gJ011bHRpUG9seWdvbidcbn1cblxuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VHZW9Kc29uUmF3RmVhdHVyZShyYXdGZWF0dXJlOiB1bmtub3duKTogRmVhdHVyZSB8IG51bGwge1xuICBpZiAodHlwZW9mIHJhd0ZlYXR1cmUgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gU3VwcG9ydCBHZW9Kc29uIGZlYXR1cmUgYXMgb2JqZWN0XG4gICAgLy8gcHJvYmFibHkgbmVlZCB0byBub3JtYWxpemUgaXQgYXMgd2VsbFxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemUocmF3RmVhdHVyZSk7XG4gICAgaWYgKCFub3JtYWxpemVkIHx8ICFBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWQuZmVhdHVyZXMpKSB7XG4gICAgICAvLyBmYWlsIHRvIG5vcm1hbGl6ZSBHZW9Kc29uXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZC5mZWF0dXJlc1swXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmF3RmVhdHVyZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VHZW9tZXRyeUZyb21TdHJpbmcocmF3RmVhdHVyZSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyYXdGZWF0dXJlKSkge1xuICAgIC8vIFN1cHBvcnQgR2VvSnNvbiAgTGluZVN0cmluZyBhcyBhbiBhcnJheSBvZiBwb2ludHNcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgLy8gd2h5IGRvIHdlIG5lZWQgdG8gZmxpcCBpdC4uLlxuICAgICAgICBjb29yZGluYXRlczogcmF3RmVhdHVyZS5tYXAocHRzID0+IFtwdHNbMV0sIHB0c1swXV0pLFxuICAgICAgICB0eXBlOiAnTGluZVN0cmluZydcbiAgICAgIH0sXG4gICAgICBwcm9wZXJ0aWVzOiB7fVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdlb2pzb25MYXllck1ldGEoe1xuICBkYXRhQ29udGFpbmVyLFxuICBnZXRGZWF0dXJlXG59OiB7XG4gIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2U7XG4gIGdldEZlYXR1cmU6IEdldEZlYXR1cmU7XG59KTogR2VvanNvbkxheWVyTWV0YVByb3BzIHtcbiAgY29uc3QgZGF0YVRvRmVhdHVyZSA9IGdldEdlb2pzb25EYXRhTWFwcyhkYXRhQ29udGFpbmVyLCBnZXRGZWF0dXJlKTtcbiAgLy8gZ2V0IGJvdW5kcyBmcm9tIGZlYXR1cmVzXG4gIGNvbnN0IGJvdW5kcyA9IGdldEdlb2pzb25Cb3VuZHMoZGF0YVRvRmVhdHVyZSk7XG4gIC8vIGlmIGFueSBvZiB0aGUgZmVhdHVyZSBoYXMgcHJvcGVydGllcy5yYWRpdXMgc2V0IHRvIGJlIHRydWVcbiAgY29uc3QgZml4ZWRSYWRpdXMgPSBCb29sZWFuKGRhdGFUb0ZlYXR1cmUuZmluZChkID0+IGQgJiYgJ3Byb3BlcnRpZXMnIGluIGQgJiYgZC5wcm9wZXJ0aWVzPy5yYWRpdXMpKTtcblxuICAvLyBrZWVwIGEgcmVjb3JkIG9mIHdoYXQgdHlwZSBvZiBnZW9tZXRyeSB0aGUgY29sbGVjdGlvbiBoYXNcbiAgY29uc3QgZmVhdHVyZVR5cGVzID0gZ2V0R2VvanNvbkZlYXR1cmVUeXBlcyhkYXRhVG9GZWF0dXJlKTtcblxuICBjb25zdCBtZWFuQ2VudGVyczogQXJyYXk8bnVtYmVyW10gfCBudWxsPiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFUb0ZlYXR1cmUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmZWF0dXJlID0gZGF0YVRvRmVhdHVyZVtpXTtcbiAgICBpZiAoZmVhdHVyZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVE9ETzogdXNlIGxpbmUgaW50ZXJwb2xhdGUgdG8gZ2V0IGNlbnRlciBvZiBsaW5lIGZvciBMaW5lU3RyaW5nXG4gICAgICAgIGNvbnN0IGNlbnQgPSBjZW50ZXIoZmVhdHVyZSBhcyBBbGxHZW9KU09OKTtcbiAgICAgICAgbWVhbkNlbnRlcnMucHVzaChjZW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbWVhbkNlbnRlcnMucHVzaChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRhdGFUb0ZlYXR1cmUsXG4gICAgYm91bmRzLFxuICAgIGZpeGVkUmFkaXVzLFxuICAgIGZlYXR1cmVUeXBlcyxcbiAgICBjZW50cm9pZHM6IG1lYW5DZW50ZXJzXG4gIH07XG59XG5cbi8qKlxuICogUGFyc2UgcmF3IGRhdGEgdG8gR2VvSnNvbiBmZWF0dXJlXG4gKiBAcGFyYW0gZGF0YUNvbnRhaW5lclxuICogQHBhcmFtIGdldEZlYXR1cmVcbiAqIEByZXR1cm5zIHt7fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdlb2pzb25EYXRhTWFwcyhkYXRhQ29udGFpbmVyOiBhbnksIGdldEZlYXR1cmU6IEdldEZlYXR1cmUpOiBHZW9qc29uRGF0YU1hcHMge1xuICBjb25zdCBhY2NlcHRhYmxlVHlwZXMgPSBbXG4gICAgJ1BvaW50JyxcbiAgICAnTXVsdGlQb2ludCcsXG4gICAgJ0xpbmVTdHJpbmcnLFxuICAgICdNdWx0aUxpbmVTdHJpbmcnLFxuICAgICdQb2x5Z29uJyxcbiAgICAnTXVsdGlQb2x5Z29uJyxcbiAgICAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xuICBdO1xuXG4gIGNvbnN0IGRhdGFUb0ZlYXR1cmU6IEdlb2pzb25EYXRhTWFwcyA9IFtdO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkYXRhQ29udGFpbmVyLm51bVJvd3MoKTsgaW5kZXgrKykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSBwYXJzZUdlb0pzb25SYXdGZWF0dXJlKGdldEZlYXR1cmUoe2luZGV4fSkpO1xuXG4gICAgaWYgKGZlYXR1cmUgJiYgZmVhdHVyZS5nZW9tZXRyeSAmJiBhY2NlcHRhYmxlVHlwZXMuaW5jbHVkZXMoZmVhdHVyZS5nZW9tZXRyeS50eXBlKSkge1xuICAgICAgY29uc3QgY2xlYW5lZCA9IHtcbiAgICAgICAgLi4uZmVhdHVyZSxcbiAgICAgICAgLy8gc3RvcmUgaW5kZXggb2YgdGhlIGRhdGEgaW4gZmVhdHVyZSBwcm9wZXJ0aWVzXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAuLi5mZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICAgICAgaW5kZXhcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZGF0YVRvRmVhdHVyZVtpbmRleF0gPSBjbGVhbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhVG9GZWF0dXJlW2luZGV4XSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGFUb0ZlYXR1cmU7XG59XG5cbi8qKlxuICogUGFyc2UgZ2VvanNvbiBmcm9tIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IGdlb1N0cmluZ1xuICogQHJldHVybnMge251bGwgfCBPYmplY3R9IGdlb2pzb24gb2JqZWN0IG9yIG51bGwgaWYgZmFpbGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUdlb21ldHJ5RnJvbVN0cmluZyhnZW9TdHJpbmc6IHN0cmluZyk6IEZlYXR1cmUgfCBudWxsIHtcbiAgbGV0IHBhcnNlZEdlbztcblxuICAvLyB0cnkgcGFyc2UgYXMgZ2VvanNvbiBzdHJpbmdcbiAgLy8ge1widHlwZVwiOlwiUG9seWdvblwiLFwiY29vcmRpbmF0ZXNcIjpbW1stNzQuMTU4NDkxLDQwLjgzNTk0XV1dfVxuICB0cnkge1xuICAgIHBhcnNlZEdlbyA9IEpTT04ucGFyc2UoZ2VvU3RyaW5nKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGtlZXAgdHJ5aW5nIHRvIHBhcnNlXG4gIH1cblxuICAvLyB0cnkgcGFyc2UgYXMgd2t0IHVzaW5nIGxvYWRlcnMuZ2wgV0tUTG9hZGVyXG4gIGlmICghcGFyc2VkR2VvKSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZEdlbyA9IHBhcnNlU3luYyhnZW9TdHJpbmcsIFdLVExvYWRlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gdHJ5IHBhcnNlIGFzIHdrYiB1c2luZyBsb2FkZXJzLmdsIFdLQkxvYWRlclxuICBpZiAoIXBhcnNlZEdlbykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShnZW9TdHJpbmcsICdoZXgnKTtcbiAgICAgIGNvbnN0IGJpbmFyeUdlbyA9IHBhcnNlU3luYyhidWZmZXIsIFdLQkxvYWRlcik7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBwYXJzZWRHZW8gPSBiaW5hcnlUb0dlb21ldHJ5KGJpbmFyeUdlbyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwYXJzZWRHZW8pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemUocGFyc2VkR2VvKTtcblxuICBpZiAoIW5vcm1hbGl6ZWQgfHwgIUFycmF5LmlzQXJyYXkobm9ybWFsaXplZC5mZWF0dXJlcykpIHtcbiAgICAvLyBmYWlsIHRvIG5vcm1hbGl6ZSBnZW9qc29uXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZC5mZWF0dXJlc1swXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdlb2pzb25Cb3VuZHMoZmVhdHVyZXM6IEdlb2pzb25EYXRhTWFwcyA9IFtdKTogQkJveCB8IG51bGwge1xuICAvLyA3MCBtcyBmb3IgMTAsMDAwIHBvbHlnb25zXG4gIC8vIGhlcmUgd2Ugb25seSBwaWNrIGNvdXBsZVxuICBjb25zdCBtYXhDb3VudCA9IDEwMDAwO1xuICBjb25zdCBzYW1wbGVzID0gZmVhdHVyZXMubGVuZ3RoID4gbWF4Q291bnQgPyBnZXRTYW1wbGVEYXRhKGZlYXR1cmVzLCBtYXhDb3VudCkgOiBmZWF0dXJlcztcblxuICBjb25zdCBub25FbXB0eSA9IHNhbXBsZXMuZmlsdGVyKFxuICAgIGQgPT4gZCAmJiBkLmdlb21ldHJ5ICYmIGQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgJiYgZC5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGhcbiAgKTtcblxuICB0cnkge1xuICAgIHJldHVybiBiYm94KHtcbiAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICBmZWF0dXJlczogbm9uRW1wdHlcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmZWF0dXJlVG9EZWNrR2xHZW9UeXBlID0ge1xuICBQb2ludDogJ3BvaW50JyxcbiAgTXVsdGlQb2ludDogJ3BvaW50JyxcbiAgTGluZVN0cmluZzogJ2xpbmUnLFxuICBNdWx0aUxpbmVTdHJpbmc6ICdsaW5lJyxcbiAgUG9seWdvbjogJ3BvbHlnb24nLFxuICBNdWx0aVBvbHlnb246ICdwb2x5Z29uJ1xufTtcblxuZXhwb3J0IHR5cGUgRGVja0dsR2VvVHlwZXMgPSB7XG4gIHBvaW50OiBib29sZWFuO1xuICBsaW5lOiBib29sZWFuO1xuICBwb2x5Z29uOiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBQYXJzZSBnZW9qc29uIGZyb20gc3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGFsbEZlYXR1cmVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBtYXBwaW5nIG9mIGZlYXR1cmUgdHlwZSBleGlzdGVuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdlb2pzb25GZWF0dXJlVHlwZXMoYWxsRmVhdHVyZXM6IEdlb2pzb25EYXRhTWFwcyk6IERlY2tHbEdlb1R5cGVzIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBzb21lIHRlc3QgY2FzZXMgb25seSBoYXZlIDEgZ2VvdHlwZVxuICBjb25zdCBmZWF0dXJlVHlwZXM6IERlY2tHbEdlb1R5cGVzID0ge307XG4gIGZvciAobGV0IGYgPSAwOyBmIDwgYWxsRmVhdHVyZXMubGVuZ3RoOyBmKyspIHtcbiAgICBjb25zdCBmZWF0dXJlID0gYWxsRmVhdHVyZXNbZl07XG4gICAgaWYgKGZlYXR1cmUgJiYgJ2dlb21ldHJ5JyBpbiBmZWF0dXJlKSB7XG4gICAgICBjb25zdCBnZW9UeXBlID0gZmVhdHVyZVRvRGVja0dsR2VvVHlwZVtmZWF0dXJlLmdlb21ldHJ5ICYmIGZlYXR1cmUuZ2VvbWV0cnkudHlwZV07XG4gICAgICBpZiAoZ2VvVHlwZSkge1xuICAgICAgICBmZWF0dXJlVHlwZXNbZ2VvVHlwZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmZWF0dXJlVHlwZXM7XG59XG4iXX0=