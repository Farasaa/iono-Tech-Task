"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.visStateSchema = exports.visStateSchemaV1 = exports.visStateSchemaV0 = exports.VisStateSchemaV1 = exports.propertiesV1 = exports.propertiesV0 = exports.filterPropsV1 = exports.EffectsSchema = exports.effectPropsV1 = exports.SplitMapsSchema = exports.DimensionFieldSchema = exports.filterPropsV0 = exports.InteractionSchemaV1 = exports.FilterSchemaV0 = exports.LayerSchemaV0 = exports.layerPropsV1 = exports.layerPropsV0 = exports.dimensionPropsV0 = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = _interopRequireDefault(require("lodash.pick"));

var _versions = require("./versions");

var _constants = require("@kepler.gl/constants");

var _utils = require("@kepler.gl/utils");

var _schema = _interopRequireDefault(require("./schema"));

var _lodash2 = _interopRequireDefault(require("lodash.clonedeep"));

var _visStateSchema;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * V0 Schema
 */
var dimensionPropsV0 = ['name', 'type'];
exports.dimensionPropsV0 = dimensionPropsV0;

// in v0 geojson there is only sizeField
// in v1 geojson
// stroke base on -> sizeField
// height based on -> heightField
// radius based on -> radiusField
// here we make our wiredst guess on which channel sizeField belongs to
function geojsonSizeFieldV0ToV1(config) {
  var defaultRaiuds = 10;
  var defaultRadiusRange = [0, 50]; // if extruded, sizeField is most likely used for height

  if (config.visConfig.extruded) {
    return 'heightField';
  } // if show stroke enabled, sizeField is most likely used for stroke


  if (config.visConfig.stroked) {
    return 'sizeField';
  } // if radius changed, or radius Range Changed, sizeField is most likely used for radius
  // this is the most unreliable guess, that's why we put it in the end


  if (config.visConfig.radius !== defaultRaiuds || config.visConfig.radiusRange.some(function (d, i) {
    return d !== defaultRadiusRange[i];
  })) {
    return 'radiusField';
  }

  return 'sizeField';
} // convert v0 to v1 layer config


var DimensionFieldSchemaV0 = /*#__PURE__*/function (_Schema) {
  (0, _inherits2["default"])(DimensionFieldSchemaV0, _Schema);

  var _super = _createSuper(DimensionFieldSchemaV0);

  function DimensionFieldSchemaV0() {
    var _this;

    (0, _classCallCheck2["default"])(this, DimensionFieldSchemaV0);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "version", _versions.VERSIONS.v0);
    return _this;
  }

  (0, _createClass2["default"])(DimensionFieldSchemaV0, [{
    key: "save",
    value: function save(field) {
      // should not be called anymore
      return (0, _defineProperty2["default"])({}, this.key, field !== null ? this.savePropertiesOrApplySchema(field)[this.key] : null);
    }
  }, {
    key: "load",
    value: function load(field, parents, accumulated) {
      var _parents$slice = parents.slice(-1),
          _parents$slice2 = (0, _slicedToArray2["default"])(_parents$slice, 1),
          config = _parents$slice2[0];

      var fieldName = this.key;

      if (config.type === 'geojson' && this.key === 'sizeField' && field) {
        fieldName = geojsonSizeFieldV0ToV1(config);
      } // fold into visualChannels to be load by VisualChannelSchemaV1


      return {
        visualChannels: _objectSpread(_objectSpread({}, accumulated.visualChannels || {}), {}, (0, _defineProperty2["default"])({}, fieldName, field))
      };
    }
  }]);
  return DimensionFieldSchemaV0;
}(_schema["default"]);

var DimensionScaleSchemaV0 = /*#__PURE__*/function (_Schema2) {
  (0, _inherits2["default"])(DimensionScaleSchemaV0, _Schema2);

  var _super2 = _createSuper(DimensionScaleSchemaV0);

  function DimensionScaleSchemaV0() {
    var _this2;

    (0, _classCallCheck2["default"])(this, DimensionScaleSchemaV0);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = _super2.call.apply(_super2, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this2), "version", _versions.VERSIONS.v0);
    return _this2;
  }

  (0, _createClass2["default"])(DimensionScaleSchemaV0, [{
    key: "save",
    value: function save(scale) {
      return (0, _defineProperty2["default"])({}, this.key, scale);
    }
  }, {
    key: "load",
    value: function load(scale, parents, accumulated) {
      var _parents$slice3 = parents.slice(-1),
          _parents$slice4 = (0, _slicedToArray2["default"])(_parents$slice3, 1),
          config = _parents$slice4[0]; // fold into visualChannels to be load by VisualChannelSchemaV1


      if (this.key === 'sizeScale' && config.type === 'geojson') {
        // sizeScale now split into radiusScale, heightScale
        // no user customization, just use default
        return {};
      }

      return {
        visualChannels: _objectSpread(_objectSpread({}, accumulated.visualChannels || {}), {}, (0, _defineProperty2["default"])({}, this.key, scale))
      };
    }
  }]);
  return DimensionScaleSchemaV0;
}(_schema["default"]); // used to convert v0 to v1 layer config


var LayerConfigSchemaV0 = /*#__PURE__*/function (_Schema3) {
  (0, _inherits2["default"])(LayerConfigSchemaV0, _Schema3);

  var _super3 = _createSuper(LayerConfigSchemaV0);

  function LayerConfigSchemaV0() {
    var _this3;

    (0, _classCallCheck2["default"])(this, LayerConfigSchemaV0);

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    _this3 = _super3.call.apply(_super3, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this3), "version", _versions.VERSIONS.v0);
    return _this3;
  }

  (0, _createClass2["default"])(LayerConfigSchemaV0, [{
    key: "load",
    value: function load(saved, parents, accumulated) {
      // fold v0 layer property into config.key
      return {
        config: _objectSpread(_objectSpread({}, accumulated.config || {}), {}, (0, _defineProperty2["default"])({}, this.key, saved))
      };
    }
  }]);
  return LayerConfigSchemaV0;
}(_schema["default"]); // used to convert v0 to v1 layer columns
// only return column value for each column


var LayerColumnsSchemaV0 = /*#__PURE__*/function (_Schema4) {
  (0, _inherits2["default"])(LayerColumnsSchemaV0, _Schema4);

  var _super4 = _createSuper(LayerColumnsSchemaV0);

  function LayerColumnsSchemaV0() {
    var _this4;

    (0, _classCallCheck2["default"])(this, LayerColumnsSchemaV0);

    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    _this4 = _super4.call.apply(_super4, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this4), "version", _versions.VERSIONS.v0);
    return _this4;
  }

  (0, _createClass2["default"])(LayerColumnsSchemaV0, [{
    key: "load",
    value: function load(saved, parents, accumulated) {
      // fold v0 layer property into config.key, flatten columns
      return {
        config: _objectSpread(_objectSpread({}, accumulated.config || {}), {}, {
          columns: Object.keys(saved).reduce(function (accu, key) {
            return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, saved[key].value));
          }, {})
        })
      };
    }
  }]);
  return LayerColumnsSchemaV0;
}(_schema["default"]); // used to convert v0 to v1 layer config.visConfig


var LayerConfigToVisConfigSchemaV0 = /*#__PURE__*/function (_Schema5) {
  (0, _inherits2["default"])(LayerConfigToVisConfigSchemaV0, _Schema5);

  var _super5 = _createSuper(LayerConfigToVisConfigSchemaV0);

  function LayerConfigToVisConfigSchemaV0() {
    var _this5;

    (0, _classCallCheck2["default"])(this, LayerConfigToVisConfigSchemaV0);

    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    _this5 = _super5.call.apply(_super5, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this5), "version", _versions.VERSIONS.v0);
    return _this5;
  }

  (0, _createClass2["default"])(LayerConfigToVisConfigSchemaV0, [{
    key: "load",
    value: function load(saved, parents, accumulated) {
      // fold v0 layer property into config.visConfig
      var accumulatedConfig = accumulated.config || {};
      return {
        config: _objectSpread(_objectSpread({}, accumulatedConfig), {}, {
          visConfig: _objectSpread(_objectSpread({}, accumulatedConfig.visConfig || {}), {}, (0, _defineProperty2["default"])({}, this.key, saved))
        })
      };
    }
  }]);
  return LayerConfigToVisConfigSchemaV0;
}(_schema["default"]);

var LayerVisConfigSchemaV0 = /*#__PURE__*/function (_Schema6) {
  (0, _inherits2["default"])(LayerVisConfigSchemaV0, _Schema6);

  var _super6 = _createSuper(LayerVisConfigSchemaV0);

  function LayerVisConfigSchemaV0() {
    var _this6;

    (0, _classCallCheck2["default"])(this, LayerVisConfigSchemaV0);

    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    _this6 = _super6.call.apply(_super6, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this6), "version", _versions.VERSIONS.v0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this6), "key", 'visConfig');
    return _this6;
  }

  (0, _createClass2["default"])(LayerVisConfigSchemaV0, [{
    key: "load",
    value: function load(visConfig, parents, accumulator) {
      var _parents$slice5 = parents.slice(-1),
          _parents$slice6 = (0, _slicedToArray2["default"])(_parents$slice5, 1),
          config = _parents$slice6[0];

      var rename = {
        geojson: {
          extruded: 'enable3d',
          elevationRange: 'heightRange'
        }
      };

      if (config.type in rename) {
        var propToRename = rename[config.type];
        return {
          config: _objectSpread(_objectSpread({}, accumulator.config || {}), {}, {
            visConfig: Object.keys(visConfig).reduce(function (accu, key) {
              return _objectSpread(_objectSpread({}, accu), propToRename[key] ? (0, _defineProperty2["default"])({}, propToRename[key], visConfig[key]) : (0, _defineProperty2["default"])({}, key, visConfig[key]));
            }, {})
          })
        };
      }

      return {
        config: _objectSpread(_objectSpread({}, accumulator.config || {}), {}, {
          visConfig: visConfig
        })
      };
    }
  }]);
  return LayerVisConfigSchemaV0;
}(_schema["default"]);

var LayerConfigSchemaDeleteV0 = /*#__PURE__*/function (_Schema7) {
  (0, _inherits2["default"])(LayerConfigSchemaDeleteV0, _Schema7);

  var _super7 = _createSuper(LayerConfigSchemaDeleteV0);

  function LayerConfigSchemaDeleteV0() {
    var _this7;

    (0, _classCallCheck2["default"])(this, LayerConfigSchemaDeleteV0);

    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    _this7 = _super7.call.apply(_super7, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this7), "version", _versions.VERSIONS.v0);
    return _this7;
  }

  (0, _createClass2["default"])(LayerConfigSchemaDeleteV0, [{
    key: "load",
    value: function load(value) {
      return {};
    }
  }]);
  return LayerConfigSchemaDeleteV0;
}(_schema["default"]);
/**
 * V0 -> V1 Changes
 * - layer is now a class
 * - config saved in a config object
 * - id, type, isAggregated is outside layer.config
 * - visualChannels is outside config, it defines available visual channel and
 *   property names for field, scale, domain and range of each visual chanel.
 * - enable3d, colorAggregation and sizeAggregation are moved into visConfig
 * - GeojsonLayer - added height, radius specific properties
 */


var layerPropsV0 = {
  id: null,
  type: null,
  // move into layer.config
  dataId: new LayerConfigSchemaV0({
    key: 'dataId'
  }),
  label: new LayerConfigSchemaV0({
    key: 'label'
  }),
  color: new LayerConfigSchemaV0({
    key: 'color'
  }),
  isVisible: new LayerConfigSchemaV0({
    key: 'isVisible'
  }),
  hidden: new LayerConfigSchemaV0({
    key: 'hidden'
  }),
  // convert visConfig
  visConfig: new LayerVisConfigSchemaV0({
    key: 'visConfig'
  }),
  // move into layer.config
  // flatten
  columns: new LayerColumnsSchemaV0(),
  // save into visualChannels
  colorField: new DimensionFieldSchemaV0({
    properties: dimensionPropsV0,
    key: 'colorField'
  }),
  colorScale: new DimensionScaleSchemaV0({
    key: 'colorScale'
  }),
  sizeField: new DimensionFieldSchemaV0({
    properties: dimensionPropsV0,
    key: 'sizeField'
  }),
  sizeScale: new DimensionScaleSchemaV0({
    key: 'sizeScale'
  }),
  // move into config.visConfig
  enable3d: new LayerConfigToVisConfigSchemaV0({
    key: 'enable3d'
  }),
  colorAggregation: new LayerConfigToVisConfigSchemaV0({
    key: 'colorAggregation'
  }),
  sizeAggregation: new LayerConfigToVisConfigSchemaV0({
    key: 'sizeAggregation'
  }),
  // delete
  isAggregated: new LayerConfigSchemaDeleteV0()
};
/**
 * V1 Schema
 */

exports.layerPropsV0 = layerPropsV0;

var ColumnSchemaV1 = /*#__PURE__*/function (_Schema8) {
  (0, _inherits2["default"])(ColumnSchemaV1, _Schema8);

  var _super8 = _createSuper(ColumnSchemaV1);

  function ColumnSchemaV1() {
    (0, _classCallCheck2["default"])(this, ColumnSchemaV1);
    return _super8.apply(this, arguments);
  }

  (0, _createClass2["default"])(ColumnSchemaV1, [{
    key: "save",
    value: function save(columns, state) {
      // starting from v1, only save column value
      // fieldIdx will be calculated during merge
      return (0, _defineProperty2["default"])({}, this.key, Object.keys(columns).reduce(function (accu, ckey) {
        var _columns$ckey;

        return _objectSpread(_objectSpread({}, accu), (_columns$ckey = columns[ckey]) !== null && _columns$ckey !== void 0 && _columns$ckey.value ? (0, _defineProperty2["default"])({}, ckey, columns[ckey].value) : {});
      }, {}));
    }
  }, {
    key: "load",
    value: function load(columns) {
      return {
        columns: columns
      };
    }
  }]);
  return ColumnSchemaV1;
}(_schema["default"]);

var TextLabelSchemaV1 = /*#__PURE__*/function (_Schema9) {
  (0, _inherits2["default"])(TextLabelSchemaV1, _Schema9);

  var _super9 = _createSuper(TextLabelSchemaV1);

  function TextLabelSchemaV1() {
    (0, _classCallCheck2["default"])(this, TextLabelSchemaV1);
    return _super9.apply(this, arguments);
  }

  (0, _createClass2["default"])(TextLabelSchemaV1, [{
    key: "save",
    value: function save(textLabel) {
      return (0, _defineProperty2["default"])({}, this.key, textLabel.map(function (tl) {
        return _objectSpread(_objectSpread({}, tl), {}, {
          field: tl.field ? (0, _lodash["default"])(tl.field, ['name', 'type']) : null
        });
      }));
    }
  }, {
    key: "load",
    value: function load(textLabel) {
      return {
        textLabel: Array.isArray(textLabel) ? textLabel : [textLabel]
      };
    }
  }]);
  return TextLabelSchemaV1;
}(_schema["default"]);

var visualChannelModificationV1 = {
  geojson: function geojson(vc, parents, accumulator) {
    var _parents$slice7 = parents.slice(-1),
        _parents$slice8 = (0, _slicedToArray2["default"])(_parents$slice7, 1),
        layer = _parents$slice8[0];

    var isOld = !vc.hasOwnProperty('strokeColorField'); // make our best guess if this geojson layer contains point

    var isPoint = vc.radiusField || layer.config.visConfig.radius !== _constants.LAYER_VIS_CONFIGS.radius.defaultValue;

    if (isOld && !isPoint && layer.config.visConfig.stroked) {
      // if stroked is true, copy color config to stroke color config
      return {
        strokeColorField: vc.colorField,
        strokeColorScale: vc.colorScale
      };
    }

    return {};
  }
};
/**
 * V1: save [field]: {name, type}, [scale]: '' for each channel
 */

var VisualChannelSchemaV1 = /*#__PURE__*/function (_Schema10) {
  (0, _inherits2["default"])(VisualChannelSchemaV1, _Schema10);

  var _super10 = _createSuper(VisualChannelSchemaV1);

  function VisualChannelSchemaV1() {
    (0, _classCallCheck2["default"])(this, VisualChannelSchemaV1);
    return _super10.apply(this, arguments);
  }

  (0, _createClass2["default"])(VisualChannelSchemaV1, [{
    key: "save",
    value: function save(visualChannels, parents) {
      // only save field and scale of each channel
      var _parents$slice9 = parents.slice(-1),
          _parents$slice10 = (0, _slicedToArray2["default"])(_parents$slice9, 1),
          layer = _parents$slice10[0];

      return (0, _defineProperty2["default"])({}, this.key, Object.keys(visualChannels).reduce( //  save channel to null if didn't select any field
      function (accu, key) {
        var _objectSpread7;

        return _objectSpread(_objectSpread({}, accu), {}, (_objectSpread7 = {}, (0, _defineProperty2["default"])(_objectSpread7, visualChannels[key].field, layer.config[visualChannels[key].field] ? (0, _lodash["default"])(layer.config[visualChannels[key].field], ['name', 'type']) : null), (0, _defineProperty2["default"])(_objectSpread7, visualChannels[key].scale, layer.config[visualChannels[key].scale]), _objectSpread7));
      }, {}));
    }
  }, {
    key: "load",
    value: function load(vc, parents, accumulator) {
      // fold channels into config
      var _parents$slice11 = parents.slice(-1),
          _parents$slice12 = (0, _slicedToArray2["default"])(_parents$slice11, 1),
          layer = _parents$slice12[0];

      var modified = visualChannelModificationV1[layer.type] ? visualChannelModificationV1[layer.type](vc, parents, accumulator) : {};
      return _objectSpread(_objectSpread({}, accumulator), {}, {
        config: _objectSpread(_objectSpread(_objectSpread({}, accumulator.config || {}), vc), modified)
      });
    }
  }]);
  return VisualChannelSchemaV1;
}(_schema["default"]);

var visConfigModificationV1 = {
  point: function point(visConfig, parents, accumulated) {
    var modified = {};

    var _parents$slice13 = parents.slice(-2, -1),
        _parents$slice14 = (0, _slicedToArray2["default"])(_parents$slice13, 1),
        layer = _parents$slice14[0];

    var isOld = !visConfig.hasOwnProperty('filled') && !visConfig.strokeColor && !visConfig.strokeColorRange;

    if (isOld) {
      // color color & color range to stroke color
      modified.strokeColor = layer.config.color;
      modified.strokeColorRange = (0, _lodash2["default"])(visConfig.colorRange);

      if (visConfig.outline) {
        // point layer now supports both outline and fill
        // for older schema where filled has not been added to point layer
        // set it to false
        modified.filled = false;
      }
    }

    return modified;
  },
  geojson: function geojson(visConfig, parents, accumulated) {
    // is points?
    var modified = {};

    var _parents$slice15 = parents.slice(-2, -1),
        _parents$slice16 = (0, _slicedToArray2["default"])(_parents$slice15, 1),
        layer = _parents$slice16[0];

    var isOld = layer.visualChannels && !layer.visualChannels.hasOwnProperty('strokeColorField') && !visConfig.strokeColor && !visConfig.strokeColorRange; // make our best guess if this geojson layer contains point

    var isPoint = layer.visualChannels && layer.visualChannels.radiusField || visConfig && visConfig.radius !== _constants.LAYER_VIS_CONFIGS.radius.defaultValue;

    if (isOld) {
      // color color & color range to stroke color
      modified.strokeColor = layer.config.color;
      modified.strokeColorRange = (0, _lodash2["default"])(visConfig.colorRange);

      if (isPoint) {
        // if is point, set stroke to false
        modified.filled = true;
        modified.stroked = false;
      }
    }

    return modified;
  }
};

var VisConfigSchemaV1 = /*#__PURE__*/function (_Schema11) {
  (0, _inherits2["default"])(VisConfigSchemaV1, _Schema11);

  var _super11 = _createSuper(VisConfigSchemaV1);

  function VisConfigSchemaV1() {
    var _this8;

    (0, _classCallCheck2["default"])(this, VisConfigSchemaV1);

    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }

    _this8 = _super11.call.apply(_super11, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this8), "key", 'visConfig');
    return _this8;
  }

  (0, _createClass2["default"])(VisConfigSchemaV1, [{
    key: "load",
    value: function load(visConfig, parents, accumulated) {
      var _parents$slice17 = parents.slice(-2, -1),
          _parents$slice18 = (0, _slicedToArray2["default"])(_parents$slice17, 1),
          layer = _parents$slice18[0];

      var modified = visConfigModificationV1[layer.type] ? visConfigModificationV1[layer.type](visConfig, parents, accumulated) : {};
      return {
        visConfig: _objectSpread(_objectSpread({}, visConfig), modified)
      };
    }
  }]);
  return VisConfigSchemaV1;
}(_schema["default"]);

var layerPropsV1 = {
  id: null,
  type: null,
  config: new _schema["default"]({
    version: _versions.VERSIONS.v1,
    key: 'config',
    properties: {
      dataId: null,
      label: null,
      color: null,
      highlightColor: null,
      columns: new ColumnSchemaV1({
        version: _versions.VERSIONS.v1,
        key: 'columns'
      }),
      isVisible: null,
      visConfig: new VisConfigSchemaV1({
        version: _versions.VERSIONS.v1
      }),
      hidden: null,
      textLabel: new TextLabelSchemaV1({
        version: _versions.VERSIONS.v1,
        key: 'textLabel'
      })
    }
  }),
  visualChannels: new VisualChannelSchemaV1({
    version: _versions.VERSIONS.v1,
    key: 'visualChannels'
  })
};
exports.layerPropsV1 = layerPropsV1;

var LayerSchemaV0 = /*#__PURE__*/function (_Schema12) {
  (0, _inherits2["default"])(LayerSchemaV0, _Schema12);

  var _super12 = _createSuper(LayerSchemaV0);

  function LayerSchemaV0() {
    var _this9;

    (0, _classCallCheck2["default"])(this, LayerSchemaV0);

    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }

    _this9 = _super12.call.apply(_super12, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this9), "key", 'layers');
    return _this9;
  }

  (0, _createClass2["default"])(LayerSchemaV0, [{
    key: "save",
    value: function save(layers, parents) {
      var _this10 = this;

      var _parents$slice19 = parents.slice(-1),
          _parents$slice20 = (0, _slicedToArray2["default"])(_parents$slice19, 1),
          visState = _parents$slice20[0];

      return (0, _defineProperty2["default"])({}, this.key, visState.layerOrder.reduce(function (saved, layerId) {
        // save layers according to their rendering order
        var layer = (0, _utils.findById)(layerId)(layers);

        if (layer !== null && layer !== void 0 && layer.isValidToSave()) {
          saved.push(_this10.savePropertiesOrApplySchema(layer).layers);
        }

        return saved;
      }, []));
    }
  }, {
    key: "load",
    value: function load(layers) {
      var _this11 = this;

      return (0, _defineProperty2["default"])({}, this.key, layers ? layers.map(function (layer) {
        return _this11.loadPropertiesOrApplySchema(layer, layers).layers;
      }) : []);
    }
  }]);
  return LayerSchemaV0;
}(_schema["default"]);

exports.LayerSchemaV0 = LayerSchemaV0;

var FilterSchemaV0 = /*#__PURE__*/function (_Schema13) {
  (0, _inherits2["default"])(FilterSchemaV0, _Schema13);

  var _super13 = _createSuper(FilterSchemaV0);

  function FilterSchemaV0() {
    var _this12;

    (0, _classCallCheck2["default"])(this, FilterSchemaV0);

    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }

    _this12 = _super13.call.apply(_super13, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this12), "key", 'filters');
    return _this12;
  }

  (0, _createClass2["default"])(FilterSchemaV0, [{
    key: "save",
    value: function save(filters) {
      var _this13 = this;

      return {
        filters: filters.filter(_utils.isFilterValidToSave).map(function (filter) {
          return _this13.savePropertiesOrApplySchema(filter).filters;
        })
      };
    }
  }, {
    key: "load",
    value: function load(filters) {
      var _this14 = this;

      return {
        filters: filters === null || filters === void 0 ? void 0 : filters.map(function (filter) {
          return _this14.loadPropertiesOrApplySchema(filter).filters;
        }) // backward compatible convert enlarged to view
        .map(function (filter) {
          var enlarged = filter.enlarged,
              view = filter.view,
              filterProps = (0, _objectWithoutProperties2["default"])(filter, ["enlarged", "view"]);

          var newFilter = _objectSpread(_objectSpread({}, filterProps), {}, {
            // if view exist use it otherwise check for enlarged
            view: view ? view : enlarged ? _constants.FILTER_VIEW_TYPES.enlarged : _constants.FILTER_VIEW_TYPES.side
          });

          return newFilter;
        })
      };
    }
  }]);
  return FilterSchemaV0;
}(_schema["default"]);

exports.FilterSchemaV0 = FilterSchemaV0;
var interactionPropsV0 = ['tooltip', 'brush'];

var InteractionSchemaV0 = /*#__PURE__*/function (_Schema14) {
  (0, _inherits2["default"])(InteractionSchemaV0, _Schema14);

  var _super14 = _createSuper(InteractionSchemaV0);

  function InteractionSchemaV0() {
    var _this15;

    (0, _classCallCheck2["default"])(this, InteractionSchemaV0);

    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      args[_key11] = arguments[_key11];
    }

    _this15 = _super14.call.apply(_super14, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this15), "key", 'interactionConfig');
    return _this15;
  }

  (0, _createClass2["default"])(InteractionSchemaV0, [{
    key: "save",
    value: function save(interactionConfig) {
      return Array.isArray(this.properties) ? (0, _defineProperty2["default"])({}, this.key, this.properties.reduce(function (accu, key) {
        return _objectSpread(_objectSpread({}, accu), interactionConfig[key].enabled ? (0, _defineProperty2["default"])({}, key, interactionConfig[key].config) : {});
      }, {})) : {};
    }
  }, {
    key: "load",
    value: function load(interactionConfig) {
      // convert v0 -> v1
      // return enabled: false if disabled,
      return Array.isArray(this.properties) ? (0, _defineProperty2["default"])({}, this.key, this.properties.reduce(function (accu, key) {
        return _objectSpread(_objectSpread({}, accu), (0, _defineProperty2["default"])({}, key, _objectSpread(_objectSpread({}, interactionConfig[key] || {}), {}, {
          enabled: Boolean(interactionConfig[key])
        })));
      }, {})) : {};
    }
  }]);
  return InteractionSchemaV0;
}(_schema["default"]);

var interactionPropsV1 = [].concat(interactionPropsV0, ['geocoder', 'coordinate']);

var InteractionSchemaV1 = /*#__PURE__*/function (_Schema15) {
  (0, _inherits2["default"])(InteractionSchemaV1, _Schema15);

  var _super15 = _createSuper(InteractionSchemaV1);

  function InteractionSchemaV1() {
    var _this16;

    (0, _classCallCheck2["default"])(this, InteractionSchemaV1);

    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }

    _this16 = _super15.call.apply(_super15, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this16), "key", 'interactionConfig');
    return _this16;
  }

  (0, _createClass2["default"])(InteractionSchemaV1, [{
    key: "save",
    value: function save(interactionConfig) {
      // save config even if disabled,
      return Array.isArray(this.properties) ? (0, _defineProperty2["default"])({}, this.key, this.properties.reduce(function (accu, key) {
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, _objectSpread(_objectSpread({}, interactionConfig[key].config), {}, {
          enabled: interactionConfig[key].enabled
        })));
      }, {})) : {};
    }
  }, {
    key: "load",
    value: function load(interactionConfig) {
      var _this17 = this;

      var modifiedConfig = interactionConfig;
      Object.keys(interactionConfig).forEach(function (configType) {
        if (configType === 'tooltip') {
          var fieldsToShow = modifiedConfig[configType].fieldsToShow;

          if (!(0, _utils.notNullorUndefined)(fieldsToShow)) {
            return (0, _defineProperty2["default"])({}, _this17.key, modifiedConfig);
          }

          Object.keys(fieldsToShow).forEach(function (key) {
            // @ts-expect-error name: fieldData should be string
            fieldsToShow[key] = fieldsToShow[key].map(function (fieldData) {
              if (!fieldData.name) {
                return {
                  name: fieldData,
                  format: null
                };
              }

              return fieldData;
            });
          });
        }

        return;
      });
      return (0, _defineProperty2["default"])({}, this.key, modifiedConfig);
    }
  }]);
  return InteractionSchemaV1;
}(_schema["default"]);

exports.InteractionSchemaV1 = InteractionSchemaV1;
var filterPropsV0 = {
  dataId: null,
  id: null,
  name: null,
  type: null,
  value: null,
  // deprecated
  enlarged: null
};
exports.filterPropsV0 = filterPropsV0;

var DimensionFieldSchema = /*#__PURE__*/function (_Schema16) {
  (0, _inherits2["default"])(DimensionFieldSchema, _Schema16);

  var _super16 = _createSuper(DimensionFieldSchema);

  function DimensionFieldSchema() {
    (0, _classCallCheck2["default"])(this, DimensionFieldSchema);
    return _super16.apply(this, arguments);
  }

  (0, _createClass2["default"])(DimensionFieldSchema, [{
    key: "save",
    value: function save(field) {
      return (0, _defineProperty2["default"])({}, this.key, field ? this.savePropertiesOrApplySchema(field)[this.key] : null);
    }
  }, {
    key: "load",
    value: function load(field) {
      return (0, _defineProperty2["default"])({}, this.key, field);
    }
  }]);
  return DimensionFieldSchema;
}(_schema["default"]);

exports.DimensionFieldSchema = DimensionFieldSchema;

var SplitMapsSchema = /*#__PURE__*/function (_Schema17) {
  (0, _inherits2["default"])(SplitMapsSchema, _Schema17);

  var _super17 = _createSuper(SplitMapsSchema);

  function SplitMapsSchema() {
    (0, _classCallCheck2["default"])(this, SplitMapsSchema);
    return _super17.apply(this, arguments);
  }

  (0, _createClass2["default"])(SplitMapsSchema, [{
    key: "convertLayerSettings",
    value: function convertLayerSettings(accu, _ref19) {
      var _ref20 = (0, _slicedToArray2["default"])(_ref19, 2),
          key = _ref20[0],
          value = _ref20[1];

      if (typeof value === 'boolean') {
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, value));
      } else if (value && (0, _typeof2["default"])(value) === 'object' && value.isAvailable) {
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, Boolean(value.isVisible)));
      }

      return accu;
    }
  }, {
    key: "load",
    value: function load(splitMaps) {
      var _this18 = this;

      // previous splitMaps Schema {layers: {layerId: {isVisible, isAvailable}}}
      if (!Array.isArray(splitMaps) || !splitMaps.length) {
        return {
          splitMaps: []
        };
      }

      return {
        splitMaps: splitMaps.map(function (settings) {
          return _objectSpread(_objectSpread({}, settings), {}, {
            layers: Object.entries(settings.layers || {}).reduce(_this18.convertLayerSettings, {})
          });
        })
      };
    }
  }]);
  return SplitMapsSchema;
}(_schema["default"]);

exports.SplitMapsSchema = SplitMapsSchema;
var effectPropsV1 = {
  id: null,
  type: null,
  isEnabled: null,
  parameters: null
};
exports.effectPropsV1 = effectPropsV1;

var EffectsSchema = /*#__PURE__*/function (_Schema18) {
  (0, _inherits2["default"])(EffectsSchema, _Schema18);

  var _super18 = _createSuper(EffectsSchema);

  function EffectsSchema() {
    var _this19;

    (0, _classCallCheck2["default"])(this, EffectsSchema);

    for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      args[_key13] = arguments[_key13];
    }

    _this19 = _super18.call.apply(_super18, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this19), "key", 'effects');
    return _this19;
  }

  (0, _createClass2["default"])(EffectsSchema, [{
    key: "save",
    value: function save(effects, parents) {
      var _this20 = this;

      var _parents$slice21 = parents.slice(-1),
          _parents$slice22 = (0, _slicedToArray2["default"])(_parents$slice21, 1),
          visState = _parents$slice22[0];

      return (0, _defineProperty2["default"])({}, this.key, visState.effectOrder.reduce(function (saved, effectId) {
        // save effects according to their rendering order

        /**
         * @type {Effect | undefined}
         */
        var effect = (0, _utils.findById)(effectId)(effects);

        if (effect !== null && effect !== void 0 && effect.isValidToSave()) {
          saved.push(_this20.savePropertiesOrApplySchema(effect).effects);
        }

        return saved;
      }, []));
    }
  }, {
    key: "load",
    value: function load(effects) {
      var _this21 = this;

      return (0, _defineProperty2["default"])({}, this.key, effects.map(function (effect) {
        // handle older configs
        var outEffect = effect.config ? _objectSpread(_objectSpread({
          id: effect.id
        }, effect.config), {}, {
          parameters: _objectSpread({}, effect.config.params || {})
        }) : effect;
        return _this21.loadPropertiesOrApplySchema(outEffect, effects).effects;
      }));
    }
  }]);
  return EffectsSchema;
}(_schema["default"]);

exports.EffectsSchema = EffectsSchema;

var filterPropsV1 = _objectSpread(_objectSpread({}, filterPropsV0), {}, {
  plotType: null,
  animationWindow: null,
  yAxis: new DimensionFieldSchema({
    version: _versions.VERSIONS.v1,
    key: 'yAxis',
    properties: {
      name: null,
      type: null
    }
  }),
  // this replaced enlarged
  view: null,
  // polygon filter properties
  layerId: null,
  speed: null,
  enabled: null
});

exports.filterPropsV1 = filterPropsV1;
var propertiesV0 = {
  filters: new FilterSchemaV0({
    version: _versions.VERSIONS.v0,
    properties: filterPropsV0
  }),
  layers: new LayerSchemaV0({
    version: _versions.VERSIONS.v0,
    properties: layerPropsV0
  }),
  interactionConfig: new InteractionSchemaV0({
    version: _versions.VERSIONS.v0,
    properties: interactionPropsV0
  }),
  layerBlending: null,
  overlayBlending: null
};
exports.propertiesV0 = propertiesV0;
var propertiesV1 = {
  filters: new FilterSchemaV0({
    version: _versions.VERSIONS.v1,
    properties: filterPropsV1
  }),
  layers: new LayerSchemaV0({
    version: _versions.VERSIONS.v1,
    properties: layerPropsV1
  }),
  effects: new EffectsSchema({
    version: _versions.VERSIONS.v1,
    properties: effectPropsV1
  }),
  interactionConfig: new InteractionSchemaV1({
    version: _versions.VERSIONS.v1,
    properties: interactionPropsV1
  }),
  layerBlending: null,
  overlayBlending: null,
  splitMaps: new SplitMapsSchema({
    key: 'splitMaps',
    version: _versions.VERSIONS.v1
  }),
  animationConfig: new _schema["default"]({
    version: _versions.VERSIONS.v1,
    properties: {
      currentTime: null,
      speed: null
    },
    key: 'animationConfig'
  }),
  editor: new _schema["default"]({
    version: _versions.VERSIONS.v1,
    properties: {
      features: null,
      visible: null
    },
    key: 'editor'
  })
};
exports.propertiesV1 = propertiesV1;

var VisStateSchemaV1 = /*#__PURE__*/function (_Schema19) {
  (0, _inherits2["default"])(VisStateSchemaV1, _Schema19);

  var _super19 = _createSuper(VisStateSchemaV1);

  function VisStateSchemaV1() {
    (0, _classCallCheck2["default"])(this, VisStateSchemaV1);
    return _super19.apply(this, arguments);
  }

  (0, _createClass2["default"])(VisStateSchemaV1, [{
    key: "save",
    value: function save(node) {
      var parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var accumulator = arguments.length > 2 ? arguments[2] : undefined;
      // @ts-expect-error
      return this.savePropertiesOrApplySchema(node, parents, accumulator);
    }
  }, {
    key: "load",
    value: function load(node) {
      // @ts-expect-error
      return this.loadPropertiesOrApplySchema(node);
    }
  }]);
  return VisStateSchemaV1;
}(_schema["default"]);

exports.VisStateSchemaV1 = VisStateSchemaV1;
var visStateSchemaV0 = new _schema["default"]({
  version: _versions.VERSIONS.v0,
  properties: propertiesV0,
  key: 'visState'
});
exports.visStateSchemaV0 = visStateSchemaV0;
var visStateSchemaV1 = new VisStateSchemaV1({
  version: _versions.VERSIONS.v1,
  properties: propertiesV1,
  key: 'visState'
});
exports.visStateSchemaV1 = visStateSchemaV1;
var visStateSchema = (_visStateSchema = {}, (0, _defineProperty2["default"])(_visStateSchema, _versions.VERSIONS.v0, {
  save: function save(toSave) {
    return visStateSchemaV0.save(toSave);
  },
  load: function load(toLoad) {
    var _visStateSchemaV0$loa;

    return visStateSchemaV1.load((_visStateSchemaV0$loa = visStateSchemaV0.load(toLoad)) === null || _visStateSchemaV0$loa === void 0 ? void 0 : _visStateSchemaV0$loa.visState);
  }
}), (0, _defineProperty2["default"])(_visStateSchema, _versions.VERSIONS.v1, visStateSchemaV1), _visStateSchema); // test load v0

exports.visStateSchema = visStateSchema;
var _default = visStateSchema;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aXMtc3RhdGUtc2NoZW1hLnRzIl0sIm5hbWVzIjpbImRpbWVuc2lvblByb3BzVjAiLCJnZW9qc29uU2l6ZUZpZWxkVjBUb1YxIiwiY29uZmlnIiwiZGVmYXVsdFJhaXVkcyIsImRlZmF1bHRSYWRpdXNSYW5nZSIsInZpc0NvbmZpZyIsImV4dHJ1ZGVkIiwic3Ryb2tlZCIsInJhZGl1cyIsInJhZGl1c1JhbmdlIiwic29tZSIsImQiLCJpIiwiRGltZW5zaW9uRmllbGRTY2hlbWFWMCIsIlZFUlNJT05TIiwidjAiLCJmaWVsZCIsImtleSIsInNhdmVQcm9wZXJ0aWVzT3JBcHBseVNjaGVtYSIsInBhcmVudHMiLCJhY2N1bXVsYXRlZCIsInNsaWNlIiwiZmllbGROYW1lIiwidHlwZSIsInZpc3VhbENoYW5uZWxzIiwiU2NoZW1hIiwiRGltZW5zaW9uU2NhbGVTY2hlbWFWMCIsInNjYWxlIiwiTGF5ZXJDb25maWdTY2hlbWFWMCIsInNhdmVkIiwiTGF5ZXJDb2x1bW5zU2NoZW1hVjAiLCJjb2x1bW5zIiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsImFjY3UiLCJ2YWx1ZSIsIkxheWVyQ29uZmlnVG9WaXNDb25maWdTY2hlbWFWMCIsImFjY3VtdWxhdGVkQ29uZmlnIiwiTGF5ZXJWaXNDb25maWdTY2hlbWFWMCIsImFjY3VtdWxhdG9yIiwicmVuYW1lIiwiZ2VvanNvbiIsImVsZXZhdGlvblJhbmdlIiwicHJvcFRvUmVuYW1lIiwiTGF5ZXJDb25maWdTY2hlbWFEZWxldGVWMCIsImxheWVyUHJvcHNWMCIsImlkIiwiZGF0YUlkIiwibGFiZWwiLCJjb2xvciIsImlzVmlzaWJsZSIsImhpZGRlbiIsImNvbG9yRmllbGQiLCJwcm9wZXJ0aWVzIiwiY29sb3JTY2FsZSIsInNpemVGaWVsZCIsInNpemVTY2FsZSIsImVuYWJsZTNkIiwiY29sb3JBZ2dyZWdhdGlvbiIsInNpemVBZ2dyZWdhdGlvbiIsImlzQWdncmVnYXRlZCIsIkNvbHVtblNjaGVtYVYxIiwic3RhdGUiLCJja2V5IiwiVGV4dExhYmVsU2NoZW1hVjEiLCJ0ZXh0TGFiZWwiLCJtYXAiLCJ0bCIsIkFycmF5IiwiaXNBcnJheSIsInZpc3VhbENoYW5uZWxNb2RpZmljYXRpb25WMSIsInZjIiwibGF5ZXIiLCJpc09sZCIsImhhc093blByb3BlcnR5IiwiaXNQb2ludCIsInJhZGl1c0ZpZWxkIiwiTEFZRVJfVklTX0NPTkZJR1MiLCJkZWZhdWx0VmFsdWUiLCJzdHJva2VDb2xvckZpZWxkIiwic3Ryb2tlQ29sb3JTY2FsZSIsIlZpc3VhbENoYW5uZWxTY2hlbWFWMSIsIm1vZGlmaWVkIiwidmlzQ29uZmlnTW9kaWZpY2F0aW9uVjEiLCJwb2ludCIsInN0cm9rZUNvbG9yIiwic3Ryb2tlQ29sb3JSYW5nZSIsImNvbG9yUmFuZ2UiLCJvdXRsaW5lIiwiZmlsbGVkIiwiVmlzQ29uZmlnU2NoZW1hVjEiLCJsYXllclByb3BzVjEiLCJ2ZXJzaW9uIiwidjEiLCJoaWdobGlnaHRDb2xvciIsIkxheWVyU2NoZW1hVjAiLCJsYXllcnMiLCJ2aXNTdGF0ZSIsImxheWVyT3JkZXIiLCJsYXllcklkIiwiaXNWYWxpZFRvU2F2ZSIsInB1c2giLCJsb2FkUHJvcGVydGllc09yQXBwbHlTY2hlbWEiLCJGaWx0ZXJTY2hlbWFWMCIsImZpbHRlcnMiLCJmaWx0ZXIiLCJpc0ZpbHRlclZhbGlkVG9TYXZlIiwiZW5sYXJnZWQiLCJ2aWV3IiwiZmlsdGVyUHJvcHMiLCJuZXdGaWx0ZXIiLCJGSUxURVJfVklFV19UWVBFUyIsInNpZGUiLCJpbnRlcmFjdGlvblByb3BzVjAiLCJJbnRlcmFjdGlvblNjaGVtYVYwIiwiaW50ZXJhY3Rpb25Db25maWciLCJlbmFibGVkIiwiQm9vbGVhbiIsImludGVyYWN0aW9uUHJvcHNWMSIsIkludGVyYWN0aW9uU2NoZW1hVjEiLCJtb2RpZmllZENvbmZpZyIsImZvckVhY2giLCJjb25maWdUeXBlIiwiZmllbGRzVG9TaG93IiwiZmllbGREYXRhIiwibmFtZSIsImZvcm1hdCIsImZpbHRlclByb3BzVjAiLCJEaW1lbnNpb25GaWVsZFNjaGVtYSIsIlNwbGl0TWFwc1NjaGVtYSIsImlzQXZhaWxhYmxlIiwic3BsaXRNYXBzIiwibGVuZ3RoIiwic2V0dGluZ3MiLCJlbnRyaWVzIiwiY29udmVydExheWVyU2V0dGluZ3MiLCJlZmZlY3RQcm9wc1YxIiwiaXNFbmFibGVkIiwicGFyYW1ldGVycyIsIkVmZmVjdHNTY2hlbWEiLCJlZmZlY3RzIiwiZWZmZWN0T3JkZXIiLCJlZmZlY3RJZCIsImVmZmVjdCIsIm91dEVmZmVjdCIsInBhcmFtcyIsImZpbHRlclByb3BzVjEiLCJwbG90VHlwZSIsImFuaW1hdGlvbldpbmRvdyIsInlBeGlzIiwic3BlZWQiLCJwcm9wZXJ0aWVzVjAiLCJsYXllckJsZW5kaW5nIiwib3ZlcmxheUJsZW5kaW5nIiwicHJvcGVydGllc1YxIiwiYW5pbWF0aW9uQ29uZmlnIiwiY3VycmVudFRpbWUiLCJlZGl0b3IiLCJmZWF0dXJlcyIsInZpc2libGUiLCJWaXNTdGF0ZVNjaGVtYVYxIiwibm9kZSIsInZpc1N0YXRlU2NoZW1hVjAiLCJ2aXNTdGF0ZVNjaGVtYVYxIiwidmlzU3RhdGVTY2hlbWEiLCJzYXZlIiwidG9TYXZlIiwibG9hZCIsInRvTG9hZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFDQTtBQUVPLElBQU1BLGdCQUFnQixHQUFHLENBQUMsTUFBRCxFQUFTLE1BQVQsQ0FBekI7OztBQWtGUDtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxzQkFBVCxDQUFnQ0MsTUFBaEMsRUFBd0M7QUFDdEMsTUFBTUMsYUFBYSxHQUFHLEVBQXRCO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFELEVBQUksRUFBSixDQUEzQixDQUZzQyxDQUl0Qzs7QUFDQSxNQUFJRixNQUFNLENBQUNHLFNBQVAsQ0FBaUJDLFFB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SUU7QUFDQTtBQUNBLGFBQU8sS0FBSzNELDJCQUFMLENBQWlDMkQsSUFBakMsQ0FBUDtBQUNEOzs7RUFibUN6SSxrQjs7O0FBZ0IvQixJQUFNMEksZ0JBQWdCLEdBQUcsSUFBSTFJLGtCQUFKLENBQVc7QUFDekNvRSxFQUFBQSxPQUFPLEVBQUUvRSxtQkFBU0MsRUFEdUI7QUFFekN1QyxFQUFBQSxVQUFVLEVBQUVrRyxZQUY2QjtBQUd6Q3ZJLEVBQUFBLEdBQUcsRUFBRTtBQUhvQyxDQUFYLENBQXpCOztBQU1BLElBQU1tSixnQkFBZ0IsR0FBRyxJQUFJSCxnQkFBSixDQUFxQjtBQUNuRHBFLEVBQUFBLE9BQU8sRUFBRS9FLG1CQUFTZ0YsRUFEaUM7QUFFbkR4QyxFQUFBQSxVQUFVLEVBQUVxRyxZQUZ1QztBQUduRDFJLEVBQUFBLEdBQUcsRUFBRTtBQUg4QyxDQUFyQixDQUF6Qjs7QUFNQSxJQUFNb0osY0FHWiw0RUFFRXZKLG1CQUFTQyxFQUZYLEVBRWdCO0FBQ2J1SixFQUFBQSxJQUFJLEVBQUUsY0FBQUMsTUFBTTtBQUFBLFdBQUlKLGdCQUFnQixDQUFDRyxJQUFqQixDQUFzQkMsTUFBdEIsQ0FBSjtBQUFBLEdBREM7QUFFYkMsRUFBQUEsSUFBSSxFQUFFLGNBQUFDLE1BQU07QUFBQTs7QUFBQSxXQUFJTCxnQkFBZ0IsQ0FBQ0ksSUFBakIsMEJBQXNCTCxnQkFBZ0IsQ0FBQ0ssSUFBakIsQ0FBc0JDLE1BQXRCLENBQXRCLDBEQUFzQixzQkFBK0J2RSxRQUFyRCxDQUFKO0FBQUE7QUFGQyxDQUZoQixxREFNRXBGLG1CQUFTZ0YsRUFOWCxFQU1nQnNFLGdCQU5oQixtQkFITSxDLENBWVA7OztlQUNlQyxjIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IHBpY2sgZnJvbSAnbG9kYXNoLnBpY2snO1xuaW1wb3J0IHtWRVJTSU9OU30gZnJvbSAnLi92ZXJzaW9ucyc7XG5pbXBvcnQge0xBWUVSX1ZJU19DT05GSUdTLCBGSUxURVJfVklFV19UWVBFU30gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtpc0ZpbHRlclZhbGlkVG9TYXZlLCBub3ROdWxsb3JVbmRlZmluZWQsIGZpbmRCeUlkfSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCBTY2hlbWEgZnJvbSAnLi9zY2hlbWEnO1xuaW1wb3J0IGNsb25lRGVlcCBmcm9tICdsb2Rhc2guY2xvbmVkZWVwJztcbmltcG9ydCB7XG4gIEFkZERhdGFUb01hcE9wdGlvbnMsXG4gIEFuaW1hdGlvbkNvbmZpZyxcbiAgRWRpdG9yLFxuICBGaWxlTG9hZGluZyxcbiAgRmlsZUxvYWRpbmdQcm9ncmVzcyxcbiAgRmlsdGVyLFxuICBJbnRlcmFjdGlvbkNvbmZpZyxcbiAgTWFwSW5mbyxcbiAgUGFyc2VkRmlsdGVyLFxuICBQYXJzZWRMYXllcixcbiAgUGFyc2VkVmlzU3RhdGUsXG4gIFNhdmVkRmlsdGVyLFxuICBNaW5TYXZlZEZpbHRlcixcbiAgU2F2ZWRJbnRlcmFjdGlvbkNvbmZpZyxcbiAgU2F2ZWRMYXllcixcbiAgTWluU2F2ZWRMYXllcixcbiAgU2F2ZWRWaXNTdGF0ZSxcbiAgU3BsaXRNYXAsXG4gIFZhbHVlT2YsXG4gIEVmZmVjdFxufSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7RGF0YXNldHN9IGZyb20gJ0BrZXBsZXIuZ2wvdGFibGUnO1xuaW1wb3J0IHtMYXllciwgTGF5ZXJDbGFzc2VzVHlwZX0gZnJvbSAnQGtlcGxlci5nbC9sYXllcnMnO1xuaW1wb3J0IHtMb2FkZXJ9IGZyb20gJ0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscyc7XG5pbXBvcnQgS2VwbGVyR0xTY2hlbWEgZnJvbSAnLi9zY2hlbWEtbWFuYWdlcic7XG5cbi8qKlxuICogVjAgU2NoZW1hXG4gKi9cblxuZXhwb3J0IGNvbnN0IGRpbWVuc2lvblByb3BzVjAgPSBbJ25hbWUnLCAndHlwZSddO1xuXG5leHBvcnQgdHlwZSBtb2RpZmllZFR5cGUgPSB7XG4gIHN0cm9rZUNvbG9yPzogYW55O1xuICBzdHJva2VDb2xvclJhbmdlPzogYW55O1xuICBmaWxsZWQ/OiBib29sZWFuO1xuICBzdHJva2VkPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlzU3RhdGUge1xuICBtYXBJbmZvOiBNYXBJbmZvO1xuICBsYXllcnM6IExheWVyW107XG4gIGxheWVyRGF0YTogYW55W107XG4gIGxheWVyVG9CZU1lcmdlZDogYW55W107XG4gIGxheWVyT3JkZXI6IHN0cmluZ1tdO1xuICBlZmZlY3RzOiBFZmZlY3RbXTtcbiAgZWZmZWN0T3JkZXI6IHN0cmluZ1tdO1xuICBmaWx0ZXJzOiBGaWx0ZXJbXTtcbiAgZmlsdGVyVG9CZU1lcmdlZDogYW55W107XG4gIGRhdGFzZXRzOiBEYXRhc2V0cztcbiAgZWRpdGluZ0RhdGFzZXQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgaW50ZXJhY3Rpb25Db25maWc6IEludGVyYWN0aW9uQ29uZmlnO1xuICBpbnRlcmFjdGlvblRvQmVNZXJnZWQ6IGFueTtcbiAgbGF5ZXJCbGVuZGluZzogc3RyaW5nO1xuICBvdmVybGF5QmxlbmRpbmc/OiBzdHJpbmc7XG4gIGhvdmVySW5mbzogYW55O1xuICBjbGlja2VkOiBhbnk7XG4gIG1vdXNlUG9zOiBhbnk7XG4gIG1heERlZmF1bHRUb29sdGlwczogbnVtYmVyO1xuICBsYXllckNsYXNzZXM6IExheWVyQ2xhc3Nlc1R5cGU7XG4gIGFuaW1hdGlvbkNvbmZpZzogQW5pbWF0aW9uQ29uZmlnO1xuICBlZGl0b3I6IEVkaXRvcjtcbiAgc3BsaXRNYXBzOiBTcGxpdE1hcFtdO1xuICBzcGxpdE1hcHNUb0JlTWVyZ2VkOiBTcGxpdE1hcFtdO1xuICBmaWxlTG9hZGluZzogRmlsZUxvYWRpbmcgfCBmYWxzZTtcbiAgZmlsZUxvYWRpbmdQcm9ncmVzczogRmlsZUxvYWRpbmdQcm9ncmVzcztcbiAgbG9hZGVyczogTG9hZGVyW107XG4gIGxvYWRPcHRpb25zOiBvYmplY3Q7XG4gIGluaXRpYWxTdGF0ZT86IFBhcnRpYWw8VmlzU3RhdGU+O1xuICBtZXJnZXJzOiBWaXNTdGF0ZU1lcmdlcnM8YW55PjtcbiAgc2NoZW1hOiB0eXBlb2YgS2VwbGVyR0xTY2hlbWE7XG4gIHByZXNlcnZlTGF5ZXJPcmRlcj86IHN0cmluZ1tdO1xuICBwcmVzZXJ2ZUZpbHRlck9yZGVyPzogc3RyaW5nW107XG4gIHByZXNlcnZlRGF0YXNldE9yZGVyPzogc3RyaW5nW107XG4gIGlzTWVyZ2luZ0RhdGFzZXRzOiB7XG4gICAgW2RhdGFzZXRJZDogc3RyaW5nXTogYm9vbGVhbjtcbiAgfTtcbn1cblxuZXhwb3J0IHR5cGUgUG9zdE1lcmdlclBheWxvYWQgPSB7XG4gIG5ld0RhdGFJZHM6IHN0cmluZ1tdO1xuICBvcHRpb25zPzogQWRkRGF0YVRvTWFwT3B0aW9ucztcbiAgbGF5ZXJNZXJnZXJzPzogTWVyZ2VyPGFueT5bXTtcbn07XG5leHBvcnQgdHlwZSBNZXJnZXJBY3Rpb25QYXlsb2FkPFMgZXh0ZW5kcyB7fT4gPSB7XG4gIG1lcmdlcnM6IE1lcmdlcjxTPltdO1xuICBwb3N0TWVyZ2VyUGF5bG9hZDogUG9zdE1lcmdlclBheWxvYWQ7XG59O1xuZXhwb3J0IHR5cGUgTWVyZ2VyTWVyZ2VGdW5jPFMgZXh0ZW5kcyB7fT4gPSAoXG4gIHN0YXRlOiBTLFxuICBjb25maWc6IGFueSxcbiAgZnJvbUNvbmZpZzogYm9vbGVhbixcbiAgbWVyZ2VyQWN0aW9uUGF5bG9hZD86IE1lcmdlckFjdGlvblBheWxvYWQ8Uz5cbikgPT4gUztcbmV4cG9ydCB0eXBlIFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzRnVuYzxUPiA9IChcbiAgaXRlbTogVCxcbiAgZGF0YUlkOiBzdHJpbmcsXG4gIGRhdGFJZFRvUmVwbGFjZTogc3RyaW5nXG4pID0+IFQgfCBudWxsO1xuZXhwb3J0IHR5cGUgTWVyZ2VyPFMgZXh0ZW5kcyB7fT4gPSB7XG4gIG1lcmdlOiBNZXJnZXJNZXJnZUZ1bmM8Uz47XG4gIHByb3A6IHN0cmluZyB8IHN0cmluZ1tdO1xuICB0b01lcmdlUHJvcD86IHN0cmluZyB8IHN0cmluZ1tdO1xuICBwcmVzZXJ2ZU9yZGVyPzogc3RyaW5nO1xuICB3YWl0VG9GaW5pc2g/OiBib29sZWFuO1xuICB3YWl0Rm9yTGF5ZXJEYXRhPzogYm9vbGVhbjtcbiAgcmVwbGFjZVBhcmVudERhdGFzZXRJZHM/OiBSZXBsYWNlUGFyZW50RGF0YXNldElkc0Z1bmM8VmFsdWVPZjxTPj47XG4gIHNhdmVVbm1lcmdlZD86IChzdGF0ZTogUywgdW5tZXJnZWQ6IGFueSkgPT4gUztcbiAgZ2V0Q2hpbGREYXRhc2V0SWRzPzogYW55O1xufTtcbmV4cG9ydCB0eXBlIFZpc1N0YXRlTWVyZ2VyczxTIGV4dGVuZHMge30+ID0gTWVyZ2VyPFM+W107XG5cbi8vIGluIHYwIGdlb2pzb24gdGhlcmUgaXMgb25seSBzaXplRmllbGRcblxuLy8gaW4gdjEgZ2VvanNvblxuLy8gc3Ryb2tlIGJhc2Ugb24gLT4gc2l6ZUZpZWxkXG4vLyBoZWlnaHQgYmFzZWQgb24gLT4gaGVpZ2h0RmllbGRcbi8vIHJhZGl1cyBiYXNlZCBvbiAtPiByYWRpdXNGaWVsZFxuLy8gaGVyZSB3ZSBtYWtlIG91ciB3aXJlZHN0IGd1ZXNzIG9uIHdoaWNoIGNoYW5uZWwgc2l6ZUZpZWxkIGJlbG9uZ3MgdG9cbmZ1bmN0aW9uIGdlb2pzb25TaXplRmllbGRWMFRvVjEoY29uZmlnKSB7XG4gIGNvbnN0IGRlZmF1bHRSYWl1ZHMgPSAxMDtcbiAgY29uc3QgZGVmYXVsdFJhZGl1c1JhbmdlID0gWzAsIDUwXTtcblxuICAvLyBpZiBleHRydWRlZCwgc2l6ZUZpZWxkIGlzIG1vc3QgbGlrZWx5IHVzZWQgZm9yIGhlaWdodFxuICBpZiAoY29uZmlnLnZpc0NvbmZpZy5leHRydWRlZCkge1xuICAgIHJldHVybiAnaGVpZ2h0RmllbGQnO1xuICB9XG5cbiAgLy8gaWYgc2hvdyBzdHJva2UgZW5hYmxlZCwgc2l6ZUZpZWxkIGlzIG1vc3QgbGlrZWx5IHVzZWQgZm9yIHN0cm9rZVxuICBpZiAoY29uZmlnLnZpc0NvbmZpZy5zdHJva2VkKSB7XG4gICAgcmV0dXJuICdzaXplRmllbGQnO1xuICB9XG5cbiAgLy8gaWYgcmFkaXVzIGNoYW5nZWQsIG9yIHJhZGl1cyBSYW5nZSBDaGFuZ2VkLCBzaXplRmllbGQgaXMgbW9zdCBsaWtlbHkgdXNlZCBmb3IgcmFkaXVzXG4gIC8vIHRoaXMgaXMgdGhlIG1vc3QgdW5yZWxpYWJsZSBndWVzcywgdGhhdCdzIHdoeSB3ZSBwdXQgaXQgaW4gdGhlIGVuZFxuICBpZiAoXG4gICAgY29uZmlnLnZpc0NvbmZpZy5yYWRpdXMgIT09IGRlZmF1bHRSYWl1ZHMgfHxcbiAgICBjb25maWcudmlzQ29uZmlnLnJhZGl1c1JhbmdlLnNvbWUoKGQsIGkpID0+IGQgIT09IGRlZmF1bHRSYWRpdXNSYW5nZVtpXSlcbiAgKSB7XG4gICAgcmV0dXJuICdyYWRpdXNGaWVsZCc7XG4gIH1cblxuICByZXR1cm4gJ3NpemVGaWVsZCc7XG59XG5cbi8vIGNvbnZlcnQgdjAgdG8gdjEgbGF5ZXIgY29uZmlnXG5jbGFzcyBEaW1lbnNpb25GaWVsZFNjaGVtYVYwIGV4dGVuZHMgU2NoZW1hIHtcbiAgdmVyc2lvbiA9IFZFUlNJT05TLnYwO1xuICBzYXZlKGZpZWxkKSB7XG4gICAgLy8gc2hvdWxkIG5vdCBiZSBjYWxsZWQgYW55bW9yZVxuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5rZXldOiBmaWVsZCAhPT0gbnVsbCA/IHRoaXMuc2F2ZVByb3BlcnRpZXNPckFwcGx5U2NoZW1hKGZpZWxkKVt0aGlzLmtleV0gOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGxvYWQoZmllbGQsIHBhcmVudHMsIGFjY3VtdWxhdGVkKSB7XG4gICAgY29uc3QgW2NvbmZpZ10gPSBwYXJlbnRzLnNsaWNlKC0xKTtcbiAgICBsZXQgZmllbGROYW1lID0gdGhpcy5rZXk7XG4gICAgaWYgKGNvbmZpZy50eXBlID09PSAnZ2VvanNvbicgJiYgdGhpcy5rZXkgPT09ICdzaXplRmllbGQnICYmIGZpZWxkKSB7XG4gICAgICBmaWVsZE5hbWUgPSBnZW9qc29uU2l6ZUZpZWxkVjBUb1YxKGNvbmZpZyk7XG4gICAgfVxuICAgIC8vIGZvbGQgaW50byB2aXN1YWxDaGFubmVscyB0byBiZSBsb2FkIGJ5IFZpc3VhbENoYW5uZWxTY2hlbWFWMVxuICAgIHJldHVybiB7XG4gICAgICB2aXN1YWxDaGFubmVsczoge1xuICAgICAgICAuLi4oYWNjdW11bGF0ZWQudmlzdWFsQ2hhbm5lbHMgfHwge30pLFxuICAgICAgICBbZmllbGROYW1lXTogZmllbGRcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmNsYXNzIERpbWVuc2lvblNjYWxlU2NoZW1hVjAgZXh0ZW5kcyBTY2hlbWEge1xuICB2ZXJzaW9uID0gVkVSU0lPTlMudjA7XG4gIHNhdmUoc2NhbGUpIHtcbiAgICByZXR1cm4ge1t0aGlzLmtleV06IHNjYWxlfTtcbiAgfVxuICBsb2FkKHNjYWxlLCBwYXJlbnRzLCBhY2N1bXVsYXRlZCkge1xuICAgIGNvbnN0IFtjb25maWddID0gcGFyZW50cy5zbGljZSgtMSk7XG4gICAgLy8gZm9sZCBpbnRvIHZpc3VhbENoYW5uZWxzIHRvIGJlIGxvYWQgYnkgVmlzdWFsQ2hhbm5lbFNjaGVtYVYxXG4gICAgaWYgKHRoaXMua2V5ID09PSAnc2l6ZVNjYWxlJyAmJiBjb25maWcudHlwZSA9PT0gJ2dlb2pzb24nKSB7XG4gICAgICAvLyBzaXplU2NhbGUgbm93IHNwbGl0IGludG8gcmFkaXVzU2NhbGUsIGhlaWdodFNjYWxlXG4gICAgICAvLyBubyB1c2VyIGN1c3RvbWl6YXRpb24sIGp1c3QgdXNlIGRlZmF1bHRcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlzdWFsQ2hhbm5lbHM6IHtcbiAgICAgICAgLi4uKGFjY3VtdWxhdGVkLnZpc3VhbENoYW5uZWxzIHx8IHt9KSxcbiAgICAgICAgW3RoaXMua2V5XTogc2NhbGVcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8vIHVzZWQgdG8gY29udmVydCB2MCB0byB2MSBsYXllciBjb25maWdcbmNsYXNzIExheWVyQ29uZmlnU2NoZW1hVjAgZXh0ZW5kcyBTY2hlbWEge1xuICB2ZXJzaW9uID0gVkVSU0lPTlMudjA7XG4gIGxvYWQoc2F2ZWQsIHBhcmVudHMsIGFjY3VtdWxhdGVkKSB7XG4gICAgLy8gZm9sZCB2MCBsYXllciBwcm9wZXJ0eSBpbnRvIGNvbmZpZy5rZXlcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIC4uLihhY2N1bXVsYXRlZC5jb25maWcgfHwge30pLFxuICAgICAgICBbdGhpcy5rZXldOiBzYXZlZFxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLy8gdXNlZCB0byBjb252ZXJ0IHYwIHRvIHYxIGxheWVyIGNvbHVtbnNcbi8vIG9ubHkgcmV0dXJuIGNvbHVtbiB2YWx1ZSBmb3IgZWFjaCBjb2x1bW5cbmNsYXNzIExheWVyQ29sdW1uc1NjaGVtYVYwIGV4dGVuZHMgU2NoZW1hIHtcbiAgdmVyc2lvbiA9IFZFUlNJT05TLnYwO1xuICBsb2FkKHNhdmVkLCBwYXJlbnRzLCBhY2N1bXVsYXRlZCkge1xuICAgIC8vIGZvbGQgdjAgbGF5ZXIgcHJvcGVydHkgaW50byBjb25maWcua2V5LCBmbGF0dGVuIGNvbHVtbnNcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIC4uLihhY2N1bXVsYXRlZC5jb25maWcgfHwge30pLFxuICAgICAgICBjb2x1bW5zOiBPYmplY3Qua2V5cyhzYXZlZCkucmVkdWNlKFxuICAgICAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgICAgICAuLi5hY2N1LFxuICAgICAgICAgICAgW2tleV06IHNhdmVkW2tleV0udmFsdWVcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7fVxuICAgICAgICApXG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG4vLyB1c2VkIHRvIGNvbnZlcnQgdjAgdG8gdjEgbGF5ZXIgY29uZmlnLnZpc0NvbmZpZ1xuY2xhc3MgTGF5ZXJDb25maWdUb1Zpc0NvbmZpZ1NjaGVtYVYwIGV4dGVuZHMgU2NoZW1hIHtcbiAgdmVyc2lvbiA9IFZFUlNJT05TLnYwO1xuICBsb2FkKHNhdmVkLCBwYXJlbnRzLCBhY2N1bXVsYXRlZCkge1xuICAgIC8vIGZvbGQgdjAgbGF5ZXIgcHJvcGVydHkgaW50byBjb25maWcudmlzQ29uZmlnXG4gICAgY29uc3QgYWNjdW11bGF0ZWRDb25maWcgPSBhY2N1bXVsYXRlZC5jb25maWcgfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICAuLi5hY2N1bXVsYXRlZENvbmZpZyxcbiAgICAgICAgdmlzQ29uZmlnOiB7XG4gICAgICAgICAgLi4uKGFjY3VtdWxhdGVkQ29uZmlnLnZpc0NvbmZpZyB8fCB7fSksXG4gICAgICAgICAgW3RoaXMua2V5XTogc2F2ZWRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgTGF5ZXJWaXNDb25maWdTY2hlbWFWMCBleHRlbmRzIFNjaGVtYSB7XG4gIHZlcnNpb24gPSBWRVJTSU9OUy52MDtcbiAga2V5ID0gJ3Zpc0NvbmZpZyc7XG5cbiAgbG9hZCh2aXNDb25maWcsIHBhcmVudHMsIGFjY3VtdWxhdG9yKSB7XG4gICAgY29uc3QgW2NvbmZpZ10gPSBwYXJlbnRzLnNsaWNlKC0xKTtcbiAgICBjb25zdCByZW5hbWUgPSB7XG4gICAgICBnZW9qc29uOiB7XG4gICAgICAgIGV4dHJ1ZGVkOiAnZW5hYmxlM2QnLFxuICAgICAgICBlbGV2YXRpb25SYW5nZTogJ2hlaWdodFJhbmdlJ1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoY29uZmlnLnR5cGUgaW4gcmVuYW1lKSB7XG4gICAgICBjb25zdCBwcm9wVG9SZW5hbWUgPSByZW5hbWVbY29uZmlnLnR5cGVdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgLi4uKGFjY3VtdWxhdG9yLmNvbmZpZyB8fCB7fSksXG4gICAgICAgICAgdmlzQ29uZmlnOiBPYmplY3Qua2V5cyh2aXNDb25maWcpLnJlZHVjZShcbiAgICAgICAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgICAgIC4uLihwcm9wVG9SZW5hbWVba2V5XVxuICAgICAgICAgICAgICAgID8ge1twcm9wVG9SZW5hbWVba2V5XV06IHZpc0NvbmZpZ1trZXldfVxuICAgICAgICAgICAgICAgIDoge1trZXldOiB2aXNDb25maWdba2V5XX0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHt9XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb25maWc6IHtcbiAgICAgICAgLi4uKGFjY3VtdWxhdG9yLmNvbmZpZyB8fCB7fSksXG4gICAgICAgIHZpc0NvbmZpZ1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgTGF5ZXJDb25maWdTY2hlbWFEZWxldGVWMCBleHRlbmRzIFNjaGVtYSB7XG4gIHZlcnNpb24gPSBWRVJTSU9OUy52MDtcbiAgbG9hZCh2YWx1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vKipcbiAqIFYwIC0+IFYxIENoYW5nZXNcbiAqIC0gbGF5ZXIgaXMgbm93IGEgY2xhc3NcbiAqIC0gY29uZmlnIHNhdmVkIGluIGEgY29uZmlnIG9iamVjdFxuICogLSBpZCwgdHlwZSwgaXNBZ2dyZWdhdGVkIGlzIG91dHNpZGUgbGF5ZXIuY29uZmlnXG4gKiAtIHZpc3VhbENoYW5uZWxzIGlzIG91dHNpZGUgY29uZmlnLCBpdCBkZWZpbmVzIGF2YWlsYWJsZSB2aXN1YWwgY2hhbm5lbCBhbmRcbiAqICAgcHJvcGVydHkgbmFtZXMgZm9yIGZpZWxkLCBzY2FsZSwgZG9tYWluIGFuZCByYW5nZSBvZiBlYWNoIHZpc3VhbCBjaGFuZWwuXG4gKiAtIGVuYWJsZTNkLCBjb2xvckFnZ3JlZ2F0aW9uIGFuZCBzaXplQWdncmVnYXRpb24gYXJlIG1vdmVkIGludG8gdmlzQ29uZmlnXG4gKiAtIEdlb2pzb25MYXllciAtIGFkZGVkIGhlaWdodCwgcmFkaXVzIHNwZWNpZmljIHByb3BlcnRpZXNcbiAqL1xuXG5leHBvcnQgY29uc3QgbGF5ZXJQcm9wc1YwID0ge1xuICBpZDogbnVsbCxcbiAgdHlwZTogbnVsbCxcblxuICAvLyBtb3ZlIGludG8gbGF5ZXIuY29uZmlnXG4gIGRhdGFJZDogbmV3IExheWVyQ29uZmlnU2NoZW1hVjAoe2tleTogJ2RhdGFJZCd9KSxcbiAgbGFiZWw6IG5ldyBMYXllckNvbmZpZ1NjaGVtYVYwKHtrZXk6ICdsYWJlbCd9KSxcbiAgY29sb3I6IG5ldyBMYXllckNvbmZpZ1NjaGVtYVYwKHtrZXk6ICdjb2xvcid9KSxcbiAgaXNWaXNpYmxlOiBuZXcgTGF5ZXJDb25maWdTY2hlbWFWMCh7a2V5OiAnaXNWaXNpYmxlJ30pLFxuICBoaWRkZW46IG5ldyBMYXllckNvbmZpZ1NjaGVtYVYwKHtrZXk6ICdoaWRkZW4nfSksXG5cbiAgLy8gY29udmVydCB2aXNDb25maWdcbiAgdmlzQ29uZmlnOiBuZXcgTGF5ZXJWaXNDb25maWdTY2hlbWFWMCh7a2V5OiAndmlzQ29uZmlnJ30pLFxuXG4gIC8vIG1vdmUgaW50byBsYXllci5jb25maWdcbiAgLy8gZmxhdHRlblxuICBjb2x1bW5zOiBuZXcgTGF5ZXJDb2x1bW5zU2NoZW1hVjAoKSxcblxuICAvLyBzYXZlIGludG8gdmlzdWFsQ2hhbm5lbHNcbiAgY29sb3JGaWVsZDogbmV3IERpbWVuc2lvbkZpZWxkU2NoZW1hVjAoe1xuICAgIHByb3BlcnRpZXM6IGRpbWVuc2lvblByb3BzVjAsXG4gICAga2V5OiAnY29sb3JGaWVsZCdcbiAgfSksXG4gIGNvbG9yU2NhbGU6IG5ldyBEaW1lbnNpb25TY2FsZVNjaGVtYVYwKHtcbiAgICBrZXk6ICdjb2xvclNjYWxlJ1xuICB9KSxcbiAgc2l6ZUZpZWxkOiBuZXcgRGltZW5zaW9uRmllbGRTY2hlbWFWMCh7XG4gICAgcHJvcGVydGllczogZGltZW5zaW9uUHJvcHNWMCxcbiAgICBrZXk6ICdzaXplRmllbGQnXG4gIH0pLFxuICBzaXplU2NhbGU6IG5ldyBEaW1lbnNpb25TY2FsZVNjaGVtYVYwKHtcbiAgICBrZXk6ICdzaXplU2NhbGUnXG4gIH0pLFxuXG4gIC8vIG1vdmUgaW50byBjb25maWcudmlzQ29uZmlnXG4gIGVuYWJsZTNkOiBuZXcgTGF5ZXJDb25maWdUb1Zpc0NvbmZpZ1NjaGVtYVYwKHtrZXk6ICdlbmFibGUzZCd9KSxcbiAgY29sb3JBZ2dyZWdhdGlvbjogbmV3IExheWVyQ29uZmlnVG9WaXNDb25maWdTY2hlbWFWMCh7XG4gICAga2V5OiAnY29sb3JBZ2dyZWdhdGlvbidcbiAgfSksXG4gIHNpemVBZ2dyZWdhdGlvbjogbmV3IExheWVyQ29uZmlnVG9WaXNDb25maWdTY2hlbWFWMCh7a2V5OiAnc2l6ZUFnZ3JlZ2F0aW9uJ30pLFxuXG4gIC8vIGRlbGV0ZVxuICBpc0FnZ3JlZ2F0ZWQ6IG5ldyBMYXllckNvbmZpZ1NjaGVtYURlbGV0ZVYwKClcbn07XG5cbi8qKlxuICogVjEgU2NoZW1hXG4gKi9cbmNsYXNzIENvbHVtblNjaGVtYVYxIGV4dGVuZHMgU2NoZW1hIHtcbiAgc2F2ZShjb2x1bW5zLCBzdGF0ZSkge1xuICAgIC8vIHN0YXJ0aW5nIGZyb20gdjEsIG9ubHkgc2F2ZSBjb2x1bW4gdmFsdWVcbiAgICAvLyBmaWVsZElkeCB3aWxsIGJlIGNhbGN1bGF0ZWQgZHVyaW5nIG1lcmdlXG4gICAgcmV0dXJuIHtcbiAgICAgIFt0aGlzLmtleV06IE9iamVjdC5rZXlzKGNvbHVtbnMpLnJlZHVjZShcbiAgICAgICAgKGFjY3UsIGNrZXkpID0+ICh7XG4gICAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgICAvLyBpZiB2YWx1ZSBpcyBudWxsLCBkb24ndCBzYXZlIGl0XG4gICAgICAgICAgLi4uKGNvbHVtbnNbY2tleV0/LnZhbHVlID8ge1tja2V5XTogY29sdW1uc1tja2V5XS52YWx1ZX0gOiB7fSlcbiAgICAgICAgfSksXG4gICAgICAgIHt9XG4gICAgICApXG4gICAgfTtcbiAgfVxuXG4gIGxvYWQoY29sdW1ucykge1xuICAgIHJldHVybiB7Y29sdW1uc307XG4gIH1cbn1cblxuY2xhc3MgVGV4dExhYmVsU2NoZW1hVjEgZXh0ZW5kcyBTY2hlbWEge1xuICBzYXZlKHRleHRMYWJlbCkge1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5rZXldOiB0ZXh0TGFiZWwubWFwKHRsID0+ICh7XG4gICAgICAgIC4uLnRsLFxuICAgICAgICBmaWVsZDogdGwuZmllbGQgPyBwaWNrKHRsLmZpZWxkLCBbJ25hbWUnLCAndHlwZSddKSA6IG51bGxcbiAgICAgIH0pKVxuICAgIH07XG4gIH1cblxuICBsb2FkKHRleHRMYWJlbCkge1xuICAgIHJldHVybiB7dGV4dExhYmVsOiBBcnJheS5pc0FycmF5KHRleHRMYWJlbCkgPyB0ZXh0TGFiZWwgOiBbdGV4dExhYmVsXX07XG4gIH1cbn1cblxuY29uc3QgdmlzdWFsQ2hhbm5lbE1vZGlmaWNhdGlvblYxID0ge1xuICBnZW9qc29uOiAodmMsIHBhcmVudHMsIGFjY3VtdWxhdG9yKSA9PiB7XG4gICAgY29uc3QgW2xheWVyXSA9IHBhcmVudHMuc2xpY2UoLTEpO1xuICAgIGNvbnN0IGlzT2xkID0gIXZjLmhhc093blByb3BlcnR5KCdzdHJva2VDb2xvckZpZWxkJyk7XG4gICAgLy8gbWFrZSBvdXIgYmVzdCBndWVzcyBpZiB0aGlzIGdlb2pzb24gbGF5ZXIgY29udGFpbnMgcG9pbnRcbiAgICBjb25zdCBpc1BvaW50ID1cbiAgICAgIHZjLnJhZGl1c0ZpZWxkIHx8IGxheWVyLmNvbmZpZy52aXNDb25maWcucmFkaXVzICE9PSBMQVlFUl9WSVNfQ09ORklHUy5yYWRpdXMuZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKGlzT2xkICYmICFpc1BvaW50ICYmIGxheWVyLmNvbmZpZy52aXNDb25maWcuc3Ryb2tlZCkge1xuICAgICAgLy8gaWYgc3Ryb2tlZCBpcyB0cnVlLCBjb3B5IGNvbG9yIGNvbmZpZyB0byBzdHJva2UgY29sb3IgY29uZmlnXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJva2VDb2xvckZpZWxkOiB2Yy5jb2xvckZpZWxkLFxuICAgICAgICBzdHJva2VDb2xvclNjYWxlOiB2Yy5jb2xvclNjYWxlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH1cbn07XG4vKipcbiAqIFYxOiBzYXZlIFtmaWVsZF06IHtuYW1lLCB0eXBlfSwgW3NjYWxlXTogJycgZm9yIGVhY2ggY2hhbm5lbFxuICovXG5jbGFzcyBWaXN1YWxDaGFubmVsU2NoZW1hVjEgZXh0ZW5kcyBTY2hlbWEge1xuICBzYXZlKHZpc3VhbENoYW5uZWxzLCBwYXJlbnRzKSB7XG4gICAgLy8gb25seSBzYXZlIGZpZWxkIGFuZCBzY2FsZSBvZiBlYWNoIGNoYW5uZWxcbiAgICBjb25zdCBbbGF5ZXJdID0gcGFyZW50cy5zbGljZSgtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFt0aGlzLmtleV06IE9iamVjdC5rZXlzKHZpc3VhbENoYW5uZWxzKS5yZWR1Y2UoXG4gICAgICAgIC8vICBzYXZlIGNoYW5uZWwgdG8gbnVsbCBpZiBkaWRuJ3Qgc2VsZWN0IGFueSBmaWVsZFxuICAgICAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgW3Zpc3VhbENoYW5uZWxzW2tleV0uZmllbGRdOiBsYXllci5jb25maWdbdmlzdWFsQ2hhbm5lbHNba2V5XS5maWVsZF1cbiAgICAgICAgICAgID8gcGljayhsYXllci5jb25maWdbdmlzdWFsQ2hhbm5lbHNba2V5XS5maWVsZF0sIFsnbmFtZScsICd0eXBlJ10pXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgW3Zpc3VhbENoYW5uZWxzW2tleV0uc2NhbGVdOiBsYXllci5jb25maWdbdmlzdWFsQ2hhbm5lbHNba2V5XS5zY2FsZV1cbiAgICAgICAgfSksXG4gICAgICAgIHt9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICBsb2FkKHZjLCBwYXJlbnRzLCBhY2N1bXVsYXRvcikge1xuICAgIC8vIGZvbGQgY2hhbm5lbHMgaW50byBjb25maWdcbiAgICBjb25zdCBbbGF5ZXJdID0gcGFyZW50cy5zbGljZSgtMSk7XG4gICAgY29uc3QgbW9kaWZpZWQgPSB2aXN1YWxDaGFubmVsTW9kaWZpY2F0aW9uVjFbbGF5ZXIudHlwZV1cbiAgICAgID8gdmlzdWFsQ2hhbm5lbE1vZGlmaWNhdGlvblYxW2xheWVyLnR5cGVdKHZjLCBwYXJlbnRzLCBhY2N1bXVsYXRvcilcbiAgICAgIDoge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjdW11bGF0b3IsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgLi4uKGFjY3VtdWxhdG9yLmNvbmZpZyB8fCB7fSksXG4gICAgICAgIC4uLnZjLFxuICAgICAgICAuLi5tb2RpZmllZFxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IHZpc0NvbmZpZ01vZGlmaWNhdGlvblYxID0ge1xuICBwb2ludDogKHZpc0NvbmZpZywgcGFyZW50cywgYWNjdW11bGF0ZWQpID0+IHtcbiAgICBjb25zdCBtb2RpZmllZDogbW9kaWZpZWRUeXBlID0ge307XG4gICAgY29uc3QgW2xheWVyXSA9IHBhcmVudHMuc2xpY2UoLTIsIC0xKTtcbiAgICBjb25zdCBpc09sZCA9XG4gICAgICAhdmlzQ29uZmlnLmhhc093blByb3BlcnR5KCdmaWxsZWQnKSAmJiAhdmlzQ29uZmlnLnN0cm9rZUNvbG9yICYmICF2aXNDb25maWcuc3Ryb2tlQ29sb3JSYW5nZTtcbiAgICBpZiAoaXNPbGQpIHtcbiAgICAgIC8vIGNvbG9yIGNvbG9yICYgY29sb3IgcmFuZ2UgdG8gc3Ryb2tlIGNvbG9yXG4gICAgICBtb2RpZmllZC5zdHJva2VDb2xvciA9IGxheWVyLmNvbmZpZy5jb2xvcjtcbiAgICAgIG1vZGlmaWVkLnN0cm9rZUNvbG9yUmFuZ2UgPSBjbG9uZURlZXAodmlzQ29uZmlnLmNvbG9yUmFuZ2UpO1xuICAgICAgaWYgKHZpc0NvbmZpZy5vdXRsaW5lKSB7XG4gICAgICAgIC8vIHBvaW50IGxheWVyIG5vdyBzdXBwb3J0cyBib3RoIG91dGxpbmUgYW5kIGZpbGxcbiAgICAgICAgLy8gZm9yIG9sZGVyIHNjaGVtYSB3aGVyZSBmaWxsZWQgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHBvaW50IGxheWVyXG4gICAgICAgIC8vIHNldCBpdCB0byBmYWxzZVxuICAgICAgICBtb2RpZmllZC5maWxsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW9kaWZpZWQ7XG4gIH0sXG4gIGdlb2pzb246ICh2aXNDb25maWcsIHBhcmVudHMsIGFjY3VtdWxhdGVkKSA9PiB7XG4gICAgLy8gaXMgcG9pbnRzP1xuICAgIGNvbnN0IG1vZGlmaWVkOiBtb2RpZmllZFR5cGUgPSB7fTtcbiAgICBjb25zdCBbbGF5ZXJdID0gcGFyZW50cy5zbGljZSgtMiwgLTEpO1xuICAgIGNvbnN0IGlzT2xkID1cbiAgICAgIGxheWVyLnZpc3VhbENoYW5uZWxzICYmXG4gICAgICAhbGF5ZXIudmlzdWFsQ2hhbm5lbHMuaGFzT3duUHJvcGVydHkoJ3N0cm9rZUNvbG9yRmllbGQnKSAmJlxuICAgICAgIXZpc0NvbmZpZy5zdHJva2VDb2xvciAmJlxuICAgICAgIXZpc0NvbmZpZy5zdHJva2VDb2xvclJhbmdlO1xuICAgIC8vIG1ha2Ugb3VyIGJlc3QgZ3Vlc3MgaWYgdGhpcyBnZW9qc29uIGxheWVyIGNvbnRhaW5zIHBvaW50XG4gICAgY29uc3QgaXNQb2ludCA9XG4gICAgICAobGF5ZXIudmlzdWFsQ2hhbm5lbHMgJiYgbGF5ZXIudmlzdWFsQ2hhbm5lbHMucmFkaXVzRmllbGQpIHx8XG4gICAgICAodmlzQ29uZmlnICYmIHZpc0NvbmZpZy5yYWRpdXMgIT09IExBWUVSX1ZJU19DT05GSUdTLnJhZGl1cy5kZWZhdWx0VmFsdWUpO1xuXG4gICAgaWYgKGlzT2xkKSB7XG4gICAgICAvLyBjb2xvciBjb2xvciAmIGNvbG9yIHJhbmdlIHRvIHN0cm9rZSBjb2xvclxuICAgICAgbW9kaWZpZWQuc3Ryb2tlQ29sb3IgPSBsYXllci5jb25maWcuY29sb3I7XG4gICAgICBtb2RpZmllZC5zdHJva2VDb2xvclJhbmdlID0gY2xvbmVEZWVwKHZpc0NvbmZpZy5jb2xvclJhbmdlKTtcbiAgICAgIGlmIChpc1BvaW50KSB7XG4gICAgICAgIC8vIGlmIGlzIHBvaW50LCBzZXQgc3Ryb2tlIHRvIGZhbHNlXG4gICAgICAgIG1vZGlmaWVkLmZpbGxlZCA9IHRydWU7XG4gICAgICAgIG1vZGlmaWVkLnN0cm9rZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW9kaWZpZWQ7XG4gIH1cbn07XG5cbmNsYXNzIFZpc0NvbmZpZ1NjaGVtYVYxIGV4dGVuZHMgU2NoZW1hIHtcbiAga2V5ID0gJ3Zpc0NvbmZpZyc7XG5cbiAgbG9hZCh2aXNDb25maWcsIHBhcmVudHMsIGFjY3VtdWxhdGVkKSB7XG4gICAgY29uc3QgW2xheWVyXSA9IHBhcmVudHMuc2xpY2UoLTIsIC0xKTtcbiAgICBjb25zdCBtb2RpZmllZCA9IHZpc0NvbmZpZ01vZGlmaWNhdGlvblYxW2xheWVyLnR5cGVdXG4gICAgICA/IHZpc0NvbmZpZ01vZGlmaWNhdGlvblYxW2xheWVyLnR5cGVdKHZpc0NvbmZpZywgcGFyZW50cywgYWNjdW11bGF0ZWQpXG4gICAgICA6IHt9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpc0NvbmZpZzoge1xuICAgICAgICAuLi52aXNDb25maWcsXG4gICAgICAgIC4uLm1vZGlmaWVkXG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbGF5ZXJQcm9wc1YxID0ge1xuICBpZDogbnVsbCxcbiAgdHlwZTogbnVsbCxcbiAgY29uZmlnOiBuZXcgU2NoZW1hKHtcbiAgICB2ZXJzaW9uOiBWRVJTSU9OUy52MSxcbiAgICBrZXk6ICdjb25maWcnLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGRhdGFJZDogbnVsbCxcbiAgICAgIGxhYmVsOiBudWxsLFxuICAgICAgY29sb3I6IG51bGwsXG4gICAgICBoaWdobGlnaHRDb2xvcjogbnVsbCxcbiAgICAgIGNvbHVtbnM6IG5ldyBDb2x1bW5TY2hlbWFWMSh7XG4gICAgICAgIHZlcnNpb246IFZFUlNJT05TLnYxLFxuICAgICAgICBrZXk6ICdjb2x1bW5zJ1xuICAgICAgfSksXG4gICAgICBpc1Zpc2libGU6IG51bGwsXG4gICAgICB2aXNDb25maWc6IG5ldyBWaXNDb25maWdTY2hlbWFWMSh7XG4gICAgICAgIHZlcnNpb246IFZFUlNJT05TLnYxXG4gICAgICB9KSxcbiAgICAgIGhpZGRlbjogbnVsbCxcbiAgICAgIHRleHRMYWJlbDogbmV3IFRleHRMYWJlbFNjaGVtYVYxKHtcbiAgICAgICAgdmVyc2lvbjogVkVSU0lPTlMudjEsXG4gICAgICAgIGtleTogJ3RleHRMYWJlbCdcbiAgICAgIH0pXG4gICAgfVxuICB9KSxcbiAgdmlzdWFsQ2hhbm5lbHM6IG5ldyBWaXN1YWxDaGFubmVsU2NoZW1hVjEoe1xuICAgIHZlcnNpb246IFZFUlNJT05TLnYxLFxuICAgIGtleTogJ3Zpc3VhbENoYW5uZWxzJ1xuICB9KVxufTtcblxuZXhwb3J0IGNsYXNzIExheWVyU2NoZW1hVjAgZXh0ZW5kcyBTY2hlbWEge1xuICBrZXkgPSAnbGF5ZXJzJztcblxuICBzYXZlKGxheWVyczogTGF5ZXJbXSwgcGFyZW50czogW1Zpc1N0YXRlXSk6IHtsYXllcnM6IFNhdmVkTGF5ZXJbXX0ge1xuICAgIGNvbnN0IFt2aXNTdGF0ZV0gPSBwYXJlbnRzLnNsaWNlKC0xKTtcblxuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5rZXkgYXMgJ2xheWVycyddOiB2aXNTdGF0ZS5sYXllck9yZGVyLnJlZHVjZSgoc2F2ZWQsIGxheWVySWQpID0+IHtcbiAgICAgICAgLy8gc2F2ZSBsYXllcnMgYWNjb3JkaW5nIHRvIHRoZWlyIHJlbmRlcmluZyBvcmRlclxuICAgICAgICBjb25zdCBsYXllciA9IGZpbmRCeUlkKGxheWVySWQpKGxheWVycyk7XG4gICAgICAgIGlmIChsYXllcj8uaXNWYWxpZFRvU2F2ZSgpKSB7XG4gICAgICAgICAgc2F2ZWQucHVzaCh0aGlzLnNhdmVQcm9wZXJ0aWVzT3JBcHBseVNjaGVtYShsYXllcikubGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2F2ZWQ7XG4gICAgICB9LCBbXSBhcyBTYXZlZExheWVyW10pXG4gICAgfTtcbiAgfVxuXG4gIGxvYWQoXG4gICAgbGF5ZXJzOiBTYXZlZExheWVyW10gfCBNaW5TYXZlZExheWVyW10gfCB1bmRlZmluZWRcbiAgKToge1xuICAgIGxheWVyczogUGFyc2VkTGF5ZXJbXSB8IHVuZGVmaW5lZDtcbiAgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFt0aGlzLmtleSBhcyAnbGF5ZXJzJ106IGxheWVyc1xuICAgICAgICA/IGxheWVycy5tYXAobGF5ZXIgPT4gdGhpcy5sb2FkUHJvcGVydGllc09yQXBwbHlTY2hlbWEobGF5ZXIsIGxheWVycykubGF5ZXJzKVxuICAgICAgICA6IFtdXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmlsdGVyU2NoZW1hVjAgZXh0ZW5kcyBTY2hlbWEge1xuICBrZXkgPSAnZmlsdGVycyc7XG4gIHNhdmUoZmlsdGVyczogRmlsdGVyW10pOiB7ZmlsdGVyczogU2F2ZWRGaWx0ZXJbXX0ge1xuICAgIHJldHVybiB7XG4gICAgICBmaWx0ZXJzOiBmaWx0ZXJzXG4gICAgICAgIC5maWx0ZXIoaXNGaWx0ZXJWYWxpZFRvU2F2ZSlcbiAgICAgICAgLm1hcChmaWx0ZXIgPT4gdGhpcy5zYXZlUHJvcGVydGllc09yQXBwbHlTY2hlbWEoZmlsdGVyKS5maWx0ZXJzKVxuICAgIH07XG4gIH1cbiAgbG9hZChcbiAgICBmaWx0ZXJzOiBTYXZlZEZpbHRlcltdIHwgTWluU2F2ZWRGaWx0ZXJbXSB8IHVuZGVmaW5lZFxuICApOiB7ZmlsdGVyczogUGFyc2VkRmlsdGVyW10gfCB1bmRlZmluZWR9IHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsdGVyczogZmlsdGVyc1xuICAgICAgICA/Lm1hcChmaWx0ZXIgPT4gdGhpcy5sb2FkUHJvcGVydGllc09yQXBwbHlTY2hlbWEoZmlsdGVyKS5maWx0ZXJzKVxuICAgICAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmxlIGNvbnZlcnQgZW5sYXJnZWQgdG8gdmlld1xuICAgICAgICAubWFwKGZpbHRlciA9PiB7XG4gICAgICAgICAgY29uc3Qge2VubGFyZ2VkLCB2aWV3LCAuLi5maWx0ZXJQcm9wc30gPSBmaWx0ZXI7XG5cbiAgICAgICAgICBjb25zdCBuZXdGaWx0ZXIgPSB7XG4gICAgICAgICAgICAuLi5maWx0ZXJQcm9wcyxcbiAgICAgICAgICAgIC8vIGlmIHZpZXcgZXhpc3QgdXNlIGl0IG90aGVyd2lzZSBjaGVjayBmb3IgZW5sYXJnZWRcbiAgICAgICAgICAgIHZpZXc6IHZpZXcgPyB2aWV3IDogZW5sYXJnZWQgPyBGSUxURVJfVklFV19UWVBFUy5lbmxhcmdlZCA6IEZJTFRFUl9WSUVXX1RZUEVTLnNpZGVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIG5ld0ZpbHRlcjtcbiAgICAgICAgfSlcbiAgICB9O1xuICB9XG59XG5cbmNvbnN0IGludGVyYWN0aW9uUHJvcHNWMCA9IFsndG9vbHRpcCcsICdicnVzaCddO1xuXG5jbGFzcyBJbnRlcmFjdGlvblNjaGVtYVYwIGV4dGVuZHMgU2NoZW1hIHtcbiAga2V5ID0gJ2ludGVyYWN0aW9uQ29uZmlnJztcblxuICBzYXZlKGludGVyYWN0aW9uQ29uZmlnKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5wcm9wZXJ0aWVzKVxuICAgICAgPyB7XG4gICAgICAgICAgW3RoaXMua2V5XTogdGhpcy5wcm9wZXJ0aWVzLnJlZHVjZShcbiAgICAgICAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgICAgIC4uLihpbnRlcmFjdGlvbkNvbmZpZ1trZXldLmVuYWJsZWQgPyB7W2tleV06IGludGVyYWN0aW9uQ29uZmlnW2tleV0uY29uZmlnfSA6IHt9KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7fVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgOiB7fTtcbiAgfVxuXG4gIGxvYWQoaW50ZXJhY3Rpb25Db25maWcpIHtcbiAgICAvLyBjb252ZXJ0IHYwIC0+IHYxXG4gICAgLy8gcmV0dXJuIGVuYWJsZWQ6IGZhbHNlIGlmIGRpc2FibGVkLFxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMucHJvcGVydGllcylcbiAgICAgID8ge1xuICAgICAgICAgIFt0aGlzLmtleV06IHRoaXMucHJvcGVydGllcy5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgICAgICAgICAuLi5hY2N1LFxuICAgICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICAgW2tleV06IHtcbiAgICAgICAgICAgICAgICAgIC4uLihpbnRlcmFjdGlvbkNvbmZpZ1trZXldIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IEJvb2xlYW4oaW50ZXJhY3Rpb25Db25maWdba2V5XSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAge31cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIDoge307XG4gIH1cbn1cblxuY29uc3QgaW50ZXJhY3Rpb25Qcm9wc1YxID0gWy4uLmludGVyYWN0aW9uUHJvcHNWMCwgJ2dlb2NvZGVyJywgJ2Nvb3JkaW5hdGUnXTtcblxuZXhwb3J0IGNsYXNzIEludGVyYWN0aW9uU2NoZW1hVjEgZXh0ZW5kcyBTY2hlbWEge1xuICBrZXkgPSAnaW50ZXJhY3Rpb25Db25maWcnO1xuXG4gIHNhdmUoXG4gICAgaW50ZXJhY3Rpb25Db25maWc6IEludGVyYWN0aW9uQ29uZmlnXG4gICk6XG4gICAgfCB7XG4gICAgICAgIGludGVyYWN0aW9uQ29uZmlnOiBTYXZlZEludGVyYWN0aW9uQ29uZmlnO1xuICAgICAgfVxuICAgIHwge30ge1xuICAgIC8vIHNhdmUgY29uZmlnIGV2ZW4gaWYgZGlzYWJsZWQsXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5wcm9wZXJ0aWVzKVxuICAgICAgPyB7XG4gICAgICAgICAgW3RoaXMua2V5XTogdGhpcy5wcm9wZXJ0aWVzLnJlZHVjZShcbiAgICAgICAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgICAgIFtrZXldOiB7XG4gICAgICAgICAgICAgICAgLi4uaW50ZXJhY3Rpb25Db25maWdba2V5XS5jb25maWcsXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogaW50ZXJhY3Rpb25Db25maWdba2V5XS5lbmFibGVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAge31cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIDoge307XG4gIH1cbiAgbG9hZChcbiAgICBpbnRlcmFjdGlvbkNvbmZpZzogU2F2ZWRJbnRlcmFjdGlvbkNvbmZpZ1xuICApOiB7XG4gICAgaW50ZXJhY3Rpb25Db25maWc6IFBhcnRpYWw8U2F2ZWRJbnRlcmFjdGlvbkNvbmZpZz47XG4gIH0ge1xuICAgIGNvbnN0IG1vZGlmaWVkQ29uZmlnID0gaW50ZXJhY3Rpb25Db25maWc7XG4gICAgT2JqZWN0LmtleXMoaW50ZXJhY3Rpb25Db25maWcpLmZvckVhY2goY29uZmlnVHlwZSA9PiB7XG4gICAgICBpZiAoY29uZmlnVHlwZSA9PT0gJ3Rvb2x0aXAnKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkc1RvU2hvdyA9IG1vZGlmaWVkQ29uZmlnW2NvbmZpZ1R5cGVdLmZpZWxkc1RvU2hvdztcbiAgICAgICAgaWYgKCFub3ROdWxsb3JVbmRlZmluZWQoZmllbGRzVG9TaG93KSkge1xuICAgICAgICAgIHJldHVybiB7W3RoaXMua2V5XTogbW9kaWZpZWRDb25maWd9O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKGZpZWxkc1RvU2hvdykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbmFtZTogZmllbGREYXRhIHNob3VsZCBiZSBzdHJpbmdcbiAgICAgICAgICBmaWVsZHNUb1Nob3dba2V5XSA9IGZpZWxkc1RvU2hvd1trZXldLm1hcChmaWVsZERhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaWVsZERhdGEubmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpZWxkRGF0YSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IG51bGxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWVsZERhdGE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0pO1xuICAgIHJldHVybiB7W3RoaXMua2V5IGFzICdpbnRlcmFjdGlvbkNvbmZpZyddOiBtb2RpZmllZENvbmZpZ307XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZpbHRlclByb3BzVjAgPSB7XG4gIGRhdGFJZDogbnVsbCxcbiAgaWQ6IG51bGwsXG4gIG5hbWU6IG51bGwsXG4gIHR5cGU6IG51bGwsXG4gIHZhbHVlOiBudWxsLFxuICAvLyBkZXByZWNhdGVkXG4gIGVubGFyZ2VkOiBudWxsXG59O1xuXG5leHBvcnQgY2xhc3MgRGltZW5zaW9uRmllbGRTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBzYXZlKGZpZWxkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFt0aGlzLmtleV06IGZpZWxkID8gdGhpcy5zYXZlUHJvcGVydGllc09yQXBwbHlTY2hlbWEoZmllbGQpW3RoaXMua2V5XSA6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgbG9hZChmaWVsZCkge1xuICAgIHJldHVybiB7W3RoaXMua2V5XTogZmllbGR9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTcGxpdE1hcHNTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb252ZXJ0TGF5ZXJTZXR0aW5ncyhhY2N1LCBba2V5LCB2YWx1ZV0pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuaXNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiBCb29sZWFuKHZhbHVlLmlzVmlzaWJsZSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhY2N1O1xuICB9XG5cbiAgbG9hZChzcGxpdE1hcHMpIHtcbiAgICAvLyBwcmV2aW91cyBzcGxpdE1hcHMgU2NoZW1hIHtsYXllcnM6IHtsYXllcklkOiB7aXNWaXNpYmxlLCBpc0F2YWlsYWJsZX19fVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNwbGl0TWFwcykgfHwgIXNwbGl0TWFwcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7c3BsaXRNYXBzOiBbXX07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNwbGl0TWFwczogc3BsaXRNYXBzLm1hcChzZXR0aW5ncyA9PiAoe1xuICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgbGF5ZXJzOiBPYmplY3QuZW50cmllcyhzZXR0aW5ncy5sYXllcnMgfHwge30pLnJlZHVjZSh0aGlzLmNvbnZlcnRMYXllclNldHRpbmdzLCB7fSlcbiAgICAgIH0pKVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGVmZmVjdFByb3BzVjEgPSB7XG4gIGlkOiBudWxsLFxuICB0eXBlOiBudWxsLFxuICBpc0VuYWJsZWQ6IG51bGwsXG4gIHBhcmFtZXRlcnM6IG51bGxcbn07XG5leHBvcnQgY2xhc3MgRWZmZWN0c1NjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGtleSA9ICdlZmZlY3RzJztcblxuICBzYXZlKGVmZmVjdHMsIHBhcmVudHMpIHtcbiAgICBjb25zdCBbdmlzU3RhdGVdID0gcGFyZW50cy5zbGljZSgtMSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgW3RoaXMua2V5XTogdmlzU3RhdGUuZWZmZWN0T3JkZXIucmVkdWNlKChzYXZlZCwgZWZmZWN0SWQpID0+IHtcbiAgICAgICAgLy8gc2F2ZSBlZmZlY3RzIGFjY29yZGluZyB0byB0aGVpciByZW5kZXJpbmcgb3JkZXJcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtFZmZlY3QgfCB1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBlZmZlY3QgPSBmaW5kQnlJZChlZmZlY3RJZCkoZWZmZWN0cyBhcyBFZmZlY3RbXSk7XG4gICAgICAgIGlmIChlZmZlY3Q/LmlzVmFsaWRUb1NhdmUoKSkge1xuICAgICAgICAgIHNhdmVkLnB1c2godGhpcy5zYXZlUHJvcGVydGllc09yQXBwbHlTY2hlbWEoZWZmZWN0KS5lZmZlY3RzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2F2ZWQ7XG4gICAgICB9LCBbXSlcbiAgICB9O1xuICB9XG5cbiAgbG9hZChlZmZlY3RzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFt0aGlzLmtleV06IGVmZmVjdHMubWFwKGVmZmVjdCA9PiB7XG4gICAgICAgIC8vIGhhbmRsZSBvbGRlciBjb25maWdzXG4gICAgICAgIGNvbnN0IG91dEVmZmVjdCA9IGVmZmVjdC5jb25maWdcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgaWQ6IGVmZmVjdC5pZCxcbiAgICAgICAgICAgICAgLi4uZWZmZWN0LmNvbmZpZyxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogey4uLihlZmZlY3QuY29uZmlnLnBhcmFtcyB8fCB7fSl9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBlZmZlY3Q7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRQcm9wZXJ0aWVzT3JBcHBseVNjaGVtYShvdXRFZmZlY3QsIGVmZmVjdHMpLmVmZmVjdHM7XG4gICAgICB9KVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZpbHRlclByb3BzVjEgPSB7XG4gIC4uLmZpbHRlclByb3BzVjAsXG4gIHBsb3RUeXBlOiBudWxsLFxuICBhbmltYXRpb25XaW5kb3c6IG51bGwsXG4gIHlBeGlzOiBuZXcgRGltZW5zaW9uRmllbGRTY2hlbWEoe1xuICAgIHZlcnNpb246IFZFUlNJT05TLnYxLFxuICAgIGtleTogJ3lBeGlzJyxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBuYW1lOiBudWxsLFxuICAgICAgdHlwZTogbnVsbFxuICAgIH1cbiAgfSksXG4gIC8vIHRoaXMgcmVwbGFjZWQgZW5sYXJnZWRcbiAgdmlldzogbnVsbCxcblxuICAvLyBwb2x5Z29uIGZpbHRlciBwcm9wZXJ0aWVzXG4gIGxheWVySWQ6IG51bGwsXG4gIHNwZWVkOiBudWxsLFxuXG4gIGVuYWJsZWQ6IG51bGxcbn07XG5cbmV4cG9ydCBjb25zdCBwcm9wZXJ0aWVzVjAgPSB7XG4gIGZpbHRlcnM6IG5ldyBGaWx0ZXJTY2hlbWFWMCh7XG4gICAgdmVyc2lvbjogVkVSU0lPTlMudjAsXG4gICAgcHJvcGVydGllczogZmlsdGVyUHJvcHNWMFxuICB9KSxcbiAgbGF5ZXJzOiBuZXcgTGF5ZXJTY2hlbWFWMCh7XG4gICAgdmVyc2lvbjogVkVSU0lPTlMudjAsXG4gICAgcHJvcGVydGllczogbGF5ZXJQcm9wc1YwXG4gIH0pLFxuICBpbnRlcmFjdGlvbkNvbmZpZzogbmV3IEludGVyYWN0aW9uU2NoZW1hVjAoe1xuICAgIHZlcnNpb246IFZFUlNJT05TLnYwLFxuICAgIHByb3BlcnRpZXM6IGludGVyYWN0aW9uUHJvcHNWMFxuICB9KSxcbiAgbGF5ZXJCbGVuZGluZzogbnVsbCxcbiAgb3ZlcmxheUJsZW5kaW5nOiBudWxsXG59O1xuXG5leHBvcnQgY29uc3QgcHJvcGVydGllc1YxID0ge1xuICBmaWx0ZXJzOiBuZXcgRmlsdGVyU2NoZW1hVjAoe1xuICAgIHZlcnNpb246IFZFUlNJT05TLnYxLFxuICAgIHByb3BlcnRpZXM6IGZpbHRlclByb3BzVjFcbiAgfSksXG4gIGxheWVyczogbmV3IExheWVyU2NoZW1hVjAoe1xuICAgIHZlcnNpb246IFZFUlNJT05TLnYxLFxuICAgIHByb3BlcnRpZXM6IGxheWVyUHJvcHNWMVxuICB9KSxcbiAgZWZmZWN0czogbmV3IEVmZmVjdHNTY2hlbWEoe1xuICAgIHZlcnNpb246IFZFUlNJT05TLnYxLFxuICAgIHByb3BlcnRpZXM6IGVmZmVjdFByb3BzVjFcbiAgfSksXG4gIGludGVyYWN0aW9uQ29uZmlnOiBuZXcgSW50ZXJhY3Rpb25TY2hlbWFWMSh7XG4gICAgdmVyc2lvbjogVkVSU0lPTlMudjEsXG4gICAgcHJvcGVydGllczogaW50ZXJhY3Rpb25Qcm9wc1YxXG4gIH0pLFxuICBsYXllckJsZW5kaW5nOiBudWxsLFxuICBvdmVybGF5QmxlbmRpbmc6IG51bGwsXG4gIHNwbGl0TWFwczogbmV3IFNwbGl0TWFwc1NjaGVtYSh7XG4gICAga2V5OiAnc3BsaXRNYXBzJyxcbiAgICB2ZXJzaW9uOiBWRVJTSU9OUy52MVxuICB9KSxcbiAgYW5pbWF0aW9uQ29uZmlnOiBuZXcgU2NoZW1hKHtcbiAgICB2ZXJzaW9uOiBWRVJTSU9OUy52MSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBjdXJyZW50VGltZTogbnVsbCxcbiAgICAgIHNwZWVkOiBudWxsXG4gICAgfSxcbiAgICBrZXk6ICdhbmltYXRpb25Db25maWcnXG4gIH0pLFxuICBlZGl0b3I6IG5ldyBTY2hlbWEoe1xuICAgIHZlcnNpb246IFZFUlNJT05TLnYxLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGZlYXR1cmVzOiBudWxsLFxuICAgICAgdmlzaWJsZTogbnVsbFxuICAgIH0sXG4gICAga2V5OiAnZWRpdG9yJ1xuICB9KVxufTtcblxuZXhwb3J0IGNsYXNzIFZpc1N0YXRlU2NoZW1hVjEgZXh0ZW5kcyBTY2hlbWEge1xuICBzYXZlKG5vZGU6IFZpc1N0YXRlLCBwYXJlbnRzOiBhbnlbXSA9IFtdLCBhY2N1bXVsYXRvcj86IGFueSk6IHt2aXNTdGF0ZTogU2F2ZWRWaXNTdGF0ZX0ge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICByZXR1cm4gdGhpcy5zYXZlUHJvcGVydGllc09yQXBwbHlTY2hlbWEobm9kZSwgcGFyZW50cywgYWNjdW11bGF0b3IpO1xuICB9XG5cbiAgbG9hZChcbiAgICBub2RlPzogU2F2ZWRWaXNTdGF0ZVxuICApOiB7XG4gICAgdmlzU3RhdGU6IFBhcnNlZFZpc1N0YXRlIHwgdW5kZWZpbmVkO1xuICB9IHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgcmV0dXJuIHRoaXMubG9hZFByb3BlcnRpZXNPckFwcGx5U2NoZW1hKG5vZGUpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB2aXNTdGF0ZVNjaGVtYVYwID0gbmV3IFNjaGVtYSh7XG4gIHZlcnNpb246IFZFUlNJT05TLnYwLFxuICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzVjAsXG4gIGtleTogJ3Zpc1N0YXRlJ1xufSk7XG5cbmV4cG9ydCBjb25zdCB2aXNTdGF0ZVNjaGVtYVYxID0gbmV3IFZpc1N0YXRlU2NoZW1hVjEoe1xuICB2ZXJzaW9uOiBWRVJTSU9OUy52MSxcbiAgcHJvcGVydGllczogcHJvcGVydGllc1YxLFxuICBrZXk6ICd2aXNTdGF0ZSdcbn0pO1xuXG5leHBvcnQgY29uc3QgdmlzU3RhdGVTY2hlbWE6IHtcbiAgdjA6IHR5cGVvZiB2aXNTdGF0ZVNjaGVtYVYwO1xuICB2MTogdHlwZW9mIHZpc1N0YXRlU2NoZW1hVjE7XG59ID0ge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIFtWRVJTSU9OUy52MF06IHtcbiAgICBzYXZlOiB0b1NhdmUgPT4gdmlzU3RhdGVTY2hlbWFWMC5zYXZlKHRvU2F2ZSksXG4gICAgbG9hZDogdG9Mb2FkID0+IHZpc1N0YXRlU2NoZW1hVjEubG9hZCh2aXNTdGF0ZVNjaGVtYVYwLmxvYWQodG9Mb2FkKT8udmlzU3RhdGUpXG4gIH0sXG4gIFtWRVJTSU9OUy52MV06IHZpc1N0YXRlU2NoZW1hVjFcbn07XG5cbi8vIHRlc3QgbG9hZCB2MFxuZXhwb3J0IGRlZmF1bHQgdmlzU3RhdGVTY2hlbWE7XG4iXX0=