"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeFilters = mergeFilters;
exports.replaceFilterDatasetIds = replaceFilterDatasetIds;
exports.isSavedLayerConfigV1 = isSavedLayerConfigV1;
exports.parseLayerConfig = parseLayerConfig;
exports.createLayerFromConfig = createLayerFromConfig;
exports.serializeLayer = serializeLayer;
exports.serializeEffect = serializeEffect;
exports.serializeVisState = serializeVisState;
exports.mergeLayers = mergeLayers;
exports.insertLayerAtRightOrder = insertLayerAtRightOrder;
exports.mergeInteractions = mergeInteractions;
exports.mergeSplitMaps = mergeSplitMaps;
exports.mergeEffects = mergeEffects;
exports.mergeInteractionTooltipConfig = mergeInteractionTooltipConfig;
exports.mergeLayerBlending = mergeLayerBlending;
exports.mergeOverlayBlending = mergeOverlayBlending;
exports.mergeAnimationConfig = mergeAnimationConfig;
exports.validateSavedLayerColumns = validateSavedLayerColumns;
exports.validateColumn = validateColumn;
exports.validateSavedTextLabel = validateSavedTextLabel;
exports.validateSavedVisualChannels = validateSavedVisualChannels;
exports.validateLayersByDatasets = validateLayersByDatasets;
exports.validateLayerWithData = validateLayerWithData;
exports.mergeEditor = mergeEditor;
exports.mergeDatasetsByOrder = mergeDatasetsByOrder;
exports.VIS_STATE_MERGERS = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = _interopRequireDefault(require("lodash.uniq"));

var _lodash2 = _interopRequireDefault(require("lodash.pick"));

var _lodash3 = _interopRequireDefault(require("lodash.flattendeep"));

var _deepmerge = _interopRequireDefault(require("deepmerge"));

var _utils = require("@kepler.gl/utils");

var _reducers = require("@kepler.gl/reducers");

var _effects = require("@kepler.gl/effects");

var _constants = require("@kepler.gl/constants");

var _schemas = require("@kepler.gl/schemas");

var _table = require("@kepler.gl/table");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Merge loaded filters with current state, if no fields or data are loaded
 * save it for later
 *
 */
function mergeFilters(state, filtersToMerge, fromConfig) {
  var preserveFilterOrder = fromConfig ? filtersToMerge === null || filtersToMerge === void 0 ? void 0 : filtersToMerge.map(function (l) {
    return l.id;
  }) : state.preserveFilterOrder;

  if (!Array.isArray(filtersToMerge) || !filtersToMerge.length) {
    return state;
  }

  var _validateFiltersUpdat = (0, _utils.validateFiltersUpdateDatasets)(state, filtersToMerge),
      validated = _validateFiltersUpdat.validated,
      failed = _validateFiltersUpdat.failed,
      updatedDatasets = _validateFiltersUpdat.updatedDatasets;

  var updatedFilters = insertItemBasedOnPreservedOrder(state.filters, validated, preserveFilterOrder); // merge filter with existing

  updatedFilters = (0, _table.resetFilterGpuMode)(updatedFilters);
  updatedFilters = (0, _table.assignGpuChannels)(updatedFilters); // filter data

  var datasetsToFilter = (0, _lodash["default"])((0, _lodash3["default"])(validated.map(function (f) {
    return f.dataId;
  })));
  var filtered = (0, _utils.applyFiltersToDatasets)(datasetsToFilter, updatedDatasets, updatedFilters, state.layers);
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: updatedFilters,
    datasets: filtered,
    preserveFilterOrder: preserveFilterOrder,
    filterToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.filterToBeMerged), (0, _toConsumableArray2["default"])(failed))
  });
} // replace dataId in saved Filter


function replaceFilterDatasetIds(savedFilter, dataId, dataIdToUse) {
  var replaced = [];
  savedFilter.forEach(function (filter) {
    if (filter.dataId.includes(dataId)) {
      var newDataId = filter.dataId.map(function (d) {
        return d === dataId ? dataIdToUse : d;
      });
      replaced.push(_objectSpread(_objectSpread({}, filter), {}, {
        dataId: newDataId
      }));
    }
  });
  return replaced.length ? replaced : null;
}

function isSavedLayerConfigV1(layerConfig) {
  // exported layer configuration contains visualChannels property
  return layerConfig === null || layerConfig === void 0 ? void 0 : layerConfig.visualChannels;
}

function parseLayerConfig(schema, layerConfig) {
  var _schema$parseSavedCon, _schema$parseSavedCon2, _schema$parseSavedCon3;

  // assume the layer config is current version
  var savedConfig = {
    version: _schemas.CURRENT_VERSION,
    config: {
      visState: {
        layers: [layerConfig],
        layerOrder: [layerConfig.id]
      }
    }
  };
  return (_schema$parseSavedCon = schema.parseSavedConfig(savedConfig)) === null || _schema$parseSavedCon === void 0 ? void 0 : (_schema$parseSavedCon2 = _schema$parseSavedCon.visState) === null || _schema$parseSavedCon2 === void 0 ? void 0 : (_schema$parseSavedCon3 = _schema$parseSavedCon2.layers) === null || _schema$parseSavedCon3 === void 0 ? void 0 : _schema$parseSavedCon3[0];
}

function insertItemBasedOnPreservedOrder(currentItems, items) {
  var preservedOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var defaultStart = arguments.length > 3 ? arguments[3] : undefined;
  var newItems = (0, _toConsumableArray2["default"])(currentItems);

  var _iterator = _createForOfIteratorHelper(items),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;
      var expectedIdx = preservedOrder.indexOf(item.id); // insertAt the end by default

      var insertAt = defaultStart ? 0 : newItems.length;

      if (expectedIdx > 0) {
        // look for layer to insert after
        var i = expectedIdx + 1;
        var preceedIdx = -1;

        var _loop = function _loop() {
          // keep looking for preceed layer that is already loaded
          var preceedItemId = preservedOrder[i - 1];
          preceedIdx = newItems.findIndex(function (d) {
            return d.id === preceedItemId;
          });
        };

        while (i-- > 0 && preceedIdx < 0) {
          _loop();
        }

        if (preceedIdx > -1) {
          // if found
          insertAt = preceedIdx + 1;
        }
      }

      newItems = (0, _utils.arrayInsert)(newItems, insertAt, item);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return newItems;
}

function createLayerFromConfig(state, layerConfig) {
  // check if the layer config is parsed
  var parsedLayerConfig = isSavedLayerConfigV1(layerConfig) ? parseLayerConfig(state.schema, layerConfig) : layerConfig;

  if (!parsedLayerConfig) {
    return null;
  } // first validate config against dataset


  var _validateLayersByData = validateLayersByDatasets(state.datasets, state.layerClasses, [parsedLayerConfig], {
    allowEmptyColumn: true
  }),
      validated = _validateLayersByData.validated,
      failed = _validateLayersByData.failed;

  if (failed !== null && failed !== void 0 && failed.length || !validated.length) {
    // failed
    return null;
  }

  var newLayer = validated[0];
  newLayer.updateLayerDomain(state.datasets);
  return newLayer;
}
/**
 * Get loaded layer from state
 */


function serializeLayer(newLayer, schema) {
  var _serializedVisState$l;

  var serializedVisState = serializeVisState({
    layers: [newLayer],
    layerOrder: [newLayer.id]
  }, schema);
  return serializedVisState === null || serializedVisState === void 0 ? void 0 : (_serializedVisState$l = serializedVisState.layers) === null || _serializedVisState$l === void 0 ? void 0 : _serializedVisState$l[0];
}
/**
 * Get loaded effect from state
 */


function serializeEffect(newEffect, schema) {
  var _serializedVisState$e;

  var serializedVisState = serializeVisState({
    effects: [newEffect],
    effectOrder: [newEffect.id]
  }, schema);
  return serializedVisState === null || serializedVisState === void 0 ? void 0 : (_serializedVisState$e = serializedVisState.effects) === null || _serializedVisState$e === void 0 ? void 0 : _serializedVisState$e[0];
}
/**
 * Get vis state config
 */


function serializeVisState(visState, schema) {
  var _schema$parseSavedCon4;

  var savedState = schema.getConfigToSave({
    visState: visState
  });
  return savedState ? (_schema$parseSavedCon4 = schema.parseSavedConfig(savedState)) === null || _schema$parseSavedCon4 === void 0 ? void 0 : _schema$parseSavedCon4.visState : undefined;
}
/**
 * Merge layers from de-serialized state, if no fields or data are loaded
 * save it for later
 *
 */


function mergeLayers(state) {
  var layersToMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var fromConfig = arguments.length > 2 ? arguments[2] : undefined;
  var preserveLayerOrder = fromConfig ? (0, _reducers.getLayerOrderFromLayers)(layersToMerge) : state.preserveLayerOrder;

  if (!Array.isArray(layersToMerge) || !layersToMerge.length) {
    return state;
  } // don't merge layer if dataset is being merged


  var unmerged = [];
  var toMerge = [];
  layersToMerge.forEach(function (l) {
    var _l$config;

    if (l !== null && l !== void 0 && (_l$config = l.config) !== null && _l$config !== void 0 && _l$config.dataId && state.isMergingDatasets[l.config.dataId]) {
      unmerged.push(l);
    } else {
      toMerge.push(l);
    }
  });

  var _validateLayersByData2 = validateLayersByDatasets(state.datasets, state.layerClasses, toMerge),
      mergedLayer = _validateLayersByData2.validated,
      failed = _validateLayersByData2.failed;

  unmerged.push.apply(unmerged, (0, _toConsumableArray2["default"])(failed)); // put new layers in front of current layers

  var _insertLayerAtRightOr = insertLayerAtRightOrder(state.layers, mergedLayer, state.layerOrder, preserveLayerOrder),
      newLayerOrder = _insertLayerAtRightOr.newLayerOrder,
      newLayers = _insertLayerAtRightOr.newLayers;

  return _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    layerOrder: newLayerOrder,
    preserveLayerOrder: preserveLayerOrder,
    layerToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.layerToBeMerged), unmerged)
  });
}

function insertLayerAtRightOrder(currentLayers, layersToInsert, currentOrder) {
  var preservedOrder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  if (!(layersToInsert !== null && layersToInsert !== void 0 && layersToInsert.length)) {
    return {
      newLayers: currentLayers,
      newLayerOrder: currentOrder
    };
  } // perservedOrder ['a', 'b', 'c'];
  // layerOrder ['a', 'b', 'c']


  var currentLayerQueue = currentOrder.map(function (id) {
    return (0, _utils.findById)(id)(currentLayers);
  }).filter(function (layer) {
    return Boolean(layer);
  });
  var newLayers = currentLayers.concat(layersToInsert);
  var newLayerOrderQueue = insertItemBasedOnPreservedOrder(currentLayerQueue, layersToInsert, preservedOrder, true); // reconstruct layerOrder after insert

  var newLayerOrder = (0, _reducers.getLayerOrderFromLayers)(newLayerOrderQueue);
  return {
    newLayerOrder: newLayerOrder,
    newLayers: newLayers
  };
}
/**
 * Merge interactions with saved config
 *
 */


function mergeInteractions(state, interactionToBeMerged, fromConfig) {
  var merged = {};
  var unmerged = {};

  if (interactionToBeMerged) {
    Object.keys(interactionToBeMerged).forEach(function (key) {
      if (!state.interactionConfig[key]) {
        return;
      }

      var currentConfig = key === 'tooltip' || key === 'brush' ? state.interactionConfig[key].config : null;

      var _ref = interactionToBeMerged[key] || {},
          enabled = _ref.enabled,
          configSaved = (0, _objectWithoutProperties2["default"])(_ref, ["enabled"]);

      var configToMerge = configSaved;

      if (key === 'tooltip') {
        var _mergeInteractionTool = mergeInteractionTooltipConfig(state, configSaved),
            mergedTooltip = _mergeInteractionTool.mergedTooltip,
            unmergedTooltip = _mergeInteractionTool.unmergedTooltip; // merge new dataset tooltips with original dataset tooltips


        configToMerge = {
          fieldsToShow: _objectSpread(_objectSpread({}, currentConfig.fieldsToShow), mergedTooltip)
        };

        if (Object.keys(unmergedTooltip).length) {
          // @ts-expect-error
          unmerged.tooltip = {
            fieldsToShow: unmergedTooltip,
            enabled: Boolean(enabled)
          };
        }
      }

      merged[key] = _objectSpread(_objectSpread({}, state.interactionConfig[key]), {}, {
        enabled: Boolean(enabled)
      }, currentConfig ? {
        config: (0, _lodash2["default"])(_objectSpread(_objectSpread({}, currentConfig), configToMerge), Object.keys(currentConfig))
      } : {});
    });
  }

  var nextState = _objectSpread(_objectSpread({}, state), {}, {
    interactionConfig: _objectSpread(_objectSpread({}, state.interactionConfig), merged),
    interactionToBeMerged: savedUnmergedInteraction(state, unmerged)
  });

  return nextState;
}

function savedUnmergedInteraction(state, unmerged) {
  var _unmerged$tooltip, _unmerged$tooltip2, _state$interactionToB, _state$interactionToB2, _unmerged$tooltip3;

  if (!(unmerged !== null && unmerged !== void 0 && (_unmerged$tooltip = unmerged.tooltip) !== null && _unmerged$tooltip !== void 0 && _unmerged$tooltip.fieldsToShow)) {
    return state.interactionToBeMerged;
  }

  return {
    tooltip: _objectSpread(_objectSpread(_objectSpread({}, state.interactionToBeMerged.tooltip), typeof (unmerged === null || unmerged === void 0 ? void 0 : (_unmerged$tooltip2 = unmerged.tooltip) === null || _unmerged$tooltip2 === void 0 ? void 0 : _unmerged$tooltip2.enabled) === 'boolean' ? {
      enabled: unmerged.tooltip.enabled
    } : {}), {}, {
      fieldsToShow: _objectSpread(_objectSpread({}, (_state$interactionToB = state.interactionToBeMerged) === null || _state$interactionToB === void 0 ? void 0 : (_state$interactionToB2 = _state$interactionToB.tooltip) === null || _state$interactionToB2 === void 0 ? void 0 : _state$interactionToB2.fieldsToShow), unmerged === null || unmerged === void 0 ? void 0 : (_unmerged$tooltip3 = unmerged.tooltip) === null || _unmerged$tooltip3 === void 0 ? void 0 : _unmerged$tooltip3.fieldsToShow)
    })
  };
}

function replaceInteractionDatasetIds(interactionConfig, dataId, dataIdToReplace) {
  var _interactionConfig$to;

  if (interactionConfig !== null && interactionConfig !== void 0 && (_interactionConfig$to = interactionConfig.tooltip) !== null && _interactionConfig$to !== void 0 && _interactionConfig$to.fieldsToShow[dataId]) {
    var _interactionConfig$to2;

    return _objectSpread(_objectSpread({}, interactionConfig), {}, {
      tooltip: _objectSpread(_objectSpread({}, interactionConfig.tooltip), {}, {
        fieldsToShow: (0, _defineProperty2["default"])({}, dataIdToReplace, interactionConfig === null || interactionConfig === void 0 ? void 0 : (_interactionConfig$to2 = interactionConfig.tooltip) === null || _interactionConfig$to2 === void 0 ? void 0 : _interactionConfig$to2.fieldsToShow[dataId])
      })
    });
  }

  return null;
}
/**
 * Merge splitMaps config with current visStete.
 * 1. if current map is split, but splitMap DOESNOT contain maps
 *    : don't merge anything
 * 2. if current map is NOT split, but splitMaps contain maps
 *    : add to splitMaps, and add current layers to splitMaps
 */


function mergeSplitMaps(state) {
  var splitMaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var fromConfig = arguments.length > 2 ? arguments[2] : undefined;
  var merged = (0, _toConsumableArray2["default"])(state.splitMaps);
  var unmerged = [];
  splitMaps.forEach(function (sm, i) {
    var entries = Object.entries(sm.layers);

    if (entries.length > 0) {
      entries.forEach(function (_ref2) {
        var _ref3 = (0, _slicedToArray2["default"])(_ref2, 2),
            id = _ref3[0],
            value = _ref3[1];

        // check if layer exists
        var pushTo = state.layers.find(function (l) {
          return l.id === id;
        }) ? merged : unmerged; // create map panel if current map is not split

        pushTo[i] = pushTo[i] || _objectSpread(_objectSpread({}, sm), {}, {
          layers: pushTo === merged ? (0, _utils.getInitialMapLayersForSplitMap)(state.layers) : []
        });
        pushTo[i].layers = _objectSpread(_objectSpread({}, pushTo[i].layers), {}, (0, _defineProperty2["default"])({}, id, value));
      });
    } else {
      // We are merging if there are no layers in both split map
      merged.push(sm);
    }
  });
  return _objectSpread(_objectSpread({}, state), {}, {
    splitMaps: merged,
    splitMapsToBeMerged: [].concat((0, _toConsumableArray2["default"])(state.splitMapsToBeMerged), unmerged)
  });
}
/**
 * Merge effects with saved config
 */


function mergeEffects(state, effects, fromConfig) {
  var newEffects = [].concat((0, _toConsumableArray2["default"])(state.effects), (0, _toConsumableArray2["default"])((effects || []).map(function (effect) {
    return fromConfig ? (0, _effects.createEffect)(_deepmerge["default"].all([effect, {
      // collapse all panels when loading effects
      isConfigActive: false
    }])) : effect;
  }).filter(function (effect) {
    return Boolean(effect && effect.isValidToSave());
  })));
  return _objectSpread(_objectSpread({}, state), {}, {
    effects: newEffects,
    effectOrder: newEffects.map(function (effect) {
      return effect.id;
    })
  });
}
/**
 * Merge interactionConfig.tooltip with saved config,
 * validate fieldsToShow
 *
 * @param state
 * @param tooltipConfig
 * @return - {mergedTooltip: {}, unmergedTooltip: {}}
 */


function mergeInteractionTooltipConfig(state) {
  var tooltipConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var unmergedTooltip = {};
  var mergedTooltip = {};

  if (!tooltipConfig || !tooltipConfig.fieldsToShow || !Object.keys(tooltipConfig.fieldsToShow).length) {
    return {
      mergedTooltip: mergedTooltip,
      unmergedTooltip: unmergedTooltip
    };
  }

  for (var dataId in tooltipConfig.fieldsToShow) {
    if (!state.datasets[dataId] || state.isMergingDatasets[dataId]) {
      // is not yet loaded
      unmergedTooltip[dataId] = tooltipConfig.fieldsToShow[dataId];
    } else {
      (function () {
        // if dataset is loaded
        var allFields = state.datasets[dataId].fields.map(function (d) {
          return d.name;
        });
        var foundFieldsToShow = tooltipConfig.fieldsToShow[dataId].filter(function (field) {
          return allFields.includes(field.name);
        });
        mergedTooltip[dataId] = foundFieldsToShow;
      })();
    }
  }

  return {
    mergedTooltip: mergedTooltip,
    unmergedTooltip: unmergedTooltip
  };
}
/**
 * Merge layerBlending with saved
 *
 */


function mergeLayerBlending(state, layerBlending, fromConfig) {
  if (layerBlending && _constants.LAYER_BLENDINGS[layerBlending]) {
    return _objectSpread(_objectSpread({}, state), {}, {
      layerBlending: layerBlending
    });
  }

  return state;
}
/**
 * Merge overlayBlending with saved
 */


function mergeOverlayBlending(state, overlayBlending, fromConfig) {
  if (overlayBlending && _constants.OVERLAY_BLENDINGS[overlayBlending]) {
    return _objectSpread(_objectSpread({}, state), {}, {
      overlayBlending: overlayBlending
    });
  }

  return state;
}
/**
 * Merge animation config
 */


function mergeAnimationConfig(state, animation, fromConfig) {
  if (animation && animation.currentTime) {
    return _objectSpread(_objectSpread({}, state), {}, {
      animationConfig: _objectSpread(_objectSpread(_objectSpread({}, state.animationConfig), animation), {}, {
        domain: null
      })
    });
  }

  return state;
}
/**
 * Validate saved layer columns with new data,
 * update fieldIdx based on new fields
 *
 * @param fields
 * @param savedCols
 * @param emptyCols
 * @param options
 * @return - validated columns or null
 */


function validateSavedLayerColumns(fields) {
  var savedCols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var emptyCols = arguments.length > 2 ? arguments[2] : undefined;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  // Prepare columns for the validator
  var columns = {};

  var _loop2 = function _loop2() {
    var key = _Object$keys[_i];
    columns[key] = _objectSpread({}, emptyCols[key]);
    var saved = savedCols[key];

    if (saved) {
      var fieldIdx = fields.findIndex(function (_ref4) {
        var name = _ref4.name;
        return name === saved;
      });

      if (fieldIdx > -1) {
        // update found columns
        columns[key].fieldIdx = fieldIdx;
        columns[key].value = saved;
      }
    }
  };

  for (var _i = 0, _Object$keys = Object.keys(emptyCols); _i < _Object$keys.length; _i++) {
    _loop2();
  } // find actual column fieldIdx, in case it has changed


  var allColFound = Object.keys(columns).every(function (key) {
    return validateColumn(columns[key], columns, fields);
  });
  var rv = allColFound ? columns : null;

  if (options.throwOnError) {
    var requiredColumns = Object.keys(emptyCols).filter(function (k) {
      return !emptyCols[k].optional;
    });
    var missingColumns = requiredColumns.filter(function (k) {
      return !(columns !== null && columns !== void 0 && columns[k].value);
    });

    if (missingColumns.length) {
      throw new Error("Layer has missing or invalid columns: ".concat(missingColumns.join(', ')));
    }

    var configColumns = Object.keys(savedCols);
    var invalidColumns = configColumns.filter(function (k) {
      var _columns$k;

      return !(columns !== null && columns !== void 0 && (_columns$k = columns[k]) !== null && _columns$k !== void 0 && _columns$k.value);
    });

    if (invalidColumns.length) {
      throw new Error("Layer has invalid columns: ".concat(invalidColumns.join(', ')));
    }
  }

  return rv;
}

function validateColumn(column, columns, allFields) {
  if (column.optional || column.value) {
    return true;
  }

  if (column.validator) {
    return column.validator(column, columns, allFields);
  }

  return false;
}
/**
 * Validate saved text label config with new data
 * refer to vis-state-schema.js TextLabelSchemaV1
 *
 * @param {Array<Object>} fields
 * @param {Object} savedTextLabel
 * @param {Object} options
 * @return {Object} - validated textlabel
 */


function validateSavedTextLabel(fields, _ref5, savedTextLabel) {
  var _ref6 = (0, _slicedToArray2["default"])(_ref5, 1),
      layerTextLabel = _ref6[0];

  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var savedTextLabels = Array.isArray(savedTextLabel) ? savedTextLabel : [savedTextLabel]; // validate field

  return savedTextLabels.map(function (textLabel) {
    var field = textLabel.field ? fields.find(function (fd) {
      return Object.keys(textLabel.field).every(function (key) {
        return textLabel.field[key] === fd[key];
      });
    }) : null;

    if (field === undefined && options.throwOnError) {
      throw new Error("Layer has invalid text label field: ".concat(JSON.stringify(textLabel.field)));
    }

    return Object.keys(layerTextLabel).reduce(function (accu, key) {
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, key === 'field' ? field : textLabel[key] || layerTextLabel[key]));
    }, {});
  });
}
/**
 * Validate saved visual channels config with new data,
 * refer to vis-state-schema.js VisualChannelSchemaV1
 */


function validateSavedVisualChannels(fields, newLayer, savedLayer) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  Object.values(newLayer.visualChannels).forEach(function (_ref7) {
    var field = _ref7.field,
        scale = _ref7.scale,
        key = _ref7.key;
    var foundField;

    if (savedLayer.config) {
      if (savedLayer.config[field]) {
        foundField = fields.find(function (fd) {
          return savedLayer.config && fd.name === savedLayer.config[field].name;
        });
      }

      var foundChannel = _objectSpread(_objectSpread({}, foundField ? (0, _defineProperty2["default"])({}, field, foundField) : {}), savedLayer.config[scale] ? (0, _defineProperty2["default"])({}, scale, savedLayer.config[scale]) : {});

      if (Object.keys(foundChannel).length) {
        newLayer.updateLayerConfig(foundChannel);
      }

      newLayer.validateVisualChannel(key);

      if (options.throwOnError) {
        var _savedLayer$config, _savedLayer$config$fi, _newLayer$config$fiel;

        var fieldName = (_savedLayer$config = savedLayer.config) === null || _savedLayer$config === void 0 ? void 0 : (_savedLayer$config$fi = _savedLayer$config[field]) === null || _savedLayer$config$fi === void 0 ? void 0 : _savedLayer$config$fi.name;

        if (fieldName && fieldName !== ((_newLayer$config$fiel = newLayer.config[field]) === null || _newLayer$config$fiel === void 0 ? void 0 : _newLayer$config$fiel.name)) {
          throw new Error("Layer has invalid visual channel field: ".concat(field));
        }
      }
    }
  });
  return newLayer;
}

function validateLayersByDatasets(datasets, layerClasses) {
  var layers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var options = arguments.length > 3 ? arguments[3] : undefined;
  var validated = [];
  var failed = [];
  layers.forEach(function (layer) {
    var _layer$config;

    var validateLayer = null;

    if (layer !== null && layer !== void 0 && (_layer$config = layer.config) !== null && _layer$config !== void 0 && _layer$config.dataId) {
      if (datasets[layer.config.dataId]) {
        // datasets are already loaded
        validateLayer = validateLayerWithData(datasets[layer.config.dataId], layer, layerClasses, options);
      }
    }

    if (validateLayer) {
      validated.push(validateLayer);
    } else {
      // datasets not yet loaded
      failed.push(layer);
    }
  });
  return {
    validated: validated,
    failed: failed
  };
}
/**
 * Validate saved layer config with new data,
 * update fieldIdx based on new fields
 */
// eslint-disable-next-line complexity


function validateLayerWithData(_ref10, savedLayer, layerClasses) {
  var fields = _ref10.fields,
      dataId = _ref10.id;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var type = savedLayer.type;
  var throwOnError = options.throwOnError; // layer doesnt have a valid type

  if (!type || !layerClasses.hasOwnProperty(type) || !savedLayer.config) {
    if (throwOnError) {
      throw new Error("Layer has invalid type \"".concat(type, "\" or config is missing"));
    }

    return null;
  }

  var newLayer = new layerClasses[type]({
    id: savedLayer.id,
    dataId: dataId,
    label: savedLayer.config.label,
    color: savedLayer.config.color,
    isVisible: savedLayer.config.isVisible,
    hidden: savedLayer.config.hidden,
    highlightColor: savedLayer.config.highlightColor
  }); // find column fieldIdx

  var columnConfig = newLayer.getLayerColumns();

  if (Object.keys(columnConfig)) {
    var columns = validateSavedLayerColumns(fields, savedLayer.config.columns, columnConfig, options);

    if (columns) {
      newLayer.updateLayerConfig({
        columns: columns
      });
    } else if (!options.allowEmptyColumn) {
      return null;
    }
  }

  var textLabel = savedLayer.config.textLabel && newLayer.config.textLabel ? validateSavedTextLabel(fields, newLayer.config.textLabel, savedLayer.config.textLabel, options) : newLayer.config.textLabel; // copy visConfig over to emptyLayer to make sure it has all the props

  var visConfig = newLayer.copyLayerConfig(newLayer.config.visConfig, savedLayer.config.visConfig || {}, {
    shallowCopy: ['colorRange', 'strokeColorRange']
  });
  newLayer.updateLayerConfig({
    visConfig: visConfig,
    textLabel: textLabel
  }); // visual channel field is saved to be {name, type}
  // find visual channel field by matching both name and type
  // refer to vis-state-schema.js VisualChannelSchemaV1

  newLayer = validateSavedVisualChannels(fields, newLayer, savedLayer, options);

  if (throwOnError) {
    if (!newLayer.isValidToSave()) {
      throw new Error("Layer is not valid to save: ".concat(newLayer.id));
    }
  }

  return newLayer;
}

function mergeEditor(state, savedEditor) {
  var _savedEditor$visible;

  if (!savedEditor) {
    return state;
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      features: [].concat((0, _toConsumableArray2["default"])(state.editor.features), (0, _toConsumableArray2["default"])(savedEditor.features || [])),
      // if savedEditor.visible is undefined keep state.editor.visible
      visible: (_savedEditor$visible = savedEditor.visible) !== null && _savedEditor$visible !== void 0 ? _savedEditor$visible : state.editor.visible
    })
  });
}
/**
 * Validate saved layer config with new data,
 * update fieldIdx based on new fields
 */


function mergeDatasetsByOrder(state, newDataEntries) {
  var merged = _objectSpread(_objectSpread({}, state.datasets), newDataEntries);

  if (Array.isArray(state.preserveDatasetOrder)) {
    // preserveDatasetOrder  might not include the  new datasets
    var newDatasetIds = Object.keys(merged).filter(function (id) {
      var _state$preserveDatase;

      return !((_state$preserveDatase = state.preserveDatasetOrder) !== null && _state$preserveDatase !== void 0 && _state$preserveDatase.includes(id));
    });
    return [].concat((0, _toConsumableArray2["default"])(state.preserveDatasetOrder), (0, _toConsumableArray2["default"])(newDatasetIds)).reduce(function (accu, dataId) {
      return _objectSpread(_objectSpread({}, accu), merged[dataId] ? (0, _defineProperty2["default"])({}, dataId, merged[dataId]) : {});
    }, {});
  }

  return merged;
}

var VIS_STATE_MERGERS = [{
  merge: mergeLayers,
  prop: 'layers',
  toMergeProp: 'layerToBeMerged',
  preserveOrder: 'preserveLayerOrder'
}, {
  merge: mergeFilters,
  prop: 'filters',
  toMergeProp: 'filterToBeMerged',
  preserveOrder: 'preserveFilterOrder',
  replaceParentDatasetIds: replaceFilterDatasetIds
}, {
  merge: mergeEffects,
  prop: 'effects'
}, {
  merge: mergeInteractions,
  prop: 'interactionConfig',
  toMergeProp: 'interactionToBeMerged',
  replaceParentDatasetIds: replaceInteractionDatasetIds,
  saveUnmerged: savedUnmergedInteraction
}, {
  merge: mergeLayerBlending,
  prop: 'layerBlending'
}, {
  merge: mergeOverlayBlending,
  prop: 'overlayBlending'
}, {
  merge: mergeSplitMaps,
  prop: 'splitMaps',
  toMergeProp: 'splitMapsToBeMerged'
}, {
  merge: mergeAnimationConfig,
  prop: 'animationConfig'
}, {
  merge: mergeEditor,
  prop: 'editor'
}];
exports.VIS_STATE_MERGERS = VIS_STATE_MERGERS;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aXMtc3RhdGUtbWVyZ2VyLnRzIl0sIm5hbWVzIjpbIm1lcmdlRmlsdGVycyIsInN0YXRlIiwiZmlsdGVyc1RvTWVyZ2UiLCJmcm9tQ29uZmlnIiwicHJlc2VydmVGaWx0ZXJPcmRlciIsIm1hcCIsImwiLCJpZCIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInZhbGlkYXRlZCIsImZhaWxlZCIsInVwZGF0ZWREYXRhc2V0cyIsInVwZGF0ZWRGaWx0ZXJzIiwiaW5zZXJ0SXRlbUJhc2VkT25QcmVzZXJ2ZWRPcmRlciIsImZpbHRlcnMiLCJkYXRhc2V0c1RvRmlsdGVyIiwiZiIsImRhdGFJZCIsImZpbHRlcmVkIiwibGF5ZXJzIiwiZGF0YXNldHMiLCJmaWx0ZXJUb0JlTWVyZ2VkIiwicmVwbGFjZUZpbHRlckRhdGFzZXRJZHMiLCJzYXZlZEZpbHRlciIsImRhdGFJZFRvVXNlIiwicmVwbGFjZWQiLCJmb3JFYWNoIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJuZXdEYXRhSWQiLCJkIiwicHVzaCIsImlzU2F2ZWRMYXllckNvbmZpZ1YxIiwibGF5ZXJDb25maWciLCJ2aXN1YWxDaGFubmVscyIsInBhcnNlTGF5ZXJDb25maWciLCJzY2hlbWEiLCJzYXZlZENvbmZpZyIsInZlcnNpb24iLCJDVVJSRU5UX1ZFUlNJT04iLCJjb25maWciLCJ2aXNTdGF0ZSIsImxheWVyT3JkZXIiLCJwYXJzZVNhdmVkQ29uZmlnIiwiY3VycmVudEl0ZW1zIiwiaXRlbXMiLCJwcmVzZXJ2ZWRPcmRlciIsImRlZmF1bHRTdGFydCIsIm5ld0l0ZW1zIiwiaXRlbSIsImV4cGVjdGVkSWR4IiwiaW5kZXhPZiIsImluc2VydEF0IiwiaSIsInByZWNlZWRJZHgiLCJwcmVjZWVkSXRlbUlkIiwiZmluZEluZGV4IiwiY3JlYXRlTGF5ZXJGcm9tQ29uZmlnIiwicGFyc2VkTGF5ZXJDb25maWciLCJ2YWxpZGF0ZUxheWVyc0J5RGF0YXNldHMiLCJsYXllckNsYXNzZXMiLCJhbGxvd0VtcHR5Q29sdW1uIiwibmV3TGF5ZXIiLCJ1cGRhdGVMYXllckRvbWFpbiIsInNlcmlhbGl6ZUxheWVyIiwic2VyaWFsaXplZFZpc1N0YXRlIiwic2VyaWFsaXplVmlzU3RhdGUiLCJzZXJpYWxpemVFZmZlY3QiLCJuZXdFZmZlY3QiLCJlZmZlY3RzIiwiZWZmZWN0T3JkZXIiLCJzYXZlZFN0YXRlIiwiZ2V0Q29uZmlnVG9TYXZlIiwidW5kZWZpbmVkIiwibWVyZ2VMYXllcnMiLCJsYXllcnNUb01lcmdlIiwicHJlc2VydmVMYXllck9yZGVyIiwidW5tZXJnZWQiLCJ0b01lcmdlIiwiaXNNZXJnaW5nRGF0YXNldHMiLCJtZXJnZWRMYXllciIsImluc2VydExheWVyQXRSaWdodE9yZGVyIiwibmV3TGF5ZXJPcmRlciIsIm5ld0xheWVycyIsImxheWVyVG9CZU1lcmdlZCIsImN1cnJlbnRMYXllcnMiLCJsYXllcnNUb0luc2VydCIsImN1cnJlbnRPcmRlciIsImN1cnJlbnRMYXllclF1ZXVlIiwibGF5ZXIiLCJCb29sZWFuIiwiY29uY2F0IiwibmV3TGF5ZXJPcmRlclF1ZXVlIiwibWVyZ2VJbnRlcmFjdGlvbnMiLCJpbnRlcmFjdGlvblRvQmVNZXJnZWQiLCJtZXJnZWQiLCJPYmplY3QiLCJrZXlzIiwia2V5IiwiaW50ZXJhY3Rpb25Db25maWciLCJjdXJyZW50Q29uZmlnIiwiZW5hYmxlZCIsImNvbmZpZ1NhdmVkIiwiY29uZmlnVG9NZXJnZSIsIm1lcmdlSW50ZXJhY3Rpb25Ub29sdGlwQ29uZmlnIiwibWVyZ2VkVG9vbHRpcCIsInVubWVyZ2VkVG9vbHRpcCIsImZpZWxkc1RvU2hvdyIsInRvb2x0aXAiLCJuZXh0U3RhdGUiLCJzYXZlZFVubWVyZ2VkSW50ZXJhY3Rpb24iLCJyZXBsYWNlSW50ZXJhY3Rpb25EYXRhc2V0SWRzIiwiZGF0YUlkVG9SZXBsYWNlIiwibWVyZ2VTcGxpdE1hcHMiLCJzcGxpdE1hcHMiLCJzbSIsImVudHJpZXMiLCJ2YWx1ZSIsInB1c2hUbyIsImZpbmQiLCJzcGxpdE1hcHNUb0JlTWVyZ2VkIiwibWVyZ2VFZmZlY3RzIiwibmV3RWZmZWN0cyIsImVmZmVjdCIsImRlZXBtZXJnZSIsImFsbCIsImlzQ29uZmlnQWN0aXZlIiwiaXNWYWxpZFRvU2F2ZSIsInRvb2x0aXBDb25maWciLCJhbGxGaWVsZHMiLCJmaWVsZHMiLCJuYW1lIiwiZm91bmRGaWVsZHNUb1Nob3ciLCJmaWVsZCIsIm1lcmdlTGF5ZXJCbGVuZGluZyIsImxheWVyQmxlbmRpbmciLCJMQVlFUl9CTEVORElOR1MiLCJtZXJnZU92ZXJsYXlCbGVuZGluZyIsIm92ZXJsYXlCbGVuZGluZyIsIk9WRVJMQVlfQkxFTkRJTkdTIiwibWVyZ2VBbmltYXRpb25Db25maWciLCJhbmltYXRpb24iLCJjdXJyZW50VGltZSIsImFuaW1hdGlvbkNvbmZpZyIsImRvbWFpbiIsInZhbGlkYXRlU2F2ZWRMYXllckNvbHVtbnMiLCJzYXZlZENvbHMiLCJlbXB0eUNvbHMiLCJvcHRpb25zIiwiY29sdW1ucyIsInNhdmVkIiwiZmllbGRJZHgiLCJhbGxDb2xGb3VuZCIsImV2ZXJ5IiwidmFsaWRhdGVDb2x1bW4iLCJydiIsInRocm93T25FcnJvciIsInJlcXVpcmVkQ29sdW1ucyIsImsiLCJvcHRpb25hbCIsIm1pc3NpbmdDb2x1bW5zIiwiRXJyb3IiLCJqb2luIiwiY29uZmlnQ29sdW1ucyIsImludmFsaWRDb2x1bW5zIiwiY29sdW1uIiwidmFsaWRhdG9yIiwidmFsaWRhdGVTYXZlZFRleHRMYWJlbCIsInNhdmVkVGV4dExhYmVsIiwibGF5ZXJUZXh0TGFiZWwiLCJzYXZlZFRleHRMYWJlbHMiLCJ0ZXh0TGFiZWwiLCJmZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZWR1Y2UiLCJhY2N1IiwidmFsaWRhdGVTYXZlZFZpc3VhbENoYW5uZWxzIiwic2F2ZWRMYXllciIsInZhbHVlcyIsInNjYWxlIiwiZm91bmRGaWVsZCIsImZvdW5kQ2hhbm5lbCIsInVwZGF0ZUxheWVyQ29uZmlnIiwidmFsaWRhdGVWaXN1YWxDaGFubmVsIiwiZmllbGROYW1lIiwidmFsaWRhdGVMYXllciIsInZhbGlkYXRlTGF5ZXJXaXRoRGF0YSIsInR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImxhYmVsIiwiY29sb3IiLCJpc1Zpc2libGUiLCJoaWRkZW4iLCJoaWdobGlnaHRDb2xvciIsImNvbHVtbkNvbmZpZyIsImdldExheWVyQ29sdW1ucyIsInZpc0NvbmZpZyIsImNvcHlMYXllckNvbmZpZyIsInNoYWxsb3dDb3B5IiwibWVyZ2VFZGl0b3IiLCJzYXZlZEVkaXRvciIsImVkaXRvciIsImZlYXR1cmVzIiwidmlzaWJsZSIsIm1lcmdlRGF0YXNldHNCeU9yZGVyIiwibmV3RGF0YUVudHJpZXMiLCJwcmVzZXJ2ZURhdGFzZXRPcmRlciIsIm5ld0RhdGFzZXRJZHMiLCJWSVNfU1RBVEVfTUVSR0VSUyIsIm1lcmdlIiwicHJvcCIsInRvTWVyZ2VQcm9wIiwicHJlc2VydmVPcmRlciIsInJlcGxhY2VQYXJlbnREYXRhc2V0SWRzIiwic2F2ZVVubWVyZ2VkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFPQTs7QUFHQTs7QUFDQTs7QUFDQTs7QUFhQTs7Ozs7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNBLFlBQVQsQ0FDTEMsS0FESyxFQUVMQyxjQUZLLEVBR0xDLFVBSEssRUFJRjtBQUNILE1BQU1DLG1CQUFtQixHQUFHRCxVQUFVLEdBQ2xDRCxjQURrQyxhQUNsQ0EsY0FEa0MsdUJBQ2xDQSxjQUFjLENBQUVHLEdBQWhCLENBQW9CLFVBQUFDLENBQUM7QUFBQSxXQUFJQSxDQUFDLENBQUNDLEVBQU47QUFBQSxHQUFyQixDQURrQyxHQUVsQ04sS0FBSyxDQUFDRyxtQkFGVjs7QUFJQSxNQUFJLENBQUNJLEtBQUssQ0FBQ0MsT0FBTixDQUFjUCxjQUFkLENBQUQsSUFBa0MsQ0FBQ0EsY0FBYyxDQUFDUSxNQUF0RCxFQUE4RDtB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LEVBQUV6RztBQUxoQixDQWxCcUQsRUF5QnJEO0FBQUNvRyxFQUFBQSxLQUFLLEVBQUU1RSxrQkFBUjtBQUE0QjZFLEVBQUFBLElBQUksRUFBRTtBQUFsQyxDQXpCcUQsRUEwQnJEO0FBQUNELEVBQUFBLEtBQUssRUFBRXpFLG9CQUFSO0FBQThCMEUsRUFBQUEsSUFBSSxFQUFFO0FBQXBDLENBMUJxRCxFQTJCckQ7QUFBQ0QsRUFBQUEsS0FBSyxFQUFFakcsY0FBUjtBQUF3QmtHLEVBQUFBLElBQUksRUFBRSxXQUE5QjtBQUEyQ0MsRUFBQUEsV0FBVyxFQUFFO0FBQXhELENBM0JxRCxFQTRCckQ7QUFBQ0YsRUFBQUEsS0FBSyxFQUFFdEUsb0JBQVI7QUFBOEJ1RSxFQUFBQSxJQUFJLEVBQUU7QUFBcEMsQ0E1QnFELEVBNkJyRDtBQUFDRCxFQUFBQSxLQUFLLEVBQUVWLFdBQVI7QUFBcUJXLEVBQUFBLElBQUksRUFBRTtBQUEzQixDQTdCcUQsQ0FBaEQiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgdW5pcSBmcm9tICdsb2Rhc2gudW5pcSc7XG5pbXBvcnQgcGljayBmcm9tICdsb2Rhc2gucGljayc7XG5pbXBvcnQgZmxhdHRlbkRlZXAgZnJvbSAnbG9kYXNoLmZsYXR0ZW5kZWVwJztcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcbmltcG9ydCB7XG4gIGFycmF5SW5zZXJ0LFxuICBnZXRJbml0aWFsTWFwTGF5ZXJzRm9yU3BsaXRNYXAsXG4gIGFwcGx5RmlsdGVyc1RvRGF0YXNldHMsXG4gIHZhbGlkYXRlRmlsdGVyc1VwZGF0ZURhdGFzZXRzLFxuICBmaW5kQnlJZFxufSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7Z2V0TGF5ZXJPcmRlckZyb21MYXllcnN9IGZyb20gJ0BrZXBsZXIuZ2wvcmVkdWNlcnMnO1xuXG5pbXBvcnQge0xheWVyQ29sdW1ucywgTGF5ZXJDb2x1bW4sIExheWVyfSBmcm9tICdAa2VwbGVyLmdsL2xheWVycyc7XG5pbXBvcnQge2NyZWF0ZUVmZmVjdH0gZnJvbSAnQGtlcGxlci5nbC9lZmZlY3RzJztcbmltcG9ydCB7TEFZRVJfQkxFTkRJTkdTLCBPVkVSTEFZX0JMRU5ESU5HU30gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtDVVJSRU5UX1ZFUlNJT04sIFZpc1N0YXRlLCBWaXNTdGF0ZU1lcmdlcnMsIEtlcGxlckdMU2NoZW1hQ2xhc3N9IGZyb20gJ0BrZXBsZXIuZ2wvc2NoZW1hcyc7XG5cbmltcG9ydCB7XG4gIFBhcnNlZExheWVyLFxuICBQYXJzZWRWaXNTdGF0ZSxcbiAgU2F2ZWRJbnRlcmFjdGlvbkNvbmZpZyxcbiAgVG9vbHRpcEluZm8sXG4gIFNhdmVkRWRpdG9yLFxuICBQYXJzZWRDb25maWcsXG4gIEZpbHRlcixcbiAgRWZmZWN0IGFzIEVmZmVjdFR5cGUsXG4gIFBhcnNlZEVmZmVjdFxufSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7S2VwbGVyVGFibGUsIERhdGFzZXRzLCBhc3NpZ25HcHVDaGFubmVscywgcmVzZXRGaWx0ZXJHcHVNb2RlfSBmcm9tICdAa2VwbGVyLmdsL3RhYmxlJztcblxuLyoqXG4gKiBNZXJnZSBsb2FkZWQgZmlsdGVycyB3aXRoIGN1cnJlbnQgc3RhdGUsIGlmIG5vIGZpZWxkcyBvciBkYXRhIGFyZSBsb2FkZWRcbiAqIHNhdmUgaXQgZm9yIGxhdGVyXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VGaWx0ZXJzPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBmaWx0ZXJzVG9NZXJnZTogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnZmlsdGVycyddLFxuICBmcm9tQ29uZmlnPzogYm9vbGVhblxuKTogUyB7XG4gIGNvbnN0IHByZXNlcnZlRmlsdGVyT3JkZXIgPSBmcm9tQ29uZmlnXG4gICAgPyBmaWx0ZXJzVG9NZXJnZT8ubWFwKGwgPT4gbC5pZClcbiAgICA6IHN0YXRlLnByZXNlcnZlRmlsdGVyT3JkZXI7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlcnNUb01lcmdlKSB8fCAhZmlsdGVyc1RvTWVyZ2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3Qge3ZhbGlkYXRlZCwgZmFpbGVkLCB1cGRhdGVkRGF0YXNldHN9ID0gdmFsaWRhdGVGaWx0ZXJzVXBkYXRlRGF0YXNldHMoc3RhdGUsIGZpbHRlcnNUb01lcmdlKTtcbiAgbGV0IHVwZGF0ZWRGaWx0ZXJzID0gaW5zZXJ0SXRlbUJhc2VkT25QcmVzZXJ2ZWRPcmRlcihcbiAgICBzdGF0ZS5maWx0ZXJzLFxuICAgIHZhbGlkYXRlZCxcbiAgICBwcmVzZXJ2ZUZpbHRlck9yZGVyXG4gICk7XG5cbiAgLy8gbWVyZ2UgZmlsdGVyIHdpdGggZXhpc3RpbmdcbiAgdXBkYXRlZEZpbHRlcnMgPSByZXNldEZpbHRlckdwdU1vZGUodXBkYXRlZEZpbHRlcnMpO1xuICB1cGRhdGVkRmlsdGVycyA9IGFzc2lnbkdwdUNoYW5uZWxzKHVwZGF0ZWRGaWx0ZXJzKTtcbiAgLy8gZmlsdGVyIGRhdGFcbiAgY29uc3QgZGF0YXNldHNUb0ZpbHRlciA9IHVuaXEoZmxhdHRlbkRlZXAodmFsaWRhdGVkLm1hcChmID0+IGYuZGF0YUlkKSkpO1xuXG4gIGNvbnN0IGZpbHRlcmVkID0gYXBwbHlGaWx0ZXJzVG9EYXRhc2V0cyhcbiAgICBkYXRhc2V0c1RvRmlsdGVyLFxuICAgIHVwZGF0ZWREYXRhc2V0cyxcbiAgICB1cGRhdGVkRmlsdGVycyxcbiAgICBzdGF0ZS5sYXllcnNcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGZpbHRlcnM6IHVwZGF0ZWRGaWx0ZXJzLFxuICAgIGRhdGFzZXRzOiBmaWx0ZXJlZCxcbiAgICBwcmVzZXJ2ZUZpbHRlck9yZGVyLFxuICAgIGZpbHRlclRvQmVNZXJnZWQ6IFsuLi5zdGF0ZS5maWx0ZXJUb0JlTWVyZ2VkLCAuLi5mYWlsZWRdXG4gIH07XG59XG5cbi8vIHJlcGxhY2UgZGF0YUlkIGluIHNhdmVkIEZpbHRlclxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VGaWx0ZXJEYXRhc2V0SWRzKFxuICBzYXZlZEZpbHRlcjogRmlsdGVyW10sXG4gIGRhdGFJZDogc3RyaW5nLFxuICBkYXRhSWRUb1VzZTogc3RyaW5nXG4pIHtcbiAgY29uc3QgcmVwbGFjZWQ6IEZpbHRlcltdID0gW107XG4gIHNhdmVkRmlsdGVyLmZvckVhY2goZmlsdGVyID0+IHtcbiAgICBpZiAoZmlsdGVyLmRhdGFJZC5pbmNsdWRlcyhkYXRhSWQpKSB7XG4gICAgICBjb25zdCBuZXdEYXRhSWQgPSBmaWx0ZXIuZGF0YUlkLm1hcChkID0+IChkID09PSBkYXRhSWQgPyBkYXRhSWRUb1VzZSA6IGQpKTtcbiAgICAgIHJlcGxhY2VkLnB1c2goe1xuICAgICAgICAuLi5maWx0ZXIsXG4gICAgICAgIGRhdGFJZDogbmV3RGF0YUlkXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVwbGFjZWQubGVuZ3RoID8gcmVwbGFjZWQgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTYXZlZExheWVyQ29uZmlnVjEobGF5ZXJDb25maWc6IGFueSk6IGJvb2xlYW4ge1xuICAvLyBleHBvcnRlZCBsYXllciBjb25maWd1cmF0aW9uIGNvbnRhaW5zIHZpc3VhbENoYW5uZWxzIHByb3BlcnR5XG4gIHJldHVybiBsYXllckNvbmZpZz8udmlzdWFsQ2hhbm5lbHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUxheWVyQ29uZmlnKFxuICBzY2hlbWE6IEtlcGxlckdMU2NoZW1hQ2xhc3MsXG4gIGxheWVyQ29uZmlnOiBhbnlcbik6IFBhcnNlZExheWVyIHwgdW5kZWZpbmVkIHtcbiAgLy8gYXNzdW1lIHRoZSBsYXllciBjb25maWcgaXMgY3VycmVudCB2ZXJzaW9uXG4gIGNvbnN0IHNhdmVkQ29uZmlnID0ge1xuICAgIHZlcnNpb246IENVUlJFTlRfVkVSU0lPTixcbiAgICBjb25maWc6IHtcbiAgICAgIHZpc1N0YXRlOiB7bGF5ZXJzOiBbbGF5ZXJDb25maWddLCBsYXllck9yZGVyOiBbbGF5ZXJDb25maWcuaWRdfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2NoZW1hLnBhcnNlU2F2ZWRDb25maWcoc2F2ZWRDb25maWcpPy52aXNTdGF0ZT8ubGF5ZXJzPy5bMF07XG59XG5cbmZ1bmN0aW9uIGluc2VydEl0ZW1CYXNlZE9uUHJlc2VydmVkT3JkZXIoXG4gIGN1cnJlbnRJdGVtczogRmlsdGVyW10sXG4gIGl0ZW1zOiBGaWx0ZXJbXSxcbiAgcHJlc2VydmVkT3JkZXI6IGFueVtdID0gW10sXG4gIGRlZmF1bHRTdGFydD86IGJvb2xlYW5cbikge1xuICBsZXQgbmV3SXRlbXMgPSBbLi4uY3VycmVudEl0ZW1zXTtcblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICBjb25zdCBleHBlY3RlZElkeCA9IHByZXNlcnZlZE9yZGVyLmluZGV4T2YoaXRlbS5pZCk7XG4gICAgLy8gaW5zZXJ0QXQgdGhlIGVuZCBieSBkZWZhdWx0XG4gICAgbGV0IGluc2VydEF0ID0gZGVmYXVsdFN0YXJ0ID8gMCA6IG5ld0l0ZW1zLmxlbmd0aDtcbiAgICBpZiAoZXhwZWN0ZWRJZHggPiAwKSB7XG4gICAgICAvLyBsb29rIGZvciBsYXllciB0byBpbnNlcnQgYWZ0ZXJcbiAgICAgIGxldCBpID0gZXhwZWN0ZWRJZHggKyAxO1xuICAgICAgbGV0IHByZWNlZWRJZHggPSAtMTtcbiAgICAgIHdoaWxlIChpLS0gPiAwICYmIHByZWNlZWRJZHggPCAwKSB7XG4gICAgICAgIC8vIGtlZXAgbG9va2luZyBmb3IgcHJlY2VlZCBsYXllciB0aGF0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGNvbnN0IHByZWNlZWRJdGVtSWQgPSBwcmVzZXJ2ZWRPcmRlcltpIC0gMV07XG4gICAgICAgIHByZWNlZWRJZHggPSBuZXdJdGVtcy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBwcmVjZWVkSXRlbUlkKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVjZWVkSWR4ID4gLTEpIHtcbiAgICAgICAgLy8gaWYgZm91bmRcbiAgICAgICAgaW5zZXJ0QXQgPSBwcmVjZWVkSWR4ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgbmV3SXRlbXMgPSBhcnJheUluc2VydChuZXdJdGVtcywgaW5zZXJ0QXQsIGl0ZW0pO1xuICB9XG4gIHJldHVybiBuZXdJdGVtcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxheWVyRnJvbUNvbmZpZyhzdGF0ZTogVmlzU3RhdGUsIGxheWVyQ29uZmlnOiBhbnkpOiBMYXllciB8IG51bGwge1xuICAvLyBjaGVjayBpZiB0aGUgbGF5ZXIgY29uZmlnIGlzIHBhcnNlZFxuICBjb25zdCBwYXJzZWRMYXllckNvbmZpZyA9IGlzU2F2ZWRMYXllckNvbmZpZ1YxKGxheWVyQ29uZmlnKVxuICAgID8gcGFyc2VMYXllckNvbmZpZyhzdGF0ZS5zY2hlbWEsIGxheWVyQ29uZmlnKVxuICAgIDogbGF5ZXJDb25maWc7XG5cbiAgaWYgKCFwYXJzZWRMYXllckNvbmZpZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGZpcnN0IHZhbGlkYXRlIGNvbmZpZyBhZ2FpbnN0IGRhdGFzZXRcbiAgY29uc3Qge3ZhbGlkYXRlZCwgZmFpbGVkfSA9IHZhbGlkYXRlTGF5ZXJzQnlEYXRhc2V0cyhcbiAgICBzdGF0ZS5kYXRhc2V0cyxcbiAgICBzdGF0ZS5sYXllckNsYXNzZXMsXG4gICAgW3BhcnNlZExheWVyQ29uZmlnXSxcbiAgICB7YWxsb3dFbXB0eUNvbHVtbjogdHJ1ZX1cbiAgKTtcblxuICBpZiAoZmFpbGVkPy5sZW5ndGggfHwgIXZhbGlkYXRlZC5sZW5ndGgpIHtcbiAgICAvLyBmYWlsZWRcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG5ld0xheWVyID0gdmFsaWRhdGVkWzBdO1xuICBuZXdMYXllci51cGRhdGVMYXllckRvbWFpbihzdGF0ZS5kYXRhc2V0cyk7XG4gIHJldHVybiBuZXdMYXllcjtcbn1cblxuLyoqXG4gKiBHZXQgbG9hZGVkIGxheWVyIGZyb20gc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUxheWVyKFxuICBuZXdMYXllcjogTGF5ZXIsXG4gIHNjaGVtYTogS2VwbGVyR0xTY2hlbWFDbGFzc1xuKTogUGFyc2VkTGF5ZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCBzZXJpYWxpemVkVmlzU3RhdGUgPSBzZXJpYWxpemVWaXNTdGF0ZShcbiAgICB7bGF5ZXJzOiBbbmV3TGF5ZXJdLCBsYXllck9yZGVyOiBbbmV3TGF5ZXIuaWRdfSxcbiAgICBzY2hlbWFcbiAgKTtcbiAgcmV0dXJuIHNlcmlhbGl6ZWRWaXNTdGF0ZT8ubGF5ZXJzPy5bMF07XG59XG5cbi8qKlxuICogR2V0IGxvYWRlZCBlZmZlY3QgZnJvbSBzdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplRWZmZWN0KFxuICBuZXdFZmZlY3Q6IEVmZmVjdFR5cGUsXG4gIHNjaGVtYTogS2VwbGVyR0xTY2hlbWFDbGFzc1xuKTogUGFyc2VkRWZmZWN0IHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc2VyaWFsaXplZFZpc1N0YXRlID0gc2VyaWFsaXplVmlzU3RhdGUoXG4gICAge2VmZmVjdHM6IFtuZXdFZmZlY3RdLCBlZmZlY3RPcmRlcjogW25ld0VmZmVjdC5pZF19LFxuICAgIHNjaGVtYVxuICApO1xuICByZXR1cm4gc2VyaWFsaXplZFZpc1N0YXRlPy5lZmZlY3RzPy5bMF07XG59XG5cbi8qKlxuICogR2V0IHZpcyBzdGF0ZSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVZpc1N0YXRlKFxuICB2aXNTdGF0ZTogUGFydGlhbDxWaXNTdGF0ZT4sXG4gIHNjaGVtYTogS2VwbGVyR0xTY2hlbWFDbGFzc1xuKTogUGFyc2VkVmlzU3RhdGUgfCB1bmRlZmluZWQge1xuICBjb25zdCBzYXZlZFN0YXRlID0gc2NoZW1hLmdldENvbmZpZ1RvU2F2ZSh7XG4gICAgdmlzU3RhdGVcbiAgfSk7XG4gIHJldHVybiBzYXZlZFN0YXRlID8gc2NoZW1hLnBhcnNlU2F2ZWRDb25maWcoc2F2ZWRTdGF0ZSk/LnZpc1N0YXRlIDogdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBNZXJnZSBsYXllcnMgZnJvbSBkZS1zZXJpYWxpemVkIHN0YXRlLCBpZiBubyBmaWVsZHMgb3IgZGF0YSBhcmUgbG9hZGVkXG4gKiBzYXZlIGl0IGZvciBsYXRlclxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTGF5ZXJzPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBsYXllcnNUb01lcmdlOiBOb25OdWxsYWJsZTxQYXJzZWRDb25maWdbJ3Zpc1N0YXRlJ10+WydsYXllcnMnXSA9IFtdLFxuICBmcm9tQ29uZmlnPzogYm9vbGVhblxuKTogUyB7XG4gIGNvbnN0IHByZXNlcnZlTGF5ZXJPcmRlciA9IGZyb21Db25maWdcbiAgICA/IGdldExheWVyT3JkZXJGcm9tTGF5ZXJzKGxheWVyc1RvTWVyZ2UpXG4gICAgOiBzdGF0ZS5wcmVzZXJ2ZUxheWVyT3JkZXI7XG4gIGlmICghQXJyYXkuaXNBcnJheShsYXllcnNUb01lcmdlKSB8fCAhbGF5ZXJzVG9NZXJnZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgLy8gZG9uJ3QgbWVyZ2UgbGF5ZXIgaWYgZGF0YXNldCBpcyBiZWluZyBtZXJnZWRcbiAgY29uc3QgdW5tZXJnZWQ6IFBhcnNlZExheWVyW10gPSBbXTtcbiAgY29uc3QgdG9NZXJnZTogUGFyc2VkTGF5ZXJbXSA9IFtdO1xuICBsYXllcnNUb01lcmdlLmZvckVhY2goKGw6IFBhcnNlZExheWVyKSA9PiB7XG4gICAgaWYgKGw/LmNvbmZpZz8uZGF0YUlkICYmIHN0YXRlLmlzTWVyZ2luZ0RhdGFzZXRzW2wuY29uZmlnLmRhdGFJZF0pIHtcbiAgICAgIHVubWVyZ2VkLnB1c2gobCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvTWVyZ2UucHVzaChsKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHt2YWxpZGF0ZWQ6IG1lcmdlZExheWVyLCBmYWlsZWR9ID0gdmFsaWRhdGVMYXllcnNCeURhdGFzZXRzKFxuICAgIHN0YXRlLmRhdGFzZXRzLFxuICAgIHN0YXRlLmxheWVyQ2xhc3NlcyxcbiAgICB0b01lcmdlXG4gICk7XG4gIHVubWVyZ2VkLnB1c2goLi4uZmFpbGVkKTtcbiAgLy8gcHV0IG5ldyBsYXllcnMgaW4gZnJvbnQgb2YgY3VycmVudCBsYXllcnNcbiAgY29uc3Qge25ld0xheWVyT3JkZXIsIG5ld0xheWVyc30gPSBpbnNlcnRMYXllckF0UmlnaHRPcmRlcihcbiAgICBzdGF0ZS5sYXllcnMsXG4gICAgbWVyZ2VkTGF5ZXIsXG4gICAgc3RhdGUubGF5ZXJPcmRlcixcbiAgICBwcmVzZXJ2ZUxheWVyT3JkZXJcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogbmV3TGF5ZXJzLFxuICAgIGxheWVyT3JkZXI6IG5ld0xheWVyT3JkZXIsXG4gICAgcHJlc2VydmVMYXllck9yZGVyLFxuICAgIGxheWVyVG9CZU1lcmdlZDogWy4uLnN0YXRlLmxheWVyVG9CZU1lcmdlZCwgLi4udW5tZXJnZWRdXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRMYXllckF0UmlnaHRPcmRlcihcbiAgY3VycmVudExheWVycyxcbiAgbGF5ZXJzVG9JbnNlcnQsXG4gIGN1cnJlbnRPcmRlcixcbiAgcHJlc2VydmVkT3JkZXI6IHN0cmluZ1tdID0gW11cbikge1xuICBpZiAoIWxheWVyc1RvSW5zZXJ0Py5sZW5ndGgpIHtcbiAgICByZXR1cm4ge25ld0xheWVyczogY3VycmVudExheWVycywgbmV3TGF5ZXJPcmRlcjogY3VycmVudE9yZGVyfTtcbiAgfVxuICAvLyBwZXJzZXJ2ZWRPcmRlciBbJ2EnLCAnYicsICdjJ107XG4gIC8vIGxheWVyT3JkZXIgWydhJywgJ2InLCAnYyddXG4gIGNvbnN0IGN1cnJlbnRMYXllclF1ZXVlID0gY3VycmVudE9yZGVyXG4gICAgLm1hcChpZCA9PiBmaW5kQnlJZChpZCkoY3VycmVudExheWVycykpXG4gICAgLmZpbHRlcihsYXllciA9PiBCb29sZWFuKGxheWVyKSk7XG4gIGNvbnN0IG5ld0xheWVycyA9IGN1cnJlbnRMYXllcnMuY29uY2F0KGxheWVyc1RvSW5zZXJ0KTtcbiAgY29uc3QgbmV3TGF5ZXJPcmRlclF1ZXVlID0gaW5zZXJ0SXRlbUJhc2VkT25QcmVzZXJ2ZWRPcmRlcihcbiAgICBjdXJyZW50TGF5ZXJRdWV1ZSxcbiAgICBsYXllcnNUb0luc2VydCxcbiAgICBwcmVzZXJ2ZWRPcmRlcixcbiAgICB0cnVlXG4gICk7XG5cbiAgLy8gcmVjb25zdHJ1Y3QgbGF5ZXJPcmRlciBhZnRlciBpbnNlcnRcbiAgY29uc3QgbmV3TGF5ZXJPcmRlciA9IGdldExheWVyT3JkZXJGcm9tTGF5ZXJzKG5ld0xheWVyT3JkZXJRdWV1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuZXdMYXllck9yZGVyLFxuICAgIG5ld0xheWVyc1xuICB9O1xufVxuXG4vKipcbiAqIE1lcmdlIGludGVyYWN0aW9ucyB3aXRoIHNhdmVkIGNvbmZpZ1xuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSW50ZXJhY3Rpb25zPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBpbnRlcmFjdGlvblRvQmVNZXJnZWQ6IFBhcnRpYWw8U2F2ZWRJbnRlcmFjdGlvbkNvbmZpZz4gfCB1bmRlZmluZWQsXG4gIGZyb21Db25maWc/OiBib29sZWFuXG4pOiBTIHtcbiAgY29uc3QgbWVyZ2VkOiBQYXJ0aWFsPFNhdmVkSW50ZXJhY3Rpb25Db25maWc+ID0ge307XG4gIGNvbnN0IHVubWVyZ2VkOiBQYXJ0aWFsPFNhdmVkSW50ZXJhY3Rpb25Db25maWc+ID0ge307XG5cbiAgaWYgKGludGVyYWN0aW9uVG9CZU1lcmdlZCkge1xuICAgIChPYmplY3Qua2V5cyhpbnRlcmFjdGlvblRvQmVNZXJnZWQpIGFzIEFycmF5PGtleW9mIFNhdmVkSW50ZXJhY3Rpb25Db25maWc+KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIXN0YXRlLmludGVyYWN0aW9uQ29uZmlnW2tleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyZW50Q29uZmlnID1cbiAgICAgICAga2V5ID09PSAndG9vbHRpcCcgfHwga2V5ID09PSAnYnJ1c2gnID8gc3RhdGUuaW50ZXJhY3Rpb25Db25maWdba2V5XS5jb25maWcgOiBudWxsO1xuXG4gICAgICBjb25zdCB7ZW5hYmxlZCwgLi4uY29uZmlnU2F2ZWR9ID0gaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkW2tleV0gfHwge307XG5cbiAgICAgIGxldCBjb25maWdUb01lcmdlID0gY29uZmlnU2F2ZWQ7XG5cbiAgICAgIGlmIChrZXkgPT09ICd0b29sdGlwJykge1xuICAgICAgICBjb25zdCB7bWVyZ2VkVG9vbHRpcCwgdW5tZXJnZWRUb29sdGlwfSA9IG1lcmdlSW50ZXJhY3Rpb25Ub29sdGlwQ29uZmlnKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGNvbmZpZ1NhdmVkIGFzIFNhdmVkSW50ZXJhY3Rpb25Db25maWdbJ3Rvb2x0aXAnXVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIG1lcmdlIG5ldyBkYXRhc2V0IHRvb2x0aXBzIHdpdGggb3JpZ2luYWwgZGF0YXNldCB0b29sdGlwc1xuICAgICAgICBjb25maWdUb01lcmdlID0ge1xuICAgICAgICAgIGZpZWxkc1RvU2hvdzoge1xuICAgICAgICAgICAgLi4uKGN1cnJlbnRDb25maWcgYXMgVG9vbHRpcEluZm9bJ2NvbmZpZyddKS5maWVsZHNUb1Nob3csXG4gICAgICAgICAgICAuLi5tZXJnZWRUb29sdGlwXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh1bm1lcmdlZFRvb2x0aXApLmxlbmd0aCkge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICB1bm1lcmdlZC50b29sdGlwID0ge2ZpZWxkc1RvU2hvdzogdW5tZXJnZWRUb29sdGlwLCBlbmFibGVkOiBCb29sZWFuKGVuYWJsZWQpfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZXJnZWRba2V5XSA9IHtcbiAgICAgICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWdba2V5XSxcbiAgICAgICAgZW5hYmxlZDogQm9vbGVhbihlbmFibGVkKSxcbiAgICAgICAgLi4uKGN1cnJlbnRDb25maWdcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgY29uZmlnOiBwaWNrKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIC4uLmN1cnJlbnRDb25maWcsXG4gICAgICAgICAgICAgICAgICAuLi5jb25maWdUb01lcmdlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjdXJyZW50Q29uZmlnKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBuZXh0U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgaW50ZXJhY3Rpb25Db25maWc6IHtcbiAgICAgIC4uLnN0YXRlLmludGVyYWN0aW9uQ29uZmlnLFxuICAgICAgLi4ubWVyZ2VkXG4gICAgfSxcbiAgICBpbnRlcmFjdGlvblRvQmVNZXJnZWQ6IHNhdmVkVW5tZXJnZWRJbnRlcmFjdGlvbihzdGF0ZSwgdW5tZXJnZWQpXG4gIH07XG4gIHJldHVybiBuZXh0U3RhdGU7XG59XG5cbmZ1bmN0aW9uIHNhdmVkVW5tZXJnZWRJbnRlcmFjdGlvbjxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgdW5tZXJnZWQ6IFBhcnRpYWw8U2F2ZWRJbnRlcmFjdGlvbkNvbmZpZz5cbikge1xuICBpZiAoIXVubWVyZ2VkPy50b29sdGlwPy5maWVsZHNUb1Nob3cpIHtcbiAgICByZXR1cm4gc3RhdGUuaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkLnRvb2x0aXAsXG4gICAgICAuLi4odHlwZW9mIHVubWVyZ2VkPy50b29sdGlwPy5lbmFibGVkID09PSAnYm9vbGVhbidcbiAgICAgICAgPyB7ZW5hYmxlZDogdW5tZXJnZWQudG9vbHRpcC5lbmFibGVkfVxuICAgICAgICA6IHt9KSxcbiAgICAgIGZpZWxkc1RvU2hvdzoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvblRvQmVNZXJnZWQ/LnRvb2x0aXA/LmZpZWxkc1RvU2hvdyxcbiAgICAgICAgLi4udW5tZXJnZWQ/LnRvb2x0aXA/LmZpZWxkc1RvU2hvd1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUludGVyYWN0aW9uRGF0YXNldElkcyhpbnRlcmFjdGlvbkNvbmZpZywgZGF0YUlkOiBzdHJpbmcsIGRhdGFJZFRvUmVwbGFjZTogc3RyaW5nKSB7XG4gIGlmIChpbnRlcmFjdGlvbkNvbmZpZz8udG9vbHRpcD8uZmllbGRzVG9TaG93W2RhdGFJZF0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaW50ZXJhY3Rpb25Db25maWcsXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIC4uLmludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAsXG4gICAgICAgIGZpZWxkc1RvU2hvdzoge1xuICAgICAgICAgIFtkYXRhSWRUb1JlcGxhY2VdOiBpbnRlcmFjdGlvbkNvbmZpZz8udG9vbHRpcD8uZmllbGRzVG9TaG93W2RhdGFJZF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIE1lcmdlIHNwbGl0TWFwcyBjb25maWcgd2l0aCBjdXJyZW50IHZpc1N0ZXRlLlxuICogMS4gaWYgY3VycmVudCBtYXAgaXMgc3BsaXQsIGJ1dCBzcGxpdE1hcCBET0VTTk9UIGNvbnRhaW4gbWFwc1xuICogICAgOiBkb24ndCBtZXJnZSBhbnl0aGluZ1xuICogMi4gaWYgY3VycmVudCBtYXAgaXMgTk9UIHNwbGl0LCBidXQgc3BsaXRNYXBzIGNvbnRhaW4gbWFwc1xuICogICAgOiBhZGQgdG8gc3BsaXRNYXBzLCBhbmQgYWRkIGN1cnJlbnQgbGF5ZXJzIHRvIHNwbGl0TWFwc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTcGxpdE1hcHM8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIHNwbGl0TWFwczogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnc3BsaXRNYXBzJ10gPSBbXSxcbiAgZnJvbUNvbmZpZz86IGJvb2xlYW5cbik6IFMge1xuICBjb25zdCBtZXJnZWQgPSBbLi4uc3RhdGUuc3BsaXRNYXBzXTtcbiAgY29uc3QgdW5tZXJnZWQgPSBbXTtcbiAgc3BsaXRNYXBzLmZvckVhY2goKHNtLCBpKSA9PiB7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHNtLmxheWVycyk7XG4gICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgZW50cmllcy5mb3JFYWNoKChbaWQsIHZhbHVlXSkgPT4ge1xuICAgICAgICAvLyBjaGVjayBpZiBsYXllciBleGlzdHNcbiAgICAgICAgY29uc3QgcHVzaFRvID0gc3RhdGUubGF5ZXJzLmZpbmQobCA9PiBsLmlkID09PSBpZCkgPyBtZXJnZWQgOiB1bm1lcmdlZDtcblxuICAgICAgICAvLyBjcmVhdGUgbWFwIHBhbmVsIGlmIGN1cnJlbnQgbWFwIGlzIG5vdCBzcGxpdFxuICAgICAgICBwdXNoVG9baV0gPSBwdXNoVG9baV0gfHwge1xuICAgICAgICAgIC8vIGtlZXAgaWRcbiAgICAgICAgICAuLi5zbSxcbiAgICAgICAgICBsYXllcnM6IHB1c2hUbyA9PT0gbWVyZ2VkID8gZ2V0SW5pdGlhbE1hcExheWVyc0ZvclNwbGl0TWFwKHN0YXRlLmxheWVycykgOiBbXVxuICAgICAgICB9O1xuICAgICAgICBwdXNoVG9baV0ubGF5ZXJzID0ge1xuICAgICAgICAgIC4uLnB1c2hUb1tpXS5sYXllcnMsXG4gICAgICAgICAgW2lkXTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBhcmUgbWVyZ2luZyBpZiB0aGVyZSBhcmUgbm8gbGF5ZXJzIGluIGJvdGggc3BsaXQgbWFwXG4gICAgICBtZXJnZWQucHVzaChzbSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIHNwbGl0TWFwczogbWVyZ2VkLFxuICAgIHNwbGl0TWFwc1RvQmVNZXJnZWQ6IFsuLi5zdGF0ZS5zcGxpdE1hcHNUb0JlTWVyZ2VkLCAuLi51bm1lcmdlZF1cbiAgfTtcbn1cblxuLyoqXG4gKiBNZXJnZSBlZmZlY3RzIHdpdGggc2F2ZWQgY29uZmlnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUVmZmVjdHM8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIGVmZmVjdHM6IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ2VmZmVjdHMnXSxcbiAgZnJvbUNvbmZpZz86IGJvb2xlYW5cbik6IFMge1xuICBjb25zdCBuZXdFZmZlY3RzID0gW1xuICAgIC4uLnN0YXRlLmVmZmVjdHMsXG4gICAgLi4uKGVmZmVjdHMgfHwgW10pXG4gICAgICAubWFwKGVmZmVjdCA9PiB7XG4gICAgICAgIHJldHVybiBmcm9tQ29uZmlnXG4gICAgICAgICAgPyBjcmVhdGVFZmZlY3QoXG4gICAgICAgICAgICAgIGRlZXBtZXJnZS5hbGwoW1xuICAgICAgICAgICAgICAgIGVmZmVjdCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZSBhbGwgcGFuZWxzIHdoZW4gbG9hZGluZyBlZmZlY3RzXG4gICAgICAgICAgICAgICAgICBpc0NvbmZpZ0FjdGl2ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAoZWZmZWN0IGFzIEVmZmVjdFR5cGUpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoZWZmZWN0ID0+IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZWZmZWN0ICYmIGVmZmVjdC5pc1ZhbGlkVG9TYXZlKCkpO1xuICAgICAgfSlcbiAgXTtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZmZlY3RzOiBuZXdFZmZlY3RzLFxuICAgIGVmZmVjdE9yZGVyOiBuZXdFZmZlY3RzLm1hcChlZmZlY3QgPT4gZWZmZWN0LmlkKVxuICB9O1xufVxuXG4vKipcbiAqIE1lcmdlIGludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAgd2l0aCBzYXZlZCBjb25maWcsXG4gKiB2YWxpZGF0ZSBmaWVsZHNUb1Nob3dcbiAqXG4gKiBAcGFyYW0gc3RhdGVcbiAqIEBwYXJhbSB0b29sdGlwQ29uZmlnXG4gKiBAcmV0dXJuIC0ge21lcmdlZFRvb2x0aXA6IHt9LCB1bm1lcmdlZFRvb2x0aXA6IHt9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJbnRlcmFjdGlvblRvb2x0aXBDb25maWcoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgdG9vbHRpcENvbmZpZzogUGljazxUb29sdGlwSW5mb1snY29uZmlnJ10sICdmaWVsZHNUb1Nob3cnPiB8IG51bGwgPSBudWxsXG4pIHtcbiAgY29uc3QgdW5tZXJnZWRUb29sdGlwOiBUb29sdGlwSW5mb1snY29uZmlnJ11bJ2ZpZWxkc1RvU2hvdyddID0ge307XG4gIGNvbnN0IG1lcmdlZFRvb2x0aXA6IFRvb2x0aXBJbmZvWydjb25maWcnXVsnZmllbGRzVG9TaG93J10gPSB7fTtcblxuICBpZiAoXG4gICAgIXRvb2x0aXBDb25maWcgfHxcbiAgICAhdG9vbHRpcENvbmZpZy5maWVsZHNUb1Nob3cgfHxcbiAgICAhT2JqZWN0LmtleXModG9vbHRpcENvbmZpZy5maWVsZHNUb1Nob3cpLmxlbmd0aFxuICApIHtcbiAgICByZXR1cm4ge21lcmdlZFRvb2x0aXAsIHVubWVyZ2VkVG9vbHRpcH07XG4gIH1cblxuICBmb3IgKGNvbnN0IGRhdGFJZCBpbiB0b29sdGlwQ29uZmlnLmZpZWxkc1RvU2hvdykge1xuICAgIGlmICghc3RhdGUuZGF0YXNldHNbZGF0YUlkXSB8fCBzdGF0ZS5pc01lcmdpbmdEYXRhc2V0c1tkYXRhSWRdKSB7XG4gICAgICAvLyBpcyBub3QgeWV0IGxvYWRlZFxuICAgICAgdW5tZXJnZWRUb29sdGlwW2RhdGFJZF0gPSB0b29sdGlwQ29uZmlnLmZpZWxkc1RvU2hvd1tkYXRhSWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBkYXRhc2V0IGlzIGxvYWRlZFxuICAgICAgY29uc3QgYWxsRmllbGRzID0gc3RhdGUuZGF0YXNldHNbZGF0YUlkXS5maWVsZHMubWFwKGQgPT4gZC5uYW1lKTtcbiAgICAgIGNvbnN0IGZvdW5kRmllbGRzVG9TaG93ID0gdG9vbHRpcENvbmZpZy5maWVsZHNUb1Nob3dbZGF0YUlkXS5maWx0ZXIoZmllbGQgPT5cbiAgICAgICAgYWxsRmllbGRzLmluY2x1ZGVzKGZpZWxkLm5hbWUpXG4gICAgICApO1xuXG4gICAgICBtZXJnZWRUb29sdGlwW2RhdGFJZF0gPSBmb3VuZEZpZWxkc1RvU2hvdztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge21lcmdlZFRvb2x0aXAsIHVubWVyZ2VkVG9vbHRpcH07XG59XG4vKipcbiAqIE1lcmdlIGxheWVyQmxlbmRpbmcgd2l0aCBzYXZlZFxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTGF5ZXJCbGVuZGluZzxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgbGF5ZXJCbGVuZGluZzogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnbGF5ZXJCbGVuZGluZyddLFxuICBmcm9tQ29uZmlnPzogYm9vbGVhblxuKTogUyB7XG4gIGlmIChsYXllckJsZW5kaW5nICYmIExBWUVSX0JMRU5ESU5HU1tsYXllckJsZW5kaW5nXSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGxheWVyQmxlbmRpbmdcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIE1lcmdlIG92ZXJsYXlCbGVuZGluZyB3aXRoIHNhdmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZU92ZXJsYXlCbGVuZGluZzxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgb3ZlcmxheUJsZW5kaW5nOiBOb25OdWxsYWJsZTxQYXJzZWRDb25maWdbJ3Zpc1N0YXRlJ10+WydvdmVybGF5QmxlbmRpbmcnXSxcbiAgZnJvbUNvbmZpZz86IGJvb2xlYW5cbik6IFMge1xuICBpZiAob3ZlcmxheUJsZW5kaW5nICYmIE9WRVJMQVlfQkxFTkRJTkdTW292ZXJsYXlCbGVuZGluZ10pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBvdmVybGF5QmxlbmRpbmdcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIE1lcmdlIGFuaW1hdGlvbiBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQW5pbWF0aW9uQ29uZmlnPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBhbmltYXRpb246IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ2FuaW1hdGlvbkNvbmZpZyddLFxuICBmcm9tQ29uZmlnPzogYm9vbGVhblxuKTogUyB7XG4gIGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLmN1cnJlbnRUaW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgICAgIC4uLnN0YXRlLmFuaW1hdGlvbkNvbmZpZyxcbiAgICAgICAgLi4uYW5pbWF0aW9uLFxuICAgICAgICBkb21haW46IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHNhdmVkIGxheWVyIGNvbHVtbnMgd2l0aCBuZXcgZGF0YSxcbiAqIHVwZGF0ZSBmaWVsZElkeCBiYXNlZCBvbiBuZXcgZmllbGRzXG4gKlxuICogQHBhcmFtIGZpZWxkc1xuICogQHBhcmFtIHNhdmVkQ29sc1xuICogQHBhcmFtIGVtcHR5Q29sc1xuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm4gLSB2YWxpZGF0ZWQgY29sdW1ucyBvciBudWxsXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2F2ZWRMYXllckNvbHVtbnMoXG4gIGZpZWxkczogS2VwbGVyVGFibGVbJ2ZpZWxkcyddLFxuICBzYXZlZENvbHM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XG4gIH0gPSB7fSxcbiAgZW1wdHlDb2xzOiBMYXllckNvbHVtbnMsXG4gIG9wdGlvbnM6IHt0aHJvd09uRXJyb3I/OiBib29sZWFufSA9IHt9XG4pIHtcbiAgLy8gUHJlcGFyZSBjb2x1bW5zIGZvciB0aGUgdmFsaWRhdG9yXG4gIGNvbnN0IGNvbHVtbnM6IHR5cGVvZiBlbXB0eUNvbHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZW1wdHlDb2xzKSkge1xuICAgIGNvbHVtbnNba2V5XSA9IHsuLi5lbXB0eUNvbHNba2V5XX07XG5cbiAgICBjb25zdCBzYXZlZCA9IHNhdmVkQ29sc1trZXldO1xuICAgIGlmIChzYXZlZCkge1xuICAgICAgY29uc3QgZmllbGRJZHggPSBmaWVsZHMuZmluZEluZGV4KCh7bmFtZX0pID0+IG5hbWUgPT09IHNhdmVkKTtcblxuICAgICAgaWYgKGZpZWxkSWR4ID4gLTEpIHtcbiAgICAgICAgLy8gdXBkYXRlIGZvdW5kIGNvbHVtbnNcbiAgICAgICAgY29sdW1uc1trZXldLmZpZWxkSWR4ID0gZmllbGRJZHg7XG4gICAgICAgIGNvbHVtbnNba2V5XS52YWx1ZSA9IHNhdmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgYWN0dWFsIGNvbHVtbiBmaWVsZElkeCwgaW4gY2FzZSBpdCBoYXMgY2hhbmdlZFxuICBjb25zdCBhbGxDb2xGb3VuZCA9IE9iamVjdC5rZXlzKGNvbHVtbnMpLmV2ZXJ5KGtleSA9PlxuICAgIHZhbGlkYXRlQ29sdW1uKGNvbHVtbnNba2V5XSwgY29sdW1ucywgZmllbGRzKVxuICApO1xuXG4gIGNvbnN0IHJ2ID0gYWxsQ29sRm91bmQgPyBjb2x1bW5zIDogbnVsbDtcbiAgaWYgKG9wdGlvbnMudGhyb3dPbkVycm9yKSB7XG4gICAgY29uc3QgcmVxdWlyZWRDb2x1bW5zID0gT2JqZWN0LmtleXMoZW1wdHlDb2xzKS5maWx0ZXIoayA9PiAhZW1wdHlDb2xzW2tdLm9wdGlvbmFsKTtcbiAgICBjb25zdCBtaXNzaW5nQ29sdW1ucyA9IHJlcXVpcmVkQ29sdW1ucy5maWx0ZXIoayA9PiAhY29sdW1ucz8uW2tdLnZhbHVlKTtcbiAgICBpZiAobWlzc2luZ0NvbHVtbnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExheWVyIGhhcyBtaXNzaW5nIG9yIGludmFsaWQgY29sdW1uczogJHttaXNzaW5nQ29sdW1ucy5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgICBjb25zdCBjb25maWdDb2x1bW5zID0gT2JqZWN0LmtleXMoc2F2ZWRDb2xzKTtcbiAgICBjb25zdCBpbnZhbGlkQ29sdW1ucyA9IGNvbmZpZ0NvbHVtbnMuZmlsdGVyKGsgPT4gIWNvbHVtbnM/LltrXT8udmFsdWUpO1xuICAgIGlmIChpbnZhbGlkQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGF5ZXIgaGFzIGludmFsaWQgY29sdW1uczogJHtpbnZhbGlkQ29sdW1ucy5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ29sdW1uKFxuICBjb2x1bW46IExheWVyQ29sdW1uICYge3ZhbGlkYXRvcj86IHR5cGVvZiB2YWxpZGF0ZUNvbHVtbn0sXG4gIGNvbHVtbnM6IExheWVyQ29sdW1ucyxcbiAgYWxsRmllbGRzOiBLZXBsZXJUYWJsZVsnZmllbGRzJ11cbik6IGJvb2xlYW4ge1xuICBpZiAoY29sdW1uLm9wdGlvbmFsIHx8IGNvbHVtbi52YWx1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb2x1bW4udmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuIGNvbHVtbi52YWxpZGF0b3IoY29sdW1uLCBjb2x1bW5zLCBhbGxGaWVsZHMpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBzYXZlZCB0ZXh0IGxhYmVsIGNvbmZpZyB3aXRoIG5ldyBkYXRhXG4gKiByZWZlciB0byB2aXMtc3RhdGUtc2NoZW1hLmpzIFRleHRMYWJlbFNjaGVtYVYxXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBmaWVsZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzYXZlZFRleHRMYWJlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gLSB2YWxpZGF0ZWQgdGV4dGxhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNhdmVkVGV4dExhYmVsKFxuICBmaWVsZHMsXG4gIFtsYXllclRleHRMYWJlbF0sXG4gIHNhdmVkVGV4dExhYmVsLFxuICBvcHRpb25zOiB7dGhyb3dPbkVycm9yPzogYm9vbGVhbn0gPSB7fVxuKSB7XG4gIGNvbnN0IHNhdmVkVGV4dExhYmVscyA9IEFycmF5LmlzQXJyYXkoc2F2ZWRUZXh0TGFiZWwpID8gc2F2ZWRUZXh0TGFiZWwgOiBbc2F2ZWRUZXh0TGFiZWxdO1xuXG4gIC8vIHZhbGlkYXRlIGZpZWxkXG4gIHJldHVybiBzYXZlZFRleHRMYWJlbHMubWFwKHRleHRMYWJlbCA9PiB7XG4gICAgY29uc3QgZmllbGQgPSB0ZXh0TGFiZWwuZmllbGRcbiAgICAgID8gZmllbGRzLmZpbmQoZmQgPT5cbiAgICAgICAgICBPYmplY3Qua2V5cyh0ZXh0TGFiZWwuZmllbGQpLmV2ZXJ5KGtleSA9PiB0ZXh0TGFiZWwuZmllbGRba2V5XSA9PT0gZmRba2V5XSlcbiAgICAgICAgKVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKGZpZWxkID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50aHJvd09uRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGF5ZXIgaGFzIGludmFsaWQgdGV4dCBsYWJlbCBmaWVsZDogJHtKU09OLnN0cmluZ2lmeSh0ZXh0TGFiZWwuZmllbGQpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhsYXllclRleHRMYWJlbCkucmVkdWNlKFxuICAgICAgKGFjY3UsIGtleSkgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgW2tleV06IGtleSA9PT0gJ2ZpZWxkJyA/IGZpZWxkIDogdGV4dExhYmVsW2tleV0gfHwgbGF5ZXJUZXh0TGFiZWxba2V5XVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHNhdmVkIHZpc3VhbCBjaGFubmVscyBjb25maWcgd2l0aCBuZXcgZGF0YSxcbiAqIHJlZmVyIHRvIHZpcy1zdGF0ZS1zY2hlbWEuanMgVmlzdWFsQ2hhbm5lbFNjaGVtYVYxXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNhdmVkVmlzdWFsQ2hhbm5lbHMoXG4gIGZpZWxkczogS2VwbGVyVGFibGVbJ2ZpZWxkcyddLFxuICBuZXdMYXllcjogTGF5ZXIsXG4gIHNhdmVkTGF5ZXI6IFBhcnNlZExheWVyLFxuICBvcHRpb25zOiB7dGhyb3dPbkVycm9yPzogYm9vbGVhbn0gPSB7fVxuKTogbnVsbCB8IExheWVyIHtcbiAgT2JqZWN0LnZhbHVlcyhuZXdMYXllci52aXN1YWxDaGFubmVscykuZm9yRWFjaCgoe2ZpZWxkLCBzY2FsZSwga2V5fSkgPT4ge1xuICAgIGxldCBmb3VuZEZpZWxkO1xuICAgIGlmIChzYXZlZExheWVyLmNvbmZpZykge1xuICAgICAgaWYgKHNhdmVkTGF5ZXIuY29uZmlnW2ZpZWxkXSkge1xuICAgICAgICBmb3VuZEZpZWxkID0gZmllbGRzLmZpbmQoXG4gICAgICAgICAgZmQgPT4gc2F2ZWRMYXllci5jb25maWcgJiYgZmQubmFtZSA9PT0gc2F2ZWRMYXllci5jb25maWdbZmllbGRdLm5hbWVcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm91bmRDaGFubmVsID0ge1xuICAgICAgICAuLi4oZm91bmRGaWVsZCA/IHtbZmllbGRdOiBmb3VuZEZpZWxkfSA6IHt9KSxcbiAgICAgICAgLi4uKHNhdmVkTGF5ZXIuY29uZmlnW3NjYWxlXSA/IHtbc2NhbGVdOiBzYXZlZExheWVyLmNvbmZpZ1tzY2FsZV19IDoge30pXG4gICAgICB9O1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGZvdW5kQ2hhbm5lbCkubGVuZ3RoKSB7XG4gICAgICAgIG5ld0xheWVyLnVwZGF0ZUxheWVyQ29uZmlnKGZvdW5kQ2hhbm5lbCk7XG4gICAgICB9XG5cbiAgICAgIG5ld0xheWVyLnZhbGlkYXRlVmlzdWFsQ2hhbm5lbChrZXkpO1xuICAgICAgaWYgKG9wdGlvbnMudGhyb3dPbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IHNhdmVkTGF5ZXIuY29uZmlnPy5bZmllbGRdPy5uYW1lO1xuICAgICAgICBpZiAoZmllbGROYW1lICYmIGZpZWxkTmFtZSAhPT0gbmV3TGF5ZXIuY29uZmlnW2ZpZWxkXT8ubmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGF5ZXIgaGFzIGludmFsaWQgdmlzdWFsIGNoYW5uZWwgZmllbGQ6ICR7ZmllbGR9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3TGF5ZXI7XG59XG5cbnR5cGUgVmFsaWRhdGVMYXllck9wdGlvbiA9IHtcbiAgYWxsb3dFbXB0eUNvbHVtbj86IGJvb2xlYW47XG4gIHRocm93T25FcnJvcj86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMYXllcnNCeURhdGFzZXRzKFxuICBkYXRhc2V0czogRGF0YXNldHMsXG4gIGxheWVyQ2xhc3NlczogVmlzU3RhdGVbJ2xheWVyQ2xhc3NlcyddLFxuICBsYXllcnM6IE5vbk51bGxhYmxlPFBhcnNlZENvbmZpZ1sndmlzU3RhdGUnXT5bJ2xheWVycyddID0gW10sXG4gIG9wdGlvbnM/OiBWYWxpZGF0ZUxheWVyT3B0aW9uXG4pIHtcbiAgY29uc3QgdmFsaWRhdGVkOiBMYXllcltdID0gW107XG4gIGNvbnN0IGZhaWxlZDogTm9uTnVsbGFibGU8UGFyc2VkQ29uZmlnWyd2aXNTdGF0ZSddPlsnbGF5ZXJzJ10gPSBbXTtcblxuICBsYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgbGV0IHZhbGlkYXRlTGF5ZXI6IExheWVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBpZiAobGF5ZXI/LmNvbmZpZz8uZGF0YUlkKSB7XG4gICAgICBpZiAoZGF0YXNldHNbbGF5ZXIuY29uZmlnLmRhdGFJZF0pIHtcbiAgICAgICAgLy8gZGF0YXNldHMgYXJlIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIHZhbGlkYXRlTGF5ZXIgPSB2YWxpZGF0ZUxheWVyV2l0aERhdGEoXG4gICAgICAgICAgZGF0YXNldHNbbGF5ZXIuY29uZmlnLmRhdGFJZF0sXG4gICAgICAgICAgbGF5ZXIsXG4gICAgICAgICAgbGF5ZXJDbGFzc2VzLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsaWRhdGVMYXllcikge1xuICAgICAgdmFsaWRhdGVkLnB1c2godmFsaWRhdGVMYXllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRhdGFzZXRzIG5vdCB5ZXQgbG9hZGVkXG4gICAgICBmYWlsZWQucHVzaChsYXllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge3ZhbGlkYXRlZCwgZmFpbGVkfTtcbn1cbi8qKlxuICogVmFsaWRhdGUgc2F2ZWQgbGF5ZXIgY29uZmlnIHdpdGggbmV3IGRhdGEsXG4gKiB1cGRhdGUgZmllbGRJZHggYmFzZWQgb24gbmV3IGZpZWxkc1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTGF5ZXJXaXRoRGF0YShcbiAge2ZpZWxkcywgaWQ6IGRhdGFJZH06IEtlcGxlclRhYmxlLFxuICBzYXZlZExheWVyOiBQYXJzZWRMYXllcixcbiAgbGF5ZXJDbGFzc2VzOiBWaXNTdGF0ZVsnbGF5ZXJDbGFzc2VzJ10sXG4gIG9wdGlvbnM6IFZhbGlkYXRlTGF5ZXJPcHRpb24gPSB7fVxuKTogTGF5ZXIgfCBudWxsIHtcbiAgY29uc3Qge3R5cGV9ID0gc2F2ZWRMYXllcjtcbiAgY29uc3Qge3Rocm93T25FcnJvcn0gPSBvcHRpb25zO1xuICAvLyBsYXllciBkb2VzbnQgaGF2ZSBhIHZhbGlkIHR5cGVcbiAgaWYgKCF0eXBlIHx8ICFsYXllckNsYXNzZXMuaGFzT3duUHJvcGVydHkodHlwZSkgfHwgIXNhdmVkTGF5ZXIuY29uZmlnKSB7XG4gICAgaWYgKHRocm93T25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXllciBoYXMgaW52YWxpZCB0eXBlIFwiJHt0eXBlfVwiIG9yIGNvbmZpZyBpcyBtaXNzaW5nYCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IG5ld0xheWVyID0gbmV3IGxheWVyQ2xhc3Nlc1t0eXBlXSh7XG4gICAgaWQ6IHNhdmVkTGF5ZXIuaWQsXG4gICAgZGF0YUlkLFxuICAgIGxhYmVsOiBzYXZlZExheWVyLmNvbmZpZy5sYWJlbCxcbiAgICBjb2xvcjogc2F2ZWRMYXllci5jb25maWcuY29sb3IsXG4gICAgaXNWaXNpYmxlOiBzYXZlZExheWVyLmNvbmZpZy5pc1Zpc2libGUsXG4gICAgaGlkZGVuOiBzYXZlZExheWVyLmNvbmZpZy5oaWRkZW4sXG4gICAgaGlnaGxpZ2h0Q29sb3I6IHNhdmVkTGF5ZXIuY29uZmlnLmhpZ2hsaWdodENvbG9yXG4gIH0pO1xuXG4gIC8vIGZpbmQgY29sdW1uIGZpZWxkSWR4XG4gIGNvbnN0IGNvbHVtbkNvbmZpZyA9IG5ld0xheWVyLmdldExheWVyQ29sdW1ucygpO1xuICBpZiAoT2JqZWN0LmtleXMoY29sdW1uQ29uZmlnKSkge1xuICAgIGNvbnN0IGNvbHVtbnMgPSB2YWxpZGF0ZVNhdmVkTGF5ZXJDb2x1bW5zKFxuICAgICAgZmllbGRzLFxuICAgICAgc2F2ZWRMYXllci5jb25maWcuY29sdW1ucyxcbiAgICAgIGNvbHVtbkNvbmZpZyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICBuZXdMYXllci51cGRhdGVMYXllckNvbmZpZyh7Y29sdW1uc30pO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuYWxsb3dFbXB0eUNvbHVtbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdGV4dExhYmVsID1cbiAgICBzYXZlZExheWVyLmNvbmZpZy50ZXh0TGFiZWwgJiYgbmV3TGF5ZXIuY29uZmlnLnRleHRMYWJlbFxuICAgICAgPyB2YWxpZGF0ZVNhdmVkVGV4dExhYmVsKFxuICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICBuZXdMYXllci5jb25maWcudGV4dExhYmVsLFxuICAgICAgICAgIHNhdmVkTGF5ZXIuY29uZmlnLnRleHRMYWJlbCxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIClcbiAgICAgIDogbmV3TGF5ZXIuY29uZmlnLnRleHRMYWJlbDtcblxuICAvLyBjb3B5IHZpc0NvbmZpZyBvdmVyIHRvIGVtcHR5TGF5ZXIgdG8gbWFrZSBzdXJlIGl0IGhhcyBhbGwgdGhlIHByb3BzXG4gIGNvbnN0IHZpc0NvbmZpZyA9IG5ld0xheWVyLmNvcHlMYXllckNvbmZpZyhcbiAgICBuZXdMYXllci5jb25maWcudmlzQ29uZmlnLFxuICAgIHNhdmVkTGF5ZXIuY29uZmlnLnZpc0NvbmZpZyB8fCB7fSxcbiAgICB7XG4gICAgICBzaGFsbG93Q29weTogWydjb2xvclJhbmdlJywgJ3N0cm9rZUNvbG9yUmFuZ2UnXVxuICAgIH1cbiAgKTtcblxuICBuZXdMYXllci51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgdmlzQ29uZmlnLFxuICAgIHRleHRMYWJlbFxuICB9KTtcblxuICAvLyB2aXN1YWwgY2hhbm5lbCBmaWVsZCBpcyBzYXZlZCB0byBiZSB7bmFtZSwgdHlwZX1cbiAgLy8gZmluZCB2aXN1YWwgY2hhbm5lbCBmaWVsZCBieSBtYXRjaGluZyBib3RoIG5hbWUgYW5kIHR5cGVcbiAgLy8gcmVmZXIgdG8gdmlzLXN0YXRlLXNjaGVtYS5qcyBWaXN1YWxDaGFubmVsU2NoZW1hVjFcbiAgbmV3TGF5ZXIgPSB2YWxpZGF0ZVNhdmVkVmlzdWFsQ2hhbm5lbHMoZmllbGRzLCBuZXdMYXllciwgc2F2ZWRMYXllciwgb3B0aW9ucyk7XG5cbiAgaWYgKHRocm93T25FcnJvcikge1xuICAgIGlmICghbmV3TGF5ZXIuaXNWYWxpZFRvU2F2ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExheWVyIGlzIG5vdCB2YWxpZCB0byBzYXZlOiAke25ld0xheWVyLmlkfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdMYXllcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRWRpdG9yPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oc3RhdGU6IFMsIHNhdmVkRWRpdG9yOiBTYXZlZEVkaXRvcikge1xuICBpZiAoIXNhdmVkRWRpdG9yKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWRpdG9yOiB7XG4gICAgICAuLi5zdGF0ZS5lZGl0b3IsXG4gICAgICBmZWF0dXJlczogWy4uLnN0YXRlLmVkaXRvci5mZWF0dXJlcywgLi4uKHNhdmVkRWRpdG9yLmZlYXR1cmVzIHx8IFtdKV0sXG4gICAgICAvLyBpZiBzYXZlZEVkaXRvci52aXNpYmxlIGlzIHVuZGVmaW5lZCBrZWVwIHN0YXRlLmVkaXRvci52aXNpYmxlXG4gICAgICB2aXNpYmxlOiBzYXZlZEVkaXRvci52aXNpYmxlID8/IHN0YXRlLmVkaXRvci52aXNpYmxlXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHNhdmVkIGxheWVyIGNvbmZpZyB3aXRoIG5ldyBkYXRhLFxuICogdXBkYXRlIGZpZWxkSWR4IGJhc2VkIG9uIG5ldyBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGF0YXNldHNCeU9yZGVyKHN0YXRlOiBWaXNTdGF0ZSwgbmV3RGF0YUVudHJpZXM6IERhdGFzZXRzKTogRGF0YXNldHMge1xuICBjb25zdCBtZXJnZWQgPSB7XG4gICAgLi4uc3RhdGUuZGF0YXNldHMsXG4gICAgLi4ubmV3RGF0YUVudHJpZXNcbiAgfTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZS5wcmVzZXJ2ZURhdGFzZXRPcmRlcikpIHtcbiAgICAvLyBwcmVzZXJ2ZURhdGFzZXRPcmRlciAgbWlnaHQgbm90IGluY2x1ZGUgdGhlICBuZXcgZGF0YXNldHNcbiAgICBjb25zdCBuZXdEYXRhc2V0SWRzID0gT2JqZWN0LmtleXMobWVyZ2VkKS5maWx0ZXIoXG4gICAgICBpZCA9PiAhc3RhdGUucHJlc2VydmVEYXRhc2V0T3JkZXI/LmluY2x1ZGVzKGlkKVxuICAgICk7XG4gICAgcmV0dXJuIFsuLi5zdGF0ZS5wcmVzZXJ2ZURhdGFzZXRPcmRlciwgLi4ubmV3RGF0YXNldElkc10ucmVkdWNlKFxuICAgICAgKGFjY3UsIGRhdGFJZCkgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgLi4uKG1lcmdlZFtkYXRhSWRdID8ge1tkYXRhSWRdOiBtZXJnZWRbZGF0YUlkXX0gOiB7fSlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZXhwb3J0IGNvbnN0IFZJU19TVEFURV9NRVJHRVJTOiBWaXNTdGF0ZU1lcmdlcnM8YW55PiA9IFtcbiAge1xuICAgIG1lcmdlOiBtZXJnZUxheWVycyxcbiAgICBwcm9wOiAnbGF5ZXJzJyxcbiAgICB0b01lcmdlUHJvcDogJ2xheWVyVG9CZU1lcmdlZCcsXG4gICAgcHJlc2VydmVPcmRlcjogJ3ByZXNlcnZlTGF5ZXJPcmRlcidcbiAgfSxcbiAge1xuICAgIG1lcmdlOiBtZXJnZUZpbHRlcnMsXG4gICAgcHJvcDogJ2ZpbHRlcnMnLFxuICAgIHRvTWVyZ2VQcm9wOiAnZmlsdGVyVG9CZU1lcmdlZCcsXG4gICAgcHJlc2VydmVPcmRlcjogJ3ByZXNlcnZlRmlsdGVyT3JkZXInLFxuICAgIHJlcGxhY2VQYXJlbnREYXRhc2V0SWRzOiByZXBsYWNlRmlsdGVyRGF0YXNldElkc1xuICB9LFxuICB7XG4gICAgbWVyZ2U6IG1lcmdlRWZmZWN0cyxcbiAgICBwcm9wOiAnZWZmZWN0cydcbiAgfSxcbiAge1xuICAgIG1lcmdlOiBtZXJnZUludGVyYWN0aW9ucyxcbiAgICBwcm9wOiAnaW50ZXJhY3Rpb25Db25maWcnLFxuICAgIHRvTWVyZ2VQcm9wOiAnaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkJyxcbiAgICByZXBsYWNlUGFyZW50RGF0YXNldElkczogcmVwbGFjZUludGVyYWN0aW9uRGF0YXNldElkcyxcbiAgICBzYXZlVW5tZXJnZWQ6IHNhdmVkVW5tZXJnZWRJbnRlcmFjdGlvblxuICB9LFxuICB7bWVyZ2U6IG1lcmdlTGF5ZXJCbGVuZGluZywgcHJvcDogJ2xheWVyQmxlbmRpbmcnfSxcbiAge21lcmdlOiBtZXJnZU92ZXJsYXlCbGVuZGluZywgcHJvcDogJ292ZXJsYXlCbGVuZGluZyd9LFxuICB7bWVyZ2U6IG1lcmdlU3BsaXRNYXBzLCBwcm9wOiAnc3BsaXRNYXBzJywgdG9NZXJnZVByb3A6ICdzcGxpdE1hcHNUb0JlTWVyZ2VkJ30sXG4gIHttZXJnZTogbWVyZ2VBbmltYXRpb25Db25maWcsIHByb3A6ICdhbmltYXRpb25Db25maWcnfSxcbiAge21lcmdlOiBtZXJnZUVkaXRvciwgcHJvcDogJ2VkaXRvcid9XG5dO1xuIl19