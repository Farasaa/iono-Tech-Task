"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.FILE_CONFLICT_MSG = exports.KEPLER_FORMAT = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _upload = _interopRequireDefault(require("./upload"));

// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
var NAME = 'cloud-provider';
var DISPLAY_NAME = 'Cloud Provider';
var THUMBNAIL = {
  width: 300,
  height: 200
};
var ICON = _upload["default"];
var KEPLER_FORMAT = 'keplergl';
exports.KEPLER_FORMAT = KEPLER_FORMAT;
var FILE_CONFLICT_MSG = 'file_conflict';
/**
 * The default provider class
 * @param {object} props
 * @param {string} props.name
 * @param {string} props.displayName
 * @param {React.Component} props.icon - React element
 * @param {object} props.thumbnail - thumbnail size object
 * @param {number} props.thumbnail.width - thumbnail width in pixels
 * @param {number} props.thumbnail.height - thumbnail height in pixels
 * @public
 * @example
 *
 * const myProvider = new Provider({
 *  name: 'foo',
 *  displayName: 'Foo Storage'
 *  icon: Icon,
 *  thumbnail: {width: 300, height: 200}
 * })
 */

exports.FILE_CONFLICT_MSG = FILE_CONFLICT_MSG;

var Provider = /*#__PURE__*/function () {
  function Provider(props) {
    (0, _classCallCheck2["default"])(this, Provider);
    (0, _defineProperty2["default"])(this, "name", void 0);
    (0, _defineProperty2["default"])(this, "displayName", void 0);
    (0, _defineProperty2["default"])(this, "icon", void 0);
    (0, _defineProperty2["default"])(this, "thumbnail", void 0);
    (0, _defineProperty2["default"])(this, "isNew", false);
    this.name = props.name || NAME;
    this.displayName = props.displayName || DISPLAY_NAME;
    this.icon = props.icon || ICON;
    this.thumbnail = props.thumbnail || THUMBNAIL;
  }
  /**
   * Whether this provider support upload map to a private storage. If truthy, user will be displayed with the storage save icon on the top right of the side bar.
   * @returns
   * @public
   */


  (0, _createClass2["default"])(Provider, [{
    key: "hasPrivateStorage",
    value: function hasPrivateStorage() {
      return true;
    }
    /**
     * Whether this provider support share map via a public url, if truthy, user will be displayed with a share map via url under the export map option on the top right of the side bar
     * @returns
     * @public
     */

  }, {
    key: "hasSharingUrl",
    value: function hasSharingUrl() {
      return false;
    }
    /**
     * This method is called after user share a map, to display the share url.
     * @param fullUrl - Whether to return the full url with domain, or just the location
     * @returns shareUrl
     * @public
     */

  }, {
    key: "getShareUrl",
    value: function getShareUrl() {
      var fullUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return '';
    }
    /**
     * This method is called by kepler.gl demo app to pushes a new location to history, becoming the current location.
     * @returns mapUrl
     * @public
     */

  }, {
    key: "getMapUrl",
    value: function getMapUrl(loadParams) {
      return '';
    }
    /**
     * This method is called to determine whether user already logged in to this provider
     * @public
     * @returns {Promise<string>} return the access token if a user already logged in
     */

  }, {
    key: "getAccessToken",
    value: function () {
      var _getAccessToken = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.reject('You must implement getAccessToken'));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function getAccessToken() {
        return _getAccessToken.apply(this, arguments);
      }

      return getAccessToken;
    }()
    /**
     * This method is called to get the user name of the current user. It will be displayed in the cloud provider tile.
     * @public
     * @deprecated please use getUser
     * @returns true if a user already logged in
     */

  }, {
    key: "getUserName",
    value: function getUserName() {
      return '';
    }
    /**
     * return a Promise with the user object
     */

  }, {
    key: "getUser",
    value: function () {
      var _getUser = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", Promise.reject('You must implement getUser'));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function getUser() {
        return _getUser.apply(this, arguments);
      }

      return getUser;
    }()
    /**
     * This return a standard error that will trigger the overwrite map modal
     */

  }, {
    key: "getFileConflictError",
    value: function getFileConflictError() {
      return new Error(FILE_CONFLICT_MSG);
    }
    /**
     * This method will be called when user click the login button in the cloud provider tile.
     * Upon login success and return the user Object {name, email, abbreviated}
     * @public
     */

  }, {
    key: "login",
    value: function () {
      var _login = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", Promise.reject(new Error('you must implement the `login` method')));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function login() {
        return _login.apply(this, arguments);
      }

      return login;
    }()
    /**
     * This method will be called when user click the logout button under the cloud provider tile.
     * Upon login success
     * @public
     */

  }, {
    key: "logout",
    value: function () {
      var _logout = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", Promise.reject(new Error('you must implement the `logout` method')));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
    /**
     * This method will be called to upload map for saving and sharing. Kepler.gl will package map data, config, title, description and thumbnail for upload to storage.
     * With the option to overwrite already saved map, and upload as private or public map.
     *
     * @param {Object} param
     * @param {Object} param.mapData - the map object
     * @param {Object} param.mapData.map - {datasets. config, info: {title, description}}
     * @param {Blob} param.mapData.thumbnail - A thumbnail of current map. thumbnail size can be defined by provider by this.thumbnail
     * @param {object} [param.options]
     * @param {boolean} [param.options.overwrite] - whether user choose to overwrite already saved map under the same name
     * @param {boolean} [param.options.isPublic] - whether user wish to share the map with others. if isPublic is truthy, kepler will call this.getShareUrl() to display an URL they can share with others
     * @public
     */

  }, {
    key: "uploadMap",
    value: function () {
      var _uploadMap = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(_ref) {
        var mapData, _ref$options, options;

        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                mapData = _ref.mapData, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options;
                return _context5.abrupt("return", Promise.reject('You must implement uploadMap'));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function uploadMap(_x) {
        return _uploadMap.apply(this, arguments);
      }

      return uploadMap;
    }()
    /**
     * This method is called to get a list of maps saved by the current logged in user.
     * @returns visualizations an array of Viz objects
     * @public
     * @example
     *  async listMaps() {
     *    return [
     *      {
     *        id: 'a',
     *        title: 'My map',
     *        description: 'My first kepler map',
     *        imageUrl: 'http://',
     *        updatedAt: 1582677787000,
     *        privateMap: false,
     *        loadParams: {}
     *      }
     *    ];
     *  }
     */

  }, {
    key: "listMaps",
    value: function () {
      var _listMaps = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", []);

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function listMaps() {
        return _listMaps.apply(this, arguments);
      }

      return listMaps;
    }()
    /**
     * This method will be called when user select a map to load from the storage map viewer
     * @param {*} loadParams - the loadParams property of each visualization object
     * @returns mapResponse - the map object containing dataset config info and format option
     * @public
     * @example
     * async downloadMap(loadParams) {
     *  const mockResponse = {
     *    map: {
     *      datasets: [],
     *      config: {},
     *      info: {
     *        app: 'kepler.gl',
     *        created_at: ''
     *        title: 'test map',
     *        description: 'Hello this is my test dropbox map'
     *      }
     *    },
     *    // pass csv here if your provider currently only support save / load file as csv
     *    format: 'keplergl'
     *  };
     *
     *  return downloadMap;
     * }
     */

  }, {
    key: "downloadMap",
    value: function () {
      var _downloadMap = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(loadParams) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", Promise.reject('You must implement downloadMap'));

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function downloadMap(_x2) {
        return _downloadMap.apply(this, arguments);
      }

      return downloadMap;
    }()
    /**
     * @return {string} return the storage location url for the current provider
     * @public
     */

  }, {
    key: "getManagementUrl",
    value: function getManagementUrl() {
      throw new Error('You must implement getManagementUrl');
    }
    /**
     * @typedef {Object} Viz
     * @property {string} id - An unique id
     * @property {string} title - The title of the map
     * @property {string} description - The description of the map
     * @property {string} imageUrl - The imageUrl of the map
     * @property {number} updatedAt - An epoch timestamp in milliseconds
     * @property {boolean} privateMap - Optional, whether if this map is private to the user, or can be accessed by others via URL
     * @property {*} loadParams - A property to be passed to `downloadMap`
     * @public
     */

    /**
     * The returned object of `downloadMap`. The response object should contain: datasets: [], config: {}, and info: {}
     * each dataset object should be {info: {id, label}, data: {...}}
     * to inform how kepler should process your data object, pass in `format`
     * @typedef {Object} MapResponse
     * @property {Object} map
     * @property {Array<Object>} map.datasets
     * @property {Object} map.config
     * @property {Object} map.info
     * @property {string} format - one of 'csv': csv file string, 'geojson': geojson object, 'row': row object, 'keplergl': datasets array saved using KeplerGlSchema.save
     * @public
     */

  }]);
  return Provider;
}();

exports["default"] = Provider;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm92aWRlci50cyJdLCJuYW1lcyI6WyJOQU1FIiwiRElTUExBWV9OQU1FIiwiVEhVTUJOQUlMIiwid2lkdGgiLCJoZWlnaHQiLCJJQ09OIiwiVXBsb2FkIiwiS0VQTEVSX0ZPUk1BVCIsIkZJTEVfQ09ORkxJQ1RfTVNHIiwiUHJvdmlkZXIiLCJwcm9wcyIsIm5hbWUiLCJkaXNwbGF5TmFtZSIsImljb24iLCJ0aHVtYm5haWwiLCJmdWxsVXJsIiwibG9hZFBhcmFtcyIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsIm1hcERhdGEiLCJvcHRpb25zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7O0FBSEE7QUFDQTtBQTRDQSxJQUFNQSxJQUFJLEdBQUcsZ0JBQWI7QUFDQSxJQUFNQyxZQUFZLEdBQUcsZ0JBQXJCO0FBQ0EsSUFBTUMsU0FBUyxHQUFHO0FBQUNDLEVBQUFBLEtBQUssRUFBRSxHQUFSO0FBQWFDLEVBQUFBLE1BQU0sRUFBRTtBQUFyQixDQUFsQjtBQUNBLElBQU1DLElBQUksR0FBR0Msa0JBQWI7QUFDTyxJQUFNQyxhQUFhLEdBQUcsVUFBdEI7O0FBQ0EsSUFBTUMsaUJBQWlCLEdBQUcsZUFBMUI7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztJQUNxQkMsUTtBQU9uQixvQkFBWUMsS0FBWixFQUFrQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvREFGakIsS0FFaUI7QUFDaEMsU0FBS0MsSUFBTCxHQUFZRCxLQUFLLENBQUNDLElBQU4sSUFBY1gsSUFBMUI7QUFDQSxTQUFLWSxXQUFMLEdBQW1CRixLQUFLLENBQUNFLFdBQU4sSUFBcUJYLFlBQXhDO0FBQ0EsU0FBS1ksSUFBTCxHQUFZSCxLQUFLLENBQUNHLElBQU4sSUFBY1IsSUFBMUI7QUFDQSxTQUFLUyxTQUFM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V0FDRSw0QkFBMkI7QUFDekIsWUFBTSxJQUFJQyxLQUFKLENBQVUscUNBQVYsQ0FBTjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgVXBsb2FkIGZyb20gJy4vdXBsb2FkJztcbmltcG9ydCB7TWFwRGF0YSwgRXhwb3J0RmlsZU9wdGlvbnMsIE1pbGxpc2Vjb25kLCBTYXZlZE1hcH0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0NvbXBvbmVudFR5cGV9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IHR5cGUgTWFwSXRlbUxvYWRQYXJhbXMgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIHBhdGg6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIE1hcExpc3RJdGVtID0ge1xuICBpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBsb2FkUGFyYW1zOiBhbnk7XG4gIGltYWdlVXJsPzogc3RyaW5nO1xuICB1cGRhdGVkQXQ/OiBNaWxsaXNlY29uZDtcbiAgcHJpdmF0ZU1hcD86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBDbG91ZFVzZXIgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgdGh1bWJuYWlsPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgVGh1bWJuYWlsID0ge1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFByb3ZpZGVyUHJvcHMgPSB7XG4gIG5hbWU/OiBzdHJpbmc7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICBpY29uPzogQ29tcG9uZW50VHlwZTxJY29uUHJvcHM+O1xuICB0aHVtYm5haWw/OiBUaHVtYm5haWw7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEljb25Qcm9wcyB7XG4gIGhlaWdodD86IHN0cmluZztcbiAgd2lkdGg/OiBzdHJpbmc7XG59XG5cbmNvbnN0IE5BTUUgPSAnY2xvdWQtcHJvdmlkZXInO1xuY29uc3QgRElTUExBWV9OQU1FID0gJ0Nsb3VkIFByb3ZpZGVyJztcbmNvbnN0IFRIVU1CTkFJTCA9IHt3aWR0aDogMzAwLCBoZWlnaHQ6IDIwMH07XG5jb25zdCBJQ09OID0gVXBsb2FkO1xuZXhwb3J0IGNvbnN0IEtFUExFUl9GT1JNQVQgPSAna2VwbGVyZ2wnO1xuZXhwb3J0IGNvbnN0IEZJTEVfQ09ORkxJQ1RfTVNHID0gJ2ZpbGVfY29uZmxpY3QnO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHByb3ZpZGVyIGNsYXNzXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5uYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuZGlzcGxheU5hbWVcbiAqIEBwYXJhbSB7UmVhY3QuQ29tcG9uZW50fSBwcm9wcy5pY29uIC0gUmVhY3QgZWxlbWVudFxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzLnRodW1ibmFpbCAtIHRodW1ibmFpbCBzaXplIG9iamVjdFxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLnRodW1ibmFpbC53aWR0aCAtIHRodW1ibmFpbCB3aWR0aCBpbiBwaXhlbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy50aHVtYm5haWwuaGVpZ2h0IC0gdGh1bWJuYWlsIGhlaWdodCBpbiBwaXhlbHNcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgbXlQcm92aWRlciA9IG5ldyBQcm92aWRlcih7XG4gKiAgbmFtZTogJ2ZvbycsXG4gKiAgZGlzcGxheU5hbWU6ICdGb28gU3RvcmFnZSdcbiAqICBpY29uOiBJY29uLFxuICogIHRodW1ibmFpbDoge3dpZHRoOiAzMDAsIGhlaWdodDogMjAwfVxuICogfSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvdmlkZXIge1xuICBuYW1lOiBzdHJpbmc7XG4gIGRpc3BsYXlOYW1lOiBzdHJpbmc7XG4gIGljb246IENvbXBvbmVudFR5cGU8SWNvblByb3BzPjtcbiAgdGh1bWJuYWlsOiBUaHVtYm5haWw7XG4gIGlzTmV3OiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3ZpZGVyUHJvcHMpIHtcbiAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lIHx8IE5BTUU7XG4gICAgdGhpcy5kaXNwbGF5TmFtZSA9IHByb3BzLmRpc3BsYXlOYW1lIHx8IERJU1BMQVlfTkFNRTtcbiAgICB0aGlzLmljb24gPSBwcm9wcy5pY29uIHx8IElDT047XG4gICAgdGhpcy50aHVtYm5haWwgPSBwcm9wcy50aHVtYm5haWwgfHwgVEhVTUJOQUlMO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBwcm92aWRlciBzdXBwb3J0IHVwbG9hZCBtYXAgdG8gYSBwcml2YXRlIHN0b3JhZ2UuIElmIHRydXRoeSwgdXNlciB3aWxsIGJlIGRpc3BsYXllZCB3aXRoIHRoZSBzdG9yYWdlIHNhdmUgaWNvbiBvbiB0aGUgdG9wIHJpZ2h0IG9mIHRoZSBzaWRlIGJhci5cbiAgICogQHJldHVybnNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFzUHJpdmF0ZVN0b3JhZ2UoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIHByb3ZpZGVyIHN1cHBvcnQgc2hhcmUgbWFwIHZpYSBhIHB1YmxpYyB1cmwsIGlmIHRydXRoeSwgdXNlciB3aWxsIGJlIGRpc3BsYXllZCB3aXRoIGEgc2hhcmUgbWFwIHZpYSB1cmwgdW5kZXIgdGhlIGV4cG9ydCBtYXAgb3B0aW9uIG9uIHRoZSB0b3AgcmlnaHQgb2YgdGhlIHNpZGUgYmFyXG4gICAqIEByZXR1cm5zXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGhhc1NoYXJpbmdVcmwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBhZnRlciB1c2VyIHNoYXJlIGEgbWFwLCB0byBkaXNwbGF5IHRoZSBzaGFyZSB1cmwuXG4gICAqIEBwYXJhbSBmdWxsVXJsIC0gV2hldGhlciB0byByZXR1cm4gdGhlIGZ1bGwgdXJsIHdpdGggZG9tYWluLCBvciBqdXN0IHRoZSBsb2NhdGlvblxuICAgKiBAcmV0dXJucyBzaGFyZVVybFxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRTaGFyZVVybChmdWxsVXJsOiBib29sZWFuID0gZmFsc2UpOiBzdHJpbmcge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkga2VwbGVyLmdsIGRlbW8gYXBwIHRvIHB1c2hlcyBhIG5ldyBsb2NhdGlvbiB0byBoaXN0b3J5LCBiZWNvbWluZyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAgICogQHJldHVybnMgbWFwVXJsXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldE1hcFVybChsb2FkUGFyYW1zOiBNYXBJdGVtTG9hZFBhcmFtcyk6IHN0cmluZyB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0byBkZXRlcm1pbmUgd2hldGhlciB1c2VyIGFscmVhZHkgbG9nZ2VkIGluIHRvIHRoaXMgcHJvdmlkZXJcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSByZXR1cm4gdGhlIGFjY2VzcyB0b2tlbiBpZiBhIHVzZXIgYWxyZWFkeSBsb2dnZWQgaW5cbiAgICovXG4gIGFzeW5jIGdldEFjY2Vzc1Rva2VuKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnWW91IG11c3QgaW1wbGVtZW50IGdldEFjY2Vzc1Rva2VuJyk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHRvIGdldCB0aGUgdXNlciBuYW1lIG9mIHRoZSBjdXJyZW50IHVzZXIuIEl0IHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSBjbG91ZCBwcm92aWRlciB0aWxlLlxuICAgKiBAcHVibGljXG4gICAqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgZ2V0VXNlclxuICAgKiBAcmV0dXJucyB0cnVlIGlmIGEgdXNlciBhbHJlYWR5IGxvZ2dlZCBpblxuICAgKi9cbiAgZ2V0VXNlck5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIGEgUHJvbWlzZSB3aXRoIHRoZSB1c2VyIG9iamVjdFxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlcigpOiBQcm9taXNlPENsb3VkVXNlciB8IG51bGw+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1lvdSBtdXN0IGltcGxlbWVudCBnZXRVc2VyJyk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyByZXR1cm4gYSBzdGFuZGFyZCBlcnJvciB0aGF0IHdpbGwgdHJpZ2dlciB0aGUgb3ZlcndyaXRlIG1hcCBtb2RhbFxuICAgKi9cbiAgZ2V0RmlsZUNvbmZsaWN0RXJyb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihGSUxFX0NPTkZMSUNUX01TRyk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgd2hlbiB1c2VyIGNsaWNrIHRoZSBsb2dpbiBidXR0b24gaW4gdGhlIGNsb3VkIHByb3ZpZGVyIHRpbGUuXG4gICAqIFVwb24gbG9naW4gc3VjY2VzcyBhbmQgcmV0dXJuIHRoZSB1c2VyIE9iamVjdCB7bmFtZSwgZW1haWwsIGFiYnJldmlhdGVkfVxuICAgKiBAcHVibGljXG4gICAqL1xuICBhc3luYyBsb2dpbigpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd5b3UgbXVzdCBpbXBsZW1lbnQgdGhlIGBsb2dpbmAgbWV0aG9kJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHdoZW4gdXNlciBjbGljayB0aGUgbG9nb3V0IGJ1dHRvbiB1bmRlciB0aGUgY2xvdWQgcHJvdmlkZXIgdGlsZS5cbiAgICogVXBvbiBsb2dpbiBzdWNjZXNzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFzeW5jIGxvZ291dCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd5b3UgbXVzdCBpbXBsZW1lbnQgdGhlIGBsb2dvdXRgIG1ldGhvZCcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB0byB1cGxvYWQgbWFwIGZvciBzYXZpbmcgYW5kIHNoYXJpbmcuIEtlcGxlci5nbCB3aWxsIHBhY2thZ2UgbWFwIGRhdGEsIGNvbmZpZywgdGl0bGUsIGRlc2NyaXB0aW9uIGFuZCB0aHVtYm5haWwgZm9yIHVwbG9hZCB0byBzdG9yYWdlLlxuICAgKiBXaXRoIHRoZSBvcHRpb24gdG8gb3ZlcndyaXRlIGFscmVhZHkgc2F2ZWQgbWFwLCBhbmQgdXBsb2FkIGFzIHByaXZhdGUgb3IgcHVibGljIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbS5tYXBEYXRhIC0gdGhlIG1hcCBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtLm1hcERhdGEubWFwIC0ge2RhdGFzZXRzLiBjb25maWcsIGluZm86IHt0aXRsZSwgZGVzY3JpcHRpb259fVxuICAgKiBAcGFyYW0ge0Jsb2J9IHBhcmFtLm1hcERhdGEudGh1bWJuYWlsIC0gQSB0aHVtYm5haWwgb2YgY3VycmVudCBtYXAuIHRodW1ibmFpbCBzaXplIGNhbiBiZSBkZWZpbmVkIGJ5IHByb3ZpZGVyIGJ5IHRoaXMudGh1bWJuYWlsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW0ub3B0aW9uc11cbiAgICogQHBhcmFtIHtib29sZWFufSBbcGFyYW0ub3B0aW9ucy5vdmVyd3JpdGVdIC0gd2hldGhlciB1c2VyIGNob29zZSB0byBvdmVyd3JpdGUgYWxyZWFkeSBzYXZlZCBtYXAgdW5kZXIgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbS5vcHRpb25zLmlzUHVibGljXSAtIHdoZXRoZXIgdXNlciB3aXNoIHRvIHNoYXJlIHRoZSBtYXAgd2l0aCBvdGhlcnMuIGlmIGlzUHVibGljIGlzIHRydXRoeSwga2VwbGVyIHdpbGwgY2FsbCB0aGlzLmdldFNoYXJlVXJsKCkgdG8gZGlzcGxheSBhbiBVUkwgdGhleSBjYW4gc2hhcmUgd2l0aCBvdGhlcnNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYXN5bmMgdXBsb2FkTWFwKHtcbiAgICBtYXBEYXRhLFxuICAgIG9wdGlvbnMgPSB7fVxuICB9OiB7XG4gICAgbWFwRGF0YTogTWFwRGF0YTtcbiAgICBvcHRpb25zOiBFeHBvcnRGaWxlT3B0aW9ucztcbiAgfSk6IFByb21pc2U8TWFwTGlzdEl0ZW0+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1lvdSBtdXN0IGltcGxlbWVudCB1cGxvYWRNYXAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdG8gZ2V0IGEgbGlzdCBvZiBtYXBzIHNhdmVkIGJ5IHRoZSBjdXJyZW50IGxvZ2dlZCBpbiB1c2VyLlxuICAgKiBAcmV0dXJucyB2aXN1YWxpemF0aW9ucyBhbiBhcnJheSBvZiBWaXogb2JqZWN0c1xuICAgKiBAcHVibGljXG4gICAqIEBleGFtcGxlXG4gICAqICBhc3luYyBsaXN0TWFwcygpIHtcbiAgICogICAgcmV0dXJuIFtcbiAgICogICAgICB7XG4gICAqICAgICAgICBpZDogJ2EnLFxuICAgKiAgICAgICAgdGl0bGU6ICdNeSBtYXAnLFxuICAgKiAgICAgICAgZGVzY3JpcHRpb246ICdNeSBmaXJzdCBrZXBsZXIgbWFwJyxcbiAgICogICAgICAgIGltYWdlVXJsOiAnaHR0cDovLycsXG4gICAqICAgICAgICB1cGRhdGVkQXQ6IDE1ODI2Nzc3ODcwMDAsXG4gICAqICAgICAgICBwcml2YXRlTWFwOiBmYWxzZSxcbiAgICogICAgICAgIGxvYWRQYXJhbXM6IHt9XG4gICAqICAgICAgfVxuICAgKiAgICBdO1xuICAgKiAgfVxuICAgKi9cbiAgYXN5bmMgbGlzdE1hcHMoKTogUHJvbWlzZTxNYXBMaXN0SXRlbVtdPiB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHdoZW4gdXNlciBzZWxlY3QgYSBtYXAgdG8gbG9hZCBmcm9tIHRoZSBzdG9yYWdlIG1hcCB2aWV3ZXJcbiAgICogQHBhcmFtIHsqfSBsb2FkUGFyYW1zIC0gdGhlIGxvYWRQYXJhbXMgcHJvcGVydHkgb2YgZWFjaCB2aXN1YWxpemF0aW9uIG9iamVjdFxuICAgKiBAcmV0dXJucyBtYXBSZXNwb25zZSAtIHRoZSBtYXAgb2JqZWN0IGNvbnRhaW5pbmcgZGF0YXNldCBjb25maWcgaW5mbyBhbmQgZm9ybWF0IG9wdGlvblxuICAgKiBAcHVibGljXG4gICAqIEBleGFtcGxlXG4gICAqIGFzeW5jIGRvd25sb2FkTWFwKGxvYWRQYXJhbXMpIHtcbiAgICogIGNvbnN0IG1vY2tSZXNwb25zZSA9IHtcbiAgICogICAgbWFwOiB7XG4gICAqICAgICAgZGF0YXNldHM6IFtdLFxuICAgKiAgICAgIGNvbmZpZzoge30sXG4gICAqICAgICAgaW5mbzoge1xuICAgKiAgICAgICAgYXBwOiAna2VwbGVyLmdsJyxcbiAgICogICAgICAgIGNyZWF0ZWRfYXQ6ICcnXG4gICAqICAgICAgICB0aXRsZTogJ3Rlc3QgbWFwJyxcbiAgICogICAgICAgIGRlc2NyaXB0aW9uOiAnSGVsbG8gdGhpcyBpcyBteSB0ZXN0IGRyb3Bib3ggbWFwJ1xuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgLy8gcGFzcyBjc3YgaGVyZSBpZiB5b3VyIHByb3ZpZGVyIGN1cnJlbnRseSBvbmx5IHN1cHBvcnQgc2F2ZSAvIGxvYWQgZmlsZSBhcyBjc3ZcbiAgICogICAgZm9ybWF0OiAna2VwbGVyZ2wnXG4gICAqICB9O1xuICAgKlxuICAgKiAgcmV0dXJuIGRvd25sb2FkTWFwO1xuICAgKiB9XG4gICAqL1xuICBhc3luYyBkb3dubG9hZE1hcChsb2FkUGFyYW1zKTogUHJvbWlzZTx7bWFwOiBTYXZlZE1hcDsgZm9ybWF0OiBzdHJpbmd9PiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdZb3UgbXVzdCBpbXBsZW1lbnQgZG93bmxvYWRNYXAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJldHVybiB0aGUgc3RvcmFnZSBsb2NhdGlvbiB1cmwgZm9yIHRoZSBjdXJyZW50IHByb3ZpZGVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldE1hbmFnZW1lbnRVcmwoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGltcGxlbWVudCBnZXRNYW5hZ2VtZW50VXJsJyk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gVml6XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIEFuIHVuaXF1ZSBpZFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGl0bGUgLSBUaGUgdGl0bGUgb2YgdGhlIG1hcFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIG1hcFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gaW1hZ2VVcmwgLSBUaGUgaW1hZ2VVcmwgb2YgdGhlIG1hcFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gdXBkYXRlZEF0IC0gQW4gZXBvY2ggdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHByaXZhdGVNYXAgLSBPcHRpb25hbCwgd2hldGhlciBpZiB0aGlzIG1hcCBpcyBwcml2YXRlIHRvIHRoZSB1c2VyLCBvciBjYW4gYmUgYWNjZXNzZWQgYnkgb3RoZXJzIHZpYSBVUkxcbiAgICogQHByb3BlcnR5IHsqfSBsb2FkUGFyYW1zIC0gQSBwcm9wZXJ0eSB0byBiZSBwYXNzZWQgdG8gYGRvd25sb2FkTWFwYFxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJuZWQgb2JqZWN0IG9mIGBkb3dubG9hZE1hcGAuIFRoZSByZXNwb25zZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW46IGRhdGFzZXRzOiBbXSwgY29uZmlnOiB7fSwgYW5kIGluZm86IHt9XG4gICAqIGVhY2ggZGF0YXNldCBvYmplY3Qgc2hvdWxkIGJlIHtpbmZvOiB7aWQsIGxhYmVsfSwgZGF0YTogey4uLn19XG4gICAqIHRvIGluZm9ybSBob3cga2VwbGVyIHNob3VsZCBwcm9jZXNzIHlvdXIgZGF0YSBvYmplY3QsIHBhc3MgaW4gYGZvcm1hdGBcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWFwUmVzcG9uc2VcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IG1hcFxuICAgKiBAcHJvcGVydHkge0FycmF5PE9iamVjdD59IG1hcC5kYXRhc2V0c1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gbWFwLmNvbmZpZ1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gbWFwLmluZm9cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGZvcm1hdCAtIG9uZSBvZiAnY3N2JzogY3N2IGZpbGUgc3RyaW5nLCAnZ2VvanNvbic6IGdlb2pzb24gb2JqZWN0LCAncm93Jzogcm93IG9iamVjdCwgJ2tlcGxlcmdsJzogZGF0YXNldHMgYXJyYXkgc2F2ZWQgdXNpbmcgS2VwbGVyR2xTY2hlbWEuc2F2ZVxuICAgKiBAcHVibGljXG4gICAqL1xufVxuIl19