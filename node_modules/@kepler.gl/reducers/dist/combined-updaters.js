"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceDataInMapUpdater = exports.toggleSplitMapUpdater = exports.combinedLayerTypeChangeUpdater = exports.combinedMapStyleChangeUpdater = exports.addDataToMapComposed = exports.loadFilesSuccessUpdater = exports.addDataToMapUpdater = exports.defaultAddDataToMapOptions = exports.isValidConfig = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _uiStateUpdaters = require("./ui-state-updaters");

var _visStateUpdaters = require("./vis-state-updaters");

var _mapStateUpdaters = require("./map-state-updaters");

var _mapStyleUpdaters = require("./map-style-updaters");

var _processors = require("@kepler.gl/processors");

var _composerHelpers = require("./composer-helpers");

var _utils = require("@kepler.gl/utils");

var _dataUtils = require("./data-utils");

var _constants = require("@kepler.gl/constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// compose action to apply result multiple reducers, with the output of one

/**
 * Some actions will affect the entire kepler.lg instance state.
 * The updaters for these actions is exported as `combinedUpdaters`. These updater take the entire instance state
 * as the first argument. Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {combinedUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // add data to map after receiving data from remote sources
 *    case 'LOAD_REMOTE_RESOURCE_SUCCESS':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          // pass in kepler.gl instance state to combinedUpdaters
 *          map:  combinedUpdaters.addDataToMapUpdater(
 *           state.keplerGl.map,
 *           {
 *             payload: {
 *               datasets: action.datasets,
 *               options: {readOnly: true},
 *               config: action.config
 *              }
 *            }
 *          )
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */
// @ts-ignore
var combinedUpdaters = null;
/* eslint-enable no-unused-vars */

var isValidConfig = function isValidConfig(config) {
  return (0, _utils.isPlainObject)(config) && (0, _utils.isPlainObject)(config.config) && config.version;
};

exports.isValidConfig = isValidConfig;
var defaultAddDataToMapOptions = {
  centerMap: true,
  keepExistingConfig: false,
  autoCreateLayers: true,
  autoCreateTooltips: true
};
/**
 * Combine data and full configuration update in a single action
 *
 * @memberof combinedUpdaters
 * @param {Object} state kepler.gl instance state, containing all subreducer state
 * @param {Object} action
 * @param {Object} action.payload `{datasets, options, config}`
 * @param action.payload.datasets - ***required** datasets can be a dataset or an array of datasets
 * Each dataset object needs to have `info` and `data` property.
 * @param [action.payload.options] option object `{centerMap: true}`
 * @param [action.payload.config] map config
 * @param [action.payload.info] map info contains title and description
 * @returns nextState
 *
 * @typedef {Object} Dataset
 * @property info -info of a dataset
 * @property info.id - id of this dataset. If config is defined, `id` should matches the `dataId` in config.
 * @property info.label - A display name of this dataset
 * @property data - ***required** The data object, in a tabular format with 2 properties `fields` and `rows`
 * @property data.fields - ***required** Array of fields,
 * @property data.fields.name - ***required** Name of the field,
 * @property data.rows - ***required** Array of rows, in a tabular format with `fields` and `rows`
 *
 * @public
 */

exports.defaultAddDataToMapOptions = defaultAddDataToMapOptions;

var addDataToMapUpdater = function addDataToMapUpdater(state, _ref) {
  var _datasets$, _datasets$2, _datasets$3;

  var payload = _ref.payload;
  var datasets = payload.datasets,
      config = payload.config,
      info = payload.info;

  var options = _objectSpread(_objectSpread({}, defaultAddDataToMapOptions), payload.options); // check if progresive loading dataset by bataches, and update visState directly


  var isProgressiveLoading = Array.isArray(datasets) && ((_datasets$ = datasets[0]) === null || _datasets$ === void 0 ? void 0 : _datasets$.info.format) === 'arrow' && ((_datasets$2 = datasets[0]) === null || _datasets$2 === void 0 ? void 0 : _datasets$2.info.id) && ((_datasets$3 = datasets[0]) === null || _datasets$3 === void 0 ? void 0 : _datasets$3.info.id) in state.visState.datasets;

  if (isProgressiveLoading) {
    return (0, _composerHelpers.compose_)([(0, _composerHelpers.pick_)('visState')((0, _composerHelpers.apply_)(_visStateUpdaters.updateVisDataUpdater, {
      datasets: datasets,
      options: options,
      config: config
    }))])(state);
  } // @ts-expect-error


  var parsedConfig = config;

  if (isValidConfig(config)) {
    // if passed in saved config
    // @ts-expect-error
    parsedConfig = state.visState.schema.parseSavedConfig(config);
  }

  var oldLayers = state.visState.layers;

  var filterNewlyAddedLayers = function filterNewlyAddedLayers(layers) {
    return layers.filter(function (nl) {
      return !oldLayers.find(function (ol) {
        return ol === nl;
      });
    });
  }; // Returns undefined if not found, to make typescript happy


  var findMapBoundsIfCentered = function findMapBoundsIfCentered(layers) {
    var bounds = options.centerMap && (0, _dataUtils.findMapBounds)(layers);
    return bounds ? bounds : undefined;
  };

  return (0, _composerHelpers.compose_)([(0, _composerHelpers.pick_)('visState')((0, _composerHelpers.apply_)(_visStateUpdaters.updateVisDataUpdater, {
    datasets: datasets,
    options: options,
    config: parsedConfig
  })), (0, _composerHelpers.if_)(Boolean(info), (0, _composerHelpers.pick_)('visState')((0, _composerHelpers.apply_)(_visStateUpdaters.setMapInfoUpdater, {
    info: info
  }))), (0, _composerHelpers.with_)(function (_ref2) {
    var visState = _ref2.visState;
    return (0, _composerHelpers.pick_)('mapState')((0, _composerHelpers.apply_)(_mapStateUpdaters.receiveMapConfigUpdater, (0, _composerHelpers.payload_)({
      config: parsedConfig,
      options: options,
      bounds: findMapBoundsIfCentered(filterNewlyAddedLayers(visState.layers))
    })));
  }), (0, _composerHelpers.pick_)('mapStyle')((0, _composerHelpers.apply_)(_mapStyleUpdaters.receiveMapConfigUpdater, (0, _composerHelpers.payload_)({
    config: parsedConfig,
    options: options
  }))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.apply_)(_uiStateUpdaters.loadFilesSuccessUpdater, (0, _composerHelpers.payload_)(null))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.apply_)(_uiStateUpdaters.toggleModalUpdater, (0, _composerHelpers.payload_)(null))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.merge_)(options.hasOwnProperty('readOnly') ? {
    readOnly: options.readOnly
  } : {}))])(state);
};

exports.addDataToMapUpdater = addDataToMapUpdater;

var loadFilesSuccessUpdater = function loadFilesSuccessUpdater(state, action) {
  // still more to load
  var payloads = (0, _processors.filesToDataPayload)(action.result);
  var nextState = (0, _composerHelpers.compose_)([(0, _composerHelpers.pick_)('visState')((0, _composerHelpers.merge_)({
    fileLoading: false,
    fileLoadingProgress: {}
  }))])(state); // make multiple add data to map calls

  var stateWithData = (0, _composerHelpers.compose_)(payloads.map(function (p) {
    return (0, _composerHelpers.apply_)(addDataToMapUpdater, (0, _composerHelpers.payload_)(p));
  }))(nextState);
  return stateWithData;
};

exports.loadFilesSuccessUpdater = loadFilesSuccessUpdater;
var addDataToMapComposed = addDataToMapUpdater;
/**
 * Helper which updates map overlay blending mode in visState,
 * but only if it's not currently in the `normal` mode.
 */

exports.addDataToMapComposed = addDataToMapComposed;

var updateOverlayBlending = function updateOverlayBlending(overlayBlending) {
  return function (visState) {
    if (visState.overlayBlending !== _constants.OVERLAY_BLENDINGS.normal.value) {
      return _objectSpread(_objectSpread({}, visState), {}, {
        overlayBlending: overlayBlending
      });
    }

    return visState;
  };
};
/**
 * Helper which updates `darkBaseMapEnabled` in all the layers in visState which
 * have this config setting (or in one specific layer if the `layerId` param is provided).
 */


var updateDarkBaseMapLayers = function updateDarkBaseMapLayers(darkBaseMapEnabled) {
  var layerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (visState) {
    return _objectSpread(_objectSpread({}, visState), {}, {
      layers: visState.layers.map(function (layer) {
        if (!layerId || layer.id === layerId) {
          if (layer.visConfigSettings.hasOwnProperty('darkBaseMapEnabled')) {
            var visConfig = layer.config.visConfig;
            return layer.updateLayerConfig({
              visConfig: _objectSpread(_objectSpread({}, visConfig), {}, {
                darkBaseMapEnabled: darkBaseMapEnabled
              })
            });
          }
        }

        return layer;
      })
    });
  };
};
/**
 * Updater that changes the map style by calling mapStyleChangeUpdater on visState.
 * In addition to that, it does the following:
 *
 *   1. Update map overlay blending mode in accordance with the colorMode of the
 *      base map, but only if it's not in the `normal` mode.
 *
 *   2. Update all the layers which have the `darkBaseMapEnabled` config setting
 *      adjusting it in accordance with the colorMode of the base map.
 *
 */


var combinedMapStyleChangeUpdater = function combinedMapStyleChangeUpdater(state, action) {
  var payload = action.payload;
  var mapStyle = state.mapStyle;

  var getColorMode = function getColorMode(key) {
    var _mapStyle$mapStyles$k;

    return (_mapStyle$mapStyles$k = mapStyle.mapStyles[key]) === null || _mapStyle$mapStyles$k === void 0 ? void 0 : _mapStyle$mapStyles$k.colorMode;
  };

  var prevColorMode = getColorMode(mapStyle.styleType);
  var nextColorMode = getColorMode(payload.styleType);
  var visState = state.visState;

  if (nextColorMode !== prevColorMode) {
    switch (nextColorMode) {
      case _constants.BASE_MAP_COLOR_MODES.DARK:
        visState = (0, _composerHelpers.compose_)([updateOverlayBlending(_constants.OVERLAY_BLENDINGS.screen.value), updateDarkBaseMapLayers(true)])(visState);
        break;

      case _constants.BASE_MAP_COLOR_MODES.LIGHT:
        visState = (0, _composerHelpers.compose_)([updateOverlayBlending(_constants.OVERLAY_BLENDINGS.darken.value), updateDarkBaseMapLayers(false)])(visState);
        break;

      default: // do nothing

    }
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    visState: visState,
    mapStyle: (0, _mapStyleUpdaters.mapStyleChangeUpdater)(mapStyle, {
      payload: _objectSpread({}, payload)
    })
  });
};
/**
 * Updater that changes the layer type by calling `layerTypeChangeUpdater` on visState.
 * In addition to that, if the new layer type has the `darkBaseMapEnabled` config
 * setting, we adjust it in accordance with the colorMode of the base map.s
 */


exports.combinedMapStyleChangeUpdater = combinedMapStyleChangeUpdater;

var combinedLayerTypeChangeUpdater = function combinedLayerTypeChangeUpdater(state, action) {
  var visState = state.visState;
  var oldLayerIndex = visState.layers.findIndex(function (layer) {
    return layer === action.oldLayer;
  });
  visState = (0, _visStateUpdaters.layerTypeChangeUpdater)(visState, action);
  var newLayer = visState.layers[oldLayerIndex];

  if (newLayer !== null && newLayer !== void 0 && newLayer.visConfigSettings.hasOwnProperty('darkBaseMapEnabled')) {
    var mapStyle = state.mapStyle;
    var colorMode = mapStyle.mapStyles[mapStyle.styleType].colorMode;
    var darkBaseMapEnabled = newLayer.config.visConfig.darkBaseMapEnabled;

    switch (colorMode) {
      case _constants.BASE_MAP_COLOR_MODES.DARK:
        if (!darkBaseMapEnabled) {
          visState = updateDarkBaseMapLayers(true, newLayer.id)(visState);
        }

        break;

      case _constants.BASE_MAP_COLOR_MODES.LIGHT:
        if (darkBaseMapEnabled) {
          visState = updateDarkBaseMapLayers(false, newLayer.id)(visState);
        }

        break;

      default: // do nothing

    }
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    visState: visState
  });
};
/**
 * Make mapLegend active when toggleSplitMap action is called
 */


exports.combinedLayerTypeChangeUpdater = combinedLayerTypeChangeUpdater;

var toggleSplitMapUpdater = function toggleSplitMapUpdater(state, action) {
  var _newState$uiState$map, _newState$uiState$map2;

  var newState = _objectSpread(_objectSpread({}, state), {}, {
    visState: (0, _visStateUpdaters.toggleSplitMapUpdater)(state.visState, action),
    uiState: (0, _uiStateUpdaters.toggleSplitMapUpdater)(state.uiState),
    mapState: (0, _mapStateUpdaters.toggleSplitMapUpdater)(state.mapState, action)
  });

  var isSplit = newState.visState.splitMaps.length !== 0;
  var isLegendActive = (_newState$uiState$map = newState.uiState.mapControls) === null || _newState$uiState$map === void 0 ? void 0 : (_newState$uiState$map2 = _newState$uiState$map.mapLegend) === null || _newState$uiState$map2 === void 0 ? void 0 : _newState$uiState$map2.active;

  if (isSplit && !isLegendActive) {
    newState.uiState = (0, _uiStateUpdaters.toggleMapControlUpdater)(newState.uiState, {
      payload: {
        panelId: 'mapLegend',
        index: action.payload
      }
    });
  }

  return newState;
};

exports.toggleSplitMapUpdater = toggleSplitMapUpdater;
var defaultReplaceDataToMapOptions = {
  keepExistingConfig: true,
  centerMap: true,
  autoCreateLayers: false
};
/**
 * Updater replace a dataset in state
 */

var replaceDataInMapUpdater = function replaceDataInMapUpdater(state, _ref3) {
  var payload = _ref3.payload;
  var datasetToReplaceId = payload.datasetToReplaceId,
      datasetToUse = payload.datasetToUse,
      _payload$options = payload.options,
      options = _payload$options === void 0 ? {} : _payload$options;

  var addDataToMapOptions = _objectSpread(_objectSpread({}, defaultReplaceDataToMapOptions), options); // check if dataset is there


  if (!state.visState.datasets[datasetToReplaceId]) {
    return state;
  } // datasetToUse is ProtoDataset


  var dataIdToUse = datasetToUse.info.id;

  if (!dataIdToUse) {
    return state;
  } // remove dataset and put dependencies in toBeMerged


  var preparedState = _objectSpread(_objectSpread({}, state), {}, {
    visState: (0, _visStateUpdaters.prepareStateForDatasetReplace)(state.visState, datasetToReplaceId, dataIdToUse)
  });

  var nextState = addDataToMapUpdater(preparedState, (0, _composerHelpers.payload_)({
    datasets: datasetToUse,
    // should zoom to new dataset
    options: addDataToMapOptions
  }));
  return nextState;
};

exports.replaceDataInMapUpdater = replaceDataInMapUpdater;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21iaW5lZC11cGRhdGVycy50cyJdLCJuYW1lcyI6WyJjb21iaW5lZFVwZGF0ZXJzIiwiaXNWYWxpZENvbmZpZyIsImNvbmZpZyIsInZlcnNpb24iLCJkZWZhdWx0QWRkRGF0YVRvTWFwT3B0aW9ucyIsImNlbnRlck1hcCIsImtlZXBFeGlzdGluZ0NvbmZpZyIsImF1dG9DcmVhdGVMYXllcnMiLCJhdXRvQ3JlYXRlVG9vbHRpcHMiLCJhZGREYXRhVG9NYXBVcGRhdGVyIiwic3RhdGUiLCJwYXlsb2FkIiwiZGF0YXNldHMiLCJpbmZvIiwib3B0aW9ucyIsImlzUHJvZ3Jlc3NpdmVMb2FkaW5nIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9ybWF0IiwiaWQiLCJ2aXNTdGF0ZSIsInZpc1N0YXRlVXBkYXRlVmlzRGF0YVVwZGF0ZXIiLCJwYXJzZWRDb25maWciLCJzY2hlbWEiLCJwYXJzZVNhdmVkQ29uZmlnIiwib2xkTGF5ZXJzIiwibGF5ZXJzIiwiZmlsdGVyTmV3bHlBZGRlZExheWVycyIsImZpbHRlciIsIm5sIiwiZmluZCIsIm9sIiwiZmluZE1hcEJvdW5kc0lmQ2VudGVyZWQiLCJib3VuZHMiLCJ1bmRlZmluZWQiLCJCb29sZWFuIiwic2V0TWFwSW5mb1VwZGF0ZXIiLCJzdGF0ZU1hcENvbmZpZ1VwZGF0ZXIiLCJzdHlsZU1hcENvbmZpZ1VwZGF0ZXIiLCJ1aVN0YXRlTG9hZEZpbGVzU3VjY2Vzc1VwZGF0ZXIiLCJ0b2dnbGVNb2RhbFVwZGF0ZXIiLCJoYXNPd25Qcm9wZXJ0eSIsInJlYWRPbmx5IiwibG9hZEZpbGVzU3VjY2Vzc1VwZGF0ZXIiLCJhY3Rpb24iLCJwYXlsb2FkcyIsInJlc3VsdCIsIm5leHRTdGF0ZSIsImZpbGVMb2FkaW5nIiwiZmlsZUxvYWRpbmdQcm9ncmVzcyIsInN0YXRlV2l0aERhdGEiLCJtYXAiLCJwIiwiYWRkRGF0YVRvTWFwQ29tcG9zZWQiLCJ1cGRhdGVPdmVybGF5QmxlbmRpbmciLCJvdmVybGF5QmxlbmRpbmciLCJPVkVSTEFZX0JMRU5ESU5HUyIsIm5vcm1hbCIsInZhbHVlIiwidXBkYXRlRGFya0Jhc2VNYXBMYXllcnMiLCJkYXJrQmFzZU1hcEVuYWJsZWQiLCJsYXllcklkIiwibGF5ZXIiLCJ2aXNDb25maWdTZXR0aW5ncyIsInZpc0NvbmZpZyIsInVwZGF0ZUxheWVyQ29uZmlnIiwiY29tYmluZWRNYXBTdHlsZUNoYW5nZVVwZGF0ZXIiLCJtYXBTdHlsZSIsImdldENvbG9yTW9kZSIsImtleSIsIm1hcFN0eWxlcyIsImNvbG9yTW9kZSIsInByZXZDb2xvck1vZGUiLCJzdHlsZVR5cGUiLCJuZXh0Q29sb3JNb2RlIiwiQkFTRV9NQVBfQ09MT1JfTU9ERVMiLCJEQVJLIiwic2NyZWVuIiwiTElHSFQiLCJkYXJrZW4iLCJjb21iaW5lZExheWVyVHlwZUNoYW5nZVVwZGF0ZXIiLCJvbGRMYXllckluZGV4IiwiZmluZEluZGV4Iiwib2xkTGF5ZXIiLCJuZXdMYXllciIsInRvZ2dsZVNwbGl0TWFwVXBkYXRlciIsIm5ld1N0YXRlIiwidWlTdGF0ZSIsIm1hcFN0YXRlIiwiaXNTcGxpdCIsInNwbGl0TWFwcyIsImxlbmd0aCIsImlzTGVnZW5kQWN0aXZlIiwibWFwQ29udHJvbHMiLCJtYXBMZWdlbmQiLCJhY3RpdmUiLCJwYW5lbElkIiwiaW5kZXgiLCJkZWZhdWx0UmVwbGFjZURhdGFUb01hcE9wdGlvbnMiLCJyZXBsYWNlRGF0YUluTWFwVXBkYXRlciIsImRhdGFzZXRUb1JlcGxhY2VJZCIsImRhdGFzZXRUb1VzZSIsImFkZERhdGFUb01hcE9wdGlvbnMiLCJkYXRhSWRUb1VzZSIsInByZXBhcmVkU3RhdGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBR0E7O0FBTUE7O0FBT0E7O0FBSUE7O0FBSUE7O0FBQ0E7O0FBYUE7O0FBQ0E7O0FBQ0E7Ozs7OztBQVVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LCtCQUFTO0FBQ1A1RixJQUFBQSxRQUFRLEVBQUV5RixZQURIO0FBRVA7QUFDQXZGLElBQUFBLE9BQU8sRUFBRXdGO0FBSEYsR0FBVCxDQUZtQyxDQUFyQztBQVNBLFNBQU92RCxTQUFQO0FBQ0QsQ0FoQ00iLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQge1xuICB0b2dnbGVNb2RhbFVwZGF0ZXIsXG4gIGxvYWRGaWxlc1N1Y2Nlc3NVcGRhdGVyIGFzIHVpU3RhdGVMb2FkRmlsZXNTdWNjZXNzVXBkYXRlcixcbiAgdG9nZ2xlTWFwQ29udHJvbFVwZGF0ZXIsXG4gIHRvZ2dsZVNwbGl0TWFwVXBkYXRlciBhcyB1aVN0YXRlVG9nZ2xlU3BsaXRNYXBVcGRhdGVyXG59IGZyb20gJy4vdWktc3RhdGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtcbiAgdXBkYXRlVmlzRGF0YVVwZGF0ZXIgYXMgdmlzU3RhdGVVcGRhdGVWaXNEYXRhVXBkYXRlcixcbiAgc2V0TWFwSW5mb1VwZGF0ZXIsXG4gIGxheWVyVHlwZUNoYW5nZVVwZGF0ZXIsXG4gIHRvZ2dsZVNwbGl0TWFwVXBkYXRlciBhcyB2aXNTdGF0ZVRvZ2dsZVNwbGl0TWFwVXBkYXRlcixcbiAgcHJlcGFyZVN0YXRlRm9yRGF0YXNldFJlcGxhY2Vcbn0gZnJvbSAnLi92aXMtc3RhdGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtcbiAgcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIgYXMgc3RhdGVNYXBDb25maWdVcGRhdGVyLFxuICB0b2dnbGVTcGxpdE1hcFVwZGF0ZXIgYXMgbWFwU3RhdGVUb2dnbGVTcGxpdE1hcFVwZGF0ZXJcbn0gZnJvbSAnLi9tYXAtc3RhdGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtcbiAgbWFwU3R5bGVDaGFuZ2VVcGRhdGVyLFxuICByZWNlaXZlTWFwQ29uZmlnVXBkYXRlciBhcyBzdHlsZU1hcENvbmZpZ1VwZGF0ZXJcbn0gZnJvbSAnLi9tYXAtc3R5bGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtmaWxlc1RvRGF0YVBheWxvYWR9IGZyb20gJ0BrZXBsZXIuZ2wvcHJvY2Vzc29ycyc7XG5pbXBvcnQge3BheWxvYWRfLCBhcHBseV8sIHdpdGhfLCBpZl8sIGNvbXBvc2VfLCBtZXJnZV8sIHBpY2tffSBmcm9tICcuL2NvbXBvc2VyLWhlbHBlcnMnO1xuaW1wb3J0IHtNYXBTdGF0ZSwgVWlTdGF0ZSwgQWRkRGF0YVRvTWFwUGF5bG9hZCwgUGFyc2VkQ29uZmlnfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7TWFwU3R5bGV9IGZyb20gJy4vbWFwLXN0eWxlLXVwZGF0ZXJzJztcbmltcG9ydCB7UHJvdmlkZXJTdGF0ZX0gZnJvbSAnLi9wcm92aWRlci1zdGF0ZS11cGRhdGVycyc7XG5pbXBvcnQge1xuICBsb2FkRmlsZXNTdWNjZXNzVXBkYXRlckFjdGlvbixcbiAgTWFwU3R5bGVDaGFuZ2VVcGRhdGVyQWN0aW9uLFxuICBMYXllclR5cGVDaGFuZ2VVcGRhdGVyQWN0aW9uLFxuICBUb2dnbGVTcGxpdE1hcFVwZGF0ZXJBY3Rpb24sXG4gIFJlcGxhY2VEYXRhSW5NYXBQYXlsb2FkXG59IGZyb20gJ0BrZXBsZXIuZ2wvYWN0aW9ucyc7XG5pbXBvcnQge1Zpc1N0YXRlfSBmcm9tICdAa2VwbGVyLmdsL3NjaGVtYXMnO1xuaW1wb3J0IHtMYXllcn0gZnJvbSAnQGtlcGxlci5nbC9sYXllcnMnO1xuaW1wb3J0IHtpc1BsYWluT2JqZWN0fSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7ZmluZE1hcEJvdW5kc30gZnJvbSAnLi9kYXRhLXV0aWxzJztcbmltcG9ydCB7QkFTRV9NQVBfQ09MT1JfTU9ERVMsIE9WRVJMQVlfQkxFTkRJTkdTfSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5cbmV4cG9ydCB0eXBlIEtlcGxlckdsU3RhdGUgPSB7XG4gIHZpc1N0YXRlOiBWaXNTdGF0ZTtcbiAgbWFwU3RhdGU6IE1hcFN0YXRlO1xuICBtYXBTdHlsZTogTWFwU3R5bGU7XG4gIHVpU3RhdGU6IFVpU3RhdGU7XG4gIHByb3ZpZGVyU3RhdGU6IFByb3ZpZGVyU3RhdGU7XG59O1xuXG4vLyBjb21wb3NlIGFjdGlvbiB0byBhcHBseSByZXN1bHQgbXVsdGlwbGUgcmVkdWNlcnMsIHdpdGggdGhlIG91dHB1dCBvZiBvbmVcblxuLyoqXG4gKiBTb21lIGFjdGlvbnMgd2lsbCBhZmZlY3QgdGhlIGVudGlyZSBrZXBsZXIubGcgaW5zdGFuY2Ugc3RhdGUuXG4gKiBUaGUgdXBkYXRlcnMgZm9yIHRoZXNlIGFjdGlvbnMgaXMgZXhwb3J0ZWQgYXMgYGNvbWJpbmVkVXBkYXRlcnNgLiBUaGVzZSB1cGRhdGVyIHRha2UgdGhlIGVudGlyZSBpbnN0YW5jZSBzdGF0ZVxuICogYXMgdGhlIGZpcnN0IGFyZ3VtZW50LiBSZWFkIG1vcmUgYWJvdXQgW1VzaW5nIHVwZGF0ZXJzXSguLi9hZHZhbmNlZC11c2FnZS91c2luZy11cGRhdGVycy5tZClcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IGtlcGxlckdsUmVkdWNlciwge2NvbWJpbmVkVXBkYXRlcnN9IGZyb20gJ2tlcGxlci5nbC9yZWR1Y2Vycyc7XG4gKiAvLyBSb290IFJlZHVjZXJcbiAqIGNvbnN0IHJlZHVjZXJzID0gY29tYmluZVJlZHVjZXJzKHtcbiAqICBrZXBsZXJHbDoga2VwbGVyR2xSZWR1Y2VyLFxuICogIGFwcDogYXBwUmVkdWNlclxuICogfSk7XG4gKlxuICogY29uc3QgY29tcG9zZWRSZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAqICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gKiAgICAvLyBhZGQgZGF0YSB0byBtYXAgYWZ0ZXIgcmVjZWl2aW5nIGRhdGEgZnJvbSByZW1vdGUgc291cmNlc1xuICogICAgY2FzZSAnTE9BRF9SRU1PVEVfUkVTT1VSQ0VfU1VDQ0VTUyc6XG4gKiAgICAgIHJldHVybiB7XG4gKiAgICAgICAgLi4uc3RhdGUsXG4gKiAgICAgICAga2VwbGVyR2w6IHtcbiAqICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLFxuICogICAgICAgICAgLy8gcGFzcyBpbiBrZXBsZXIuZ2wgaW5zdGFuY2Ugc3RhdGUgdG8gY29tYmluZWRVcGRhdGVyc1xuICogICAgICAgICAgbWFwOiAgY29tYmluZWRVcGRhdGVycy5hZGREYXRhVG9NYXBVcGRhdGVyKFxuICogICAgICAgICAgIHN0YXRlLmtlcGxlckdsLm1hcCxcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gKiAgICAgICAgICAgICAgIGRhdGFzZXRzOiBhY3Rpb24uZGF0YXNldHMsXG4gKiAgICAgICAgICAgICAgIG9wdGlvbnM6IHtyZWFkT25seTogdHJ1ZX0sXG4gKiAgICAgICAgICAgICAgIGNvbmZpZzogYWN0aW9uLmNvbmZpZ1xuICogICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgfVxuICogICAgICAgICAgKVxuICogICAgICAgIH1cbiAqICAgICAgfTtcbiAqICB9XG4gKiAgcmV0dXJuIHJlZHVjZXJzKHN0YXRlLCBhY3Rpb24pO1xuICogfTtcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjb21wb3NlZFJlZHVjZXI7XG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbWJpbmVkVXBkYXRlcnMgPSBudWxsO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG5leHBvcnQgY29uc3QgaXNWYWxpZENvbmZpZyA9IGNvbmZpZyA9PlxuICBpc1BsYWluT2JqZWN0KGNvbmZpZykgJiYgaXNQbGFpbk9iamVjdChjb25maWcuY29uZmlnKSAmJiBjb25maWcudmVyc2lvbjtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRBZGREYXRhVG9NYXBPcHRpb25zID0ge1xuICBjZW50ZXJNYXA6IHRydWUsXG4gIGtlZXBFeGlzdGluZ0NvbmZpZzogZmFsc2UsXG4gIGF1dG9DcmVhdGVMYXllcnM6IHRydWUsXG4gIGF1dG9DcmVhdGVUb29sdGlwczogdHJ1ZVxufTtcblxuLyoqXG4gKiBDb21iaW5lIGRhdGEgYW5kIGZ1bGwgY29uZmlndXJhdGlvbiB1cGRhdGUgaW4gYSBzaW5nbGUgYWN0aW9uXG4gKlxuICogQG1lbWJlcm9mIGNvbWJpbmVkVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBrZXBsZXIuZ2wgaW5zdGFuY2Ugc3RhdGUsIGNvbnRhaW5pbmcgYWxsIHN1YnJlZHVjZXIgc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ucGF5bG9hZCBge2RhdGFzZXRzLCBvcHRpb25zLCBjb25maWd9YFxuICogQHBhcmFtIGFjdGlvbi5wYXlsb2FkLmRhdGFzZXRzIC0gKioqcmVxdWlyZWQqKiBkYXRhc2V0cyBjYW4gYmUgYSBkYXRhc2V0IG9yIGFuIGFycmF5IG9mIGRhdGFzZXRzXG4gKiBFYWNoIGRhdGFzZXQgb2JqZWN0IG5lZWRzIHRvIGhhdmUgYGluZm9gIGFuZCBgZGF0YWAgcHJvcGVydHkuXG4gKiBAcGFyYW0gW2FjdGlvbi5wYXlsb2FkLm9wdGlvbnNdIG9wdGlvbiBvYmplY3QgYHtjZW50ZXJNYXA6IHRydWV9YFxuICogQHBhcmFtIFthY3Rpb24ucGF5bG9hZC5jb25maWddIG1hcCBjb25maWdcbiAqIEBwYXJhbSBbYWN0aW9uLnBheWxvYWQuaW5mb10gbWFwIGluZm8gY29udGFpbnMgdGl0bGUgYW5kIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEYXRhc2V0XG4gKiBAcHJvcGVydHkgaW5mbyAtaW5mbyBvZiBhIGRhdGFzZXRcbiAqIEBwcm9wZXJ0eSBpbmZvLmlkIC0gaWQgb2YgdGhpcyBkYXRhc2V0LiBJZiBjb25maWcgaXMgZGVmaW5lZCwgYGlkYCBzaG91bGQgbWF0Y2hlcyB0aGUgYGRhdGFJZGAgaW4gY29uZmlnLlxuICogQHByb3BlcnR5IGluZm8ubGFiZWwgLSBBIGRpc3BsYXkgbmFtZSBvZiB0aGlzIGRhdGFzZXRcbiAqIEBwcm9wZXJ0eSBkYXRhIC0gKioqcmVxdWlyZWQqKiBUaGUgZGF0YSBvYmplY3QsIGluIGEgdGFidWxhciBmb3JtYXQgd2l0aCAyIHByb3BlcnRpZXMgYGZpZWxkc2AgYW5kIGByb3dzYFxuICogQHByb3BlcnR5IGRhdGEuZmllbGRzIC0gKioqcmVxdWlyZWQqKiBBcnJheSBvZiBmaWVsZHMsXG4gKiBAcHJvcGVydHkgZGF0YS5maWVsZHMubmFtZSAtICoqKnJlcXVpcmVkKiogTmFtZSBvZiB0aGUgZmllbGQsXG4gKiBAcHJvcGVydHkgZGF0YS5yb3dzIC0gKioqcmVxdWlyZWQqKiBBcnJheSBvZiByb3dzLCBpbiBhIHRhYnVsYXIgZm9ybWF0IHdpdGggYGZpZWxkc2AgYW5kIGByb3dzYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZERhdGFUb01hcFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBLZXBsZXJHbFN0YXRlLFxuICB7cGF5bG9hZH06IHtwYXlsb2FkOiBBZGREYXRhVG9NYXBQYXlsb2FkfVxuKTogS2VwbGVyR2xTdGF0ZSA9PiB7XG4gIGNvbnN0IHtkYXRhc2V0cywgY29uZmlnLCBpbmZvfSA9IHBheWxvYWQ7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0QWRkRGF0YVRvTWFwT3B0aW9ucyxcbiAgICAuLi5wYXlsb2FkLm9wdGlvbnNcbiAgfTtcblxuICAvLyBjaGVjayBpZiBwcm9ncmVzaXZlIGxvYWRpbmcgZGF0YXNldCBieSBiYXRhY2hlcywgYW5kIHVwZGF0ZSB2aXNTdGF0ZSBkaXJlY3RseVxuICBjb25zdCBpc1Byb2dyZXNzaXZlTG9hZGluZyA9XG4gICAgQXJyYXkuaXNBcnJheShkYXRhc2V0cykgJiZcbiAgICBkYXRhc2V0c1swXT8uaW5mby5mb3JtYXQgPT09ICdhcnJvdycgJiZcbiAgICBkYXRhc2V0c1swXT8uaW5mby5pZCAmJlxuICAgIGRhdGFzZXRzWzBdPy5pbmZvLmlkIGluIHN0YXRlLnZpc1N0YXRlLmRhdGFzZXRzO1xuICBpZiAoaXNQcm9ncmVzc2l2ZUxvYWRpbmcpIHtcbiAgICByZXR1cm4gY29tcG9zZV88S2VwbGVyR2xTdGF0ZT4oW1xuICAgICAgcGlja18oJ3Zpc1N0YXRlJykoXG4gICAgICAgIGFwcGx5XzxWaXNTdGF0ZSwgYW55Pih2aXNTdGF0ZVVwZGF0ZVZpc0RhdGFVcGRhdGVyLCB7XG4gICAgICAgICAgZGF0YXNldHMsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBjb25maWdcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICBdKShzdGF0ZSk7XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGxldCBwYXJzZWRDb25maWc6IFBhcnNlZENvbmZpZyA9IGNvbmZpZztcblxuICBpZiAoaXNWYWxpZENvbmZpZyhjb25maWcpKSB7XG4gICAgLy8gaWYgcGFzc2VkIGluIHNhdmVkIGNvbmZpZ1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBwYXJzZWRDb25maWcgPSBzdGF0ZS52aXNTdGF0ZS5zY2hlbWEucGFyc2VTYXZlZENvbmZpZyhjb25maWcpO1xuICB9XG4gIGNvbnN0IG9sZExheWVycyA9IHN0YXRlLnZpc1N0YXRlLmxheWVycztcbiAgY29uc3QgZmlsdGVyTmV3bHlBZGRlZExheWVycyA9IChsYXllcnM6IExheWVyW10pID0+XG4gICAgbGF5ZXJzLmZpbHRlcihubCA9PiAhb2xkTGF5ZXJzLmZpbmQob2wgPT4gb2wgPT09IG5sKSk7XG5cbiAgLy8gUmV0dXJucyB1bmRlZmluZWQgaWYgbm90IGZvdW5kLCB0byBtYWtlIHR5cGVzY3JpcHQgaGFwcHlcbiAgY29uc3QgZmluZE1hcEJvdW5kc0lmQ2VudGVyZWQgPSAobGF5ZXJzOiBMYXllcltdKSA9PiB7XG4gICAgY29uc3QgYm91bmRzID0gb3B0aW9ucy5jZW50ZXJNYXAgJiYgZmluZE1hcEJvdW5kcyhsYXllcnMpO1xuICAgIHJldHVybiBib3VuZHMgPyBib3VuZHMgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcmV0dXJuIGNvbXBvc2VfPEtlcGxlckdsU3RhdGU+KFtcbiAgICBwaWNrXygndmlzU3RhdGUnKShcbiAgICAgIGFwcGx5XzxWaXNTdGF0ZSwgYW55Pih2aXNTdGF0ZVVwZGF0ZVZpc0RhdGFVcGRhdGVyLCB7XG4gICAgICAgIGRhdGFzZXRzLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBjb25maWc6IHBhcnNlZENvbmZpZ1xuICAgICAgfSlcbiAgICApLFxuXG4gICAgaWZfKFxuICAgICAgQm9vbGVhbihpbmZvKSxcbiAgICAgIHBpY2tfKCd2aXNTdGF0ZScpKFxuICAgICAgICBhcHBseV88VmlzU3RhdGUsIGFueT4oc2V0TWFwSW5mb1VwZGF0ZXIsIHtpbmZvfSlcbiAgICAgIClcbiAgICApLFxuICAgIHdpdGhfKCh7dmlzU3RhdGV9KSA9PlxuICAgICAgcGlja18oJ21hcFN0YXRlJykoXG4gICAgICAgIGFwcGx5XyhcbiAgICAgICAgICBzdGF0ZU1hcENvbmZpZ1VwZGF0ZXIsXG4gICAgICAgICAgcGF5bG9hZF8oe1xuICAgICAgICAgICAgY29uZmlnOiBwYXJzZWRDb25maWcsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgYm91bmRzOiBmaW5kTWFwQm91bmRzSWZDZW50ZXJlZChmaWx0ZXJOZXdseUFkZGVkTGF5ZXJzKHZpc1N0YXRlLmxheWVycykpXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICksXG4gICAgcGlja18oJ21hcFN0eWxlJykoYXBwbHlfKHN0eWxlTWFwQ29uZmlnVXBkYXRlciwgcGF5bG9hZF8oe2NvbmZpZzogcGFyc2VkQ29uZmlnLCBvcHRpb25zfSkpKSxcbiAgICBwaWNrXygndWlTdGF0ZScpKGFwcGx5Xyh1aVN0YXRlTG9hZEZpbGVzU3VjY2Vzc1VwZGF0ZXIsIHBheWxvYWRfKG51bGwpKSksXG4gICAgcGlja18oJ3VpU3RhdGUnKShhcHBseV8odG9nZ2xlTW9kYWxVcGRhdGVyLCBwYXlsb2FkXyhudWxsKSkpLFxuICAgIHBpY2tfKCd1aVN0YXRlJykobWVyZ2VfKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3JlYWRPbmx5JykgPyB7cmVhZE9ubHk6IG9wdGlvbnMucmVhZE9ubHl9IDoge30pKVxuICBdKShzdGF0ZSk7XG59O1xuXG5leHBvcnQgY29uc3QgbG9hZEZpbGVzU3VjY2Vzc1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBLZXBsZXJHbFN0YXRlLFxuICBhY3Rpb246IGxvYWRGaWxlc1N1Y2Nlc3NVcGRhdGVyQWN0aW9uXG4pOiBLZXBsZXJHbFN0YXRlID0+IHtcbiAgLy8gc3RpbGwgbW9yZSB0byBsb2FkXG4gIGNvbnN0IHBheWxvYWRzID0gZmlsZXNUb0RhdGFQYXlsb2FkKGFjdGlvbi5yZXN1bHQpO1xuICBjb25zdCBuZXh0U3RhdGUgPSBjb21wb3NlXyhbXG4gICAgcGlja18oJ3Zpc1N0YXRlJykoXG4gICAgICBtZXJnZV8oe1xuICAgICAgICBmaWxlTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGZpbGVMb2FkaW5nUHJvZ3Jlc3M6IHt9XG4gICAgICB9KVxuICAgIClcbiAgXSkoc3RhdGUpO1xuICAvLyBtYWtlIG11bHRpcGxlIGFkZCBkYXRhIHRvIG1hcCBjYWxsc1xuICBjb25zdCBzdGF0ZVdpdGhEYXRhID0gY29tcG9zZV8ocGF5bG9hZHMubWFwKHAgPT4gYXBwbHlfKGFkZERhdGFUb01hcFVwZGF0ZXIsIHBheWxvYWRfKHApKSkpKFxuICAgIG5leHRTdGF0ZVxuICApO1xuICByZXR1cm4gc3RhdGVXaXRoRGF0YSBhcyBLZXBsZXJHbFN0YXRlO1xufTtcblxuZXhwb3J0IGNvbnN0IGFkZERhdGFUb01hcENvbXBvc2VkID0gYWRkRGF0YVRvTWFwVXBkYXRlcjtcblxuLyoqXG4gKiBIZWxwZXIgd2hpY2ggdXBkYXRlcyBtYXAgb3ZlcmxheSBibGVuZGluZyBtb2RlIGluIHZpc1N0YXRlLFxuICogYnV0IG9ubHkgaWYgaXQncyBub3QgY3VycmVudGx5IGluIHRoZSBgbm9ybWFsYCBtb2RlLlxuICovXG5jb25zdCB1cGRhdGVPdmVybGF5QmxlbmRpbmcgPSBvdmVybGF5QmxlbmRpbmcgPT4gdmlzU3RhdGUgPT4ge1xuICBpZiAodmlzU3RhdGUub3ZlcmxheUJsZW5kaW5nICE9PSBPVkVSTEFZX0JMRU5ESU5HUy5ub3JtYWwudmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udmlzU3RhdGUsXG4gICAgICBvdmVybGF5QmxlbmRpbmdcbiAgICB9O1xuICB9XG4gIHJldHVybiB2aXNTdGF0ZTtcbn07XG5cbi8qKlxuICogSGVscGVyIHdoaWNoIHVwZGF0ZXMgYGRhcmtCYXNlTWFwRW5hYmxlZGAgaW4gYWxsIHRoZSBsYXllcnMgaW4gdmlzU3RhdGUgd2hpY2hcbiAqIGhhdmUgdGhpcyBjb25maWcgc2V0dGluZyAob3IgaW4gb25lIHNwZWNpZmljIGxheWVyIGlmIHRoZSBgbGF5ZXJJZGAgcGFyYW0gaXMgcHJvdmlkZWQpLlxuICovXG5jb25zdCB1cGRhdGVEYXJrQmFzZU1hcExheWVycyA9IChcbiAgZGFya0Jhc2VNYXBFbmFibGVkOiBib29sZWFuLFxuICBsYXllcklkOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuKSA9PiB2aXNTdGF0ZSA9PiAoe1xuICAuLi52aXNTdGF0ZSxcbiAgbGF5ZXJzOiB2aXNTdGF0ZS5sYXllcnMubWFwKGxheWVyID0+IHtcbiAgICBpZiAoIWxheWVySWQgfHwgbGF5ZXIuaWQgPT09IGxheWVySWQpIHtcbiAgICAgIGlmIChsYXllci52aXNDb25maWdTZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnZGFya0Jhc2VNYXBFbmFibGVkJykpIHtcbiAgICAgICAgY29uc3Qge3Zpc0NvbmZpZ30gPSBsYXllci5jb25maWc7XG4gICAgICAgIHJldHVybiBsYXllci51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgICAgICAgdmlzQ29uZmlnOiB7Li4udmlzQ29uZmlnLCBkYXJrQmFzZU1hcEVuYWJsZWR9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGF5ZXI7XG4gIH0pXG59KTtcblxuLyoqXG4gKiBVcGRhdGVyIHRoYXQgY2hhbmdlcyB0aGUgbWFwIHN0eWxlIGJ5IGNhbGxpbmcgbWFwU3R5bGVDaGFuZ2VVcGRhdGVyIG9uIHZpc1N0YXRlLlxuICogSW4gYWRkaXRpb24gdG8gdGhhdCwgaXQgZG9lcyB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAgMS4gVXBkYXRlIG1hcCBvdmVybGF5IGJsZW5kaW5nIG1vZGUgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBjb2xvck1vZGUgb2YgdGhlXG4gKiAgICAgIGJhc2UgbWFwLCBidXQgb25seSBpZiBpdCdzIG5vdCBpbiB0aGUgYG5vcm1hbGAgbW9kZS5cbiAqXG4gKiAgIDIuIFVwZGF0ZSBhbGwgdGhlIGxheWVycyB3aGljaCBoYXZlIHRoZSBgZGFya0Jhc2VNYXBFbmFibGVkYCBjb25maWcgc2V0dGluZ1xuICogICAgICBhZGp1c3RpbmcgaXQgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBjb2xvck1vZGUgb2YgdGhlIGJhc2UgbWFwLlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbWJpbmVkTWFwU3R5bGVDaGFuZ2VVcGRhdGVyID0gKFxuICBzdGF0ZTogS2VwbGVyR2xTdGF0ZSxcbiAgYWN0aW9uOiBNYXBTdHlsZUNoYW5nZVVwZGF0ZXJBY3Rpb25cbik6IEtlcGxlckdsU3RhdGUgPT4ge1xuICBjb25zdCB7cGF5bG9hZH0gPSBhY3Rpb247XG4gIGNvbnN0IHttYXBTdHlsZX0gPSBzdGF0ZTtcbiAgY29uc3QgZ2V0Q29sb3JNb2RlID0ga2V5ID0+IG1hcFN0eWxlLm1hcFN0eWxlc1trZXldPy5jb2xvck1vZGU7XG4gIGNvbnN0IHByZXZDb2xvck1vZGUgPSBnZXRDb2xvck1vZGUobWFwU3R5bGUuc3R5bGVUeXBlKTtcbiAgY29uc3QgbmV4dENvbG9yTW9kZSA9IGdldENvbG9yTW9kZShwYXlsb2FkLnN0eWxlVHlwZSk7XG4gIGxldCB7dmlzU3RhdGV9ID0gc3RhdGU7XG4gIGlmIChuZXh0Q29sb3JNb2RlICE9PSBwcmV2Q29sb3JNb2RlKSB7XG4gICAgc3dpdGNoIChuZXh0Q29sb3JNb2RlKSB7XG4gICAgICBjYXNlIEJBU0VfTUFQX0NPTE9SX01PREVTLkRBUks6XG4gICAgICAgIHZpc1N0YXRlID0gY29tcG9zZV8oW1xuICAgICAgICAgIHVwZGF0ZU92ZXJsYXlCbGVuZGluZyhPVkVSTEFZX0JMRU5ESU5HUy5zY3JlZW4udmFsdWUpLFxuICAgICAgICAgIHVwZGF0ZURhcmtCYXNlTWFwTGF5ZXJzKHRydWUpXG4gICAgICAgIF0pKHZpc1N0YXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJBU0VfTUFQX0NPTE9SX01PREVTLkxJR0hUOlxuICAgICAgICB2aXNTdGF0ZSA9IGNvbXBvc2VfKFtcbiAgICAgICAgICB1cGRhdGVPdmVybGF5QmxlbmRpbmcoT1ZFUkxBWV9CTEVORElOR1MuZGFya2VuLnZhbHVlKSxcbiAgICAgICAgICB1cGRhdGVEYXJrQmFzZU1hcExheWVycyhmYWxzZSlcbiAgICAgICAgXSkodmlzU3RhdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgdmlzU3RhdGUsXG4gICAgbWFwU3R5bGU6IG1hcFN0eWxlQ2hhbmdlVXBkYXRlcihtYXBTdHlsZSwge3BheWxvYWQ6IHsuLi5wYXlsb2FkfX0pXG4gIH07XG59O1xuXG4vKipcbiAqIFVwZGF0ZXIgdGhhdCBjaGFuZ2VzIHRoZSBsYXllciB0eXBlIGJ5IGNhbGxpbmcgYGxheWVyVHlwZUNoYW5nZVVwZGF0ZXJgIG9uIHZpc1N0YXRlLlxuICogSW4gYWRkaXRpb24gdG8gdGhhdCwgaWYgdGhlIG5ldyBsYXllciB0eXBlIGhhcyB0aGUgYGRhcmtCYXNlTWFwRW5hYmxlZGAgY29uZmlnXG4gKiBzZXR0aW5nLCB3ZSBhZGp1c3QgaXQgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBjb2xvck1vZGUgb2YgdGhlIGJhc2UgbWFwLnNcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbWJpbmVkTGF5ZXJUeXBlQ2hhbmdlVXBkYXRlciA9IChcbiAgc3RhdGU6IEtlcGxlckdsU3RhdGUsXG4gIGFjdGlvbjogTGF5ZXJUeXBlQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogS2VwbGVyR2xTdGF0ZSA9PiB7XG4gIGxldCB7dmlzU3RhdGV9ID0gc3RhdGU7XG4gIGNvbnN0IG9sZExheWVySW5kZXggPSB2aXNTdGF0ZS5sYXllcnMuZmluZEluZGV4KGxheWVyID0+IGxheWVyID09PSBhY3Rpb24ub2xkTGF5ZXIpO1xuICB2aXNTdGF0ZSA9IGxheWVyVHlwZUNoYW5nZVVwZGF0ZXIodmlzU3RhdGUsIGFjdGlvbik7XG4gIGNvbnN0IG5ld0xheWVyID0gdmlzU3RhdGUubGF5ZXJzW29sZExheWVySW5kZXhdO1xuICBpZiAobmV3TGF5ZXI/LnZpc0NvbmZpZ1NldHRpbmdzLmhhc093blByb3BlcnR5KCdkYXJrQmFzZU1hcEVuYWJsZWQnKSkge1xuICAgIGNvbnN0IHttYXBTdHlsZX0gPSBzdGF0ZTtcbiAgICBjb25zdCB7Y29sb3JNb2RlfSA9IG1hcFN0eWxlLm1hcFN0eWxlc1ttYXBTdHlsZS5zdHlsZVR5cGVdO1xuICAgIGNvbnN0IHtkYXJrQmFzZU1hcEVuYWJsZWR9ID0gbmV3TGF5ZXIuY29uZmlnLnZpc0NvbmZpZztcbiAgICBzd2l0Y2ggKGNvbG9yTW9kZSkge1xuICAgICAgY2FzZSBCQVNFX01BUF9DT0xPUl9NT0RFUy5EQVJLOlxuICAgICAgICBpZiAoIWRhcmtCYXNlTWFwRW5hYmxlZCkge1xuICAgICAgICAgIHZpc1N0YXRlID0gdXBkYXRlRGFya0Jhc2VNYXBMYXllcnModHJ1ZSwgbmV3TGF5ZXIuaWQpKHZpc1N0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQkFTRV9NQVBfQ09MT1JfTU9ERVMuTElHSFQ6XG4gICAgICAgIGlmIChkYXJrQmFzZU1hcEVuYWJsZWQpIHtcbiAgICAgICAgICB2aXNTdGF0ZSA9IHVwZGF0ZURhcmtCYXNlTWFwTGF5ZXJzKGZhbHNlLCBuZXdMYXllci5pZCkodmlzU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICB2aXNTdGF0ZVxuICB9O1xufTtcblxuLyoqXG4gKiBNYWtlIG1hcExlZ2VuZCBhY3RpdmUgd2hlbiB0b2dnbGVTcGxpdE1hcCBhY3Rpb24gaXMgY2FsbGVkXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVTcGxpdE1hcFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBLZXBsZXJHbFN0YXRlLFxuICBhY3Rpb246IFRvZ2dsZVNwbGl0TWFwVXBkYXRlckFjdGlvblxuKTogS2VwbGVyR2xTdGF0ZSA9PiB7XG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIHZpc1N0YXRlOiB2aXNTdGF0ZVRvZ2dsZVNwbGl0TWFwVXBkYXRlcihzdGF0ZS52aXNTdGF0ZSwgYWN0aW9uKSxcbiAgICB1aVN0YXRlOiB1aVN0YXRlVG9nZ2xlU3BsaXRNYXBVcGRhdGVyKHN0YXRlLnVpU3RhdGUpLFxuICAgIG1hcFN0YXRlOiBtYXBTdGF0ZVRvZ2dsZVNwbGl0TWFwVXBkYXRlcihzdGF0ZS5tYXBTdGF0ZSwgYWN0aW9uKVxuICB9O1xuXG4gIGNvbnN0IGlzU3BsaXQgPSBuZXdTdGF0ZS52aXNTdGF0ZS5zcGxpdE1hcHMubGVuZ3RoICE9PSAwO1xuICBjb25zdCBpc0xlZ2VuZEFjdGl2ZSA9IG5ld1N0YXRlLnVpU3RhdGUubWFwQ29udHJvbHM/Lm1hcExlZ2VuZD8uYWN0aXZlO1xuICBpZiAoaXNTcGxpdCAmJiAhaXNMZWdlbmRBY3RpdmUpIHtcbiAgICBuZXdTdGF0ZS51aVN0YXRlID0gdG9nZ2xlTWFwQ29udHJvbFVwZGF0ZXIobmV3U3RhdGUudWlTdGF0ZSwge1xuICAgICAgcGF5bG9hZDoge3BhbmVsSWQ6ICdtYXBMZWdlbmQnLCBpbmRleDogYWN0aW9uLnBheWxvYWR9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59O1xuXG5jb25zdCBkZWZhdWx0UmVwbGFjZURhdGFUb01hcE9wdGlvbnMgPSB7XG4gIGtlZXBFeGlzdGluZ0NvbmZpZzogdHJ1ZSxcbiAgY2VudGVyTWFwOiB0cnVlLFxuICBhdXRvQ3JlYXRlTGF5ZXJzOiBmYWxzZVxufTtcblxuLyoqXG4gKiBVcGRhdGVyIHJlcGxhY2UgYSBkYXRhc2V0IGluIHN0YXRlXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsYWNlRGF0YUluTWFwVXBkYXRlciA9IChcbiAgc3RhdGU6IEtlcGxlckdsU3RhdGUsXG4gIHtwYXlsb2FkfToge3BheWxvYWQ6IFJlcGxhY2VEYXRhSW5NYXBQYXlsb2FkfVxuKTogS2VwbGVyR2xTdGF0ZSA9PiB7XG4gIGNvbnN0IHtkYXRhc2V0VG9SZXBsYWNlSWQsIGRhdGFzZXRUb1VzZSwgb3B0aW9ucyA9IHt9fSA9IHBheWxvYWQ7XG4gIGNvbnN0IGFkZERhdGFUb01hcE9wdGlvbnMgPSB7Li4uZGVmYXVsdFJlcGxhY2VEYXRhVG9NYXBPcHRpb25zLCAuLi5vcHRpb25zfTtcblxuICAvLyBjaGVjayBpZiBkYXRhc2V0IGlzIHRoZXJlXG4gIGlmICghc3RhdGUudmlzU3RhdGUuZGF0YXNldHNbZGF0YXNldFRvUmVwbGFjZUlkXSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICAvLyBkYXRhc2V0VG9Vc2UgaXMgUHJvdG9EYXRhc2V0XG4gIGNvbnN0IGRhdGFJZFRvVXNlID0gZGF0YXNldFRvVXNlLmluZm8uaWQ7XG4gIGlmICghZGF0YUlkVG9Vc2UpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgLy8gcmVtb3ZlIGRhdGFzZXQgYW5kIHB1dCBkZXBlbmRlbmNpZXMgaW4gdG9CZU1lcmdlZFxuICBjb25zdCBwcmVwYXJlZFN0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIHZpc1N0YXRlOiBwcmVwYXJlU3RhdGVGb3JEYXRhc2V0UmVwbGFjZShzdGF0ZS52aXNTdGF0ZSwgZGF0YXNldFRvUmVwbGFjZUlkLCBkYXRhSWRUb1VzZSlcbiAgfTtcblxuICBjb25zdCBuZXh0U3RhdGUgPSBhZGREYXRhVG9NYXBVcGRhdGVyKFxuICAgIHByZXBhcmVkU3RhdGUsXG4gICAgcGF5bG9hZF8oe1xuICAgICAgZGF0YXNldHM6IGRhdGFzZXRUb1VzZSxcbiAgICAgIC8vIHNob3VsZCB6b29tIHRvIG5ldyBkYXRhc2V0XG4gICAgICBvcHRpb25zOiBhZGREYXRhVG9NYXBPcHRpb25zXG4gICAgfSlcbiAgKTtcblxuICByZXR1cm4gbmV4dFN0YXRlO1xufTtcbiJdfQ==