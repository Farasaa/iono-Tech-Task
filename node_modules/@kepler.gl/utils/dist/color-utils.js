"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hexToRgb = hexToRgb;
exports.isHexColor = isHexColor;
exports.rgbToHex = rgbToHex;
exports.getColorGroupByName = getColorGroupByName;
exports.reverseColorRange = reverseColorRange;
exports.createLinearGradient = createLinearGradient;
exports.colorMaybeToRGB = colorMaybeToRGB;
exports.isRgbColor = isRgbColor;
exports.normalizeColor = normalizeColor;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _d3Color = require("d3-color");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * get r g b from hex code
 *
 * @param hex
 * @returns array of r g bs
 */
function hexToRgb(hex) {
  var result = isHexColor(hex);

  if (!result) {
    return [0, 0, 0];
  }

  var r = parseInt(result[1], 16);
  var g = parseInt(result[2], 16);
  var b = parseInt(result[3], 16);
  return [r, g, b];
}

function isHexColor(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result;
}

function PadNum(c) {
  var hex = c.toString(16);
  return hex.length === 1 ? "0".concat(hex) : hex;
}
/**
 * get hex from r g b
 *
 * @param rgb
 * @returns hex string
 */


function rgbToHex(_ref) {
  var _ref2 = (0, _slicedToArray2["default"])(_ref, 3),
      r = _ref2[0],
      g = _ref2[1],
      b = _ref2[2];

  return "#".concat([r, g, b].map(function (n) {
    return PadNum(n);
  }).join('')).toUpperCase();
}
/**
 * Get color group name by parsing name, discard step in the name
 * e.g. Global Warming 6 -> Global Warming
 *
 * @param {Object} colorRange
 * @return {string | null}
 */


function getColorGroupByName(colorRange) {
  if (!colorRange || typeof colorRange.name !== 'string') {
    return null;
  }

  return colorRange.name.replace(/\b[^a-zA-Z]+$/, '');
}
/**
 * Get a reversed colorRange
 * @param reversed
 * @param colorRange
 */


function reverseColorRange(reversed, colorRange) {
  if (!colorRange) return null; // if (colorRange.reversed) return colorRange;

  return _objectSpread(_objectSpread({}, colorRange), {}, {
    reversed: reversed,
    colors: colorRange.colors.slice().reverse()
  });
}
/**
 * given a list of rgb arrays it will generate a linear gradient css rule
 * @param direction
 * @param colors
 * @return
 */


function createLinearGradient(direction, colors) {
  var step = parseFloat((100.0 / colors.length).toFixed(2));
  var bands = colors.map(function (rgb, index) {
    return "rgba(".concat(rgb.join(','), ", 1) ").concat(step * index, "%, rgba(").concat(rgb.join(','), ", 1) ").concat(step * (index + 1), "%");
  });
  return "linear-gradient(to ".concat(direction, ", ").concat(bands.join(','), ")");
}
/**
 * Convert color to RGB
 */


function colorMaybeToRGB(color) {
  if (isRgbColor(color)) {
    return color;
  }

  if (typeof color === 'string') {
    var rgbObj = (0, _d3Color.rgb)(color);

    if (Number.isFinite(rgbObj === null || rgbObj === void 0 ? void 0 : rgbObj.r) && Number.isFinite(rgbObj === null || rgbObj === void 0 ? void 0 : rgbObj.g) && Number.isFinite(rgbObj === null || rgbObj === void 0 ? void 0 : rgbObj.b)) {
      return [rgbObj.r, rgbObj.g, rgbObj.b];
    }
  }

  return null;
}
/**
 * Whether color is rgb
 * @returns
 */


function isRgbColor(color) {
  return Boolean(color && Array.isArray(color) && color.length === 3 && color.every(function (n) {
    return Number.isFinite(n) && n <= 255 && n >= 0;
  }));
}
/**
 * Take color values in 0-255 range and map to [0, 1]
 */


function normalizeColor(color) {
  return color.map(function (component) {
    return component / 255.0;
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb2xvci11dGlscy50cyJdLCJuYW1lcyI6WyJoZXhUb1JnYiIsImhleCIsInJlc3VsdCIsImlzSGV4Q29sb3IiLCJyIiwicGFyc2VJbnQiLCJnIiwiYiIsImV4ZWMiLCJQYWROdW0iLCJjIiwidG9TdHJpbmciLCJsZW5ndGgiLCJyZ2JUb0hleCIsIm1hcCIsIm4iLCJqb2luIiwidG9VcHBlckNhc2UiLCJnZXRDb2xvckdyb3VwQnlOYW1lIiwiY29sb3JSYW5nZSIsIm5hbWUiLCJyZXBsYWNlIiwicmV2ZXJzZUNvbG9yUmFuZ2UiLCJyZXZlcnNlZCIsImNvbG9ycyIsInNsaWNlIiwicmV2ZXJzZSIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiZGlyZWN0aW9uIiwic3RlcCIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwiYmFuZHMiLCJyZ2IiLCJpbmRleCIsImNvbG9yTWF5YmVUb1JHQiIsImNvbG9yIiwiaXNSZ2JDb2xvciIsInJnYk9iaiIsIk51bWJlciIsImlzRmluaXRlIiwiQm9vbGVhbiIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5Iiwibm9ybWFsaXplQ29sb3IiLCJjb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQSxRQUFULENBQWtCQyxHQUFsQixFQUF5QztBQUM5QyxNQUFNQyxNQUFNLEdBQUdDLFVBQVUsQ0FBQ0YsR0FBRCxDQUF6Qjs7QUFFQSxNQUFJLENBQUNDLE1BQUwsRUFBYTtBQUNYLFdBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBUDtBQUNEOztBQUVELE1BQU1FLENBQUMsR0FBR0MsUUFBUSxDQUFDSCxNQUFNLENBQUMsQ0FBRCxDQUFQLEVBQVksRUFBWixDQUFsQjtBQUNBLE1BQU1JLENBQUMsR0FBR0QsUUFBUSxDQUFDSCxNQUFNLENBQUMsQ0FBRCxDQUFQLEVBQVksRUFBWixDQUFs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ZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCB7cmdiIGFzIGQzUmdifSBmcm9tICdkMy1jb2xvcic7XG5pbXBvcnQge0NvbG9yUmFuZ2V9IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7SGV4Q29sb3IsIFJHQkNvbG9yfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcblxuLyoqXG4gKiBnZXQgciBnIGIgZnJvbSBoZXggY29kZVxuICpcbiAqIEBwYXJhbSBoZXhcbiAqIEByZXR1cm5zIGFycmF5IG9mIHIgZyBic1xuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9SZ2IoaGV4OiBzdHJpbmcpOiBSR0JDb2xvciB7XG4gIGNvbnN0IHJlc3VsdCA9IGlzSGV4Q29sb3IoaGV4KTtcblxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICBjb25zdCByID0gcGFyc2VJbnQocmVzdWx0WzFdLCAxNik7XG4gIGNvbnN0IGcgPSBwYXJzZUludChyZXN1bHRbMl0sIDE2KTtcbiAgY29uc3QgYiA9IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpO1xuXG4gIHJldHVybiBbciwgZywgYl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hleENvbG9yKGhleDogc3RyaW5nKTogUmVnRXhwRXhlY0FycmF5IHwgbnVsbCB7XG4gIGNvbnN0IHJlc3VsdCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFBhZE51bShjKSB7XG4gIGNvbnN0IGhleCA9IGMudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cblxuLyoqXG4gKiBnZXQgaGV4IGZyb20gciBnIGJcbiAqXG4gKiBAcGFyYW0gcmdiXG4gKiBAcmV0dXJucyBoZXggc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZ2JUb0hleChbciwgZywgYl06IFJHQkNvbG9yKTogSGV4Q29sb3Ige1xuICByZXR1cm4gYCMke1tyLCBnLCBiXS5tYXAobiA9PiBQYWROdW0obikpLmpvaW4oJycpfWAudG9VcHBlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBHZXQgY29sb3IgZ3JvdXAgbmFtZSBieSBwYXJzaW5nIG5hbWUsIGRpc2NhcmQgc3RlcCBpbiB0aGUgbmFtZVxuICogZS5nLiBHbG9iYWwgV2FybWluZyA2IC0+IEdsb2JhbCBXYXJtaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbG9yUmFuZ2VcbiAqIEByZXR1cm4ge3N0cmluZyB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xvckdyb3VwQnlOYW1lKGNvbG9yUmFuZ2U6IENvbG9yUmFuZ2UpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFjb2xvclJhbmdlIHx8IHR5cGVvZiBjb2xvclJhbmdlLm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY29sb3JSYW5nZS5uYW1lLnJlcGxhY2UoL1xcYlteYS16QS1aXSskLywgJycpO1xufVxuXG4vKipcbiAqIEdldCBhIHJldmVyc2VkIGNvbG9yUmFuZ2VcbiAqIEBwYXJhbSByZXZlcnNlZFxuICogQHBhcmFtIGNvbG9yUmFuZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VDb2xvclJhbmdlKHJldmVyc2VkOiBib29sZWFuLCBjb2xvclJhbmdlOiBDb2xvclJhbmdlKTogQ29sb3JSYW5nZSB8IG51bGwge1xuICBpZiAoIWNvbG9yUmFuZ2UpIHJldHVybiBudWxsO1xuICAvLyBpZiAoY29sb3JSYW5nZS5yZXZlcnNlZCkgcmV0dXJuIGNvbG9yUmFuZ2U7XG4gIHJldHVybiB7XG4gICAgLi4uY29sb3JSYW5nZSxcbiAgICByZXZlcnNlZCxcbiAgICBjb2xvcnM6IGNvbG9yUmFuZ2UuY29sb3JzLnNsaWNlKCkucmV2ZXJzZSgpXG4gIH07XG59XG5cbi8qKlxuICogZ2l2ZW4gYSBsaXN0IG9mIHJnYiBhcnJheXMgaXQgd2lsbCBnZW5lcmF0ZSBhIGxpbmVhciBncmFkaWVudCBjc3MgcnVsZVxuICogQHBhcmFtIGRpcmVjdGlvblxuICogQHBhcmFtIGNvbG9yc1xuICogQHJldHVyblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGluZWFyR3JhZGllbnQoZGlyZWN0aW9uOiBzdHJpbmcsIGNvbG9yczogUkdCQ29sb3JbXSkge1xuICBjb25zdCBzdGVwID0gcGFyc2VGbG9hdCgoMTAwLjAgLyBjb2xvcnMubGVuZ3RoKS50b0ZpeGVkKDIpKTtcbiAgY29uc3QgYmFuZHMgPSBjb2xvcnMubWFwKChyZ2IsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIGByZ2JhKCR7cmdiLmpvaW4oJywnKX0sIDEpICR7c3RlcCAqIGluZGV4fSUsIHJnYmEoJHtyZ2Iuam9pbignLCcpfSwgMSkgJHtzdGVwICpcbiAgICAgIChpbmRleCArIDEpfSVgO1xuICB9KTtcblxuICByZXR1cm4gYGxpbmVhci1ncmFkaWVudCh0byAke2RpcmVjdGlvbn0sICR7YmFuZHMuam9pbignLCcpfSlgO1xufVxuXG4vKipcbiAqIENvbnZlcnQgY29sb3IgdG8gUkdCXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2xvck1heWJlVG9SR0IoY29sb3I6IHVua25vd24pOiBSR0JDb2xvciB8IG51bGwge1xuICBpZiAoaXNSZ2JDb2xvcihjb2xvcikpIHtcbiAgICByZXR1cm4gY29sb3IgYXMgUkdCQ29sb3I7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHJnYk9iaiA9IGQzUmdiKGNvbG9yKTtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJnYk9iaj8ucikgJiYgTnVtYmVyLmlzRmluaXRlKHJnYk9iaj8uZykgJiYgTnVtYmVyLmlzRmluaXRlKHJnYk9iaj8uYikpIHtcbiAgICAgIHJldHVybiBbcmdiT2JqLnIsIHJnYk9iai5nLCByZ2JPYmouYl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogV2hldGhlciBjb2xvciBpcyByZ2JcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JnYkNvbG9yKGNvbG9yOiB1bmtub3duKTogYm9vbGVhbiB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIGNvbG9yICYmXG4gICAgICBBcnJheS5pc0FycmF5KGNvbG9yKSAmJlxuICAgICAgY29sb3IubGVuZ3RoID09PSAzICYmXG4gICAgICBjb2xvci5ldmVyeShuID0+IE51bWJlci5pc0Zpbml0ZShuKSAmJiBuIDw9IDI1NSAmJiBuID49IDApXG4gICk7XG59XG5cbi8qKlxuICogVGFrZSBjb2xvciB2YWx1ZXMgaW4gMC0yNTUgcmFuZ2UgYW5kIG1hcCB0byBbMCwgMV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgcmV0dXJuIGNvbG9yLm1hcChjb21wb25lbnQgPT4gY29tcG9uZW50IC8gMjU1LjApO1xufVxuIl19