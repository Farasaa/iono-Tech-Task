"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = PanelHeaderActionFactory;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _localization = require("@kepler.gl/localization");

var _styledComponents2 = require("../common/styled-components");

var _templateObject;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var HeaderActionWrapper = _styledComponents["default"].div.attrs(function (props) {
  return {
    dataTestId: props.testId
  };
})(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["\n  margin-left: ", "px;\n  display: flex;\n  align-items: center;\n  color: ", ";\n\n  cursor: pointer;\n\n  :hover {\n    color: ", ";\n  }\n\n  &.disabled {\n    cursor: none;\n    pointer-events: none;\n    opacity: 0.3;\n  }\n"])), function (props) {
  return props.flush ? 0 : 8;
}, function (props) {
  return props.active ? props.theme.panelHeaderIconActive : props.theme.panelHeaderIcon;
}, function (props) {
  return props.hoverColor ? props.theme[props.hoverColor] : props.theme.panelHeaderIconHover;
});

PanelHeaderActionFactory.deps = []; // Need to use react class to access props.component

function PanelHeaderActionFactory() {
  var PanelHeaderActionUnmemoized = function PanelHeaderActionUnmemoized(_ref) {
    var onClick = _ref.onClick,
        tooltip = _ref.tooltip,
        id = _ref.id,
        _ref$active = _ref.active,
        active = _ref$active === void 0 ? false : _ref$active,
        flush = _ref.flush,
        hoverColor = _ref.hoverColor,
        tooltipType = _ref.tooltipType,
        disabled = _ref.disabled,
        className = _ref.className,
        IconComponent = _ref.IconComponent,
        testId = _ref.testId;
    return /*#__PURE__*/_react["default"].createElement(HeaderActionWrapper, {
      className: (0, _classnames["default"])('panel--header__action', _objectSpread({
        disabled: disabled
      }, className ? (0, _defineProperty2["default"])({}, className, true) : {})),
      active: active,
      hoverColor: hoverColor,
      flush: flush
    }, IconComponent ? /*#__PURE__*/_react["default"].createElement(IconComponent, {
      className: "panel--header__action__component",
      "data-testid": testId,
      "data-tip": true,
      "data-for": "".concat(tooltip, "_").concat(id),
      height: "16px",
      onClick: onClick
    }) : null, tooltip ? /*#__PURE__*/_react["default"].createElement(_styledComponents2.Tooltip, {
      id: "".concat(tooltip, "_").concat(id),
      effect: "solid",
      delayShow: 500,
      type: tooltipType
    }, /*#__PURE__*/_react["default"].createElement("span", null, /*#__PURE__*/_react["default"].createElement(_localization.FormattedMessage, {
      id: tooltip
    }))) : null);
  };

  var PanelHeaderAction = /*#__PURE__*/_react["default"].memo(PanelHeaderActionUnmemoized);

  PanelHeaderAction.displayName = 'PanelHeaderAction';
  return PanelHeaderAction;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaWRlLXBhbmVsL3BhbmVsLWhlYWRlci1hY3Rpb24udHN4Il0sIm5hbWVzIjpbIkhlYWRlckFjdGlvbldyYXBwZXIiLCJzdHlsZWQiLCJkaXYiLCJhdHRycyIsInByb3BzIiwiZGF0YVRlc3RJZCIsInRlc3RJZCIsImZsdXNoIiwiYWN0aXZlIiwidGhlbWUiLCJwYW5lbEhlYWRlckljb25BY3RpdmUiLCJwYW5lbEhlYWRlckljb24iLCJob3ZlckNvbG9yIiwicGFuZWxIZWFkZXJJY29uSG92ZXIiLCJQYW5lbEhlYWRlckFjdGlvbkZhY3RvcnkiLCJkZXBzIiwiUGFuZWxIZWFkZXJBY3Rpb25Vbm1lbW9pemVkIiwib25DbGljayIsInRvb2x0aXAiLCJpZCIsInRvb2x0aXBUeXBlIiwiZGlzYWJsZWQiLCJjbGFzc05hbWUiLCJJY29uQ29tcG9uZW50IiwiUGFuZWxIZWFkZXJBY3Rpb24iLCJSZWFjdCIsIm1lbW8iLCJkaXNwbGF5TmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUdBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQTBCQSxJQUFNQSxtQkFBbUIsR0FBR0MsNkJBQU9DLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQixVQUFDQyxLQUFEO0FBQUEsU0FBc0M7QUFDakZDLElBQUFBLFVBQVUsRUFBRUQsS0FBSyxDQUFDRTtBQUQrRCxHQUF0QztBQUFBLENBQWpCLENBQUgsOFRBR1IsVUFBQUYsS0FBSztBQUFBLFNBQUtBLEtBQUssQ0FBQ0csS0FBTixHQUFjLENBQWQsR0FBa0IsQ0FBdkI7QUFBQSxDQUhHLEVBTWQsVUFBQUgsS0FBSztBQUFBLFNBQ1pBLEtBQUssQ0FBQ0ksTUFBTixHQUFlSixLQUFLLENBQUNLLEtBQU4sQ0FBWUMscUJBQTNCLEdBQW1ETixLQUFLLENBQUNLLEtBQU4sQ0FBWUUsZUFEbkQ7QUFBQSxDQU5TLEVBWVosVUFBQVAsS0FBSztBQUFBLFNBQ1pBLEtBQUssQ0FBQ1EsVUFBTixHQUFtQlIsS0FBSyxDQUFDSyxLQUFOLENBQVlMLEtBQUssQ0FBQ1EsVUFBbEIsQ0FBbkIsR0FBbURSLEtBQUssQ0FBQ0ssS0FBTixDQUFZSSxvQkFEbkQ7QUFBQSxDQVpPLENBQXpCOztBQXVCQUMsd0JBQXdCLENBQUNDLElBQXpCLEdBQWdDLEVBQWhDLEMsQ0FDQTs7QUFDZSxTQUFTRCx3QkFBVCxHQUFzRTtBQUNuRixNQUFNRSwyQkFBNkQsR0FBRyxTQUFoRUEsMkJBQWdFLE9BWWhFO0FBQUEsUUFYSkMsT0FXSSxRQVhKQSxPQVdJO0FBQUEsUUFWSkMsT0FVSSxRQVZKQSxPQVVJO0FBQUEsUUFUSkMsRUFTSSxRQVRKQSxFQVNJO0FBQUEsMkJBUkpYLE1BUUk7QUFBQSxRQVJKQSxNQVFJLDRCQVJLLEtBUUw7QUFBQSxRQVBKRCxLQU9JLFFBUEpBLEtBT0k7QUFBQSxRQU5KSyxVQU1JLFFBTkpBLFVBTUk7QUFBQSxRQUxKUSxXQUtJLFFBTEpBLFdBS0k7QUFBQSxRQUpKQyxRQUlJLFFBSkpBLFFBSUk7QUFBQSxRQUhKQyxTQUdJLFFBSEpBLFNBR0k7QUFBQSxRQUZKQyxhQUVJLFFBRkpBLGFBRUk7QUFBQSxRQURKakIsTUFDSSxRQURKQSxNQUNJO0FBQ0osd0JBQ0UsZ0NBQUMsbUJBQUQ7QUFDRSxNQUFBLFNBQVMsRUFBRSw0QkFBVyx1QkFBWDtBQUNUZSxRQUFBQSxRQUFRLEVBQVJBO0FBRFMsU0FFTEMsU0FBUyx3Q0FBS0EsU0FBTCxFQUFpQixJQUFqQixJQUF5QixFQUY3QixFQURiO0FBS0UsTUFBQSxNQUFNLEVBQUVkLE1BTFY7QUFNRSxNQUFBLFVBQVUsRUFBRUksVUFOZDtBQU9FLE1BQUEsS0FBSyxFQUFFTDtBQVBULE9BU0dnQixhQUFhLGdCQUNaLGdDQUFDLGFBQUQ7QUFDRSxNQUFBLFNBQVMsRUFBQyxrQ0FEWjtBQUVFLHFCQUFhakIsTUFGZjtBQUdFLHNCQUhGO0FBSUUsNEJBQWFZLE9BQWIsY0FBd0JDLEVBQXhCLENBSkY7QUFLRSxNQUFBLE1BQU0sRUFBQyxNQUxUO0FBTUUsTUFBQSxPQUFPLEVBQUVGO0FBTlgsTUFEWSxHQVNWLElBbEJOLEVBbUJHQyxPQUFPLGdCQUNOLGdDQUFDLDBCQUFEO0FBQVMsTUFBQSxFQUFFLFlBQUtBLE9BQUwsY0FBZ0JDLEVBQWhCLENBQVg7QUFBaUMsTUFBQSxNQUFNLEVBQUMsT0FBeEM7QUFBZ0QsTUFBQSxTQUFTLEVBQUUsR0FBM0Q7QUFBZ0UsTUFBQSxJQUFJLEVBQUVDO0FBQXRFLG9CQUNFLDJEQUNFLGdDQUFDLDhCQUFEO0FBQWtCLE1BQUEsRUFBRSxFQUFFRjtBQUF0QixNQURGLENBREYsQ0FETSxHQU1KLElBekJOLENBREY7QUE2QkQsR0ExQ0Q7O0FBNENBLE1BQU1NLGlCQUFpQixnQkFBR0Msa0JBQU1DLElBQU4sQ0FBV1YsMkJBQVgsQ0FBMUI7O0FBQ0FRLEVBQUFBLGlCQUFpQixDQUFDRyxXQUFsQixHQUFnQyxtQkFBaEM7QUFDQSxTQUFPSCxpQkFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50VHlwZSwgTW91c2VFdmVudEhhbmRsZXJ9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7VG9vbHRpcFByb3BzfSBmcm9tICdyZWFjdC10b29sdGlwJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XG5pbXBvcnQge0Zvcm1hdHRlZE1lc3NhZ2V9IGZyb20gJ0BrZXBsZXIuZ2wvbG9jYWxpemF0aW9uJztcbmltcG9ydCB7VG9vbHRpcH0gZnJvbSAnLi4vY29tbW9uL3N0eWxlZC1jb21wb25lbnRzJztcbmltcG9ydCB7QmFzZVByb3BzfSBmcm9tICcuLi9jb21tb24vaWNvbnMnO1xuXG5leHBvcnQgdHlwZSBQYW5lbEhlYWRlckFjdGlvbkljb24gPSBDb21wb25lbnRUeXBlPFBhcnRpYWw8QmFzZVByb3BzPj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFuZWxIZWFkZXJBY3Rpb25Qcm9wcyB7XG4gIGlkPzogc3RyaW5nO1xuICB0b29sdGlwPzogc3RyaW5nO1xuICBob3ZlckNvbG9yPzogc3RyaW5nO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIGFjdGl2ZT86IGJvb2xlYW47XG4gIGZsdXNoPzogYm9vbGVhbjtcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICBvbkNsaWNrPzogTW91c2VFdmVudEhhbmRsZXI7XG4gIHRvb2x0aXBUeXBlPzogVG9vbHRpcFByb3BzWyd0eXBlJ107XG4gIEljb25Db21wb25lbnQ6IFBhbmVsSGVhZGVyQWN0aW9uSWNvbjtcbiAgdGVzdElkPzogc3RyaW5nO1xufVxuXG50eXBlIEhlYWRlckFjdGlvbldyYXBwZXJQcm9wcyA9IHtcbiAgZmx1c2g/OiBib29sZWFuO1xuICBhY3RpdmU/OiBib29sZWFuO1xuICBob3ZlckNvbG9yPzogc3RyaW5nIHwgbnVsbDtcbiAgdGVzdElkPzogc3RyaW5nO1xufTtcblxuY29uc3QgSGVhZGVyQWN0aW9uV3JhcHBlciA9IHN0eWxlZC5kaXYuYXR0cnMoKHByb3BzOiBIZWFkZXJBY3Rpb25XcmFwcGVyUHJvcHMpID0+ICh7XG4gIGRhdGFUZXN0SWQ6IHByb3BzLnRlc3RJZFxufSkpPEhlYWRlckFjdGlvbldyYXBwZXJQcm9wcz5gXG4gIG1hcmdpbi1sZWZ0OiAke3Byb3BzID0+IChwcm9wcy5mbHVzaCA/IDAgOiA4KX1weDtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgY29sb3I6ICR7cHJvcHMgPT5cbiAgICBwcm9wcy5hY3RpdmUgPyBwcm9wcy50aGVtZS5wYW5lbEhlYWRlckljb25BY3RpdmUgOiBwcm9wcy50aGVtZS5wYW5lbEhlYWRlckljb259O1xuXG4gIGN1cnNvcjogcG9pbnRlcjtcblxuICA6aG92ZXIge1xuICAgIGNvbG9yOiAke3Byb3BzID0+XG4gICAgICBwcm9wcy5ob3ZlckNvbG9yID8gcHJvcHMudGhlbWVbcHJvcHMuaG92ZXJDb2xvcl0gOiBwcm9wcy50aGVtZS5wYW5lbEhlYWRlckljb25Ib3Zlcn07XG4gIH1cblxuICAmLmRpc2FibGVkIHtcbiAgICBjdXJzb3I6IG5vbmU7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgb3BhY2l0eTogMC4zO1xuICB9XG5gO1xuXG5QYW5lbEhlYWRlckFjdGlvbkZhY3RvcnkuZGVwcyA9IFtdO1xuLy8gTmVlZCB0byB1c2UgcmVhY3QgY2xhc3MgdG8gYWNjZXNzIHByb3BzLmNvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGFuZWxIZWFkZXJBY3Rpb25GYWN0b3J5KCk6IFJlYWN0LkZDPFBhbmVsSGVhZGVyQWN0aW9uUHJvcHM+IHtcbiAgY29uc3QgUGFuZWxIZWFkZXJBY3Rpb25Vbm1lbW9pemVkOiBSZWFjdC5GQzxQYW5lbEhlYWRlckFjdGlvblByb3BzPiA9ICh7XG4gICAgb25DbGljayxcbiAgICB0b29sdGlwLFxuICAgIGlkLFxuICAgIGFjdGl2ZSA9IGZhbHNlLFxuICAgIGZsdXNoLFxuICAgIGhvdmVyQ29sb3IsXG4gICAgdG9vbHRpcFR5cGUsXG4gICAgZGlzYWJsZWQsXG4gICAgY2xhc3NOYW1lLFxuICAgIEljb25Db21wb25lbnQsXG4gICAgdGVzdElkXG4gIH0pID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPEhlYWRlckFjdGlvbldyYXBwZXJcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKCdwYW5lbC0taGVhZGVyX19hY3Rpb24nLCB7XG4gICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgLi4uKGNsYXNzTmFtZSA/IHtbY2xhc3NOYW1lXTogdHJ1ZX0gOiB7fSlcbiAgICAgICAgfSl9XG4gICAgICAgIGFjdGl2ZT17YWN0aXZlfVxuICAgICAgICBob3ZlckNvbG9yPXtob3ZlckNvbG9yfVxuICAgICAgICBmbHVzaD17Zmx1c2h9XG4gICAgICA+XG4gICAgICAgIHtJY29uQ29tcG9uZW50ID8gKFxuICAgICAgICAgIDxJY29uQ29tcG9uZW50XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJwYW5lbC0taGVhZGVyX19hY3Rpb25fX2NvbXBvbmVudFwiXG4gICAgICAgICAgICBkYXRhLXRlc3RpZD17dGVzdElkfVxuICAgICAgICAgICAgZGF0YS10aXBcbiAgICAgICAgICAgIGRhdGEtZm9yPXtgJHt0b29sdGlwfV8ke2lkfWB9XG4gICAgICAgICAgICBoZWlnaHQ9XCIxNnB4XCJcbiAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgLz5cbiAgICAgICAgKSA6IG51bGx9XG4gICAgICAgIHt0b29sdGlwID8gKFxuICAgICAgICAgIDxUb29sdGlwIGlkPXtgJHt0b29sdGlwfV8ke2lkfWB9IGVmZmVjdD1cInNvbGlkXCIgZGVsYXlTaG93PXs1MDB9IHR5cGU9e3Rvb2x0aXBUeXBlfT5cbiAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICA8Rm9ybWF0dGVkTWVzc2FnZSBpZD17dG9vbHRpcH0gLz5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICkgOiBudWxsfVxuICAgICAgPC9IZWFkZXJBY3Rpb25XcmFwcGVyPlxuICAgICk7XG4gIH07XG5cbiAgY29uc3QgUGFuZWxIZWFkZXJBY3Rpb24gPSBSZWFjdC5tZW1vKFBhbmVsSGVhZGVyQWN0aW9uVW5tZW1vaXplZCk7XG4gIFBhbmVsSGVhZGVyQWN0aW9uLmRpc3BsYXlOYW1lID0gJ1BhbmVsSGVhZGVyQWN0aW9uJztcbiAgcmV0dXJuIFBhbmVsSGVhZGVyQWN0aW9uO1xufVxuIl19