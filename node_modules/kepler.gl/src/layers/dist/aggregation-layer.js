"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.aggregateRequiredColumns = exports.getFilterDataFunc = exports.getValueAggrFunc = exports.pointPosResolver = exports.pointPosAccessor = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = _interopRequireDefault(require("lodash.memoize"));

var _baseLayer = _interopRequireDefault(require("./base-layer"));

var _utils = require("@kepler.gl/utils");

var _constants = require("@kepler.gl/constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var pointPosAccessor = function pointPosAccessor(_ref) {
  var lat = _ref.lat,
      lng = _ref.lng;
  return function (dc) {
    return function (d) {
      return [dc.valueAt(d.index, lng.fieldIdx), dc.valueAt(d.index, lat.fieldIdx)];
    };
  };
};

exports.pointPosAccessor = pointPosAccessor;

var pointPosResolver = function pointPosResolver(_ref2) {
  var lat = _ref2.lat,
      lng = _ref2.lng;
  return "".concat(lat.fieldIdx, "-").concat(lng.fieldIdx);
};

exports.pointPosResolver = pointPosResolver;

var getValueAggrFunc = function getValueAggrFunc(getPointData) {
  return function (field, aggregation) {
    return function (points) {
      return field ? (0, _utils.aggregate)(points.map(function (p) {
        return field.valueAccessor(getPointData(p));
      }), aggregation) : points.length;
    };
  };
};

exports.getValueAggrFunc = getValueAggrFunc;

var getFilterDataFunc = function getFilterDataFunc(filterRange, getFilterValue) {
  return function (pt) {
    return getFilterValue(pt).every(function (val, i) {
      return val >= filterRange[i][0] && val <= filterRange[i][1];
    });
  };
};

exports.getFilterDataFunc = getFilterDataFunc;

var getLayerColorRange = function getLayerColorRange(colorRange) {
  return colorRange.colors.map(_utils.hexToRgb);
};

var aggregateRequiredColumns = ['lat', 'lng'];
exports.aggregateRequiredColumns = aggregateRequiredColumns;

var AggregationLayer = /*#__PURE__*/function (_Layer) {
  (0, _inherits2["default"])(AggregationLayer, _Layer);

  var _super = _createSuper(AggregationLayer);

  function AggregationLayer(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, AggregationLayer);
    _this = _super.call(this, props);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getColorRange", void 0);

    _this.getPositionAccessor = function (dataContainer) {
      return pointPosAccessor(_this.config.columns)(dataContainer);
    };

    _this.getColorRange = (0, _lodash["default"])(getLayerColorRange); // Access data of a point from aggregated bins, depends on how BinSorter works
    // Deck.gl's BinSorter puts data in point.source

    _this.getPointData = function (pt) {
      return pt.source;
    };

    _this.gpuFilterGetIndex = function (pt) {
      return _this.getPointData(pt).index;
    };

    _this.gpuFilterGetData = function (dataContainer, data, fieldIndex) {
      return dataContainer.valueAt(data.index, fieldIndex);
    };

    return _this;
  }

  (0, _createClass2["default"])(AggregationLayer, [{
    key: "isAggregated",
    get: function get() {
      return true;
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return aggregateRequiredColumns;
    }
  }, {
    key: "columnPairs",
    get: function get() {
      return this.defaultPointColumnPairs;
    }
  }, {
    key: "noneLayerDataAffectingProps",
    get: function get() {
      return [].concat((0, _toConsumableArray2["default"])((0, _get2["default"])((0, _getPrototypeOf2["default"])(AggregationLayer.prototype), "noneLayerDataAffectingProps", this)), ['enable3d', 'colorRange', 'colorDomain', 'sizeRange', 'sizeScale', 'sizeDomain', 'percentile', 'coverage', 'elevationPercentile', 'elevationScale', 'enableElevationZoomFactor']);
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return {
        color: {
          aggregation: 'colorAggregation',
          channelScaleType: _constants.CHANNEL_SCALES.colorAggr,
          defaultMeasure: 'property.pointCount',
          domain: 'colorDomain',
          field: 'colorField',
          key: 'color',
          property: 'color',
          range: 'colorRange',
          scale: 'colorScale'
        },
        size: {
          aggregation: 'sizeAggregation',
          channelScaleType: _constants.CHANNEL_SCALES.sizeAggr,
          condition: function condition(config) {
            return config.visConfig.enable3d;
          },
          defaultMeasure: 'property.pointCount',
          domain: 'sizeDomain',
          field: 'sizeField',
          key: 'size',
          property: 'height',
          range: 'sizeRange',
          scale: 'sizeScale'
        }
      };
    }
    /**
     * Get the description of a visualChannel config
     * @param key
     * @returns
     */

  }, {
    key: "getVisualChannelDescription",
    value: function getVisualChannelDescription(key) {
      var _this$visConfigSettin;

      var channel = this.visualChannels[key];
      if (!channel) return {
        label: '',
        measure: undefined
      }; // e.g. label: Color, measure: Average of ETA

      var range = channel.range,
          field = channel.field,
          defaultMeasure = channel.defaultMeasure,
          aggregation = channel.aggregation;
      var fieldConfig = this.config[field];
      var label = (_this$visConfigSettin = this.visConfigSettings[range]) === null || _this$visConfigSettin === void 0 ? void 0 : _this$visConfigSettin.label;
      return {
        label: typeof label === 'function' ? label(this.config) : label || '',
        measure: fieldConfig && aggregation ? "".concat(this.config.visConfig[aggregation], " of ").concat(fieldConfig.displayName || fieldConfig.name) : defaultMeasure
      };
    }
  }, {
    key: "getHoverData",
    value: function getHoverData(object) {
      // return aggregated object
      return object;
    }
    /**
     * Aggregation layer handles visual channel aggregation inside deck.gl layer
     */

  }, {
    key: "updateLayerVisualChannel",
    value: function updateLayerVisualChannel(_ref3, channel) {
      var dataContainer = _ref3.dataContainer;
      this.validateVisualChannel(channel);
    }
    /**
     * Validate aggregation type on top of basic layer visual channel validation
     * @param channel
     */

  }, {
    key: "validateVisualChannel",
    value: function validateVisualChannel(channel) {
      // field type decides aggregation type decides scale type
      this.validateFieldType(channel);
      this.validateAggregationType(channel);
      this.validateScale(channel);
    }
    /**
     * Validate aggregation type based on selected field
     */

  }, {
    key: "validateAggregationType",
    value: function validateAggregationType(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
          aggregation = visualChannel.aggregation;
      var aggregationOptions = this.getAggregationOptions(channel);

      if (!aggregation) {
        return;
      }

      if (!aggregationOptions.length) {
        // if field cannot be aggregated, set field to null
        this.updateLayerConfig((0, _defineProperty2["default"])({}, field, null));
      } else if (!aggregationOptions.includes(this.config.visConfig[aggregation])) {
        // current aggregation type is not supported by this field
        // set aggregation to the first supported option
        this.updateLayerVisConfig((0, _defineProperty2["default"])({}, aggregation, aggregationOptions[0]));
      }
    }
  }, {
    key: "getAggregationOptions",
    value: function getAggregationOptions(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
          channelScaleType = visualChannel.channelScaleType;
      return Object.keys(this.config[field] ? _constants.FIELD_OPTS[this.config[field].type].scale[channelScaleType] : _constants.DEFAULT_AGGREGATION[channelScaleType]);
    }
    /**
     * Get scale options based on current field and aggregation type
     * @param channel
     * @returns
     */

  }, {
    key: "getScaleOptions",
    value: function getScaleOptions(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
          aggregation = visualChannel.aggregation,
          channelScaleType = visualChannel.channelScaleType;
      var aggregationType = aggregation ? this.config.visConfig[aggregation] : null;

      if (!aggregationType) {
        return [];
      }

      return this.config[field] ? // scale options based on aggregation
      _constants.FIELD_OPTS[this.config[field].type].scale[channelScaleType][aggregationType] : // default scale options for point count
      _constants.DEFAULT_AGGREGATION[channelScaleType][aggregationType];
    }
    /**
     * Aggregation layer handles visual channel aggregation inside deck.gl layer
     */

  }, {
    key: "updateLayerDomain",
    value: function updateLayerDomain(datasets, newFilter) {
      return this;
    }
  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataContainer, getPosition) {
      // get bounds from points
      var bounds = this.getPointsBounds(dataContainer, getPosition);
      this.updateMeta({
        bounds: bounds
      });
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(_ref4, getPosition) {
      var dataContainer = _ref4.dataContainer,
          filteredIndex = _ref4.filteredIndex;
      var data = [];

      for (var i = 0; i < filteredIndex.length; i++) {
        var index = filteredIndex[i];
        var pos = getPosition({
          index: index
        }); // if doesn't have point lat or lng, do not add the point
        // deck.gl can't handle position = null

        if (pos.every(Number.isFinite)) {
          data.push({
            index: index
          });
        }
      }

      return data;
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData) {
      if (this.config.dataId === null) {
        return {};
      }

      var _datasets$this$config = datasets[this.config.dataId],
          gpuFilter = _datasets$this$config.gpuFilter,
          dataContainer = _datasets$this$config.dataContainer;
      var getPosition = this.getPositionAccessor(dataContainer);
      var aggregatePoints = getValueAggrFunc(this.getPointData);
      var getColorValue = aggregatePoints(this.config.colorField, this.config.visConfig.colorAggregation);
      var getElevationValue = aggregatePoints(this.config.sizeField, this.config.visConfig.sizeAggregation);
      var hasFilter = Object.values(gpuFilter.filterRange).some(function (arr) {
        return arr.some(function (v) {
          return v !== 0;
        });
      });
      var getFilterValue = gpuFilter.filterValueAccessor(dataContainer)(this.gpuFilterGetIndex, this.gpuFilterGetData);
      var filterData = hasFilter ? getFilterDataFunc(gpuFilter.filterRange, getFilterValue) : undefined;

      var _this$updateData = this.updateData(datasets, oldLayerData),
          data = _this$updateData.data;

      return _objectSpread(_objectSpread({
        data: data,
        getPosition: getPosition,
        _filterData: filterData
      }, getColorValue ? {
        getColorValue: getColorValue
      } : {}), getElevationValue ? {
        getElevationValue: getElevationValue
      } : {});
    }
  }, {
    key: "getDefaultDeckLayerProps",
    value: function getDefaultDeckLayerProps(opts) {
      var baseProp = (0, _get2["default"])((0, _getPrototypeOf2["default"])(AggregationLayer.prototype), "getDefaultDeckLayerProps", this).call(this, opts);
      return _objectSpread(_objectSpread({}, baseProp), {}, {
        highlightColor: _constants.HIGHLIGH_COLOR_3D,
        // gpu data filtering is not supported in aggregation layer
        extensions: [],
        autoHighlight: this.config.visConfig.enable3d
      });
    }
  }, {
    key: "getDefaultAggregationLayerProp",
    value: function getDefaultAggregationLayerProp(opts) {
      var gpuFilter = opts.gpuFilter,
          mapState = opts.mapState,
          _opts$layerCallbacks = opts.layerCallbacks,
          layerCallbacks = _opts$layerCallbacks === void 0 ? {} : _opts$layerCallbacks;
      var visConfig = this.config.visConfig;
      var eleZoomFactor = this.getElevationZoomFactor(mapState);
      var updateTriggers = {
        getColorValue: {
          colorField: this.config.colorField,
          colorAggregation: this.config.visConfig.colorAggregation
        },
        getElevationValue: {
          sizeField: this.config.sizeField,
          sizeAggregation: this.config.visConfig.sizeAggregation
        },
        _filterData: _objectSpread({
          filterRange: gpuFilter.filterRange
        }, gpuFilter.filterValueUpdateTriggers)
      };
      return _objectSpread(_objectSpread({}, this.getDefaultDeckLayerProps(opts)), {}, {
        coverage: visConfig.coverage,
        // color
        colorRange: this.getColorRange(visConfig.colorRange),
        colorScaleType: this.config.colorScale,
        upperPercentile: visConfig.percentile[1],
        lowerPercentile: visConfig.percentile[0],
        colorAggregation: visConfig.colorAggregation,
        // elevation
        extruded: visConfig.enable3d,
        elevationScale: visConfig.elevationScale * eleZoomFactor,
        elevationScaleType: this.config.sizeScale,
        elevationRange: visConfig.sizeRange,
        elevationLowerPercentile: visConfig.elevationPercentile[0],
        elevationUpperPercentile: visConfig.elevationPercentile[1],
        // updateTriggers
        updateTriggers: updateTriggers,
        // callbacks
        onSetColorDomain: layerCallbacks.onSetLayerDomain
      });
    }
  }]);
  return AggregationLayer;
}(_baseLayer["default"]);

exports["default"] = AggregationLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hZ2dyZWdhdGlvbi1sYXllci50cyJdLCJuYW1lcyI6WyJwb2ludFBvc0FjY2Vzc29yIiwibGF0IiwibG5nIiwiZGMiLCJkIiwidmFsdWVBdCIsImluZGV4IiwiZmllbGRJZHgiLCJwb2ludFBvc1Jlc29sdmVyIiwiZ2V0VmFsdWVBZ2dyRnVuYyIsImdldFBvaW50RGF0YSIsImZpZWxkIiwiYWdncmVnYXRpb24iLCJwb2ludHMiLCJtYXAiLCJwIiwidmFsdWVBY2Nlc3NvciIsImxlbmd0aCIsImdldEZpbHRlckRhdGFGdW5jIiwiZmlsdGVyUmFuZ2UiLCJnZXRGaWx0ZXJWYWx1ZSIsInB0IiwiZXZlcnkiLCJ2YWwiLCJpIiwiZ2V0TGF5ZXJDb2xvclJhbmdlIiwiY29sb3JSYW5nZSIsImNvbG9ycyIsImhleFRvUmdiIiwiYWdncmVnYXRlUmVxdWlyZWRDb2x1bW5zIiwiQWdncmVnYXRpb25MYXllciIsInByb3BzIiwiZ2V0UG9zaXRpb25BY2Nlc3NvciIsImRhdGFDb250YWluZXIiLCJjb25maWciLCJjb2x1bW5zIiwiZ2V0Q29sb3JSYW5nZSIsInNvdXJjZSIsImdwdUZpbHRlckdldEluZGV4IiwiZ3B1RmlsdGVyR2V0RGF0YSIsImRhdGEiLCJmaWVsZEluZGV4IiwiZGVmYXVsdFBvaW50Q29sdW1uUGFpcnMiLCJjb2xvciIsImNoYW5uZWxTY2FsZVR5cGUiLCJDSEFOTkVMX1NDQUxFUyIsImNvbG9yQWdnciIsImRlZmF1bHRNZWFzdXJlIiwiZG9tYWluIiwia2V5IiwicHJvcGVydHkiLCJyYW5nZSIsInNjYWxlIiwic2l6ZSIsInNpemVBZ2dyIiwiY29uZGl0aW9uIiwidmlzQ29uZmlnIiwiZW5hYmxlM2QiLCJjaGFubmVsIiwidmlzdWFsQ2hhbm5lbHMiLCJsYWJlbCIsIm1lYXN1cmUiLCJ1bmRlZmluZWQiLCJmaWVsZENvbmZpZyIsInZpc0NvbmZpZ1NldHRpbmdzIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwib2JqZWN0IiwidmFsaWRhdGVWaXN1YWxDaGFubmVsIiwidmFsaWRhdGVGaWVsZFR5cGUiLCJ2YWxpZGF0ZUFnZ3JlZ2F0aW9uVHlwZSIsInZhbGlkYXRlU2NhbGUiLCJ2aXN1YWxDaGFubmVsIiwiYWdncmVnYXRpb25PcHRpb25zIiwiZ2V0QWdncmVnYXRpb25PcHRpb25zIiwidXBkYXRlTGF5ZXJDb25maWciLCJpbmNsdWRlcyIsInVwZGF0ZUxheWVyVmlzQ29uZmlnIiwiT2JqZWN0Iiwia2V5cyIsIkZJRUxEX09QVFMiLCJ0eXBlIiwiREVGQVVMVF9BR0dSRUdBVElPTiIsImFnZ3JlZ2F0aW9uVHlwZSIsImRhdGFzZXRzIiwibmV3RmlsdGVyIiwiZ2V0UG9zaXRpb24iLCJib3VuZHMiLCJnZXRQb2ludHNCb3VuZHMiLCJ1cGRhdGVNZXRhIiwiZmlsdGVyZWRJbmRleCIsInBvcyIsIk51bWJlciIsImlzRmluaXRlIiwicHVzaCIsIm9sZExheWVyRGF0YSIsImRhdGFJZCIsImdwdUZpbHRlciIsImFnZ3JlZ2F0ZVBvaW50cyIsImdldENvbG9yVmFsdWUiLCJjb2xvckZpZWxkIiwiY29sb3JBZ2dyZWdhdGlvbiIsImdldEVsZXZhdGlvblZhbHVlIiwic2l6ZUZpZWxkIiwic2l6ZUFnZ3JlZ2F0aW9uIiwiaGFzRmlsdGVyIiwidmFsdWVzIiwic29tZSIsImFyciIsInYiLCJmaWx0ZXJWYWx1ZUFjY2Vzc29yIiwiZmlsdGVyRGF0YSIsInVwZGF0ZURhdGEiLCJfZmlsdGVyRGF0YSIsIm9wdHMiLCJiYXNlUHJvcCIsImhpZ2hsaWdodENvbG9yIiwiSElHSExJR0hfQ09MT1JfM0QiLCJleHRlbnNpb25zIiwiYXV0b0hpZ2hsaWdodCIsIm1hcFN0YXRlIiwibGF5ZXJDYWxsYmFja3MiLCJlbGVab29tRmFjdG9yIiwiZ2V0RWxldmF0aW9uWm9vbUZhY3RvciIsInVwZGF0ZVRyaWdnZXJzIiwiZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VycyIsImdldERlZmF1bHREZWNrTGF5ZXJQcm9wcyIsImNvdmVyYWdlIiwiY29sb3JTY2FsZVR5cGUiLCJjb2xvclNjYWxlIiwidXBwZXJQZXJjZW50aWxlIiwicGVyY2VudGlsZSIsImxvd2VyUGVyY2VudGlsZSIsImV4dHJ1ZGVkIiwiZWxldmF0aW9uU2NhbGUiLCJlbGV2YXRpb25TY2FsZVR5cGUiLCJzaXplU2NhbGUiLCJlbGV2YXRpb25SYW5nZSIsInNpemVSYW5nZSIsImVsZXZhdGlvbkxvd2VyUGVyY2VudGlsZSIsImVsZXZhdGlvblBlcmNlbnRpbGUiLCJlbGV2YXRpb25VcHBlclBlcmNlbnRpbGUiLCJvblNldENvbG9yRG9tYWluIiwib25TZXRMYXllckRvbWFpbiIsIkxheWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTs7QUFDQTs7QUFTQTs7QUFDQTs7Ozs7Ozs7OztBQW1CTyxJQUFNQSxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CO0FBQUEsTUFBRUMsR0FBRixRQUFFQSxHQUFGO0FBQUEsTUFBT0MsR0FBUCxRQUFPQSxHQUFQO0FBQUEsU0FBeUMsVUFBQUMsRUFBRTtBQUFBLFdBQUksVUFBQUMsQ0FBQztBQUFBLGFBQUksQ0FDbEZELEVBQUUsQ0FBQ0UsT0FBSCxDQUFXRCxDQUFDLENBQUNFLEtBQWIsRUFBb0JKLEdBQUcsQ0FBQ0ssUUFBeEIsQ0FEa0YsRUFFbEZKLEVBQUUsQ0FBQ0UsT0FBSCxDQUFXRCxDQUFDLENBQUNFLEtBQWIsRUFBb0JMLEdBQUcsQ0FBQ00sUUFBeEIsQ0FGa0YsQ0FBSjtBQUFBLEtBQUw7QUFBQSxHQUEzQztBQUFBLENBQXpCOzs7O0FBS0EsSUFBTUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQjtBQUFBLE1BQUVQLEdBQUYsU0FBRUEsR0FBRjtBQUFBLE1BQU9DLEdBQVAsU0FBT0EsR0FBUDtBQUFBLG1CQUMzQkQsR0FBRyxDQUFDTSxRQUR1QixjQUNYTCxHQUFHLENBQUNLLFFBRE87QUFBQSxDQUF6Qjs7OztBQUdBLElBQU1FLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBQUMsWUFBWTtBQUFBLFNBQUksVUFBQ0Ms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LGdCQUFnQixFQUFFN0MsU0FBUyxDQUFDNkMsZ0JBVDlCO0FBV0U7QUFDQWdDLFFBQUFBLFFBQVEsRUFBRTdFLFNBQVMsQ0FBQ0MsUUFadEI7QUFhRTZFLFFBQUFBLGNBQWMsRUFBRTlFLFNBQVMsQ0FBQzhFLGNBQVYsR0FBMkJaLGFBYjdDO0FBY0VhLFFBQUFBLGtCQUFrQixFQUFFLEtBQUtyRyxNQUFMLENBQVlzRyxTQWRsQztBQWVFQyxRQUFBQSxjQUFjLEVBQUVqRixTQUFTLENBQUNrRixTQWY1QjtBQWdCRUMsUUFBQUEsd0JBQXdCLEVBQUVuRixTQUFTLENBQUNvRixtQkFBVixDQUE4QixDQUE5QixDQWhCNUI7QUFpQkVDLFFBQUFBLHdCQUF3QixFQUFFckYsU0FBUyxDQUFDb0YsbUJBQVYsQ0FBOEIsQ0FBOUIsQ0FqQjVCO0FBbUJFO0FBQ0FoQixRQUFBQSxjQUFjLEVBQWRBLGNBcEJGO0FBc0JFO0FBQ0FrQixRQUFBQSxnQkFBZ0IsRUFBRXJCLGNBQWMsQ0FBQ3NCO0FBdkJuQztBQXlCRDs7O0VBM1QyQ0MscUIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgbWVtb2l6ZSBmcm9tICdsb2Rhc2gubWVtb2l6ZSc7XG5pbXBvcnQgTGF5ZXIsIHtcbiAgTGF5ZXJCYXNlQ29uZmlnLFxuICBMYXllckJhc2VDb25maWdQYXJ0aWFsLFxuICBMYXllckNvbG9yQ29uZmlnLFxuICBMYXllckNvbHVtbixcbiAgTGF5ZXJTaXplQ29uZmlnLFxuICBWaXN1YWxDaGFubmVsRGVzY3JpcHRpb24sXG4gIFZpc3VhbENoYW5uZWxzXG59IGZyb20gJy4vYmFzZS1sYXllcic7XG5pbXBvcnQge2hleFRvUmdiLCBhZ2dyZWdhdGV9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtcbiAgSElHSExJR0hfQ09MT1JfM0QsXG4gIENIQU5ORUxfU0NBTEVTLFxuICBGSUVMRF9PUFRTLFxuICBERUZBVUxUX0FHR1JFR0FUSU9OLFxuICBDb2xvclJhbmdlXG59IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7TWVyZ2V9IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuaW1wb3J0IHtLZXBsZXJUYWJsZSwgRGF0YXNldHN9IGZyb20gJ0BrZXBsZXIuZ2wvdGFibGUnO1xuXG50eXBlIEFnZ3JlZ2F0aW9uTGF5ZXJDb2x1bW5zID0ge1xuICBsYXQ6IExheWVyQ29sdW1uO1xuICBsbmc6IExheWVyQ29sdW1uO1xufTtcblxuZXhwb3J0IHR5cGUgQWdncmVnYXRpb25MYXllckRhdGEgPSB7XG4gIGluZGV4OiBudW1iZXI7XG59O1xuXG5leHBvcnQgY29uc3QgcG9pbnRQb3NBY2Nlc3NvciA9ICh7bGF0LCBsbmd9OiBBZ2dyZWdhdGlvbkxheWVyQ29sdW1ucykgPT4gZGMgPT4gZCA9PiBbXG4gIGRjLnZhbHVlQXQoZC5pbmRleCwgbG5nLmZpZWxkSWR4KSxcbiAgZGMudmFsdWVBdChkLmluZGV4LCBsYXQuZmllbGRJZHgpXG5dO1xuXG5leHBvcnQgY29uc3QgcG9pbnRQb3NSZXNvbHZlciA9ICh7bGF0LCBsbmd9OiBBZ2dyZWdhdGlvbkxheWVyQ29sdW1ucykgPT5cbiAgYCR7bGF0LmZpZWxkSWR4fS0ke2xuZy5maWVsZElkeH1gO1xuXG5leHBvcnQgY29uc3QgZ2V0VmFsdWVBZ2dyRnVuYyA9IGdldFBvaW50RGF0YSA9PiAoZmllbGQsIGFnZ3JlZ2F0aW9uKSA9PiBwb2ludHMgPT5cbiAgZmllbGRcbiAgICA/IGFnZ3JlZ2F0ZShcbiAgICAgICAgcG9pbnRzLm1hcChwID0+IGZpZWxkLnZhbHVlQWNjZXNzb3IoZ2V0UG9pbnREYXRhKHApKSksXG4gICAgICAgIGFnZ3JlZ2F0aW9uXG4gICAgICApXG4gICAgOiBwb2ludHMubGVuZ3RoO1xuXG5leHBvcnQgY29uc3QgZ2V0RmlsdGVyRGF0YUZ1bmMgPSAoXG4gIGZpbHRlclJhbmdlOiBudW1iZXJbXVtdLFxuICBnZXRGaWx0ZXJWYWx1ZTogKGQ6IGFueSkgPT4gbnVtYmVyW11cbik6ICgoZDogYW55KSA9PiBib29sZWFuKSA9PiBwdCA9PlxuICBnZXRGaWx0ZXJWYWx1ZShwdCkuZXZlcnkoKHZhbCwgaSkgPT4gdmFsID49IGZpbHRlclJhbmdlW2ldWzBdICYmIHZhbCA8PSBmaWx0ZXJSYW5nZVtpXVsxXSk7XG5cbmNvbnN0IGdldExheWVyQ29sb3JSYW5nZSA9IChjb2xvclJhbmdlOiBDb2xvclJhbmdlKSA9PiBjb2xvclJhbmdlLmNvbG9ycy5tYXAoaGV4VG9SZ2IpO1xuXG5leHBvcnQgY29uc3QgYWdncmVnYXRlUmVxdWlyZWRDb2x1bW5zOiBbJ2xhdCcsICdsbmcnXSA9IFsnbGF0JywgJ2xuZyddO1xuXG5leHBvcnQgdHlwZSBBZ2dyZWdhdGlvbkxheWVyVmlzdWFsQ2hhbm5lbENvbmZpZyA9IExheWVyQ29sb3JDb25maWcgJiBMYXllclNpemVDb25maWc7XG5leHBvcnQgdHlwZSBBZ2dyZWdhdGlvbkxheWVyQ29uZmlnID0gTWVyZ2U8TGF5ZXJCYXNlQ29uZmlnLCB7Y29sdW1uczogQWdncmVnYXRpb25MYXllckNvbHVtbnN9PiAmXG4gIEFnZ3JlZ2F0aW9uTGF5ZXJWaXN1YWxDaGFubmVsQ29uZmlnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWdncmVnYXRpb25MYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0Q29sb3JSYW5nZTogYW55O1xuICBkZWNsYXJlIGNvbmZpZzogQWdncmVnYXRpb25MYXllckNvbmZpZztcbiAgZGVjbGFyZSBnZXRQb2ludERhdGE6IChhbnkpID0+IGFueTtcbiAgZGVjbGFyZSBncHVGaWx0ZXJHZXRJbmRleDogKGFueSkgPT4gbnVtYmVyO1xuICBkZWNsYXJlIGdwdUZpbHRlckdldERhdGE6IChkYXRhQ29udGFpbmVyLCBkYXRhLCBmaWVsZEluZGV4KSA9PiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvcHM6IHtcbiAgICAgIGlkPzogc3RyaW5nO1xuICAgIH0gJiBMYXllckJhc2VDb25maWdQYXJ0aWFsXG4gICkge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuZ2V0UG9zaXRpb25BY2Nlc3NvciA9IGRhdGFDb250YWluZXIgPT5cbiAgICAgIHBvaW50UG9zQWNjZXNzb3IodGhpcy5jb25maWcuY29sdW1ucykoZGF0YUNvbnRhaW5lcik7XG4gICAgdGhpcy5nZXRDb2xvclJhbmdlID0gbWVtb2l6ZShnZXRMYXllckNvbG9yUmFuZ2UpO1xuXG4gICAgLy8gQWNjZXNzIGRhdGEgb2YgYSBwb2ludCBmcm9tIGFnZ3JlZ2F0ZWQgYmlucywgZGVwZW5kcyBvbiBob3cgQmluU29ydGVyIHdvcmtzXG4gICAgLy8gRGVjay5nbCdzIEJpblNvcnRlciBwdXRzIGRhdGEgaW4gcG9pbnQuc291cmNlXG4gICAgdGhpcy5nZXRQb2ludERhdGEgPSBwdCA9PiBwdC5zb3VyY2U7XG5cbiAgICB0aGlzLmdwdUZpbHRlckdldEluZGV4ID0gcHQgPT4gdGhpcy5nZXRQb2ludERhdGEocHQpLmluZGV4O1xuICAgIHRoaXMuZ3B1RmlsdGVyR2V0RGF0YSA9IChkYXRhQ29udGFpbmVyLCBkYXRhLCBmaWVsZEluZGV4KSA9PlxuICAgICAgZGF0YUNvbnRhaW5lci52YWx1ZUF0KGRhdGEuaW5kZXgsIGZpZWxkSW5kZXgpO1xuICB9XG5cbiAgZ2V0IGlzQWdncmVnYXRlZCgpOiB0cnVlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldCByZXF1aXJlZExheWVyQ29sdW1ucygpIHtcbiAgICByZXR1cm4gYWdncmVnYXRlUmVxdWlyZWRDb2x1bW5zO1xuICB9XG5cbiAgZ2V0IGNvbHVtblBhaXJzKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRQb2ludENvbHVtblBhaXJzO1xuICB9XG5cbiAgZ2V0IG5vbmVMYXllckRhdGFBZmZlY3RpbmdQcm9wcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4uc3VwZXIubm9uZUxheWVyRGF0YUFmZmVjdGluZ1Byb3BzLFxuICAgICAgJ2VuYWJsZTNkJyxcbiAgICAgICdjb2xvclJhbmdlJyxcbiAgICAgICdjb2xvckRvbWFpbicsXG4gICAgICAnc2l6ZVJhbmdlJyxcbiAgICAgICdzaXplU2NhbGUnLFxuICAgICAgJ3NpemVEb21haW4nLFxuICAgICAgJ3BlcmNlbnRpbGUnLFxuICAgICAgJ2NvdmVyYWdlJyxcbiAgICAgICdlbGV2YXRpb25QZXJjZW50aWxlJyxcbiAgICAgICdlbGV2YXRpb25TY2FsZScsXG4gICAgICAnZW5hYmxlRWxldmF0aW9uWm9vbUZhY3RvcidcbiAgICBdO1xuICB9XG5cbiAgZ2V0IHZpc3VhbENoYW5uZWxzKCk6IFZpc3VhbENoYW5uZWxzIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgYWdncmVnYXRpb246ICdjb2xvckFnZ3JlZ2F0aW9uJyxcbiAgICAgICAgY2hhbm5lbFNjYWxlVHlwZTogQ0hBTk5FTF9TQ0FMRVMuY29sb3JBZ2dyLFxuICAgICAgICBkZWZhdWx0TWVhc3VyZTogJ3Byb3BlcnR5LnBvaW50Q291bnQnLFxuICAgICAgICBkb21haW46ICdjb2xvckRvbWFpbicsXG4gICAgICAgIGZpZWxkOiAnY29sb3JGaWVsZCcsXG4gICAgICAgIGtleTogJ2NvbG9yJyxcbiAgICAgICAgcHJvcGVydHk6ICdjb2xvcicsXG4gICAgICAgIHJhbmdlOiAnY29sb3JSYW5nZScsXG4gICAgICAgIHNjYWxlOiAnY29sb3JTY2FsZSdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIGFnZ3JlZ2F0aW9uOiAnc2l6ZUFnZ3JlZ2F0aW9uJyxcbiAgICAgICAgY2hhbm5lbFNjYWxlVHlwZTogQ0hBTk5FTF9TQ0FMRVMuc2l6ZUFnZ3IsXG4gICAgICAgIGNvbmRpdGlvbjogY29uZmlnID0+IGNvbmZpZy52aXNDb25maWcuZW5hYmxlM2QsXG4gICAgICAgIGRlZmF1bHRNZWFzdXJlOiAncHJvcGVydHkucG9pbnRDb3VudCcsXG4gICAgICAgIGRvbWFpbjogJ3NpemVEb21haW4nLFxuICAgICAgICBmaWVsZDogJ3NpemVGaWVsZCcsXG4gICAgICAgIGtleTogJ3NpemUnLFxuICAgICAgICBwcm9wZXJ0eTogJ2hlaWdodCcsXG4gICAgICAgIHJhbmdlOiAnc2l6ZVJhbmdlJyxcbiAgICAgICAgc2NhbGU6ICdzaXplU2NhbGUnXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlc2NyaXB0aW9uIG9mIGEgdmlzdWFsQ2hhbm5lbCBjb25maWdcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VmlzdWFsQ2hhbm5lbERlc2NyaXB0aW9uKGtleTogc3RyaW5nKTogVmlzdWFsQ2hhbm5lbERlc2NyaXB0aW9uIHtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy52aXN1YWxDaGFubmVsc1trZXldO1xuICAgIGlmICghY2hhbm5lbCkgcmV0dXJuIHtsYWJlbDogJycsIG1lYXN1cmU6IHVuZGVmaW5lZH07XG4gICAgLy8gZS5nLiBsYWJlbDogQ29sb3IsIG1lYXN1cmU6IEF2ZXJhZ2Ugb2YgRVRBXG4gICAgY29uc3Qge3JhbmdlLCBmaWVsZCwgZGVmYXVsdE1lYXN1cmUsIGFnZ3JlZ2F0aW9ufSA9IGNoYW5uZWw7XG4gICAgY29uc3QgZmllbGRDb25maWcgPSB0aGlzLmNvbmZpZ1tmaWVsZF07XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnZpc0NvbmZpZ1NldHRpbmdzW3JhbmdlXT8ubGFiZWw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IHR5cGVvZiBsYWJlbCA9PT0gJ2Z1bmN0aW9uJyA/IGxhYmVsKHRoaXMuY29uZmlnKSA6IGxhYmVsIHx8ICcnLFxuICAgICAgbWVhc3VyZTpcbiAgICAgICAgZmllbGRDb25maWcgJiYgYWdncmVnYXRpb25cbiAgICAgICAgICA/IGAke3RoaXMuY29uZmlnLnZpc0NvbmZpZ1thZ2dyZWdhdGlvbl19IG9mICR7ZmllbGRDb25maWcuZGlzcGxheU5hbWUgfHxcbiAgICAgICAgICAgICAgZmllbGRDb25maWcubmFtZX1gXG4gICAgICAgICAgOiBkZWZhdWx0TWVhc3VyZVxuICAgIH07XG4gIH1cblxuICBnZXRIb3ZlckRhdGEob2JqZWN0KSB7XG4gICAgLy8gcmV0dXJuIGFnZ3JlZ2F0ZWQgb2JqZWN0XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZ2dyZWdhdGlvbiBsYXllciBoYW5kbGVzIHZpc3VhbCBjaGFubmVsIGFnZ3JlZ2F0aW9uIGluc2lkZSBkZWNrLmdsIGxheWVyXG4gICAqL1xuICB1cGRhdGVMYXllclZpc3VhbENoYW5uZWwoe2RhdGFDb250YWluZXJ9LCBjaGFubmVsKSB7XG4gICAgdGhpcy52YWxpZGF0ZVZpc3VhbENoYW5uZWwoY2hhbm5lbCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYWdncmVnYXRpb24gdHlwZSBvbiB0b3Agb2YgYmFzaWMgbGF5ZXIgdmlzdWFsIGNoYW5uZWwgdmFsaWRhdGlvblxuICAgKiBAcGFyYW0gY2hhbm5lbFxuICAgKi9cbiAgdmFsaWRhdGVWaXN1YWxDaGFubmVsKGNoYW5uZWwpIHtcbiAgICAvLyBmaWVsZCB0eXBlIGRlY2lkZXMgYWdncmVnYXRpb24gdHlwZSBkZWNpZGVzIHNjYWxlIHR5cGVcbiAgICB0aGlzLnZhbGlkYXRlRmllbGRUeXBlKGNoYW5uZWwpO1xuICAgIHRoaXMudmFsaWRhdGVBZ2dyZWdhdGlvblR5cGUoY2hhbm5lbCk7XG4gICAgdGhpcy52YWxpZGF0ZVNjYWxlKGNoYW5uZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGFnZ3JlZ2F0aW9uIHR5cGUgYmFzZWQgb24gc2VsZWN0ZWQgZmllbGRcbiAgICovXG4gIHZhbGlkYXRlQWdncmVnYXRpb25UeXBlKGNoYW5uZWwpIHtcbiAgICBjb25zdCB2aXN1YWxDaGFubmVsID0gdGhpcy52aXN1YWxDaGFubmVsc1tjaGFubmVsXTtcbiAgICBjb25zdCB7ZmllbGQsIGFnZ3JlZ2F0aW9ufSA9IHZpc3VhbENoYW5uZWw7XG4gICAgY29uc3QgYWdncmVnYXRpb25PcHRpb25zID0gdGhpcy5nZXRBZ2dyZWdhdGlvbk9wdGlvbnMoY2hhbm5lbCk7XG5cbiAgICBpZiAoIWFnZ3JlZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFhZ2dyZWdhdGlvbk9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAvLyBpZiBmaWVsZCBjYW5ub3QgYmUgYWdncmVnYXRlZCwgc2V0IGZpZWxkIHRvIG51bGxcbiAgICAgIHRoaXMudXBkYXRlTGF5ZXJDb25maWcoe1tmaWVsZF06IG51bGx9KTtcbiAgICB9IGVsc2UgaWYgKCFhZ2dyZWdhdGlvbk9wdGlvbnMuaW5jbHVkZXModGhpcy5jb25maWcudmlzQ29uZmlnW2FnZ3JlZ2F0aW9uXSkpIHtcbiAgICAgIC8vIGN1cnJlbnQgYWdncmVnYXRpb24gdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgZmllbGRcbiAgICAgIC8vIHNldCBhZ2dyZWdhdGlvbiB0byB0aGUgZmlyc3Qgc3VwcG9ydGVkIG9wdGlvblxuICAgICAgdGhpcy51cGRhdGVMYXllclZpc0NvbmZpZyh7W2FnZ3JlZ2F0aW9uXTogYWdncmVnYXRpb25PcHRpb25zWzBdfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QWdncmVnYXRpb25PcHRpb25zKGNoYW5uZWwpIHtcbiAgICBjb25zdCB2aXN1YWxDaGFubmVsID0gdGhpcy52aXN1YWxDaGFubmVsc1tjaGFubmVsXTtcbiAgICBjb25zdCB7ZmllbGQsIGNoYW5uZWxTY2FsZVR5cGV9ID0gdmlzdWFsQ2hhbm5lbDtcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhcbiAgICAgIHRoaXMuY29uZmlnW2ZpZWxkXVxuICAgICAgICA/IEZJRUxEX09QVFNbdGhpcy5jb25maWdbZmllbGRdLnR5cGVdLnNjYWxlW2NoYW5uZWxTY2FsZVR5cGVdXG4gICAgICAgIDogREVGQVVMVF9BR0dSRUdBVElPTltjaGFubmVsU2NhbGVUeXBlXVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNjYWxlIG9wdGlvbnMgYmFzZWQgb24gY3VycmVudCBmaWVsZCBhbmQgYWdncmVnYXRpb24gdHlwZVxuICAgKiBAcGFyYW0gY2hhbm5lbFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0U2NhbGVPcHRpb25zKGNoYW5uZWw6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCB2aXN1YWxDaGFubmVsID0gdGhpcy52aXN1YWxDaGFubmVsc1tjaGFubmVsXTtcbiAgICBjb25zdCB7ZmllbGQsIGFnZ3JlZ2F0aW9uLCBjaGFubmVsU2NhbGVUeXBlfSA9IHZpc3VhbENoYW5uZWw7XG4gICAgY29uc3QgYWdncmVnYXRpb25UeXBlID0gYWdncmVnYXRpb24gPyB0aGlzLmNvbmZpZy52aXNDb25maWdbYWdncmVnYXRpb25dIDogbnVsbDtcblxuICAgIGlmICghYWdncmVnYXRpb25UeXBlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29uZmlnW2ZpZWxkXVxuICAgICAgPyAvLyBzY2FsZSBvcHRpb25zIGJhc2VkIG9uIGFnZ3JlZ2F0aW9uXG4gICAgICAgIEZJRUxEX09QVFNbdGhpcy5jb25maWdbZmllbGRdLnR5cGVdLnNjYWxlW2NoYW5uZWxTY2FsZVR5cGVdW2FnZ3JlZ2F0aW9uVHlwZV1cbiAgICAgIDogLy8gZGVmYXVsdCBzY2FsZSBvcHRpb25zIGZvciBwb2ludCBjb3VudFxuICAgICAgICBERUZBVUxUX0FHR1JFR0FUSU9OW2NoYW5uZWxTY2FsZVR5cGVdW2FnZ3JlZ2F0aW9uVHlwZV07XG4gIH1cblxuICAvKipcbiAgICogQWdncmVnYXRpb24gbGF5ZXIgaGFuZGxlcyB2aXN1YWwgY2hhbm5lbCBhZ2dyZWdhdGlvbiBpbnNpZGUgZGVjay5nbCBsYXllclxuICAgKi9cbiAgdXBkYXRlTGF5ZXJEb21haW4oZGF0YXNldHMsIG5ld0ZpbHRlcik6IEFnZ3JlZ2F0aW9uTGF5ZXIge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJNZXRhKGRhdGFDb250YWluZXIsIGdldFBvc2l0aW9uKSB7XG4gICAgLy8gZ2V0IGJvdW5kcyBmcm9tIHBvaW50c1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0UG9pbnRzQm91bmRzKGRhdGFDb250YWluZXIsIGdldFBvc2l0aW9uKTtcblxuICAgIHRoaXMudXBkYXRlTWV0YSh7Ym91bmRzfSk7XG4gIH1cblxuICBjYWxjdWxhdGVEYXRhQXR0cmlidXRlKHtkYXRhQ29udGFpbmVyLCBmaWx0ZXJlZEluZGV4fTogS2VwbGVyVGFibGUsIGdldFBvc2l0aW9uKSB7XG4gICAgY29uc3QgZGF0YTogQWdncmVnYXRpb25MYXllckRhdGFbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJlZEluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGZpbHRlcmVkSW5kZXhbaV07XG4gICAgICBjb25zdCBwb3MgPSBnZXRQb3NpdGlvbih7aW5kZXh9KTtcblxuICAgICAgLy8gaWYgZG9lc24ndCBoYXZlIHBvaW50IGxhdCBvciBsbmcsIGRvIG5vdCBhZGQgdGhlIHBvaW50XG4gICAgICAvLyBkZWNrLmdsIGNhbid0IGhhbmRsZSBwb3NpdGlvbiA9IG51bGxcbiAgICAgIGlmIChwb3MuZXZlcnkoTnVtYmVyLmlzRmluaXRlKSkge1xuICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgIGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgZm9ybWF0TGF5ZXJEYXRhKGRhdGFzZXRzOiBEYXRhc2V0cywgb2xkTGF5ZXJEYXRhKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmRhdGFJZCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCB7Z3B1RmlsdGVyLCBkYXRhQ29udGFpbmVyfSA9IGRhdGFzZXRzW3RoaXMuY29uZmlnLmRhdGFJZF07XG4gICAgY29uc3QgZ2V0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uQWNjZXNzb3IoZGF0YUNvbnRhaW5lcik7XG5cbiAgICBjb25zdCBhZ2dyZWdhdGVQb2ludHMgPSBnZXRWYWx1ZUFnZ3JGdW5jKHRoaXMuZ2V0UG9pbnREYXRhKTtcbiAgICBjb25zdCBnZXRDb2xvclZhbHVlID0gYWdncmVnYXRlUG9pbnRzKFxuICAgICAgdGhpcy5jb25maWcuY29sb3JGaWVsZCxcbiAgICAgIHRoaXMuY29uZmlnLnZpc0NvbmZpZy5jb2xvckFnZ3JlZ2F0aW9uXG4gICAgKTtcblxuICAgIGNvbnN0IGdldEVsZXZhdGlvblZhbHVlID0gYWdncmVnYXRlUG9pbnRzKFxuICAgICAgdGhpcy5jb25maWcuc2l6ZUZpZWxkLFxuICAgICAgdGhpcy5jb25maWcudmlzQ29uZmlnLnNpemVBZ2dyZWdhdGlvblxuICAgICk7XG4gICAgY29uc3QgaGFzRmlsdGVyID0gT2JqZWN0LnZhbHVlcyhncHVGaWx0ZXIuZmlsdGVyUmFuZ2UpLnNvbWUoKGFycjogYW55KSA9PlxuICAgICAgYXJyLnNvbWUodiA9PiB2ICE9PSAwKVxuICAgICk7XG5cbiAgICBjb25zdCBnZXRGaWx0ZXJWYWx1ZSA9IGdwdUZpbHRlci5maWx0ZXJWYWx1ZUFjY2Vzc29yKGRhdGFDb250YWluZXIpKFxuICAgICAgdGhpcy5ncHVGaWx0ZXJHZXRJbmRleCxcbiAgICAgIHRoaXMuZ3B1RmlsdGVyR2V0RGF0YVxuICAgICk7XG4gICAgY29uc3QgZmlsdGVyRGF0YSA9IGhhc0ZpbHRlclxuICAgICAgPyBnZXRGaWx0ZXJEYXRhRnVuYyhncHVGaWx0ZXIuZmlsdGVyUmFuZ2UsIGdldEZpbHRlclZhbHVlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnVwZGF0ZURhdGEoZGF0YXNldHMsIG9sZExheWVyRGF0YSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGdldFBvc2l0aW9uLFxuICAgICAgX2ZpbHRlckRhdGE6IGZpbHRlckRhdGEsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAuLi4oZ2V0Q29sb3JWYWx1ZSA/IHtnZXRDb2xvclZhbHVlfSA6IHt9KSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIC4uLihnZXRFbGV2YXRpb25WYWx1ZSA/IHtnZXRFbGV2YXRpb25WYWx1ZX0gOiB7fSlcbiAgICB9O1xuICB9XG5cbiAgZ2V0RGVmYXVsdERlY2tMYXllclByb3BzKG9wdHMpOiBhbnkge1xuICAgIGNvbnN0IGJhc2VQcm9wID0gc3VwZXIuZ2V0RGVmYXVsdERlY2tMYXllclByb3BzKG9wdHMpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5iYXNlUHJvcCxcbiAgICAgIGhpZ2hsaWdodENvbG9yOiBISUdITElHSF9DT0xPUl8zRCxcbiAgICAgIC8vIGdwdSBkYXRhIGZpbHRlcmluZyBpcyBub3Qgc3VwcG9ydGVkIGluIGFnZ3JlZ2F0aW9uIGxheWVyXG4gICAgICBleHRlbnNpb25zOiBbXSxcbiAgICAgIGF1dG9IaWdobGlnaHQ6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5lbmFibGUzZFxuICAgIH07XG4gIH1cblxuICBnZXREZWZhdWx0QWdncmVnYXRpb25MYXllclByb3Aob3B0cykge1xuICAgIGNvbnN0IHtncHVGaWx0ZXIsIG1hcFN0YXRlLCBsYXllckNhbGxiYWNrcyA9IHt9fSA9IG9wdHM7XG4gICAgY29uc3Qge3Zpc0NvbmZpZ30gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBlbGVab29tRmFjdG9yID0gdGhpcy5nZXRFbGV2YXRpb25ab29tRmFjdG9yKG1hcFN0YXRlKTtcblxuICAgIGNvbnN0IHVwZGF0ZVRyaWdnZXJzID0ge1xuICAgICAgZ2V0Q29sb3JWYWx1ZToge1xuICAgICAgICBjb2xvckZpZWxkOiB0aGlzLmNvbmZpZy5jb2xvckZpZWxkLFxuICAgICAgICBjb2xvckFnZ3JlZ2F0aW9uOiB0aGlzLmNvbmZpZy52aXNDb25maWcuY29sb3JBZ2dyZWdhdGlvblxuICAgICAgfSxcbiAgICAgIGdldEVsZXZhdGlvblZhbHVlOiB7XG4gICAgICAgIHNpemVGaWVsZDogdGhpcy5jb25maWcuc2l6ZUZpZWxkLFxuICAgICAgICBzaXplQWdncmVnYXRpb246IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5zaXplQWdncmVnYXRpb25cbiAgICAgIH0sXG4gICAgICBfZmlsdGVyRGF0YToge1xuICAgICAgICBmaWx0ZXJSYW5nZTogZ3B1RmlsdGVyLmZpbHRlclJhbmdlLFxuICAgICAgICAuLi5ncHVGaWx0ZXIuZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2Vyc1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5nZXREZWZhdWx0RGVja0xheWVyUHJvcHMob3B0cyksXG4gICAgICBjb3ZlcmFnZTogdmlzQ29uZmlnLmNvdmVyYWdlLFxuXG4gICAgICAvLyBjb2xvclxuICAgICAgY29sb3JSYW5nZTogdGhpcy5nZXRDb2xvclJhbmdlKHZpc0NvbmZpZy5jb2xvclJhbmdlKSxcbiAgICAgIGNvbG9yU2NhbGVUeXBlOiB0aGlzLmNvbmZpZy5jb2xvclNjYWxlLFxuICAgICAgdXBwZXJQZXJjZW50aWxlOiB2aXNDb25maWcucGVyY2VudGlsZVsxXSxcbiAgICAgIGxvd2VyUGVyY2VudGlsZTogdmlzQ29uZmlnLnBlcmNlbnRpbGVbMF0sXG4gICAgICBjb2xvckFnZ3JlZ2F0aW9uOiB2aXNDb25maWcuY29sb3JBZ2dyZWdhdGlvbixcblxuICAgICAgLy8gZWxldmF0aW9uXG4gICAgICBleHRydWRlZDogdmlzQ29uZmlnLmVuYWJsZTNkLFxuICAgICAgZWxldmF0aW9uU2NhbGU6IHZpc0NvbmZpZy5lbGV2YXRpb25TY2FsZSAqIGVsZVpvb21GYWN0b3IsXG4gICAgICBlbGV2YXRpb25TY2FsZVR5cGU6IHRoaXMuY29uZmlnLnNpemVTY2FsZSxcbiAgICAgIGVsZXZhdGlvblJhbmdlOiB2aXNDb25maWcuc2l6ZVJhbmdlLFxuICAgICAgZWxldmF0aW9uTG93ZXJQZXJjZW50aWxlOiB2aXNDb25maWcuZWxldmF0aW9uUGVyY2VudGlsZVswXSxcbiAgICAgIGVsZXZhdGlvblVwcGVyUGVyY2VudGlsZTogdmlzQ29uZmlnLmVsZXZhdGlvblBlcmNlbnRpbGVbMV0sXG5cbiAgICAgIC8vIHVwZGF0ZVRyaWdnZXJzXG4gICAgICB1cGRhdGVUcmlnZ2VycyxcblxuICAgICAgLy8gY2FsbGJhY2tzXG4gICAgICBvblNldENvbG9yRG9tYWluOiBsYXllckNhbGxiYWNrcy5vblNldExheWVyRG9tYWluXG4gICAgfTtcbiAgfVxufVxuIl19