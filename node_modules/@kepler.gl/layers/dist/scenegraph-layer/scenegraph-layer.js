"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.scenegraphVisConfigs = exports.scenegraphPosAccessor = exports.scenegraphOptionalColumns = exports.scenegraphRequiredColumns = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _meshLayers = require("@deck.gl/mesh-layers");

var _core = require("@loaders.gl/core");

var _gltf = require("@loaders.gl/gltf");

var _baseLayer = _interopRequireDefault(require("../base-layer"));

var _scenegraphLayerIcon = _interopRequireDefault(require("./scenegraph-layer-icon"));

var _scenegraphInfoModal = _interopRequireDefault(require("./scenegraph-info-modal"));

var _constants = require("@kepler.gl/constants");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var scenegraphRequiredColumns = ['lat', 'lng'];
exports.scenegraphRequiredColumns = scenegraphRequiredColumns;
var scenegraphOptionalColumns = ['altitude'];
exports.scenegraphOptionalColumns = scenegraphOptionalColumns;

function fetch(url) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      propName = _ref.propName,
      layer = _ref.layer;

  if (propName === 'scenegraph') {
    return (0, _core.load)(url, _gltf.GLTFLoader, layer.getLoadOptions());
  }

  return fetch(url).then(function (response) {
    return response.json();
  });
}

var scenegraphPosAccessor = function scenegraphPosAccessor(_ref2) {
  var lat = _ref2.lat,
      lng = _ref2.lng,
      altitude = _ref2.altitude;
  return function (dc) {
    return function (d) {
      return [dc.valueAt(d.index, lng.fieldIdx), dc.valueAt(d.index, lat.fieldIdx), altitude && altitude.fieldIdx > -1 ? dc.valueAt(d.index, altitude.fieldIdx) : 0];
    };
  };
};

exports.scenegraphPosAccessor = scenegraphPosAccessor;
var scenegraphVisConfigs = {
  opacity: 'opacity',
  colorRange: 'colorRange',
  //
  sizeScale: 'sizeScale',
  angleX: _objectSpread(_objectSpread({}, _constants.LAYER_VIS_CONFIGS.angle), {}, {
    property: 'angleX',
    label: 'angle X'
  }),
  angleY: _objectSpread(_objectSpread({}, _constants.LAYER_VIS_CONFIGS.angle), {}, {
    property: 'angleY',
    label: 'angle Y'
  }),
  angleZ: _objectSpread(_objectSpread({}, _constants.LAYER_VIS_CONFIGS.angle), {}, {
    property: 'angleZ',
    defaultValue: 90,
    label: 'angle Z'
  })
};
exports.scenegraphVisConfigs = scenegraphVisConfigs;
var DEFAULT_MODEL = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb';
var DEFAULT_TRANSITION = [0, 0, 0];
var DEFAULT_SCALE = [1, 1, 1];
var DEFAULT_COLOR = [255, 255, 255, 255];

var ScenegraphLayer = /*#__PURE__*/function (_Layer) {
  (0, _inherits2["default"])(ScenegraphLayer, _Layer);

  var _super = _createSuper(ScenegraphLayer);

  function ScenegraphLayer(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, ScenegraphLayer);
    _this = _super.call(this, props);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_layerInfoModal", void 0);

    _this.registerVisConfig(scenegraphVisConfigs);

    _this.getPositionAccessor = function (dataContainer) {
      return scenegraphPosAccessor(_this.config.columns)(dataContainer);
    }; // prepare layer info modal


    _this._layerInfoModal = (0, _scenegraphInfoModal["default"])();
    return _this;
  }

  (0, _createClass2["default"])(ScenegraphLayer, [{
    key: "type",
    get: function get() {
      return '3D';
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return scenegraphRequiredColumns;
    }
  }, {
    key: "optionalColumns",
    get: function get() {
      return scenegraphOptionalColumns;
    }
  }, {
    key: "columnPairs",
    get: function get() {
      return this.defaultPointColumnPairs;
    }
  }, {
    key: "layerIcon",
    get: function get() {
      return _scenegraphLayerIcon["default"];
    }
  }, {
    key: "layerInfoModal",
    get: function get() {
      return {
        id: 'scenegraphInfo',
        template: this._layerInfoModal,
        modalProps: {
          title: 'How to use Scenegraph'
        }
      };
    }
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(_ref3, getPosition) {
      var dataContainer = _ref3.dataContainer,
          filteredIndex = _ref3.filteredIndex;
      var data = [];

      for (var i = 0; i < filteredIndex.length; i++) {
        var index = filteredIndex[i];
        var pos = getPosition({
          index: index
        }); // if doesn't have point lat or lng, do not add the point
        // deck.gl can't handle position = null

        if (pos.every(Number.isFinite)) {
          data.push({
            position: pos,
            index: index
          });
        }
      }

      return data;
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData) {
      if (this.config.dataId === null) {
        return {};
      }

      var _datasets$this$config = datasets[this.config.dataId],
          gpuFilter = _datasets$this$config.gpuFilter,
          dataContainer = _datasets$this$config.dataContainer;

      var _this$updateData = this.updateData(datasets, oldLayerData),
          data = _this$updateData.data;

      var getPosition = this.getPositionAccessor(dataContainer);
      return {
        data: data,
        getPosition: getPosition,
        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)()
      };
    }
  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataContainer, getPosition) {
      var bounds = this.getPointsBounds(dataContainer, getPosition);
      this.updateMeta({
        bounds: bounds
      });
    }
  }, {
    key: "renderLayer",
    value: function renderLayer(opts) {
      var data = opts.data,
          gpuFilter = opts.gpuFilter;
      var _this$config$visConfi = this.config.visConfig,
          _this$config$visConfi2 = _this$config$visConfi.sizeScale,
          sizeScale = _this$config$visConfi2 === void 0 ? 1 : _this$config$visConfi2,
          _this$config$visConfi3 = _this$config$visConfi.angleX,
          angleX = _this$config$visConfi3 === void 0 ? 0 : _this$config$visConfi3,
          _this$config$visConfi4 = _this$config$visConfi.angleY,
          angleY = _this$config$visConfi4 === void 0 ? 0 : _this$config$visConfi4,
          _this$config$visConfi5 = _this$config$visConfi.angleZ,
          angleZ = _this$config$visConfi5 === void 0 ? 90 : _this$config$visConfi5;
      return [new _meshLayers.ScenegraphLayer(_objectSpread(_objectSpread(_objectSpread({}, this.getDefaultDeckLayerProps(opts)), {}, {
        // gpu data filtering is not supported at the moment in scenegraphLayer https://github.com/visgl/deck.gl/issues/8099
        extensions: []
      }, data), {}, {
        fetch: fetch,
        scenegraph: this.config.visConfig.scenegraph || DEFAULT_MODEL,
        sizeScale: sizeScale,
        getTranslation: DEFAULT_TRANSITION,
        getScale: DEFAULT_SCALE,
        getOrientation: [angleX, angleY, angleZ],
        getColor: DEFAULT_COLOR,
        // parameters
        parameters: {
          depthTest: true,
          blend: false
        },
        // update triggers
        updateTriggers: {
          getOrientation: {
            angleX: angleX,
            angleY: angleY,
            angleZ: angleZ
          },
          getPosition: this.config.columns,
          getFilterValue: gpuFilter.filterValueUpdateTriggers
        }
      }))];
    }
  }]);
  return ScenegraphLayer;
}(_baseLayer["default"]);

exports["default"] = ScenegraphLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2VuZWdyYXBoLWxheWVyL3NjZW5lZ3JhcGgtbGF5ZXIudHMiXSwibmFtZXMiOlsic2NlbmVncmFwaFJlcXVpcmVkQ29sdW1ucyIsInNjZW5lZ3JhcGhPcHRpb25hbENvbHVtbnMiLCJmZXRjaCIsInVybCIsInByb3BOYW1lIiwibGF5ZXIiLCJHTFRGTG9hZGVyIiwiZ2V0TG9hZE9wdGlvbnMiLCJ0aGVuIiwicmVzcG9uc2UiLCJqc29uIiwic2NlbmVncmFwaFBvc0FjY2Vzc29yIiwibGF0IiwibG5nIiwiYWx0aXR1ZGUiLCJkYyIsImQiLCJ2YWx1ZUF0IiwiaW5kZXgiLCJmaWVsZElkeCIsInNjZW5lZ3JhcGhWaXNDb25maWdzIiwib3BhY2l0eSIsImNvbG9yUmFuZ2UiLCJzaXplU2NhbGUiLCJhbmdsZVgiLCJMQVlFUl9WSVNfQ09ORklHUyIsImFuZ2xlIiwicHJvcGVydHkiLCJsYWJlbCIsImFuZ2xlWSIsImFuZ2xlWiIsImRlZmF1bHRWYWx1ZSIsIkRFRkFVTFRfTU9ERUwiLCJERUZBVUxUX1RSQU5TSVRJT04iLCJERUZBVUxUX1NDQUxFIiwiREVGQVVMVF9DT0xPUiIsIlNjZW5lZ3JhcGhMYXllciIsInByb3BzIiwicmVnaXN0ZXJWaXNDb25maWciLCJnZXRQb3NpdGlvbkFjY2Vzc29yIiwiZGF0YUNvbnRhaW5lciIsImNvbmZpZyIsImNvbHVtbnMiLCJfbGF5ZXJJbmZvTW9kYWwiLCJkZWZhdWx0UG9pbnRDb2x1bW5QYWlycyIsIlNjZW5lZ3JhcGhMYXllckljb24iLCJpZCIsInRlbXBsYXRlIiwibW9kYWxQcm9wcyIsInRpdGxlIiwiZ2V0UG9zaXRpb24iLCJmaWx0ZXJlZEluZGV4IiwiZGF0YSIsImkiLCJsZW5ndGgiLCJwb3MiLCJldmVyeSIsIk51bWJlciIsImlzRmluaXRlIiwicHVzaCIsInBvc2l0aW9uIiwiZGF0YXNldHMiLCJvbGRMYXllckRhdGEiLCJkYXRhSWQiLCJncHVGaWx0ZXIiLCJ1cGRhdGVEYXRhIiwiZ2V0RmlsdGVyVmFsdWUiLCJmaWx0ZXJWYWx1ZUFjY2Vzc29yIiwiYm91bmRzIiwiZ2V0UG9pbnRzQm91bmRzIiwidXBkYXRlTWV0YSIsIm9wdHMiLCJ2aXNDb25maWciLCJEZWNrU2NlbmVncmFwaExheWVyIiwiZ2V0RGVmYXVsdERlY2tMYXllclByb3BzIiwiZXh0ZW5zaW9ucyIsInNjZW5lZ3JhcGgiLCJnZXRUcmFuc2xhdGlvbiIsImdldFNjYWxlIiwiZ2V0T3JpZW50YXRpb24iLCJnZXRDb2xvciIsInBhcmFtZXRlcnMiLCJkZXB0aFRlc3QiLCJibGVuZCIsInVwZGF0ZVRyaWdnZXJzIiwiZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VycyIsIkxheWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0FBcUNPLElBQU1BLHlCQUF5QyxHQUFHLENBQUMsS0FBRCxFQUFRLEtBQVIsQ0FBbEQ7O0FBQ0EsSUFBTUMseUJBQXVDLEdBQUcsQ0FBQyxVQUFELENBQWhEOzs7QUFFUCxTQUFTQyxLQUFULENBQWVDLEdBQWYsRUFBOEU7QUFBQSxpRkFBSixFQUFJO0FBQUEsTUFBekRDLFFBQXlELFFBQXpEQSxRQUF5RDtBQUFBLE1BQS9DQyxLQUErQyxRQUEvQ0EsS0FBK0M7O0FBQzVFLE1BQUlELFFBQVEsS0FBSyxZQUFqQixFQUErQjtBQUM3QixXQUFPLGdCQUFLRCxHQUFMLEVBQVVHLGdCQUFWLEVBQXNCRCxLQUFLLENBQUNFLGNBQU4sRUFBdEIsQ0FBUDtBQUNEOztBQUVELFNBQU9MLEtBQUssQ0FBQ0MsR0FBRCxDQUFMLENBQVdLLElBQVgsQ0FBZ0IsVUFBQUMsUUFBUTtBQUFBLFdBQUlBLFFBQVEsQ0FBQ0MsSUFBVCxFQUFKO0FBQUEsR0FBeEIsQ0FBUDtBQUNEOztBQUVNLElBQU1DLHFCQUFxQixHQUFHLFNBQXhCQSxxQkFBd0I7QUFBQSxNQUFFQyxHQUFGLFNBQUVBLEdBQUY7QUFBQSxNQUFPQyxH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RWtELFFBQUFBLFFBQVEsRUFBRTdDLGFBWFo7QUFZRTtBQUNBOEMsUUFBQUEsVUFBVSxFQUFFO0FBQUNDLFVBQUFBLFNBQVMsRUFBRSxJQUFaO0FBQWtCQyxVQUFBQSxLQUFLLEVBQUU7QUFBekIsU0FiZDtBQWNFO0FBQ0FDLFFBQUFBLGNBQWMsRUFBRTtBQUNkTCxVQUFBQSxjQUFjLEVBQUU7QUFBQ3ZELFlBQUFBLE1BQU0sRUFBTkEsTUFBRDtBQUFTSyxZQUFBQSxNQUFNLEVBQU5BLE1BQVQ7QUFBaUJDLFlBQUFBLE1BQU0sRUFBTkE7QUFBakIsV0FERjtBQUVkb0IsVUFBQUEsV0FBVyxFQUFFLEtBQUtULE1BQUwsQ0FBWUMsT0FGWDtBQUdkd0IsVUFBQUEsY0FBYyxFQUFFRixTQUFTLENBQUNxQjtBQUhaO0FBZmxCLFNBREssQ0FBUDtBQXVCRDs7O0VBbkgwQ0MscUIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQge1NjZW5lZ3JhcGhMYXllciBhcyBEZWNrU2NlbmVncmFwaExheWVyfSBmcm9tICdAZGVjay5nbC9tZXNoLWxheWVycyc7XG5pbXBvcnQge2xvYWR9IGZyb20gJ0Bsb2FkZXJzLmdsL2NvcmUnO1xuaW1wb3J0IHtHTFRGTG9hZGVyfSBmcm9tICdAbG9hZGVycy5nbC9nbHRmJztcblxuaW1wb3J0IExheWVyLCB7TGF5ZXJCYXNlQ29uZmlnLCBMYXllckNvbHVtbn0gZnJvbSAnLi4vYmFzZS1sYXllcic7XG5pbXBvcnQgU2NlbmVncmFwaExheWVySWNvbiBmcm9tICcuL3NjZW5lZ3JhcGgtbGF5ZXItaWNvbic7XG5pbXBvcnQgU2NlbmVncmFwaEluZm9Nb2RhbEZhY3RvcnkgZnJvbSAnLi9zY2VuZWdyYXBoLWluZm8tbW9kYWwnO1xuaW1wb3J0IHtMQVlFUl9WSVNfQ09ORklHUywgQ29sb3JSYW5nZX0gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtNZXJnZSwgVmlzQ29uZmlnQ29sb3JSYW5nZSwgVmlzQ29uZmlnTnVtYmVyfSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBLZXBsZXJUYWJsZX0gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5pbXBvcnQge0RhdGFDb250YWluZXJJbnRlcmZhY2V9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBTY2VuZWdyYXBoTGF5ZXJWaXNDb25maWdTZXR0aW5ncyA9IHtcbiAgb3BhY2l0eTogVmlzQ29uZmlnTnVtYmVyO1xuICBjb2xvclJhbmdlOiBWaXNDb25maWdDb2xvclJhbmdlO1xuICBzaXplU2NhbGU6IFZpc0NvbmZpZ051bWJlcjtcbiAgYW5nbGVYOiBWaXNDb25maWdOdW1iZXI7XG4gIGFuZ2xlWTogVmlzQ29uZmlnTnVtYmVyO1xuICBhbmdsZVo6IFZpc0NvbmZpZ051bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFNjZW5lZ3JhcGhMYXllckNvbHVtbnNDb25maWcgPSB7XG4gIGxhdDogTGF5ZXJDb2x1bW47XG4gIGxuZzogTGF5ZXJDb2x1bW47XG4gIGFsdGl0dWRlPzogTGF5ZXJDb2x1bW47XG59O1xuXG5leHBvcnQgdHlwZSBTY2VuZWdyYXBoTGF5ZXJWaXNDb25maWcgPSB7XG4gIG9wYWNpdHk6IG51bWJlcjtcbiAgY29sb3JSYW5nZTogQ29sb3JSYW5nZTtcbiAgc2l6ZVNjYWxlOiBudW1iZXI7XG4gIGFuZ2xlWDogbnVtYmVyO1xuICBhbmdsZVk6IG51bWJlcjtcbiAgYW5nbGVaOiBudW1iZXI7XG4gIHNjZW5lZ3JhcGg6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIFNjZW5lZ3JhcGhMYXllckNvbmZpZyA9IE1lcmdlPFxuICBMYXllckJhc2VDb25maWcsXG4gIHtjb2x1bW5zOiBTY2VuZWdyYXBoTGF5ZXJDb2x1bW5zQ29uZmlnOyB2aXNDb25maWc6IFNjZW5lZ3JhcGhMYXllclZpc0NvbmZpZ31cbj47XG5cbmV4cG9ydCB0eXBlIFNjZW5lZ3JhcGhMYXllckRhdGEgPSB7cG9zaXRpb246IG51bWJlcltdOyBpbmRleDogbnVtYmVyfTtcblxuZXhwb3J0IGNvbnN0IHNjZW5lZ3JhcGhSZXF1aXJlZENvbHVtbnM6IFsnbGF0JywgJ2xuZyddID0gWydsYXQnLCAnbG5nJ107XG5leHBvcnQgY29uc3Qgc2NlbmVncmFwaE9wdGlvbmFsQ29sdW1uczogWydhbHRpdHVkZSddID0gWydhbHRpdHVkZSddO1xuXG5mdW5jdGlvbiBmZXRjaCh1cmwsIHtwcm9wTmFtZSwgbGF5ZXJ9OiB7cHJvcE5hbWU/OiBzdHJpbmc7IGxheWVyPzogYW55fSA9IHt9KSB7XG4gIGlmIChwcm9wTmFtZSA9PT0gJ3NjZW5lZ3JhcGgnKSB7XG4gICAgcmV0dXJuIGxvYWQodXJsLCBHTFRGTG9hZGVyLCBsYXllci5nZXRMb2FkT3B0aW9ucygpKTtcbiAgfVxuXG4gIHJldHVybiBmZXRjaCh1cmwpLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKTtcbn1cblxuZXhwb3J0IGNvbnN0IHNjZW5lZ3JhcGhQb3NBY2Nlc3NvciA9ICh7bGF0LCBsbmcsIGFsdGl0dWRlfTogU2NlbmVncmFwaExheWVyQ29sdW1uc0NvbmZpZykgPT4gKFxuICBkYzogRGF0YUNvbnRhaW5lckludGVyZmFjZVxuKSA9PiBkID0+IFtcbiAgZGMudmFsdWVBdChkLmluZGV4LCBsbmcuZmllbGRJZHgpLFxuICBkYy52YWx1ZUF0KGQuaW5kZXgsIGxhdC5maWVsZElkeCksXG4gIGFsdGl0dWRlICYmIGFsdGl0dWRlLmZpZWxkSWR4ID4gLTEgPyBkYy52YWx1ZUF0KGQuaW5kZXgsIGFsdGl0dWRlLmZpZWxkSWR4KSA6IDBcbl07XG5cbmV4cG9ydCBjb25zdCBzY2VuZWdyYXBoVmlzQ29uZmlnczoge1xuICBvcGFjaXR5OiAnb3BhY2l0eSc7XG4gIGNvbG9yUmFuZ2U6ICdjb2xvclJhbmdlJztcbiAgLy9cbiAgc2l6ZVNjYWxlOiAnc2l6ZVNjYWxlJztcbiAgYW5nbGVYOiBWaXNDb25maWdOdW1iZXI7XG4gIGFuZ2xlWTogVmlzQ29uZmlnTnVtYmVyO1xuICBhbmdsZVo6IFZpc0NvbmZpZ051bWJlcjtcbn0gPSB7XG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgY29sb3JSYW5nZTogJ2NvbG9yUmFuZ2UnLFxuICAvL1xuICBzaXplU2NhbGU6ICdzaXplU2NhbGUnLFxuICBhbmdsZVg6IHtcbiAgICAuLi5MQVlFUl9WSVNfQ09ORklHUy5hbmdsZSxcbiAgICBwcm9wZXJ0eTogJ2FuZ2xlWCcsXG4gICAgbGFiZWw6ICdhbmdsZSBYJ1xuICB9LFxuICBhbmdsZVk6IHtcbiAgICAuLi5MQVlFUl9WSVNfQ09ORklHUy5hbmdsZSxcbiAgICBwcm9wZXJ0eTogJ2FuZ2xlWScsXG4gICAgbGFiZWw6ICdhbmdsZSBZJ1xuICB9LFxuICBhbmdsZVo6IHtcbiAgICAuLi5MQVlFUl9WSVNfQ09ORklHUy5hbmdsZSxcbiAgICBwcm9wZXJ0eTogJ2FuZ2xlWicsXG4gICAgZGVmYXVsdFZhbHVlOiA5MCxcbiAgICBsYWJlbDogJ2FuZ2xlIFonXG4gIH1cbn07XG5cbmNvbnN0IERFRkFVTFRfTU9ERUwgPVxuICAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0tocm9ub3NHcm91cC9nbFRGLVNhbXBsZS1Nb2RlbHMvbWFzdGVyLzIuMC9EdWNrL2dsVEYtQmluYXJ5L0R1Y2suZ2xiJztcbmNvbnN0IERFRkFVTFRfVFJBTlNJVElPTjogWzAsIDAsIDBdID0gWzAsIDAsIDBdO1xuY29uc3QgREVGQVVMVF9TQ0FMRTogWzEsIDEsIDFdID0gWzEsIDEsIDFdO1xuY29uc3QgREVGQVVMVF9DT0xPUjogWzI1NSwgMjU1LCAyNTUsIDI1NV0gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVncmFwaExheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBkZWNsYXJlIHZpc0NvbmZpZ1NldHRpbmdzOiBTY2VuZWdyYXBoTGF5ZXJWaXNDb25maWdTZXR0aW5ncztcbiAgZGVjbGFyZSBjb25maWc6IFNjZW5lZ3JhcGhMYXllckNvbmZpZztcblxuICBfbGF5ZXJJbmZvTW9kYWw6ICgpID0+IEpTWC5FbGVtZW50O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5yZWdpc3RlclZpc0NvbmZpZyhzY2VuZWdyYXBoVmlzQ29uZmlncyk7XG4gICAgdGhpcy5nZXRQb3NpdGlvbkFjY2Vzc29yID0gKGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2UpID0+XG4gICAgICBzY2VuZWdyYXBoUG9zQWNjZXNzb3IodGhpcy5jb25maWcuY29sdW1ucykoZGF0YUNvbnRhaW5lcik7XG5cbiAgICAvLyBwcmVwYXJlIGxheWVyIGluZm8gbW9kYWxcbiAgICB0aGlzLl9sYXllckluZm9Nb2RhbCA9IFNjZW5lZ3JhcGhJbmZvTW9kYWxGYWN0b3J5KCk7XG4gIH1cblxuICBnZXQgdHlwZSgpOiAnM0QnIHtcbiAgICByZXR1cm4gJzNEJztcbiAgfVxuXG4gIGdldCByZXF1aXJlZExheWVyQ29sdW1ucygpIHtcbiAgICByZXR1cm4gc2NlbmVncmFwaFJlcXVpcmVkQ29sdW1ucztcbiAgfVxuXG4gIGdldCBvcHRpb25hbENvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHNjZW5lZ3JhcGhPcHRpb25hbENvbHVtbnM7XG4gIH1cblxuICBnZXQgY29sdW1uUGFpcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFBvaW50Q29sdW1uUGFpcnM7XG4gIH1cblxuICBnZXQgbGF5ZXJJY29uKCkge1xuICAgIHJldHVybiBTY2VuZWdyYXBoTGF5ZXJJY29uO1xuICB9XG5cbiAgZ2V0IGxheWVySW5mb01vZGFsKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogJ3NjZW5lZ3JhcGhJbmZvJyxcbiAgICAgIHRlbXBsYXRlOiB0aGlzLl9sYXllckluZm9Nb2RhbCxcbiAgICAgIG1vZGFsUHJvcHM6IHtcbiAgICAgICAgdGl0bGU6ICdIb3cgdG8gdXNlIFNjZW5lZ3JhcGgnXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNhbGN1bGF0ZURhdGFBdHRyaWJ1dGUoe2RhdGFDb250YWluZXIsIGZpbHRlcmVkSW5kZXh9OiBLZXBsZXJUYWJsZSwgZ2V0UG9zaXRpb24pIHtcbiAgICBjb25zdCBkYXRhOiBTY2VuZWdyYXBoTGF5ZXJEYXRhW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyZWRJbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBmaWx0ZXJlZEluZGV4W2ldO1xuICAgICAgY29uc3QgcG9zOiBudW1iZXJbXSA9IGdldFBvc2l0aW9uKHtpbmRleH0pO1xuXG4gICAgICAvLyBpZiBkb2Vzbid0IGhhdmUgcG9pbnQgbGF0IG9yIGxuZywgZG8gbm90IGFkZCB0aGUgcG9pbnRcbiAgICAgIC8vIGRlY2suZ2wgY2FuJ3QgaGFuZGxlIHBvc2l0aW9uID0gbnVsbFxuICAgICAgaWYgKHBvcy5ldmVyeShOdW1iZXIuaXNGaW5pdGUpKSB7XG4gICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICBpbmRleFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBmb3JtYXRMYXllckRhdGEoZGF0YXNldHMsIG9sZExheWVyRGF0YSkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5kYXRhSWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3Qge2dwdUZpbHRlciwgZGF0YUNvbnRhaW5lcn0gPSBkYXRhc2V0c1t0aGlzLmNvbmZpZy5kYXRhSWRdO1xuICAgIGNvbnN0IHtkYXRhfSA9IHRoaXMudXBkYXRlRGF0YShkYXRhc2V0cywgb2xkTGF5ZXJEYXRhKTtcbiAgICBjb25zdCBnZXRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb25BY2Nlc3NvcihkYXRhQ29udGFpbmVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGdldFBvc2l0aW9uLFxuICAgICAgZ2V0RmlsdGVyVmFsdWU6IGdwdUZpbHRlci5maWx0ZXJWYWx1ZUFjY2Vzc29yKGRhdGFDb250YWluZXIpKClcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJNZXRhKGRhdGFDb250YWluZXIsIGdldFBvc2l0aW9uKSB7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRQb2ludHNCb3VuZHMoZGF0YUNvbnRhaW5lciwgZ2V0UG9zaXRpb24pO1xuICAgIHRoaXMudXBkYXRlTWV0YSh7Ym91bmRzfSk7XG4gIH1cblxuICByZW5kZXJMYXllcihvcHRzKSB7XG4gICAgY29uc3Qge2RhdGEsIGdwdUZpbHRlcn0gPSBvcHRzO1xuXG4gICAgY29uc3Qge1xuICAgICAgdmlzQ29uZmlnOiB7c2l6ZVNjYWxlID0gMSwgYW5nbGVYID0gMCwgYW5nbGVZID0gMCwgYW5nbGVaID0gOTB9XG4gICAgfSA9IHRoaXMuY29uZmlnO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBEZWNrU2NlbmVncmFwaExheWVyKHtcbiAgICAgICAgLi4udGhpcy5nZXREZWZhdWx0RGVja0xheWVyUHJvcHMob3B0cyksXG4gICAgICAgIC8vIGdwdSBkYXRhIGZpbHRlcmluZyBpcyBub3Qgc3VwcG9ydGVkIGF0IHRoZSBtb21lbnQgaW4gc2NlbmVncmFwaExheWVyIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9kZWNrLmdsL2lzc3Vlcy84MDk5XG4gICAgICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBmZXRjaCxcbiAgICAgICAgc2NlbmVncmFwaDogdGhpcy5jb25maWcudmlzQ29uZmlnLnNjZW5lZ3JhcGggfHwgREVGQVVMVF9NT0RFTCxcbiAgICAgICAgc2l6ZVNjYWxlLFxuICAgICAgICBnZXRUcmFuc2xhdGlvbjogREVGQVVMVF9UUkFOU0lUSU9OLFxuICAgICAgICBnZXRTY2FsZTogREVGQVVMVF9TQ0FMRSxcbiAgICAgICAgZ2V0T3JpZW50YXRpb246IFthbmdsZVgsIGFuZ2xlWSwgYW5nbGVaXSxcbiAgICAgICAgZ2V0Q29sb3I6IERFRkFVTFRfQ09MT1IsXG4gICAgICAgIC8vIHBhcmFtZXRlcnNcbiAgICAgICAgcGFyYW1ldGVyczoge2RlcHRoVGVzdDogdHJ1ZSwgYmxlbmQ6IGZhbHNlfSxcbiAgICAgICAgLy8gdXBkYXRlIHRyaWdnZXJzXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgZ2V0T3JpZW50YXRpb246IHthbmdsZVgsIGFuZ2xlWSwgYW5nbGVafSxcbiAgICAgICAgICBnZXRQb3NpdGlvbjogdGhpcy5jb25maWcuY29sdW1ucyxcbiAgICAgICAgICBnZXRGaWx0ZXJWYWx1ZTogZ3B1RmlsdGVyLmZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnNcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59XG4iXX0=