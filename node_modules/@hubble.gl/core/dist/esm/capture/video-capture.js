import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import download from 'downloadjs';
import { FrameEncoder } from '../encoders';
import { guid } from './utils';
export class VideoCapture {
  constructor() {
    _defineProperty(this, "recording", void 0);

    _defineProperty(this, "capturing", void 0);

    _defineProperty(this, "timeMs", void 0);

    _defineProperty(this, "timecode", void 0);

    _defineProperty(this, "encoder", void 0);

    _defineProperty(this, "filename", void 0);

    this.recording = false;
    this.capturing = false;
    this.timeMs = 0;
    this.timecode = null;
    this.encoder = null;
    this.filename = null;
    this._getNextTimeMs = this._getNextTimeMs.bind(this);
    this._step = this._step.bind(this);
    this._capture = this._capture.bind(this);
    this.capture = this.capture.bind(this);
    this.render = this.render.bind(this);
    this.download = this.download.bind(this);
    this.stop = this.stop.bind(this);
    this._save = this._save.bind(this);
  }

  isRecording() {
    return this.recording;
  }

  render(_ref) {
    let {
      Encoder,
      formatConfigs,
      timecode,
      filename = undefined,
      onStop = undefined
    } = _ref;

    if (!this.isRecording()) {
      console.time('render');
      this.filename = this._sanitizeFilename(filename);
      this.timecode = this._sanatizeTimecode(timecode);
      console.log("Starting recording for ".concat(this.timecode.duration, "ms."));
      this.onStop = onStop;
      this.encoder = new Encoder({ ...formatConfigs,
        framerate: this.timecode.framerate
      });
      this.recording = true;
      this.encoder.start();
    }
  }

  capture(canvas, proceedToNextFrame) {
    if (!this.capturing && this.isRecording()) {
      this.capturing = true;

      this._capture(canvas).then(data => {
        this.capturing = false;

        if (data.kind === 'next-frame') {
          proceedToNextFrame(data.nextTimeMs);
        } else if (data.kind === 'stop') {
          this.onStop();
        } else {
          console.log(data);
        }
      });
    }
  }

  stop(_ref2) {
    let {
      onComplete = undefined,
      onSave = undefined,
      onStopped = undefined,
      abort = false
    } = _ref2;

    if (this.isRecording()) {
      console.log("Stopped recording. Recorded for ".concat(this.timeMs, "ms."));
      this.recording = false;
      this.capturing = false;

      if (onStopped) {
        onStopped();
      }

      console.timeEnd('render');

      const finish = () => {
        if (onComplete) {
          onComplete();
        }

        this.timecode = null;
        this.onStop = undefined;
      };

      if (!abort) {
        this._save(onSave).then(finish);
      }

      finish();
    }
  }

  download(blob) {
    if (blob) {
      download(blob, this.filename + this.encoder.extension, this.encoder.mimeType);
    }

    return false;
  }

  async _save(callback) {
    if (!callback) {
      callback = this.download;
    }

    console.time('save');
    await this.encoder.save().then(callback).then(() => console.timeEnd('save'));
  }

  _sanitizeFilename(filename) {
    if (!filename) {
      filename = guid();
    }

    return filename;
  }

  _sanatizeTimecode(timecode) {
    const parsedTimecode = {
      duration: undefined,
      ...timecode
    };

    if (!parsedTimecode.start) {
      parsedTimecode.start = 0;
    }

    this.timeMs = parsedTimecode.start;

    if (!parsedTimecode.duration) {
      parsedTimecode.duration = parsedTimecode.end - parsedTimecode.start;
    }

    if (parsedTimecode.duration <= 0) {
      throw new Error("Invalid recording length (".concat(parsedTimecode.duration, "ms).  Must be greater than 0."));
    }

    return parsedTimecode;
  }

  async _capture(canvas) {
    if (!this.isRecording()) {
      return {
        kind: 'error',
        error: 'NOT_RECORDING'
      };
    }

    return await this.encoder.add(canvas).then(this._step).catch(reason => ({
      kind: 'error',
      error: reason
    }));
  }

  _step() {
    const nextTimeMs = this._getNextTimeMs();

    if (nextTimeMs > this.timecode.end) {
      return {
        kind: 'stop'
      };
    }

    this.timeMs = nextTimeMs;
    return {
      kind: 'next-frame',
      nextTimeMs
    };
  }

  _getNextTimeMs() {
    const frameLengthMs = Math.floor(1000.0 / this.timecode.framerate);
    return this.timeMs + frameLengthMs;
  }

}
//# sourceMappingURL=video-capture.js.map