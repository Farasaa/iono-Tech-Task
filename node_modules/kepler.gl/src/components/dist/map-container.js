"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = MapContainerFactory;
exports.Attribution = exports.Droppable = exports.isSplitSelector = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));

var _react = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _maplibre = require("react-map-gl/maplibre");

var _react2 = _interopRequireDefault(require("@deck.gl/react"));

var _reselect = require("reselect");

var _maplibreGl = _interopRequireDefault(require("maplibre-gl"));

var _core = require("@dnd-kit/core");

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _mapPopover = _interopRequireDefault(require("./map/map-popover"));

var _mapControl = _interopRequireDefault(require("./map/map-control"));

var _styledComponents2 = require("./common/styled-components");

var _editor = _interopRequireDefault(require("./editor/editor"));

var _layers = require("@kepler.gl/layers");

var _utils = require("@kepler.gl/utils");

var _styles = require("@kepler.gl/styles");

var _constants = require("@kepler.gl/constants");

var _mapViewStateContext = require("./map-view-state-context");

var _errorBoundary = _interopRequireDefault(require("./common/error-boundary"));

var _localization = require("@kepler.gl/localization");

var _core2 = require("@deck.gl/core");

var _reducers = require("@kepler.gl/reducers");

var _templateObject, _templateObject2;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// Debounce the propagation of viewport change and mouse moves to redux store.
// This is to avoid too many renders of other components when the map is
// being panned/zoomed (leading to laggy basemap/deck syncing).
var DEBOUNCE_VIEWPORT_PROPAGATE = 10;
var DEBOUNCE_MOUSE_MOVE_PROPAGATE = 10;
/** @type {{[key: string]: React.CSSProperties}} */

var MAP_STYLE = {
  container: {
    display: 'inline-block',
    position: 'relative',
    width: '100%',
    height: '100%'
  },
  top: {
    position: 'absolute',
    top: 0,
    width: '100%',
    height: '100%',
    pointerEvents: 'none'
  }
};
var LOCALE_CODES_ARRAY = Object.keys(_localization.LOCALE_CODES);
var StyledMap = (0, _styledComponents["default"])(_styledComponents2.StyledMapContainer)(function (_ref) {
  var _ref$mixBlendMode = _ref.mixBlendMode,
      mixBlendMode = _ref$mixBlendMode === void 0 ? 'normal' : _ref$mixBlendMode;
  return "\n  #default-deckgl-overlay {\n    mix-blend-mode: ".concat(mixBlendMode, ";\n  };\n  *[maplibregl-children] {\n    position: absolute;\n  }\n");
});
var MAPBOXGL_STYLE_UPDATE = 'style.load';
var MAPBOXGL_RENDER = 'render';

var nop = function nop() {};

var MapLibreLogo = function MapLibreLogo() {
  return /*#__PURE__*/_react["default"].createElement("div", {
    className: "attrition-logo"
  }, "Basemap by:", /*#__PURE__*/_react["default"].createElement("a", {
    style: {
      marginLeft: "5px"
    },
    className: "maplibregl-ctrl-logo",
    target: "_blank",
    rel: "noopener noreferrer",
    href: "https://www.maplibre.org/",
    "aria-label": "MapLibre logo"
  }));
};

var StyledDroppable = _styledComponents["default"].div(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["\n  background-color: ", ";\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  pointer-events: none;\n  z-index: 1;\n"])), function (props) {
  return props.isOver ? props.theme.dndOverBackgroundColor : 'none';
});

var isSplitSelector = function isSplitSelector(props) {
  return props.visState.splitMaps && props.visState.splitMaps.length > 1;
};

exports.isSplitSelector = isSplitSelector;

var Droppable = function Droppable(_ref2) {
  var containerId = _ref2.containerId;

  var _useDroppable = (0, _core.useDroppable)({
    id: containerId,
    data: {
      type: _constants.DROPPABLE_MAP_CONTAINER_TYPE,
      index: containerId
    },
    disabled: !containerId
  }),
      isOver = _useDroppable.isOver,
      setNodeRef = _useDroppable.setNodeRef;

  return /*#__PURE__*/_react["default"].createElement(StyledDroppable, {
    ref: setNodeRef,
    isOver: isOver
  });
};

exports.Droppable = Droppable;

var StyledDatasetAttributionsContainer = _styledComponents["default"].div(_templateObject2 || (_templateObject2 = (0, _taggedTemplateLiteral2["default"])(["\n  max-width: ", ";\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n  color: ", ";\n  margin-right: 2px;\n  line-height: ", ";\n  :hover {\n    white-space: inherit;\n  }\n"])), function (props) {
  return props.isPalm ? '130px' : '180px';
}, function (props) {
  return props.theme.labelColor;
}, function (props) {
  return props.isPalm ? '1em' : '1.4em';
});

var DatasetAttributions = function DatasetAttributions(_ref3) {
  var datasetAttributions = _ref3.datasetAttributions,
      isPalm = _ref3.isPalm;
  return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, datasetAttributions !== null && datasetAttributions !== void 0 && datasetAttributions.length ? /*#__PURE__*/_react["default"].createElement(StyledDatasetAttributionsContainer, {
    isPalm: isPalm
  }, datasetAttributions.map(function (ds, idx) {
    return /*#__PURE__*/_react["default"].createElement("a", (0, _extends2["default"])({}, ds.url ? {
      href: ds.url
    } : null, {
      target: "_blank",
      rel: "noopener noreferrer",
      key: "".concat(ds.title, "_").concat(idx)
    }), ds.title, idx !== datasetAttributions.length - 1 ? ', ' : null);
  })) : null);
};

var Attribution = function Attribution(_ref4) {
  var _ref4$showMapboxLogo = _ref4.showMapboxLogo,
      showMapboxLogo = _ref4$showMapboxLogo === void 0 ? true : _ref4$showMapboxLogo,
      _ref4$showOsmBasemapA = _ref4.showOsmBasemapAttribution,
      showOsmBasemapAttribution = _ref4$showOsmBasemapA === void 0 ? false : _ref4$showOsmBasemapA,
      datasetAttributions = _ref4.datasetAttributions;
  var isPalm = (0, _utils.hasMobileWidth)(_styles.breakPointValues);
  var memoizedComponents = (0, _react.useMemo)(function () {
    if (!showMapboxLogo) {
      return /*#__PURE__*/_react["default"].createElement(_styledComponents2.StyledAttrbution, null, /*#__PURE__*/_react["default"].createElement(_styledComponents2.EndHorizontalFlexbox, null, /*#__PURE__*/_react["default"].createElement(DatasetAttributions, {
        datasetAttributions: datasetAttributions,
        isPalm: isPalm
      }), showOsmBasemapAttribution ? /*#__PURE__*/_react["default"].createElement("div", {
        className: "attrition-link"
      }, datasetAttributions !== null && datasetAttributions !== void 0 && datasetAttributions.length ? /*#__PURE__*/_react["default"].createElement("span", {
        className: "pipe-separator"
      }, "|") : null, /*#__PURE__*/_react["default"].createElement("a", {
        href: "http://www.openstreetmap.org/copyright",
        target: "_blank",
        rel: "noopener noreferrer"
      }, "\xA9 OpenStreetMap")) : null));
    }

    return /*#__PURE__*/_react["default"].createElement(_styledComponents2.StyledAttrbution, null, /*#__PURE__*/_react["default"].createElement(_styledComponents2.EndHorizontalFlexbox, null, /*#__PURE__*/_react["default"].createElement(DatasetAttributions, {
      datasetAttributions: datasetAttributions,
      isPalm: isPalm
    }), /*#__PURE__*/_react["default"].createElement("div", {
      className: "attrition-link"
    }, datasetAttributions !== null && datasetAttributions !== void 0 && datasetAttributions.length ? /*#__PURE__*/_react["default"].createElement("span", {
      className: "pipe-separator"
    }, "|") : null, isPalm ? /*#__PURE__*/_react["default"].createElement(MapLibreLogo, null) : null, /*#__PURE__*/_react["default"].createElement("a", {
      href: "https://kepler.gl/policy/",
      target: "_blank",
      rel: "noopener noreferrer"
    }, "\xA9 kepler.gl |", ' '), !isPalm ? /*#__PURE__*/_react["default"].createElement(MapLibreLogo, null) : null)));
  }, [showMapboxLogo, showOsmBasemapAttribution, datasetAttributions, isPalm]);
  return memoizedComponents;
};

exports.Attribution = Attribution;
MapContainerFactory.deps = [_mapPopover["default"], _mapControl["default"], _editor["default"]];

function MapContainerFactory(MapPopover, MapControl, Editor) {
  var MapContainer = /*#__PURE__*/function (_Component) {
    (0, _inherits2["default"])(MapContainer, _Component);

    var _super = _createSuper(MapContainer);

    function MapContainer(_props) {
      var _this;

      (0, _classCallCheck2["default"])(this, MapContainer);
      _this = _super.call(this, _props);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "displayName", 'MapContainer');
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "state", {
        // Determines whether attribution should be visible based the result of loading the map style
        showMapboxAttribution: true
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_deck", null);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_map", null);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_ref", /*#__PURE__*/(0, _react.createRef)());
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_deckGLErrorsElapsed", {});
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "previousLayers", {// [layers.id]: mapboxLayerConfig
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleResize", function (dimensions) {
        var _this$props = _this.props,
            primary = _this$props.primary,
            index = _this$props.index;

        if (primary) {
          var mapStateActions = _this.props.mapStateActions;

          if (dimensions && dimensions.width > 0 && dimensions.height > 0) {
            mapStateActions.updateMap(dimensions, index);
          }
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layersSelector", function (props) {
        return props.visState.layers;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layerDataSelector", function (props) {
        return props.visState.layerData;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "splitMapSelector", function (props) {
        return props.visState.splitMaps;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "splitMapIndexSelector", function (props) {
        return props.index;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "mapLayersSelector", (0, _reselect.createSelector)(_this.splitMapSelector, _this.splitMapIndexSelector, _utils.getMapLayersFromSplitMaps));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layerOrderSelector", function (props) {
        return props.visState.layerOrder;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layersToRenderSelector", (0, _reselect.createSelector)(_this.layersSelector, _this.layerDataSelector, _this.mapLayersSelector, _reducers.prepareLayersToRender));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layersForDeckSelector", (0, _reselect.createSelector)(_this.layersSelector, _this.layerDataSelector, _reducers.prepareLayersForDeck));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "filtersSelector", function (props) {
        return props.visState.filters;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "polygonFiltersSelector", (0, _reselect.createSelector)(_this.filtersSelector, function (filters) {
        return filters.filter(function (f) {
          return f.type === _constants.FILTER_TYPES.polygon && f.enabled !== false;
        });
      }));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "featuresSelector", function (props) {
        return props.visState.editor.features;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "selectedFeatureSelector", function (props) {
        return props.visState.editor.selectedFeature;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "featureCollectionSelector", (0, _reselect.createSelector)(_this.polygonFiltersSelector, _this.featuresSelector, function (polygonFilters, features) {
        return {
          type: 'FeatureCollection',
          features: features.concat(polygonFilters.map(function (f) {
            return f.value;
          }))
        };
      }));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "selectedPolygonIndexSelector", (0, _reselect.createSelector)(_this.featureCollectionSelector, _this.selectedFeatureSelector, function (collection, selectedFeature) {
        return collection.features.findIndex(function (f) {
          return f.id === (selectedFeature === null || selectedFeature === void 0 ? void 0 : selectedFeature.id);
        });
      }));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "selectedFeatureIndexArraySelector", (0, _reselect.createSelector)(function (value) {
        return value;
      }, function (value) {
        return value < 0 ? [] : [value];
      }));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "generateMapboxLayerMethodSelector", function (props) {
        var _props$generateMapbox;

        return (_props$generateMapbox = props.generateMapboxLayers) !== null && _props$generateMapbox !== void 0 ? _props$generateMapbox : _layers.generateMapboxLayers;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "mapboxLayersSelector", (0, _reselect.createSelector)(_this.layersSelector, _this.layerDataSelector, _this.layerOrderSelector, _this.layersToRenderSelector, _this.generateMapboxLayerMethodSelector, function (layer, layerData, layerOrder, layersToRender, generateMapboxLayerMethod) {
        return generateMapboxLayerMethod(layer, layerData, layerOrder, layersToRender);
      }));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "mapStyleTypeSelector", function (props) {
        return props.mapStyle.styleType;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "mapStyleBackgroundColorSelector", function (props) {
        return props.mapStyle.backgroundColor;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "styleSelector", (0, _reselect.createSelector)(_this.mapStyleTypeSelector, _this.mapStyleBackgroundColorSelector, function (styleType, backgroundColor) {
        return _objectSpread(_objectSpread({}, MAP_STYLE.container), styleType === _constants.NO_MAP_ID ? {
          backgroundColor: (0, _utils.rgbToHex)(backgroundColor)
        } : {});
      }));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onCloseMapPopover", function () {
        _this.props.visStateActions.onLayerClick(null);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onLayerHover", function (idx, info) {
        _this.props.visStateActions.onLayerHover(info);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onLayerSetDomain", function (idx, colorDomain) {
        _this.props.visStateActions.layerConfigChange(_this.props.visState.layers[idx], {
          colorDomain: colorDomain
        });
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleMapToggleLayer", function (layerId) {
        var _this$props2 = _this.props,
            _this$props2$index = _this$props2.index,
            mapIndex = _this$props2$index === void 0 ? 0 : _this$props2$index,
            visStateActions = _this$props2.visStateActions;
        visStateActions.toggleLayerForMap(mapIndex, layerId);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onMapboxStyleUpdate", function (update) {
        // force refresh mapboxgl layers
        _this.previousLayers = {};

        _this._updateMapboxLayers();

        if (update && update.style) {
          // No attributions are needed if the style doesn't reference Mapbox sources
          _this.setState({
            showMapboxAttribution: (0, _utils.isStyleUsingMapboxTiles)(update.style)
          });
        }

        if (typeof _this.props.onMapStyleLoaded === 'function') {
          _this.props.onMapStyleLoaded(_this._map);
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_setMapboxMap", function (mapbox) {
        if (!_this._map && mapbox) {
          _this._map = mapbox.getMap(); // i noticed in certain context we don't access the actual map element

          if (!_this._map) {
            return;
          } // bind mapboxgl event listener


          _this._map.on(MAPBOXGL_STYLE_UPDATE, _this._onMapboxStyleUpdate);

          _this._map.on(MAPBOXGL_RENDER, function () {
            if (typeof _this.props.onMapRender === 'function') {
              _this.props.onMapRender(_this._map);
            }
          });
        }

        if (_this.props.getMapboxRef) {
          // The parent component can gain access to our MapboxGlMap by
          // providing this callback. Note that 'mapbox' will be null when the
          // ref is unset (e.g. when a split map is closed).
          _this.props.getMapboxRef(mapbox, _this.props.index);
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onBeforeRender", function (_ref5) {
        var gl = _ref5.gl;
        (0, _utils.setLayerBlending)(gl, _this.props.visState.layerBlending);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onDeckError", function (error, layer) {
        var errorMessage = (error === null || error === void 0 ? void 0 : error.message) || 'unknown-error';
        var layerMessage = layer !== null && layer !== void 0 && layer.id ? " in ".concat(layer.id, " layer") : '';
        var errorMessageFull = errorMessage === 'WebGL context is lost' ? 'Your GPU was disconnected. This can happen if your computer goes to sleep. It can also occur for other reasons, such as if you are running too many GPU applications.' : "An error in deck.gl: ".concat(errorMessage).concat(layerMessage, "."); // Throttle error notifications, as React doesn't like too many state changes from here.

        var lastShown = _this._deckGLErrorsElapsed[errorMessageFull];

        if (!lastShown || lastShown < Date.now() - _constants.THROTTLE_NOTIFICATION_TIME) {
          _this._deckGLErrorsElapsed[errorMessageFull] = Date.now(); // Mark layer as invalid

          var extraLayerMessage = '';
          var visStateActions = _this.props.visStateActions;

          if (layer) {
            var _topMostLayer$props;

            var topMostLayer = layer;

            while (topMostLayer.parent) {
              topMostLayer = topMostLayer.parent;
            }

            if ((_topMostLayer$props = topMostLayer.props) !== null && _topMostLayer$props !== void 0 && _topMostLayer$props.id) {
              visStateActions.layerSetIsValid(topMostLayer, false);
              extraLayerMessage = 'The layer has been disabled and highlighted.';
            }
          } // Create new error notification or update existing one with same id.
          // Update is required to preserve the order of notifications as they probably are going to "jump" based on order of errors.


          var uiStateActions = _this.props.uiStateActions;
          uiStateActions.addNotification((0, _utils.errorNotification)({
            message: "".concat(errorMessageFull, " ").concat(extraLayerMessage),
            id: errorMessageFull // treat the error message as id

          }));
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onViewportChangePropagateDebounced", (0, _lodash["default"])(function () {
        var _this$context;

        var viewState = (_this$context = _this.context) === null || _this$context === void 0 ? void 0 : _this$context.getInternalViewState(_this.props.index);
        (0, _utils.onViewPortChange)(viewState, _this.props.mapStateActions.updateMap, _this.props.onViewStateChange, _this.props.primary, _this.props.index);
      }, DEBOUNCE_VIEWPORT_PROPAGATE));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onViewportChange", function (viewport) {
        var viewState = viewport.viewState;

        if (_this.props.isExport) {
          // Image export map shouldn't be interactive (otherwise this callback can
          // lead to inadvertent changes to the state of the main map)
          return;
        }

        var setInternalViewState = _this.context.setInternalViewState;
        setInternalViewState(viewState, _this.props.index);

        _this._onViewportChangePropagateDebounced();
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onLayerHoverDebounced", (0, _lodash["default"])(function (data, index, event) {
        // add `mapIndex` property which will end up in the the `hoverInfo` object of `visState`
        // this is for limiting the display of the `<MapPopover>` to the `<MapContainer>` the user is interacting with
        // TODO this should be part of onLayerHover arguments, investigate
        // @ts-ignore (does not fail with local yarn-test)
        data.mapIndex = index;

        _this.props.visStateActions.onLayerHover(data);
      }, DEBOUNCE_MOUSE_MOVE_PROPAGATE));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onMouseMoveDebounced", (0, _lodash["default"])(function (event, viewport) {
        _this.props.visStateActions.onMouseMove((0, _utils.normalizeEvent)(event, viewport));
      }, DEBOUNCE_MOUSE_MOVE_PROPAGATE));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_toggleMapControl", function (panelId) {
        var _this$props3 = _this.props,
            index = _this$props3.index,
            uiStateActions = _this$props3.uiStateActions;
        uiStateActions.toggleMapControl(panelId, Number(index));
      });
      return _this;
    }

    (0, _createClass2["default"])(MapContainer, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (!this._ref.current) {
          return;
        }

        (0, _utils.observeDimensions)(this._ref.current, this._handleResize);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        // unbind mapboxgl event listener
        if (this._map) {
          var _this$_map, _this$_map2;

          (_this$_map = this._map) === null || _this$_map === void 0 ? void 0 : _this$_map.off(MAPBOXGL_STYLE_UPDATE, nop);
          (_this$_map2 = this._map) === null || _this$_map2 === void 0 ? void 0 : _this$_map2.off(MAPBOXGL_RENDER, nop);
        }

        if (!this._ref.current) {
          return;
        }

        (0, _utils.unobserveDimensions)(this._ref.current);
      }
    }, {
      key: "_onDeckInitialized",
      value: function _onDeckInitialized(gl) {
        if (this.props.onDeckInitialized) {
          this.props.onDeckInitialized(this._deck, gl);
        }
      }
      /**
       * 1) Allow effects only for the first view.
       * 2) Prevent effect:preRender call without valid generated viewports.
       * @param viewIndex View index.
       * @returns Returns true if effects can be used.
       */

    }, {
      key: "_isOKToRenderEffects",
      value: function _isOKToRenderEffects(viewIndex) {
        var _this$_deck, _this$_deck$viewManag, _this$_deck$viewManag2;

        return !viewIndex && Boolean((_this$_deck = this._deck) === null || _this$_deck === void 0 ? void 0 : (_this$_deck$viewManag = _this$_deck.viewManager) === null || _this$_deck$viewManag === void 0 ? void 0 : (_this$_deck$viewManag2 = _this$_deck$viewManag._viewports) === null || _this$_deck$viewManag2 === void 0 ? void 0 : _this$_deck$viewManag2.length);
      }
    }, {
      key: "_renderMapPopover",
      value:
      /* component render functions */

      /* eslint-disable complexity */
      function _renderMapPopover() {
        var _this$props$visState$;

        // this check is for limiting the display of the `<MapPopover>` to the `<MapContainer>` the user is interacting with
        // the DeckGL onHover event handler adds a `mapIndex` property which is available in the `hoverInfo` object of `visState`
        if (this.props.index !== ((_this$props$visState$ = this.props.visState.hoverInfo) === null || _this$props$visState$ === void 0 ? void 0 : _this$props$visState$.mapIndex)) {
          return null;
        } // TODO: move this into reducer so it can be tested


        var _this$props4 = this.props,
            mapState = _this$props4.mapState,
            _this$props4$visState = _this$props4.visState,
            hoverInfo = _this$props4$visState.hoverInfo,
            clicked = _this$props4$visState.clicked,
            datasets = _this$props4$visState.datasets,
            interactionConfig = _this$props4$visState.interactionConfig,
            layers = _this$props4$visState.layers,
            _this$props4$visState2 = _this$props4$visState.mousePos,
            mousePosition = _this$props4$visState2.mousePosition,
            coordinate = _this$props4$visState2.coordinate,
            pinned = _this$props4$visState2.pinned;
        var layersToRender = this.layersToRenderSelector(this.props);

        if (!mousePosition || !interactionConfig.tooltip) {
          return null;
        }

        var layerHoverProp = (0, _reducers.getLayerHoverProp)({
          interactionConfig: interactionConfig,
          hoverInfo: hoverInfo,
          layers: layers,
          layersToRender: layersToRender,
          datasets: datasets
        });
        var compareMode = interactionConfig.tooltip.config ? interactionConfig.tooltip.config.compareMode : false;
        var pinnedPosition = {
          x: 0,
          y: 0
        };
        var layerPinnedProp = null;

        if (pinned || clicked) {
          // project lnglat to screen so that tooltip follows the object on zoom
          var _viewport = (0, _utils.getViewportFromMapState)(mapState);

          var lngLat = clicked ? clicked.coordinate : pinned.coordinate;
          pinnedPosition = this._getHoverXY(_viewport, lngLat);
          layerPinnedProp = (0, _reducers.getLayerHoverProp)({
            interactionConfig: interactionConfig,
            hoverInfo: clicked,
            layers: layers,
            layersToRender: layersToRender,
            datasets: datasets
          });

          if (layerHoverProp && layerPinnedProp) {
            layerHoverProp.primaryData = layerPinnedProp.data;
            layerHoverProp.compareType = interactionConfig.tooltip.config.compareType;
          }
        }

        var commonProp = {
          onClose: this._onCloseMapPopover,
          zoom: mapState.zoom,
          container: this._deck ? this._deck.canvas : undefined
        };
        return /*#__PURE__*/_react["default"].createElement(_errorBoundary["default"], null, layerPinnedProp && /*#__PURE__*/_react["default"].createElement(MapPopover, (0, _extends2["default"])({}, pinnedPosition, commonProp, {
          layerHoverProp: layerPinnedProp,
          coordinate: interactionConfig.coordinate.enabled && (pinned || {}).coordinate,
          frozen: true,
          isBase: compareMode,
          onSetFeatures: this.props.visStateActions.setFeatures,
          setSelectedFeature: this.props.visStateActions.setSelectedFeature,
          featureCollection: this.featureCollectionSelector(this.props)
        })), layerHoverProp && (!layerPinnedProp || compareMode) && /*#__PURE__*/_react["default"].createElement(MapPopover, (0, _extends2["default"])({
          x: mousePosition[0],
          y: mousePosition[1]
        }, commonProp, {
          layerHoverProp: layerHoverProp,
          frozen: false,
          coordinate: interactionConfig.coordinate.enabled && coordinate,
          onSetFeatures: this.props.visStateActions.setFeatures,
          setSelectedFeature: this.props.visStateActions.setSelectedFeature,
          featureCollection: this.featureCollectionSelector(this.props)
        })));
      }
      /* eslint-enable complexity */

    }, {
      key: "_getHoverXY",
      value: function _getHoverXY(viewport, lngLat) {
        var screenCoord = !viewport || !lngLat ? null : viewport.project(lngLat);
        return screenCoord && {
          x: screenCoord[0],
          y: screenCoord[1]
        };
      }
    }, {
      key: "_renderDeckOverlay",
      value: function _renderDeckOverlay(layersForDeck) {
        var _this$context2,
            _this2 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          primaryMap: false
        };
        var _this$props5 = this.props,
            mapStyle = _this$props5.mapStyle,
            visState = _this$props5.visState,
            mapState = _this$props5.mapState,
            visStateActions = _this$props5.visStateActions,
            mapboxApiAccessToken = _this$props5.mapboxApiAccessToken,
            mapboxApiUrl = _this$props5.mapboxApiUrl,
            deckGlProps = _this$props5.deckGlProps,
            index = _this$props5.index,
            mapControls = _this$props5.mapControls,
            deckRenderCallbacks = _this$props5.deckRenderCallbacks,
            theme = _this$props5.theme,
            generateDeckGLLayers = _this$props5.generateDeckGLLayers,
            onMouseMove = _this$props5.onMouseMove;
        var hoverInfo = visState.hoverInfo,
            editor = visState.editor;
        var primaryMap = options.primaryMap,
            isInteractive = options.isInteractive,
            children = options.children; // disable double click zoom when editor is in any draw mode

        var mapDraw = mapControls.mapDraw;

        var _ref6 = mapDraw || {},
            _ref6$active = _ref6.active,
            editorMenuActive = _ref6$active === void 0 ? false : _ref6$active;

        var isEditorDrawingMode = _layers.EditorLayerUtils.isDrawingActive(editorMenuActive, editor.mode);

        var internalViewState = (_this$context2 = this.context) === null || _this$context2 === void 0 ? void 0 : _this$context2.getInternalViewState(index);

        var internalMapState = _objectSpread(_objectSpread({}, mapState), internalViewState);

        var viewport = (0, _utils.getViewportFromMapState)(internalMapState);
        var editorFeatureSelectedIndex = this.selectedPolygonIndexSelector(this.props);
        var setFeatures = visStateActions.setFeatures,
            onLayerClick = visStateActions.onLayerClick,
            setSelectedFeature = visStateActions.setSelectedFeature;
        var generateDeckGLLayersMethod = generateDeckGLLayers !== null && generateDeckGLLayers !== void 0 ? generateDeckGLLayers : _reducers.computeDeckLayers;
        var deckGlLayers = generateDeckGLLayersMethod({
          visState: visState,
          mapState: internalMapState,
          mapStyle: mapStyle
        }, {
          mapIndex: index,
          primaryMap: primaryMap,
          mapboxApiAccessToken: mapboxApiAccessToken,
          mapboxApiUrl: mapboxApiUrl,
          layersForDeck: layersForDeck,
          editorInfo: primaryMap ? {
            editor: editor,
            editorMenuActive: editorMenuActive,
            onSetFeatures: setFeatures,
            setSelectedFeature: setSelectedFeature,
            featureCollection: this.featureCollectionSelector(this.props),
            selectedFeatureIndexes: this.selectedFeatureIndexArraySelector(editorFeatureSelectedIndex),
            viewport: viewport
          } : undefined
        }, {
          onLayerHover: this._onLayerHover,
          onSetLayerDomain: this._onLayerSetDomain
        }, deckGlProps);
        var extraDeckParams = {};

        if (primaryMap) {
          extraDeckParams.getTooltip = function (info) {
            return _layers.EditorLayerUtils.getTooltip(info, {
              editorMenuActive: editorMenuActive,
              editor: editor,
              theme: theme
            });
          };

          extraDeckParams.getCursor = function (_ref7) {
            var isDragging = _ref7.isDragging;

            var editorCursor = _layers.EditorLayerUtils.getCursor({
              editorMenuActive: editorMenuActive,
              editor: editor,
              hoverInfo: hoverInfo
            });

            if (editorCursor) return editorCursor;
            if (isDragging) return 'grabbing';
            if (hoverInfo !== null && hoverInfo !== void 0 && hoverInfo.layer) return 'pointer';
            return 'grab';
          };
        }

        var effects = this._isOKToRenderEffects(index) ? (0, _utils.computeDeckEffects)({
          visState: visState,
          mapState: mapState
        }) : [];
        var views = deckGlProps !== null && deckGlProps !== void 0 && deckGlProps.views ? deckGlProps === null || deckGlProps === void 0 ? void 0 : deckGlProps.views() : new _core2.MapView({
          legacyMeterSizes: true
        });

        var allDeckGlProps = _objectSpread(_objectSpread({}, deckGlProps), {}, {
          pickingRadius: _constants.DEFAULT_PICKING_RADIUS,
          views: views,
          layers: deckGlLayers,
          effects: effects
        });

        if (typeof (deckRenderCallbacks === null || deckRenderCallbacks === void 0 ? void 0 : deckRenderCallbacks.onDeckRender) === 'function') {
          allDeckGlProps = deckRenderCallbacks.onDeckRender(allDeckGlProps);

          if (!allDeckGlProps) {
            // if onDeckRender returns null, do not render deck.gl
            return null;
          }
        }

        return /*#__PURE__*/_react["default"].createElement("div", isInteractive ? {
          onMouseMove: primaryMap ? function (event) {
            onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(event);

            _this2._onMouseMoveDebounced(event, viewport);
          } : undefined
        } : {
          style: {
            pointerEvents: 'none'
          }
        }, /*#__PURE__*/_react["default"].createElement(_react2["default"], (0, _extends2["default"])({
          id: "default-deckgl-overlay",
          onLoad: function onLoad() {
            if (typeof (deckRenderCallbacks === null || deckRenderCallbacks === void 0 ? void 0 : deckRenderCallbacks.onDeckLoad) === 'function') {
              deckRenderCallbacks.onDeckLoad();
            }
          }
        }, allDeckGlProps, {
          controller: isInteractive ? {
            doubleClickZoom: !isEditorDrawingMode,
            dragRotate: this.props.mapState.dragRotate
          } : false,
          initialViewState: internalViewState,
          onBeforeRender: this._onBeforeRender,
          onViewStateChange: isInteractive ? this._onViewportChange : undefined
        }, extraDeckParams, {
          onHover: isInteractive ? function (data, event) {
            var res = _layers.EditorLayerUtils.onHover(data, {
              editorMenuActive: editorMenuActive,
              editor: editor,
              hoverInfo: hoverInfo
            });

            if (res) return;

            _this2._onLayerHoverDebounced(data, index, event);
          } : null,
          onClick: function onClick(data, event) {
            // @ts-ignore
            (0, _utils.normalizeEvent)(event.srcEvent, viewport);

            var res = _layers.EditorLayerUtils.onClick(data, event, {
              editorMenuActive: editorMenuActive,
              editor: editor,
              onLayerClick: onLayerClick,
              setSelectedFeature: setSelectedFeature,
              mapIndex: index
            });

            if (res) return;
            visStateActions.onLayerClick(data);
          },
          onError: this._onDeckError,
          ref: function ref(comp) {
            // @ts-ignore
            if (comp && comp.deck && !_this2._deck) {
              // @ts-ignore
              _this2._deck = comp.deck;
            }
          },
          onWebGLInitialized: function onWebGLInitialized(gl) {
            return _this2._onDeckInitialized(gl);
          },
          onAfterRender: function onAfterRender() {
            if (typeof (deckRenderCallbacks === null || deckRenderCallbacks === void 0 ? void 0 : deckRenderCallbacks.onDeckAfterRender) === 'function') {
              deckRenderCallbacks.onDeckAfterRender(allDeckGlProps);
            }
          }
        }), children));
      }
    }, {
      key: "_updateMapboxLayers",
      value: function _updateMapboxLayers() {
        var mapboxLayers = this.mapboxLayersSelector(this.props);

        if (!Object.keys(mapboxLayers).length && !Object.keys(this.previousLayers).length) {
          return;
        }

        (0, _layers.updateMapboxLayers)(this._map, mapboxLayers, this.previousLayers);
        this.previousLayers = mapboxLayers;
      }
    }, {
      key: "_renderMapboxOverlays",
      value: function _renderMapboxOverlays() {
        if (this._map && this._map.isStyleLoaded()) {
          this._updateMapboxLayers();
        }
      }
    }, {
      key: "_renderMap",
      value:
      /* eslint-disable complexity */
      function _renderMap() {
        var _mapStyle$mapStyles, _this$context3, _mapStyle$bottomMapSt;

        var _this$props6 = this.props,
            visState = _this$props6.visState,
            mapState = _this$props6.mapState,
            mapStyle = _this$props6.mapStyle,
            mapStateActions = _this$props6.mapStateActions,
            _this$props6$MapCompo = _this$props6.MapComponent,
            MapComponent = _this$props6$MapCompo === void 0 ? _maplibre.Map : _this$props6$MapCompo,
            mapboxApiAccessToken = _this$props6.mapboxApiAccessToken,
            mapboxApiUrl = _this$props6.mapboxApiUrl,
            mapControls = _this$props6.mapControls,
            isExport = _this$props6.isExport,
            locale = _this$props6.locale,
            uiStateActions = _this$props6.uiStateActions,
            visStateActions = _this$props6.visStateActions,
            index = _this$props6.index,
            primary = _this$props6.primary,
            bottomMapContainerProps = _this$props6.bottomMapContainerProps,
            topMapContainerProps = _this$props6.topMapContainerProps,
            theme = _this$props6.theme,
            _this$props6$datasetA = _this$props6.datasetAttributions,
            datasetAttributions = _this$props6$datasetA === void 0 ? [] : _this$props6$datasetA,
            _this$props6$containe = _this$props6.containerId,
            containerId = _this$props6$containe === void 0 ? 0 : _this$props6$containe;
        var layers = visState.layers,
            datasets = visState.datasets,
            editor = visState.editor,
            interactionConfig = visState.interactionConfig;
        var layersToRender = this.layersToRenderSelector(this.props);
        var layersForDeck = this.layersForDeckSelector(this.props); // Current style can be a custom style, from which we pull the mapbox API acccess token

        var currentStyle = (_mapStyle$mapStyles = mapStyle.mapStyles) === null || _mapStyle$mapStyles === void 0 ? void 0 : _mapStyle$mapStyles[mapStyle.styleType];
        var internalViewState = (_this$context3 = this.context) === null || _this$context3 === void 0 ? void 0 : _this$context3.getInternalViewState(index);

        var mapProps = _objectSpread(_objectSpread({}, internalViewState), {}, {
          preserveDrawingBuffer: true,
          mapboxAccessToken: (currentStyle === null || currentStyle === void 0 ? void 0 : currentStyle.accessToken) || mapboxApiAccessToken,
          baseApiUrl: mapboxApiUrl,
          mapLib: _maplibreGl["default"],
          transformRequest: this.props.transformRequest || _utils.transformRequest
        });

        var hasGeocoderLayer = Boolean(layers.find(function (l) {
          return l.id === _constants.GEOCODER_LAYER_ID;
        }));
        var isSplit = Boolean(mapState.isSplit);

        var deck = this._renderDeckOverlay(layersForDeck, {
          primaryMap: true,
          isInteractive: true,
          children: /*#__PURE__*/_react["default"].createElement(MapComponent, (0, _extends2["default"])({
            key: "bottom"
          }, mapProps, {
            mapStyle: (_mapStyle$bottomMapSt = mapStyle.bottomMapStyle) !== null && _mapStyle$bottomMapSt !== void 0 ? _mapStyle$bottomMapSt : _constants.EMPTY_MAPBOX_STYLE
          }, bottomMapContainerProps, {
            ref: this._setMapboxMap
          }))
        });

        if (!deck) {
          // deckOverlay can be null if onDeckRender returns null
          // in this case we don't want to render the map
          return null;
        }

        return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, /*#__PURE__*/_react["default"].createElement(MapControl, {
          mapState: mapState,
          datasets: datasets,
          availableLocales: LOCALE_CODES_ARRAY,
          dragRotate: mapState.dragRotate,
          isSplit: isSplit,
          primary: Boolean(primary),
          isExport: isExport,
          layers: layers,
          layersToRender: layersToRender,
          mapIndex: index || 0,
          mapControls: mapControls,
          readOnly: this.props.readOnly,
          scale: mapState.scale || 1,
          top: interactionConfig.geocoder && interactionConfig.geocoder.enabled ? theme.mapControlTop : 0,
          editor: editor,
          locale: locale,
          onTogglePerspective: mapStateActions.togglePerspective,
          onToggleSplitMap: mapStateActions.toggleSplitMap,
          onMapToggleLayer: this._handleMapToggleLayer,
          onToggleMapControl: this._toggleMapControl,
          onToggleSplitMapViewport: mapStateActions.toggleSplitMapViewport,
          onSetEditorMode: visStateActions.setEditorMode,
          onSetLocale: uiStateActions.setLocale,
          onToggleEditorVisibility: visStateActions.toggleEditorVisibility,
          mapHeight: mapState.height
        }), isSplitSelector(this.props) && /*#__PURE__*/_react["default"].createElement(Droppable, {
          containerId: containerId
        }), deck, this._renderMapboxOverlays(), /*#__PURE__*/_react["default"].createElement(Editor, {
          index: index || 0,
          datasets: datasets,
          editor: editor,
          filters: this.polygonFiltersSelector(this.props),
          layers: layers,
          onDeleteFeature: visStateActions.deleteFeature,
          onSelect: visStateActions.setSelectedFeature,
          onTogglePolygonFilter: visStateActions.setPolygonFilterLayer,
          onSetEditorMode: visStateActions.setEditorMode,
          style: {
            pointerEvents: 'all',
            position: 'absolute',
            display: editor.visible ? 'block' : 'none'
          }
        }), this.props.children, mapStyle.topMapStyle ? /*#__PURE__*/_react["default"].createElement(MapComponent, (0, _extends2["default"])({
          key: "top",
          viewState: internalViewState,
          mapStyle: mapStyle.topMapStyle,
          style: MAP_STYLE.top,
          mapboxAccessToken: mapProps.mapboxAccessToken,
          baseApiUrl: mapProps.baseApiUrl,
          mapLib: _maplibreGl["default"]
        }, topMapContainerProps)) : null, hasGeocoderLayer ? this._renderDeckOverlay((0, _defineProperty2["default"])({}, _constants.GEOCODER_LAYER_ID, hasGeocoderLayer), {
          primaryMap: false,
          isInteractive: false
        }) : null, this._renderMapPopover(), this.props.primary ? /*#__PURE__*/_react["default"].createElement(Attribution, {
          showMapboxLogo: this.state.showMapboxAttribution,
          showOsmBasemapAttribution: true,
          datasetAttributions: datasetAttributions
        }) : null);
      }
    }, {
      key: "render",
      value: function render() {
        var visState = this.props.visState;

        var mapContent = this._renderMap();

        if (!mapContent) {
          // mapContent can be null if onDeckRender returns null
          // in this case we don't want to render the map
          return null;
        }

        return /*#__PURE__*/_react["default"].createElement(StyledMap, {
          ref: this._ref,
          style: this.styleSelector(this.props),
          onContextMenu: function onContextMenu(event) {
            return event.preventDefault();
          },
          mixBlendMode: visState.overlayBlending
        }, mapContent);
      }
    }]);
    return MapContainer;
  }(_react.Component);

  (0, _defineProperty2["default"])(MapContainer, "contextType", _mapViewStateContext.MapViewStateContext);
  (0, _defineProperty2["default"])(MapContainer, "defaultProps", {
    MapComponent: _maplibre.Map,
    deckGlProps: {},
    index: 0,
    primary: true
  });
  return (0, _styledComponents.withTheme)(MapContainer);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYXAtY29udGFpbmVyLnRzeCJdLCJuYW1lcyI6WyJERUJPVU5DRV9WSUVXUE9SVF9QUk9QQUdBVEUiLCJERUJPVU5DRV9NT1VTRV9NT1ZFX1BST1BBR0FURSIsIk1BUF9TVFlMRSIsImNvbnRhaW5lciIsImRpc3BsYXkiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwidG9wIiwicG9pbnRlckV2ZW50cyIsIkxPQ0FMRV9DT0RFU19BUlJBWSIsIk9iamVjdCIsImtleXMiLCJMT0NBTEVfQ09ERVMiLCJTdHlsZWRNYXAiLCJTdHlsZWRNYXBDb250YWluZXIiLCJtaXhCbGVuZE1vZGUiLCJNQVBCT1hHTF9TVFlMRV9VUERBVEUiLCJNQVBCT1hHTF9SRU5ERVIiLCJub3AiLCJNYXBMaWJyZUxvZ28iLCJtYXJnaW5MZWZ0IiwiU3R5bGVkRHJvcHBhYmxlIiwic3R5bGVkIiwiZGl2IiwicHJvcHMiLCJpc092ZXIiLCJ0aGVtZSIsImRuZE92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJpc1NwbGl0U2VsZWN0b3IiLCJ2aXNTdGF0ZSIsInNwbGl0TWFwcyIsImxlbmd0aCIsIkRyb3BwYWJsZSIsImNvbnRhaW5lcklkIiwiaWQiLCJkYXRhIiwidHlwZSIsIkRST1BQQUJMRV9NQVBfQ09OVEFJTkVSX1RZUEUiLCJpbmRleCIsImRpc2FibGVkIiwic2V0Tm9kZVJlZiIsIlN0eWxlZERhdGFzZXRBdHRyaWJ1dGlvbnNDb250YWluZXIiLCJpc1BhbG0iLCJsYWJlbENvbG9yIiwiRGF0YXNldEF0dHJpYnV0aW9ucyIsImRhdGFzZXRBdHRyaWJ1dGlvbnMiLCJtYXAiLCJkcyIsImlkeCIsInVybCIsImhyZWYiLCJ0aXRsZSIsIkF0dHJpYnV0aW9uIiwic2hvd01hcGJveExvZ28iLCJzaG93T3NtQmFzZW1hcEF0dHJpYnV0aW9uIiwiYnJlYWtQb2ludFZhbHVlcyIsIm1lbW9pemVkQ29tcG9uZW50cyIsIk1hcENvbnRhaW5lckZhY3RvcnkiLCJkZXBzIiwiTWFwUG9wb3ZlckZhY3RvcnkiLCJNYXBDb250cm9sRmFjdG9yeSIsIkVkaXRvckZhY3RvcnkiLCJNYXBQb3BvdmVyIiwiTWFwQ29udHJvbCIsIkVkaXRvciIsIk1hcENvbnRhaW5lciIsInNob3dNYXBib3hBdHRyaWJ1dGlvbiIsImRpbWVuc2lvbnMiLCJwcmltYXJ5IiwibWFwU3RhdGVBY3Rpb25zIiwidXBkYXRlTWFwIiwibGF5ZXJzIiwibGF5ZXJEYXRhIiwic3BsaXRNYXBTZWxlY3RvciIsInNwbGl0TWFwSW5kZXhTZWxlY3RvciIsImdldE1hcExheWVyc0Zyb21TcGxpdE1hcHMiLCJsYXllck9yZGVyIiwibGF5ZXJzU2VsZWN0b3IiLCJsYXllckRhdGFTZWxlY3RvciIsIm1hcExheWVyc1NlbGVjdG9yIiwicHJlcGFyZUxheWVyc1RvUmVuZGVyIiwicHJlcGFyZUxheWVyc0ZvckRlY2siLCJmaWx0ZXJzIiwiZmlsdGVyc1NlbGVjdG9yIiwiZmlsdGVyIiwiZiIsIkZJTFRFUl9UWVBFUyIsInBvbHlnb24iLCJlbmFibGVkIiwiZWRpdG9yIiwiZmVhdHVyZXMiLCJzZWxlY3RlZEZlYXR1cmUiLCJwb2x5Z29uRmlsdGVyc1NlbGVjdG9yIiwiZmVhdHVyZXNTZWxlY3RvciIsInBvbHlnb25GaWx0ZXJzIiwiY29uY2F0IiwidmFsdWUiLCJmZWF0dXJlQ29sbGVjdGlvblNlbGVjdG9yIiwic2VsZWN0ZWRGZWF0dXJlU2VsZWN0b3IiLCJjb2xsZWN0aW9uIiwiZmluZEluZGV4IiwiZ2VuZXJhdGVNYXBib3hMYXllcnMiLCJsYXllck9yZGVyU2VsZWN0b3IiLCJsYXllcnNUb1JlbmRlclNlbGVjdG9yIiwiZ2VuZXJhdGVNYXBib3hMYXllck1ldGhvZFNlbGVjdG9yIiwibGF5ZXIiLCJsYXllcnNUb1JlbmRlciIsImdlbmVyYXRlTWFwYm94TGF5ZXJNZXRob2QiLCJtYXBTdHlsZSIsInN0eWxlVHlwZSIsImJhY2tncm91bmRDb2xvciIsIm1hcFN0eWxlVHlwZVNlbGVjdG9yIiwibWFwU3R5bGVCYWNrZ3JvdW5kQ29sb3JTZWxlY3RvciIsIk5PX01BUF9JRCIsInZpc1N0YXRlQWN0aW9ucyIsIm9uTGF5ZXJDbGljayIsImluZm8iLCJvbkxheWVySG92ZXIiLCJjb2xvckRvbWFpbiIsImxheWVyQ29uZmlnQ2hhbmdlIiwibGF5ZXJJZCIsIm1hcEluZGV4IiwidG9nZ2xlTGF5ZXJGb3JNYXAiLCJ1cGRhdGUiLCJwcmV2aW91c0xheWVycyIsIl91cGRhdGVNYXBib3hMYXllcnMiLCJzdHlsZSIsInNldFN0YXRlIiwib25NYXBTdHlsZUxvYWRlZCIsIl9tYXAiLCJtYXBib3giLCJnZXRNYXAiLCJvbiIsIl9vbk1hcGJveFN0eWxlVXBkYXRlIiwib25NYXBSZW5kZXIiLCJnZXRNYXBib3hSZWYiLCJnbCIsImxheWVyQmxlbmRpbmciLCJlcnJvciIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJsYXllck1lc3NhZ2UiLCJlcnJvck1lc3NhZ2VGdWxsIiwibGFzdFNob3duIiwiX2RlY2tHTEVycm9yc0VsYXBzZWQiLCJEYXRlIiwibm93IiwiVEhST1RUTEVfTk9USUZJQ0FUSU9OX1RJTUUiLCJleHRyYUxheWVyTWVzc2FnZSIsInRvcE1vc3RMYXllciIsInBhcmVudCIsImxheWVyU2V0SXNWYWxpZCIsInVpU3RhdGVBY3Rpb25zIiwiYWRkTm90aWZpY2F0aW9uIiwidmlld1N0YXRlIiwiY29udGV4dCIsImdldEludGVybmFsVmlld1N0YXRlIiwib25WaWV3U3RhdGVDaGFuZ2UiLCJ2aWV3cG9ydCIsImlzRXhwb3J0Iiwic2V0SW50ZXJuYWxWaWV3U3RhdGUiLCJfb25WaWV3cG9ydENoYW5nZVByb3BhZ2F0ZURlYm91bmNlZCIsImV2ZW50Iiwib25Nb3VzZU1vdmUiLCJwYW5lbElkIiwidG9nZ2xlTWFwQ29udHJvbCIsIk51bWJlciIsIl9yZWYiLCJjdXJyZW50IiwiX2hhbmRsZVJlc2l6ZSIsIm9mZiIsIm9uRGVja0luaXRpYWxpemVkIiwiX2RlY2siLCJ2aWV3SW5kZXgiLCJCb29sZWFuIiwidmlld01hbmFnZXIiLCJfdmlld3BvcnRzIiwiaG92ZXJJbmZvIiwibWFwU3RhdGUiLCJjbGlja2VkIiwiZGF0YXNldHMiLCJpbnRlcmFjdGlvbkNvbmZpZyIsIm1vdXNlUG9zIiwibW91c2VQb3NpdGlvbiIsImNvb3JkaW5hdGUiLCJwaW5uZWQiLCJ0b29sdGlwIiwibGF5ZXJIb3ZlclByb3AiLCJjb21wYXJlTW9kZSIsImNvbmZpZyIsInBpbm5lZFBvc2l0aW9uIiwieCIsInkiLCJsYXllclBpbm5lZFByb3AiLCJsbmdMYXQiLCJfZ2V0SG92ZXJYWSIsInByaW1hcnlEYXRhIiwiY29tcGFyZVR5cGUiLCJjb21tb25Qcm9wIiwib25DbG9zZSIsIl9vbkNsb3NlTWFwUG9wb3ZlciIsInpvb20iLCJjYW52YXMiLCJ1bmRlZmluZWQiLCJzZXRGZWF0dXJlcyIsInNldFNlbGVjdGVkRmVhdHVyZSIsInNjcmVlbkNvb3JkIiwicHJvamVjdCIsImxheWVyc0ZvckRlY2siLCJvcHRpb25zIiwicHJpbWFyeU1hcCIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwibWFwYm94QXBpVXJsIiwiZGVja0dsUHJvcHMiLCJtYXBDb250cm9scyIsImRlY2tSZW5kZXJDYWxsYmFja3MiLCJnZW5lcmF0ZURlY2tHTExheWVycyIsImlzSW50ZXJhY3RpdmUiLCJjaGlsZHJlbiIsIm1hcERyYXciLCJhY3RpdmUiLCJlZGl0b3JNZW51QWN0aXZlIiwiaXNFZGl0b3JEcmF3aW5nTW9kZSIsIkVkaXRvckxheWVyVXRpbHMiLCJpc0RyYXdpbmdBY3RpdmUiLCJtb2RlIiwiaW50ZXJuYWxWaWV3U3RhdGUiLCJpbnRlcm5hbE1hcFN0YXRlIiwiZWRpdG9yRmVhdHVyZVNlbGVjdGVkSW5kZXgiLCJzZWxlY3RlZFBvbHlnb25JbmRleFNlbGVjdG9yIiwiZ2VuZXJhdGVEZWNrR0xMYXllcnNNZXRob2QiLCJjb21wdXRlRGVja0xheWVycyIsImRlY2tHbExheWVycyIsImVkaXRvckluZm8iLCJvblNldEZlYXR1cmVzIiwiZmVhdHVyZUNvbGxlY3Rpb24iLCJzZWxlY3RlZEZlYXR1cmVJbmRleGVzIiwic2VsZWN0ZWRGZWF0dXJlSW5kZXhBcnJheVNlbGVjdG9yIiwiX29uTGF5ZXJIb3ZlciIsIm9uU2V0TGF5ZXJEb21haW4iLCJfb25MYXllclNldERvbWFpbiIsImV4dHJhRGVja1BhcmFtcyIsImdldFRvb2x0aXAiLCJnZXRDdXJzb3IiLCJpc0RyYWdnaW5nIiwiZWRpdG9yQ3Vyc29yIiwiZWZmZWN0cyIsIl9pc09LVG9SZW5kZXJFZmZlY3RzIiwidmlld3MiLCJNYXBWaWV3IiwibGVnYWN5TWV0ZXJTaXplcyIsImFsbERlY2tHbFByb3BzIiwicGlja2luZ1JhZGl1cyIsIkRFRkFVTFRfUElDS0lOR19SQURJVVMiLCJvbkRlY2tSZW5kZXIiLCJfb25Nb3VzZU1vdmVEZWJvdW5jZWQiLCJvbkRlY2tMb2FkIiwiZG91YmxlQ2xpY2tab29tIiwiZHJhZ1JvdGF0ZSIsIl9vbkJlZm9yZVJlbmRlciIsIl9vblZpZXdwb3J0Q2hhbmdlIiwicmVzIiwib25Ib3ZlciIsIl9vbkxheWVySG92ZXJEZWJvdW5jZWQiLCJzcmNFdmVudCIsIm9uQ2xpY2siLCJfb25EZWNrRXJyb3IiLCJjb21wIiwiZGVjayIsIl9vbkRlY2tJbml0aWFsaXplZCIsIm9uRGVja0FmdGVyUmVuZGVyIiwibWFwYm94TGF5ZXJzIiwibWFwYm94TGF5ZXJzU2VsZWN0b3IiLCJpc1N0eWxlTG9hZGVkIiwiTWFwQ29tcG9uZW50IiwiTWFwIiwibG9jYWxlIiwiYm90dG9tTWFwQ29udGFpbmVyUHJvcHMiLCJ0b3BNYXBDb250YWluZXJQcm9wcyIsImxheWVyc0ZvckRlY2tTZWxlY3RvciIsImN1cnJlbnRTdHlsZSIsIm1hcFN0eWxlcyIsIm1hcFByb3BzIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwibWFwYm94QWNjZXNzVG9rZW4iLCJhY2Nlc3NUb2tlbiIsImJhc2VBcGlVcmwiLCJtYXBMaWIiLCJtYXBsaWJyZWdsIiwidHJhbnNmb3JtUmVxdWVzdCIsImhhc0dlb2NvZGVyTGF5ZXIiLCJmaW5kIiwibCIsIkdFT0NPREVSX0xBWUVSX0lEIiwiaXNTcGxpdCIsIl9yZW5kZXJEZWNrT3ZlcmxheSIsImJvdHRvbU1hcFN0eWxlIiwiRU1QVFlfTUFQQk9YX1NUWUxFIiwiX3NldE1hcGJveE1hcCIsInJlYWRPbmx5Iiwic2NhbGUiLCJnZW9jb2RlciIsIm1hcENvbnRyb2xUb3AiLCJ0b2dnbGVQZXJzcGVjdGl2ZSIsInRvZ2dsZVNwbGl0TWFwIiwiX2hhbmRsZU1hcFRvZ2dsZUxheWVyIiwiX3RvZ2dsZU1hcENvbnRyb2wiLCJ0b2dnbGVTcGxpdE1hcFZpZXdwb3J0Iiwic2V0RWRpdG9yTW9kZSIsInNldExvY2FsZSIsInRvZ2dsZUVkaXRvclZpc2liaWxpdHkiLCJfcmVuZGVyTWFwYm94T3ZlcmxheXMiLCJkZWxldGVGZWF0dXJlIiwic2V0UG9seWdvbkZpbHRlckxheWVyIiwidmlzaWJsZSIsInRvcE1hcFN0eWxlIiwiX3JlbmRlck1hcFBvcG92ZXIiLCJzdGF0ZSIsIm1hcENvbnRlbnQiLCJfcmVuZGVyTWFwIiwic3R5bGVTZWxlY3RvciIsInByZXZlbnREZWZhdWx0Iiwib3ZlcmxheUJsZW5kaW5nIiwiQ29tcG9uZW50IiwiTWFwVmlld1N0YXRlQ29udGV4dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBS0E7O0FBQ0E7O0FBQ0E7O0FBTUE7O0FBR0E7O0FBUUE7O0FBZUE7O0FBR0E7O0FBV0E7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBLElBQU1BLDJCQUEyQixHQUFHLEVBQXBDO0FBQ0EsSUFBTUMsNkJBQTZCLEdBQUcsRUFBdEM7QUFFQTs7QUFDQSxJQUFNQyxTQUErQyxHQUFHO0FBQ3REQyxFQUFBQSxTQUFTLEVBQUU7QUFDVEMsSUFBQUEsT0FBTyxFQUFFLGNBREE7QUFFVEMsSUFBQUEsUUFBUSxFQUFFLFVBRkQ7QUFHVEMsSUFBQUEs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YUFpd0J0QyxrQkFBUztBQUFBLFlBQ0FoQixRQURBLEdBQ1ksS0FBS0wsS0FEakIsQ0FDQUssUUFEQTs7QUFFUCxZQUFNaVMsVUFBVSxHQUFHLEtBQUtDLFVBQUwsRUFBbkI7O0FBQ0EsWUFBSSxDQUFDRCxVQUFMLEVBQWlCO0FBQ2Y7QUFDQTtBQUNBLGlCQUFPLElBQVA7QUFDRDs7QUFDRCw0QkFDRSxnQ0FBQyxTQUFEO0FBQ0UsVUFBQSxHQUFHLEVBQUUsS0FBS3ZKLElBRFo7QUFFRSxVQUFBLEtBQUssRUFBRSxLQUFLeUosYUFBTCxDQUFtQixLQUFLeFMsS0FBeEIsQ0FGVDtBQUdFLFVBQUEsYUFBYSxFQUFFLHVCQUFBMEksS0FBSztBQUFBLG1CQUFJQSxLQUFLLENBQUMrSixjQUFOLEVBQUo7QUFBQSxXQUh0QjtBQUlFLFVBQUEsWUFBWSxFQUFFcFMsUUFBUSxDQUFDcVM7QUFKekIsV0FNR0osVUFOSCxDQURGO0FBVUQ7QUFueEJxQztBQUFBO0FBQUEsSUFDYkssZ0JBRGE7O0FBQUEsbUNBQ2xDbFEsWUFEa0MsaUJBSWpCbVEsd0NBSmlCO0FBQUEsbUNBQ2xDblEsWUFEa0Msa0JBUWhCO0FBQ3BCaU4sSUFBQUEsWUFBWSxFQUFFQyxhQURNO0FBRXBCOUQsSUFBQUEsV0FBVyxFQUFFLEVBRk87QUFHcEIvSyxJQUFBQSxLQUFLLEVBQUUsQ0FIYTtBQUlwQjhCLElBQUFBLE9BQU8sRUFBRTtBQUpXLEdBUmdCO0FBc3hCeEMsU0FBTyxpQ0FBVUgsWUFBVixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG4vLyBsaWJyYXJpZXNcbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudCwgY3JlYXRlUmVmLCB1c2VNZW1vfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc3R5bGVkLCB7d2l0aFRoZW1lfSBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XG5pbXBvcnQge01hcCwgTWFwUmVmfSBmcm9tICdyZWFjdC1tYXAtZ2wvbWFwbGlicmUnO1xuaW1wb3J0IHtQaWNrSW5mb30gZnJvbSAnQGRlY2suZ2wvY29yZS9saWIvZGVjayc7XG5pbXBvcnQgRGVja0dMIGZyb20gJ0BkZWNrLmdsL3JlYWN0JztcbmltcG9ydCB7Y3JlYXRlU2VsZWN0b3IsIFNlbGVjdG9yfSBmcm9tICdyZXNlbGVjdCc7XG5pbXBvcnQgbWFwbGlicmVnbCBmcm9tICdtYXBsaWJyZS1nbCc7XG5pbXBvcnQge3VzZURyb3BwYWJsZX0gZnJvbSAnQGRuZC1raXQvY29yZSc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcblxuaW1wb3J0IHtWaXNTdGF0ZUFjdGlvbnMsIE1hcFN0YXRlQWN0aW9ucywgVUlTdGF0ZUFjdGlvbnN9IGZyb20gJ0BrZXBsZXIuZ2wvYWN0aW9ucyc7XG5cbi8vIGNvbXBvbmVudHNcbmltcG9ydCBNYXBQb3BvdmVyRmFjdG9yeSBmcm9tICcuL21hcC9tYXAtcG9wb3Zlcic7XG5pbXBvcnQgTWFwQ29udHJvbEZhY3RvcnkgZnJvbSAnLi9tYXAvbWFwLWNvbnRyb2wnO1xuaW1wb3J0IHtcbiAgU3R5bGVkTWFwQ29udGFpbmVyLFxuICBTdHlsZWRBdHRyYnV0aW9uLFxuICBFbmRIb3Jpem9udGFsRmxleGJveFxufSBmcm9tICcuL2NvbW1vbi9zdHlsZWQtY29tcG9uZW50cyc7XG5cbmltcG9ydCBFZGl0b3JGYWN0b3J5IGZyb20gJy4vZWRpdG9yL2VkaXRvcic7XG5cbi8vIHV0aWxzXG5pbXBvcnQge1xuICBnZW5lcmF0ZU1hcGJveExheWVycyxcbiAgdXBkYXRlTWFwYm94TGF5ZXJzLFxuICBMYXllckJhc2VDb25maWcsXG4gIFZpc3VhbENoYW5uZWxEb21haW4sXG4gIEVkaXRvckxheWVyVXRpbHNcbn0gZnJvbSAnQGtlcGxlci5nbC9sYXllcnMnO1xuaW1wb3J0IHtNYXBTdGF0ZSwgTWFwQ29udHJvbHMsIFZpZXdwb3J0LCBTcGxpdE1hcCwgU3BsaXRNYXBMYXllcnN9IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuaW1wb3J0IHtcbiAgZXJyb3JOb3RpZmljYXRpb24sXG4gIHNldExheWVyQmxlbmRpbmcsXG4gIGlzU3R5bGVVc2luZ01hcGJveFRpbGVzLFxuICB0cmFuc2Zvcm1SZXF1ZXN0LFxuICBvYnNlcnZlRGltZW5zaW9ucyxcbiAgdW5vYnNlcnZlRGltZW5zaW9ucyxcbiAgaGFzTW9iaWxlV2lkdGgsXG4gIGdldE1hcExheWVyc0Zyb21TcGxpdE1hcHMsXG4gIG9uVmlld1BvcnRDaGFuZ2UsXG4gIGdldFZpZXdwb3J0RnJvbU1hcFN0YXRlLFxuICBub3JtYWxpemVFdmVudCxcbiAgcmdiVG9IZXgsXG4gIGNvbXB1dGVEZWNrRWZmZWN0c1xufSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7YnJlYWtQb2ludFZhbHVlc30gZnJvbSAnQGtlcGxlci5nbC9zdHlsZXMnO1xuXG4vLyBkZWZhdWx0LXNldHRpbmdzXG5pbXBvcnQge1xuICBGSUxURVJfVFlQRVMsXG4gIEdFT0NPREVSX0xBWUVSX0lELFxuICBUSFJPVFRMRV9OT1RJRklDQVRJT05fVElNRSxcbiAgREVGQVVMVF9QSUNLSU5HX1JBRElVUyxcbiAgTk9fTUFQX0lELFxuICBFTVBUWV9NQVBCT1hfU1RZTEUsXG4gIERST1BQQUJMRV9NQVBfQ09OVEFJTkVSX1RZUEVcbn0gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuXG4vLyBDb250ZXh0c1xuaW1wb3J0IHtNYXBWaWV3U3RhdGVDb250ZXh0fSBmcm9tICcuL21hcC12aWV3LXN0YXRlLWNvbnRleHQnO1xuXG5pbXBvcnQgRXJyb3JCb3VuZGFyeSBmcm9tICcuL2NvbW1vbi9lcnJvci1ib3VuZGFyeSc7XG5pbXBvcnQge0RhdGFzZXRBdHRyaWJ1dGlvbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge0xPQ0FMRV9DT0RFU30gZnJvbSAnQGtlcGxlci5nbC9sb2NhbGl6YXRpb24nO1xuaW1wb3J0IHtNYXBWaWV3fSBmcm9tICdAZGVjay5nbC9jb3JlJztcbmltcG9ydCB7XG4gIE1hcFN0eWxlLFxuICBjb21wdXRlRGVja0xheWVycyxcbiAgZ2V0TGF5ZXJIb3ZlclByb3AsXG4gIExheWVySG92ZXJQcm9wLFxuICBwcmVwYXJlTGF5ZXJzRm9yRGVjayxcbiAgcHJlcGFyZUxheWVyc1RvUmVuZGVyLFxuICBMYXllcnNUb1JlbmRlclxufSBmcm9tICdAa2VwbGVyLmdsL3JlZHVjZXJzJztcbmltcG9ydCB7VmlzU3RhdGV9IGZyb20gJ0BrZXBsZXIuZ2wvc2NoZW1hcyc7XG5cbi8vIERlYm91bmNlIHRoZSBwcm9wYWdhdGlvbiBvZiB2aWV3cG9ydCBjaGFuZ2UgYW5kIG1vdXNlIG1vdmVzIHRvIHJlZHV4IHN0b3JlLlxuLy8gVGhpcyBpcyB0byBhdm9pZCB0b28gbWFueSByZW5kZXJzIG9mIG90aGVyIGNvbXBvbmVudHMgd2hlbiB0aGUgbWFwIGlzXG4vLyBiZWluZyBwYW5uZWQvem9vbWVkIChsZWFkaW5nIHRvIGxhZ2d5IGJhc2VtYXAvZGVjayBzeW5jaW5nKS5cbmNvbnN0IERFQk9VTkNFX1ZJRVdQT1JUX1BST1BBR0FURSA9IDEwO1xuY29uc3QgREVCT1VOQ0VfTU9VU0VfTU9WRV9QUk9QQUdBVEUgPSAxMDtcblxuLyoqIEB0eXBlIHt7W2tleTogc3RyaW5nXTogUmVhY3QuQ1NTUHJvcGVydGllc319ICovXG5jb25zdCBNQVBfU1RZTEU6IHtba2V5OiBzdHJpbmddOiBSZWFjdC5DU1NQcm9wZXJ0aWVzfSA9IHtcbiAgY29udGFpbmVyOiB7XG4gICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJ1xuICB9LFxuICB0b3A6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IDAsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgfVxufTtcblxuY29uc3QgTE9DQUxFX0NPREVTX0FSUkFZID0gT2JqZWN0LmtleXMoTE9DQUxFX0NPREVTKTtcblxuaW50ZXJmYWNlIFN0eWxlZE1hcENvbnRhaW5lclByb3BzIHtcbiAgbWl4QmxlbmRNb2RlPzogc3RyaW5nO1xufVxuXG5jb25zdCBTdHlsZWRNYXAgPSBzdHlsZWQoU3R5bGVkTWFwQ29udGFpbmVyKTxTdHlsZWRNYXBDb250YWluZXJQcm9wcz4oXG4gICh7bWl4QmxlbmRNb2RlID0gJ25vcm1hbCd9KSA9PiBgXG4gICNkZWZhdWx0LWRlY2tnbC1vdmVybGF5IHtcbiAgICBtaXgtYmxlbmQtbW9kZTogJHttaXhCbGVuZE1vZGV9O1xuICB9O1xuICAqW21hcGxpYnJlZ2wtY2hpbGRyZW5dIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIH1cbmBcbik7XG5cbmNvbnN0IE1BUEJPWEdMX1NUWUxFX1VQREFURSA9ICdzdHlsZS5sb2FkJztcbmNvbnN0IE1BUEJPWEdMX1JFTkRFUiA9ICdyZW5kZXInO1xuY29uc3Qgbm9wID0gKCkgPT4ge307XG5cbmNvbnN0IE1hcExpYnJlTG9nbyA9ICgpID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJhdHRyaXRpb24tbG9nb1wiPlxuICAgIEJhc2VtYXAgYnk6XG4gICAgPGFcbiAgICAgIHN0eWxlPXt7bWFyZ2luTGVmdDogXCI1cHhcIn19XG4gICAgICBjbGFzc05hbWU9XCJtYXBsaWJyZWdsLWN0cmwtbG9nb1wiXG4gICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICBocmVmPVwiaHR0cHM6Ly93d3cubWFwbGlicmUub3JnL1wiXG4gICAgICBhcmlhLWxhYmVsPVwiTWFwTGlicmUgbG9nb1wiXG4gICAgLz5cbiAgPC9kaXY+XG4pO1xuXG5pbnRlcmZhY2UgU3R5bGVkRHJvcHBhYmxlUHJvcHMge1xuICBpc092ZXI6IGJvb2xlYW47XG59XG5cbmNvbnN0IFN0eWxlZERyb3BwYWJsZSA9IHN0eWxlZC5kaXY8U3R5bGVkRHJvcHBhYmxlUHJvcHM+YFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAke3Byb3BzID0+IChwcm9wcy5pc092ZXIgPyBwcm9wcy50aGVtZS5kbmRPdmVyQmFja2dyb3VuZENvbG9yIDogJ25vbmUnKX07XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIHotaW5kZXg6IDE7XG5gO1xuXG5leHBvcnQgY29uc3QgaXNTcGxpdFNlbGVjdG9yID0gcHJvcHMgPT5cbiAgcHJvcHMudmlzU3RhdGUuc3BsaXRNYXBzICYmIHByb3BzLnZpc1N0YXRlLnNwbGl0TWFwcy5sZW5ndGggPiAxO1xuXG5leHBvcnQgY29uc3QgRHJvcHBhYmxlID0gKHtjb250YWluZXJJZH0pID0+IHtcbiAgY29uc3Qge2lzT3Zlciwgc2V0Tm9kZVJlZn0gPSB1c2VEcm9wcGFibGUoe1xuICAgIGlkOiBjb250YWluZXJJZCxcbiAgICBkYXRhOiB7dHlwZTogRFJPUFBBQkxFX01BUF9DT05UQUlORVJfVFlQRSwgaW5kZXg6IGNvbnRhaW5lcklkfSxcbiAgICBkaXNhYmxlZDogIWNvbnRhaW5lcklkXG4gIH0pO1xuXG4gIHJldHVybiA8U3R5bGVkRHJvcHBhYmxlIHJlZj17c2V0Tm9kZVJlZn0gaXNPdmVyPXtpc092ZXJ9IC8+O1xufTtcblxuaW50ZXJmYWNlIFN0eWxlZERhdGFzZXRBdHRyaWJ1dGlvbnNDb250YWluZXJQcm9wcyB7XG4gIGlzUGFsbTogYm9vbGVhbjtcbn1cblxuY29uc3QgU3R5bGVkRGF0YXNldEF0dHJpYnV0aW9uc0NvbnRhaW5lciA9IHN0eWxlZC5kaXY8U3R5bGVkRGF0YXNldEF0dHJpYnV0aW9uc0NvbnRhaW5lclByb3BzPmBcbiAgbWF4LXdpZHRoOiAke3Byb3BzID0+IChwcm9wcy5pc1BhbG0gPyAnMTMwcHgnIDogJzE4MHB4Jyl9O1xuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgY29sb3I6ICR7cHJvcHMgPT4gcHJvcHMudGhlbWUubGFiZWxDb2xvcn07XG4gIG1hcmdpbi1yaWdodDogMnB4O1xuICBsaW5lLWhlaWdodDogJHtwcm9wcyA9PiAocHJvcHMuaXNQYWxtID8gJzFlbScgOiAnMS40ZW0nKX07XG4gIDpob3ZlciB7XG4gICAgd2hpdGUtc3BhY2U6IGluaGVyaXQ7XG4gIH1cbmA7XG5cbmNvbnN0IERhdGFzZXRBdHRyaWJ1dGlvbnMgPSAoe1xuICBkYXRhc2V0QXR0cmlidXRpb25zLFxuICBpc1BhbG1cbn06IHtcbiAgZGF0YXNldEF0dHJpYnV0aW9uczogRGF0YXNldEF0dHJpYnV0aW9uW107XG4gIGlzUGFsbTogYm9vbGVhbjtcbn0pID0+IChcbiAgPD5cbiAgICB7ZGF0YXNldEF0dHJpYnV0aW9ucz8ubGVuZ3RoID8gKFxuICAgICAgPFN0eWxlZERhdGFzZXRBdHRyaWJ1dGlvbnNDb250YWluZXIgaXNQYWxtPXtpc1BhbG19PlxuICAgICAgICB7ZGF0YXNldEF0dHJpYnV0aW9ucy5tYXAoKGRzLCBpZHgpID0+IChcbiAgICAgICAgICA8YVxuICAgICAgICAgICAgey4uLihkcy51cmwgPyB7aHJlZjogZHMudXJsfSA6IG51bGwpfVxuICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxuICAgICAgICAgICAga2V5PXtgJHtkcy50aXRsZX1fJHtpZHh9YH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7ZHMudGl0bGV9XG4gICAgICAgICAgICB7aWR4ICE9PSBkYXRhc2V0QXR0cmlidXRpb25zLmxlbmd0aCAtIDEgPyAnLCAnIDogbnVsbH1cbiAgICAgICAgICA8L2E+XG4gICAgICAgICkpfVxuICAgICAgPC9TdHlsZWREYXRhc2V0QXR0cmlidXRpb25zQ29udGFpbmVyPlxuICAgICkgOiBudWxsfVxuICA8Lz5cbik7XG5cbmV4cG9ydCBjb25zdCBBdHRyaWJ1dGlvbjogUmVhY3QuRkM8e1xuICBzaG93TWFwYm94TG9nbzogYm9vbGVhbjtcbiAgc2hvd09zbUJhc2VtYXBBdHRyaWJ1dGlvbjogYm9vbGVhbjtcbiAgZGF0YXNldEF0dHJpYnV0aW9uczogRGF0YXNldEF0dHJpYnV0aW9uW107XG59PiA9ICh7c2hvd01hcGJveExvZ28gPSB0cnVlLCBzaG93T3NtQmFzZW1hcEF0dHJpYnV0aW9uID0gZmFsc2UsIGRhdGFzZXRBdHRyaWJ1dGlvbnN9KSA9PiB7XG4gIGNvbnN0IGlzUGFsbSA9IGhhc01vYmlsZVdpZHRoKGJyZWFrUG9pbnRWYWx1ZXMpO1xuXG4gIGNvbnN0IG1lbW9pemVkQ29tcG9uZW50cyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghc2hvd01hcGJveExvZ28pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxTdHlsZWRBdHRyYnV0aW9uPlxuICAgICAgICAgIDxFbmRIb3Jpem9udGFsRmxleGJveD5cbiAgICAgICAgICAgIDxEYXRhc2V0QXR0cmlidXRpb25zIGRhdGFzZXRBdHRyaWJ1dGlvbnM9e2RhdGFzZXRBdHRyaWJ1dGlvbnN9IGlzUGFsbT17aXNQYWxtfSAvPlxuICAgICAgICAgICAge3Nob3dPc21CYXNlbWFwQXR0cmlidXRpb24gPyAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYXR0cml0aW9uLWxpbmtcIj5cbiAgICAgICAgICAgICAgICB7ZGF0YXNldEF0dHJpYnV0aW9ucz8ubGVuZ3RoID8gPHNwYW4gY2xhc3NOYW1lPVwicGlwZS1zZXBhcmF0b3JcIj58PC9zcGFuPiA6IG51bGx9XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgwqkgT3BlblN0cmVldE1hcFxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICA8L0VuZEhvcml6b250YWxGbGV4Ym94PlxuICAgICAgICA8L1N0eWxlZEF0dHJidXRpb24+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8U3R5bGVkQXR0cmJ1dGlvbj5cbiAgICAgICAgPEVuZEhvcml6b250YWxGbGV4Ym94PlxuICAgICAgICAgIDxEYXRhc2V0QXR0cmlidXRpb25zIGRhdGFzZXRBdHRyaWJ1dGlvbnM9e2RhdGFzZXRBdHRyaWJ1dGlvbnN9IGlzUGFsbT17aXNQYWxtfSAvPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYXR0cml0aW9uLWxpbmtcIj5cbiAgICAgICAgICAgIHtkYXRhc2V0QXR0cmlidXRpb25zPy5sZW5ndGggPyA8c3BhbiBjbGFzc05hbWU9XCJwaXBlLXNlcGFyYXRvclwiPnw8L3NwYW4+IDogbnVsbH1cbiAgICAgICAgICAgIHtpc1BhbG0gPyA8TWFwTGlicmVMb2dvIC8+IDogbnVsbH1cbiAgICAgICAgICAgIDxhIGhyZWY9XCJodHRwczovL2tlcGxlci5nbC9wb2xpY3kvXCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPlxuICAgICAgICAgICAgICDCqSBrZXBsZXIuZ2wgfHsnICd9XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICB7IWlzUGFsbSA/IDxNYXBMaWJyZUxvZ28gLz4gOiBudWxsfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0VuZEhvcml6b250YWxGbGV4Ym94PlxuICAgICAgPC9TdHlsZWRBdHRyYnV0aW9uPlxuICAgICk7XG4gIH0sIFtzaG93TWFwYm94TG9nbywgc2hvd09zbUJhc2VtYXBBdHRyaWJ1dGlvbiwgZGF0YXNldEF0dHJpYnV0aW9ucywgaXNQYWxtXSk7XG5cbiAgcmV0dXJuIG1lbW9pemVkQ29tcG9uZW50cztcbn07XG5cbk1hcENvbnRhaW5lckZhY3RvcnkuZGVwcyA9IFtNYXBQb3BvdmVyRmFjdG9yeSwgTWFwQ29udHJvbEZhY3RvcnksIEVkaXRvckZhY3RvcnldO1xuXG50eXBlIE1hcGJveFN0eWxlID0gc3RyaW5nIHwgb2JqZWN0IHwgdW5kZWZpbmVkO1xudHlwZSBQcm9wU2VsZWN0b3I8Uj4gPSBTZWxlY3RvcjxNYXBDb250YWluZXJQcm9wcywgUj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFwQ29udGFpbmVyUHJvcHMge1xuICB2aXNTdGF0ZTogVmlzU3RhdGU7XG4gIG1hcFN0YXRlOiBNYXBTdGF0ZTtcbiAgbWFwQ29udHJvbHM6IE1hcENvbnRyb2xzO1xuICBtYXBTdHlsZToge2JvdHRvbU1hcFN0eWxlPzogTWFwYm94U3R5bGU7IHRvcE1hcFN0eWxlPzogTWFwYm94U3R5bGV9ICYgTWFwU3R5bGU7XG4gIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBzdHJpbmc7XG4gIG1hcGJveEFwaVVybDogc3RyaW5nO1xuICB2aXNTdGF0ZUFjdGlvbnM6IHR5cGVvZiBWaXNTdGF0ZUFjdGlvbnM7XG4gIG1hcFN0YXRlQWN0aW9uczogdHlwZW9mIE1hcFN0YXRlQWN0aW9ucztcbiAgdWlTdGF0ZUFjdGlvbnM6IHR5cGVvZiBVSVN0YXRlQWN0aW9ucztcblxuICAvLyBvcHRpb25hbFxuICBwcmltYXJ5PzogYm9vbGVhbjsgLy8gcHJpbWFyeSBvbmUgd2lsbCBiZSByZXBvcnRpbmcgaXRzIHNpemUgdG8gYXBwU3RhdGVcbiAgcmVhZE9ubHk/OiBib29sZWFuO1xuICBpc0V4cG9ydD86IGJvb2xlYW47XG4gIG9uTWFwVG9nZ2xlTGF5ZXI/OiBGdW5jdGlvbjtcbiAgb25NYXBTdHlsZUxvYWRlZD86IEZ1bmN0aW9uO1xuICBvbk1hcFJlbmRlcj86IEZ1bmN0aW9uO1xuICBnZXRNYXBib3hSZWY/OiAobWFwYm94PzogTWFwUmVmIHwgbnVsbCwgaW5kZXg/OiBudW1iZXIpID0+IHZvaWQ7XG4gIGluZGV4PzogbnVtYmVyO1xuICBkZWxldGVNYXBMYWJlbHM/OiAoY29udGFpbmVySWQ6IHN0cmluZywgbGF5ZXJJZDogc3RyaW5nKSA9PiB2b2lkO1xuICBjb250YWluZXJJZD86IG51bWJlcjtcblxuICBsb2NhbGU/OiBhbnk7XG4gIHRoZW1lPzogYW55O1xuICBlZGl0b3I/OiBhbnk7XG4gIE1hcENvbXBvbmVudD86IHR5cGVvZiBNYXA7XG4gIGRlY2tHbFByb3BzPzogYW55O1xuICBvbkRlY2tJbml0aWFsaXplZD86IChhOiBhbnksIGI6IGFueSkgPT4gdm9pZDtcbiAgb25WaWV3U3RhdGVDaGFuZ2U/OiAodmlld3BvcnQ6IFZpZXdwb3J0KSA9PiB2b2lkO1xuXG4gIHRvcE1hcENvbnRhaW5lclByb3BzOiBhbnk7XG4gIGJvdHRvbU1hcENvbnRhaW5lclByb3BzOiBhbnk7XG4gIHRyYW5zZm9ybVJlcXVlc3Q/OiBhbnk7XG5cbiAgZGF0YXNldEF0dHJpYnV0aW9ucz86IERhdGFzZXRBdHRyaWJ1dGlvbltdO1xuXG4gIGdlbmVyYXRlTWFwYm94TGF5ZXJzPzogdHlwZW9mIGdlbmVyYXRlTWFwYm94TGF5ZXJzO1xuICBnZW5lcmF0ZURlY2tHTExheWVycz86IHR5cGVvZiBjb21wdXRlRGVja0xheWVycztcblxuICBvbk1vdXNlTW92ZT86IChldmVudDogUmVhY3QuTW91c2VFdmVudCAmIHtsbmdMYXQ/OiBbbnVtYmVyLCBudW1iZXJdfSkgPT4gdm9pZDtcblxuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZGVja1JlbmRlckNhbGxiYWNrcz86IHtcbiAgICBvbkRlY2tMb2FkPzogKCkgPT4gdm9pZDtcbiAgICBvbkRlY2tSZW5kZXI/OiAoZGVja1Byb3BzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4gUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsO1xuICAgIG9uRGVja0FmdGVyUmVuZGVyPzogKGRlY2tQcm9wczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IGFueTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFwQ29udGFpbmVyRmFjdG9yeShcbiAgTWFwUG9wb3ZlcjogUmV0dXJuVHlwZTx0eXBlb2YgTWFwUG9wb3ZlckZhY3Rvcnk+LFxuICBNYXBDb250cm9sOiBSZXR1cm5UeXBlPHR5cGVvZiBNYXBDb250cm9sRmFjdG9yeT4sXG4gIEVkaXRvcjogUmV0dXJuVHlwZTx0eXBlb2YgRWRpdG9yRmFjdG9yeT5cbik6IFJlYWN0LkNvbXBvbmVudFR5cGU8TWFwQ29udGFpbmVyUHJvcHM+IHtcbiAgY2xhc3MgTWFwQ29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50PE1hcENvbnRhaW5lclByb3BzPiB7XG4gICAgZGlzcGxheU5hbWUgPSAnTWFwQ29udGFpbmVyJztcblxuICAgIHN0YXRpYyBjb250ZXh0VHlwZSA9IE1hcFZpZXdTdGF0ZUNvbnRleHQ7XG5cbiAgICBkZWNsYXJlIGNvbnRleHQ6IFJlYWN0LkNvbnRleHRUeXBlPHR5cGVvZiBNYXBWaWV3U3RhdGVDb250ZXh0PjtcblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICBNYXBDb21wb25lbnQ6IE1hcCxcbiAgICAgIGRlY2tHbFByb3BzOiB7fSxcbiAgICAgIGluZGV4OiAwLFxuICAgICAgcHJpbWFyeTogdHJ1ZVxuICAgIH07XG5cbiAgICBzdGF0ZSA9IHtcbiAgICAgIC8vIERldGVybWluZXMgd2hldGhlciBhdHRyaWJ1dGlvbiBzaG91bGQgYmUgdmlzaWJsZSBiYXNlZCB0aGUgcmVzdWx0IG9mIGxvYWRpbmcgdGhlIG1hcCBzdHlsZVxuICAgICAgc2hvd01hcGJveEF0dHJpYnV0aW9uOiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAoIXRoaXMuX3JlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9ic2VydmVEaW1lbnNpb25zKHRoaXMuX3JlZi5jdXJyZW50LCB0aGlzLl9oYW5kbGVSZXNpemUpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgLy8gdW5iaW5kIG1hcGJveGdsIGV2ZW50IGxpc3RlbmVyXG4gICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgIHRoaXMuX21hcD8ub2ZmKE1BUEJPWEdMX1NUWUxFX1VQREFURSwgbm9wKTtcbiAgICAgICAgdGhpcy5fbWFwPy5vZmYoTUFQQk9YR0xfUkVOREVSLCBub3ApO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9yZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1bm9ic2VydmVEaW1lbnNpb25zKHRoaXMuX3JlZi5jdXJyZW50KTtcbiAgICB9XG5cbiAgICBfZGVjazogYW55ID0gbnVsbDtcbiAgICBfbWFwOiBtYXBsaWJyZWdsLk1hcCB8IG51bGwgPSBudWxsO1xuICAgIF9yZWYgPSBjcmVhdGVSZWY8SFRNTERpdkVsZW1lbnQ+KCk7XG4gICAgX2RlY2tHTEVycm9yc0VsYXBzZWQ6IHtbaWQ6IHN0cmluZ106IG51bWJlcn0gPSB7fTtcblxuICAgIHByZXZpb3VzTGF5ZXJzID0ge1xuICAgICAgLy8gW2xheWVycy5pZF06IG1hcGJveExheWVyQ29uZmlnXG4gICAgfTtcblxuICAgIF9oYW5kbGVSZXNpemUgPSBkaW1lbnNpb25zID0+IHtcbiAgICAgIGNvbnN0IHtwcmltYXJ5LCBpbmRleH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKHByaW1hcnkpIHtcbiAgICAgICAgY29uc3Qge21hcFN0YXRlQWN0aW9uc30gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoZGltZW5zaW9ucyAmJiBkaW1lbnNpb25zLndpZHRoID4gMCAmJiBkaW1lbnNpb25zLmhlaWdodCA+IDApIHtcbiAgICAgICAgICBtYXBTdGF0ZUFjdGlvbnMudXBkYXRlTWFwKGRpbWVuc2lvbnMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBsYXllcnNTZWxlY3RvcjogUHJvcFNlbGVjdG9yPFZpc1N0YXRlWydsYXllcnMnXT4gPSBwcm9wcyA9PiBwcm9wcy52aXNTdGF0ZS5sYXllcnM7XG4gICAgbGF5ZXJEYXRhU2VsZWN0b3I6IFByb3BTZWxlY3RvcjxWaXNTdGF0ZVsnbGF5ZXJzJ10+ID0gcHJvcHMgPT4gcHJvcHMudmlzU3RhdGUubGF5ZXJEYXRhO1xuICAgIHNwbGl0TWFwU2VsZWN0b3I6IFByb3BTZWxlY3RvcjxTcGxpdE1hcFtdPiA9IHByb3BzID0+IHByb3BzLnZpc1N0YXRlLnNwbGl0TWFwcztcbiAgICBzcGxpdE1hcEluZGV4U2VsZWN0b3I6IFByb3BTZWxlY3RvcjxudW1iZXIgfCB1bmRlZmluZWQ+ID0gcHJvcHMgPT4gcHJvcHMuaW5kZXg7XG4gICAgbWFwTGF5ZXJzU2VsZWN0b3I6IFByb3BTZWxlY3RvcjxTcGxpdE1hcExheWVycyB8IG51bGwgfCB1bmRlZmluZWQ+ID0gY3JlYXRlU2VsZWN0b3IoXG4gICAgICB0aGlzLnNwbGl0TWFwU2VsZWN0b3IsXG4gICAgICB0aGlzLnNwbGl0TWFwSW5kZXhTZWxlY3RvcixcbiAgICAgIGdldE1hcExheWVyc0Zyb21TcGxpdE1hcHNcbiAgICApO1xuICAgIGxheWVyT3JkZXJTZWxlY3RvcjogUHJvcFNlbGVjdG9yPFZpc1N0YXRlWydsYXllck9yZGVyJ10+ID0gcHJvcHMgPT4gcHJvcHMudmlzU3RhdGUubGF5ZXJPcmRlcjtcbiAgICBsYXllcnNUb1JlbmRlclNlbGVjdG9yOiBQcm9wU2VsZWN0b3I8TGF5ZXJzVG9SZW5kZXI+ID0gY3JlYXRlU2VsZWN0b3IoXG4gICAgICB0aGlzLmxheWVyc1NlbGVjdG9yLFxuICAgICAgdGhpcy5sYXllckRhdGFTZWxlY3RvcixcbiAgICAgIHRoaXMubWFwTGF5ZXJzU2VsZWN0b3IsXG4gICAgICBwcmVwYXJlTGF5ZXJzVG9SZW5kZXJcbiAgICApO1xuICAgIGxheWVyc0ZvckRlY2tTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKFxuICAgICAgdGhpcy5sYXllcnNTZWxlY3RvcixcbiAgICAgIHRoaXMubGF5ZXJEYXRhU2VsZWN0b3IsXG4gICAgICBwcmVwYXJlTGF5ZXJzRm9yRGVja1xuICAgICk7XG4gICAgZmlsdGVyc1NlbGVjdG9yID0gcHJvcHMgPT4gcHJvcHMudmlzU3RhdGUuZmlsdGVycztcbiAgICBwb2x5Z29uRmlsdGVyc1NlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IodGhpcy5maWx0ZXJzU2VsZWN0b3IsIGZpbHRlcnMgPT5cbiAgICAgIGZpbHRlcnMuZmlsdGVyKGYgPT4gZi50eXBlID09PSBGSUxURVJfVFlQRVMucG9seWdvbiAmJiBmLmVuYWJsZWQgIT09IGZhbHNlKVxuICAgICk7XG4gICAgZmVhdHVyZXNTZWxlY3RvciA9IHByb3BzID0+IHByb3BzLnZpc1N0YXRlLmVkaXRvci5mZWF0dXJlcztcbiAgICBzZWxlY3RlZEZlYXR1cmVTZWxlY3RvciA9IHByb3BzID0+IHByb3BzLnZpc1N0YXRlLmVkaXRvci5zZWxlY3RlZEZlYXR1cmU7XG4gICAgZmVhdHVyZUNvbGxlY3Rpb25TZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKFxuICAgICAgdGhpcy5wb2x5Z29uRmlsdGVyc1NlbGVjdG9yLFxuICAgICAgdGhpcy5mZWF0dXJlc1NlbGVjdG9yLFxuICAgICAgKHBvbHlnb25GaWx0ZXJzLCBmZWF0dXJlcykgPT4gKHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzLmNvbmNhdChwb2x5Z29uRmlsdGVycy5tYXAoZiA9PiBmLnZhbHVlKSlcbiAgICAgIH0pXG4gICAgKTtcbiAgICBzZWxlY3RlZFBvbHlnb25JbmRleFNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IoXG4gICAgICB0aGlzLmZlYXR1cmVDb2xsZWN0aW9uU2VsZWN0b3IsXG4gICAgICB0aGlzLnNlbGVjdGVkRmVhdHVyZVNlbGVjdG9yLFxuICAgICAgKGNvbGxlY3Rpb24sIHNlbGVjdGVkRmVhdHVyZSkgPT5cbiAgICAgICAgY29sbGVjdGlvbi5mZWF0dXJlcy5maW5kSW5kZXgoZiA9PiBmLmlkID09PSBzZWxlY3RlZEZlYXR1cmU/LmlkKVxuICAgICk7XG4gICAgc2VsZWN0ZWRGZWF0dXJlSW5kZXhBcnJheVNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IoXG4gICAgICAodmFsdWU6IG51bWJlcikgPT4gdmFsdWUsXG4gICAgICB2YWx1ZSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyBbXSA6IFt2YWx1ZV07XG4gICAgICB9XG4gICAgKTtcblxuICAgIGdlbmVyYXRlTWFwYm94TGF5ZXJNZXRob2RTZWxlY3RvciA9IHByb3BzID0+IHByb3BzLmdlbmVyYXRlTWFwYm94TGF5ZXJzID8/IGdlbmVyYXRlTWFwYm94TGF5ZXJzO1xuXG4gICAgbWFwYm94TGF5ZXJzU2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcihcbiAgICAgIHRoaXMubGF5ZXJzU2VsZWN0b3IsXG4gICAgICB0aGlzLmxheWVyRGF0YVNlbGVjdG9yLFxuICAgICAgdGhpcy5sYXllck9yZGVyU2VsZWN0b3IsXG4gICAgICB0aGlzLmxheWVyc1RvUmVuZGVyU2VsZWN0b3IsXG4gICAgICB0aGlzLmdlbmVyYXRlTWFwYm94TGF5ZXJNZXRob2RTZWxlY3RvcixcbiAgICAgIChsYXllciwgbGF5ZXJEYXRhLCBsYXllck9yZGVyLCBsYXllcnNUb1JlbmRlciwgZ2VuZXJhdGVNYXBib3hMYXllck1ldGhvZCkgPT5cbiAgICAgICAgZ2VuZXJhdGVNYXBib3hMYXllck1ldGhvZChsYXllciwgbGF5ZXJEYXRhLCBsYXllck9yZGVyLCBsYXllcnNUb1JlbmRlcilcbiAgICApO1xuXG4gICAgLy8gbWVyZ2UgaW4gYSBiYWNrZ3JvdW5kLWNvbG9yIHN0eWxlIGlmIHRoZSBiYXNlbWFwIGNob2ljZSBpcyBOT19NQVBfSURcbiAgICAvLyB1c2VkIGJ5IDxTdHlsZWRNYXA+IGlubGluZSBzdHlsZSBwcm9wXG4gICAgbWFwU3R5bGVUeXBlU2VsZWN0b3IgPSBwcm9wcyA9PiBwcm9wcy5tYXBTdHlsZS5zdHlsZVR5cGU7XG4gICAgbWFwU3R5bGVCYWNrZ3JvdW5kQ29sb3JTZWxlY3RvciA9IHByb3BzID0+IHByb3BzLm1hcFN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgICBzdHlsZVNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IoXG4gICAgICB0aGlzLm1hcFN0eWxlVHlwZVNlbGVjdG9yLFxuICAgICAgdGhpcy5tYXBTdHlsZUJhY2tncm91bmRDb2xvclNlbGVjdG9yLFxuICAgICAgKHN0eWxlVHlwZSwgYmFja2dyb3VuZENvbG9yKSA9PiAoe1xuICAgICAgICAuLi5NQVBfU1RZTEUuY29udGFpbmVyLFxuICAgICAgICAuLi4oc3R5bGVUeXBlID09PSBOT19NQVBfSUQgPyB7YmFja2dyb3VuZENvbG9yOiByZ2JUb0hleChiYWNrZ3JvdW5kQ29sb3IpfSA6IHt9KVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgLyogY29tcG9uZW50IHByaXZhdGUgZnVuY3Rpb25zICovXG4gICAgX29uQ2xvc2VNYXBQb3BvdmVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5wcm9wcy52aXNTdGF0ZUFjdGlvbnMub25MYXllckNsaWNrKG51bGwpO1xuICAgIH07XG5cbiAgICBfb25MYXllckhvdmVyID0gKGlkeDogbnVtYmVyLCBpbmZvOiBQaWNrSW5mbzxhbnk+IHwgbnVsbCkgPT4ge1xuICAgICAgdGhpcy5wcm9wcy52aXNTdGF0ZUFjdGlvbnMub25MYXllckhvdmVyKGluZm8pO1xuICAgIH07XG5cbiAgICBfb25MYXllclNldERvbWFpbiA9IChpZHg6IG51bWJlciwgY29sb3JEb21haW46IFZpc3VhbENoYW5uZWxEb21haW4pID0+IHtcbiAgICAgIHRoaXMucHJvcHMudmlzU3RhdGVBY3Rpb25zLmxheWVyQ29uZmlnQ2hhbmdlKHRoaXMucHJvcHMudmlzU3RhdGUubGF5ZXJzW2lkeF0sIHtcbiAgICAgICAgY29sb3JEb21haW5cbiAgICAgIH0gYXMgUGFydGlhbDxMYXllckJhc2VDb25maWc+KTtcbiAgICB9O1xuXG4gICAgX2hhbmRsZU1hcFRvZ2dsZUxheWVyID0gbGF5ZXJJZCA9PiB7XG4gICAgICBjb25zdCB7aW5kZXg6IG1hcEluZGV4ID0gMCwgdmlzU3RhdGVBY3Rpb25zfSA9IHRoaXMucHJvcHM7XG4gICAgICB2aXNTdGF0ZUFjdGlvbnMudG9nZ2xlTGF5ZXJGb3JNYXAobWFwSW5kZXgsIGxheWVySWQpO1xuICAgIH07XG5cbiAgICBfb25NYXBib3hTdHlsZVVwZGF0ZSA9IHVwZGF0ZSA9PiB7XG4gICAgICAvLyBmb3JjZSByZWZyZXNoIG1hcGJveGdsIGxheWVyc1xuICAgICAgdGhpcy5wcmV2aW91c0xheWVycyA9IHt9O1xuICAgICAgdGhpcy5fdXBkYXRlTWFwYm94TGF5ZXJzKCk7XG5cbiAgICAgIGlmICh1cGRhdGUgJiYgdXBkYXRlLnN0eWxlKSB7XG4gICAgICAgIC8vIE5vIGF0dHJpYnV0aW9ucyBhcmUgbmVlZGVkIGlmIHRoZSBzdHlsZSBkb2Vzbid0IHJlZmVyZW5jZSBNYXBib3ggc291cmNlc1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtzaG93TWFwYm94QXR0cmlidXRpb246IGlzU3R5bGVVc2luZ01hcGJveFRpbGVzKHVwZGF0ZS5zdHlsZSl9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uTWFwU3R5bGVMb2FkZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbk1hcFN0eWxlTG9hZGVkKHRoaXMuX21hcCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9zZXRNYXBib3hNYXA6IFJlYWN0LlJlZjxNYXBSZWY+ID0gbWFwYm94ID0+IHtcbiAgICAgIGlmICghdGhpcy5fbWFwICYmIG1hcGJveCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXBib3guZ2V0TWFwKCk7XG4gICAgICAgIC8vIGkgbm90aWNlZCBpbiBjZXJ0YWluIGNvbnRleHQgd2UgZG9uJ3QgYWNjZXNzIHRoZSBhY3R1YWwgbWFwIGVsZW1lbnRcbiAgICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmluZCBtYXBib3hnbCBldmVudCBsaXN0ZW5lclxuICAgICAgICB0aGlzLl9tYXAub24oTUFQQk9YR0xfU1RZTEVfVVBEQVRFLCB0aGlzLl9vbk1hcGJveFN0eWxlVXBkYXRlKTtcblxuICAgICAgICB0aGlzLl9tYXAub24oTUFQQk9YR0xfUkVOREVSLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uTWFwUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uTWFwUmVuZGVyKHRoaXMuX21hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvcHMuZ2V0TWFwYm94UmVmKSB7XG4gICAgICAgIC8vIFRoZSBwYXJlbnQgY29tcG9uZW50IGNhbiBnYWluIGFjY2VzcyB0byBvdXIgTWFwYm94R2xNYXAgYnlcbiAgICAgICAgLy8gcHJvdmlkaW5nIHRoaXMgY2FsbGJhY2suIE5vdGUgdGhhdCAnbWFwYm94JyB3aWxsIGJlIG51bGwgd2hlbiB0aGVcbiAgICAgICAgLy8gcmVmIGlzIHVuc2V0IChlLmcuIHdoZW4gYSBzcGxpdCBtYXAgaXMgY2xvc2VkKS5cbiAgICAgICAgdGhpcy5wcm9wcy5nZXRNYXBib3hSZWYobWFwYm94LCB0aGlzLnByb3BzLmluZGV4KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX29uRGVja0luaXRpYWxpemVkKGdsKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vbkRlY2tJbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uRGVja0luaXRpYWxpemVkKHRoaXMuX2RlY2ssIGdsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAxKSBBbGxvdyBlZmZlY3RzIG9ubHkgZm9yIHRoZSBmaXJzdCB2aWV3LlxuICAgICAqIDIpIFByZXZlbnQgZWZmZWN0OnByZVJlbmRlciBjYWxsIHdpdGhvdXQgdmFsaWQgZ2VuZXJhdGVkIHZpZXdwb3J0cy5cbiAgICAgKiBAcGFyYW0gdmlld0luZGV4IFZpZXcgaW5kZXguXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIGVmZmVjdHMgY2FuIGJlIHVzZWQuXG4gICAgICovXG4gICAgX2lzT0tUb1JlbmRlckVmZmVjdHModmlld0luZGV4PzogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gIXZpZXdJbmRleCAmJiBCb29sZWFuKHRoaXMuX2RlY2s/LnZpZXdNYW5hZ2VyPy5fdmlld3BvcnRzPy5sZW5ndGgpO1xuICAgIH1cblxuICAgIF9vbkJlZm9yZVJlbmRlciA9ICh7Z2x9KSA9PiB7XG4gICAgICBzZXRMYXllckJsZW5kaW5nKGdsLCB0aGlzLnByb3BzLnZpc1N0YXRlLmxheWVyQmxlbmRpbmcpO1xuICAgIH07XG5cbiAgICBfb25EZWNrRXJyb3IgPSAoZXJyb3IsIGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvcj8ubWVzc2FnZSB8fCAndW5rbm93bi1lcnJvcic7XG4gICAgICBjb25zdCBsYXllck1lc3NhZ2UgPSBsYXllcj8uaWQgPyBgIGluICR7bGF5ZXIuaWR9IGxheWVyYCA6ICcnO1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlRnVsbCA9XG4gICAgICAgIGVycm9yTWVzc2FnZSA9PT0gJ1dlYkdMIGNvbnRleHQgaXMgbG9zdCdcbiAgICAgICAgICA/ICdZb3VyIEdQVSB3YXMgZGlzY29ubmVjdGVkLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91ciBjb21wdXRlciBnb2VzIHRvIHNsZWVwLiBJdCBjYW4gYWxzbyBvY2N1ciBmb3Igb3RoZXIgcmVhc29ucywgc3VjaCBhcyBpZiB5b3UgYXJlIHJ1bm5pbmcgdG9vIG1hbnkgR1BVIGFwcGxpY2F0aW9ucy4nXG4gICAgICAgICAgOiBgQW4gZXJyb3IgaW4gZGVjay5nbDogJHtlcnJvck1lc3NhZ2V9JHtsYXllck1lc3NhZ2V9LmA7XG5cbiAgICAgIC8vIFRocm90dGxlIGVycm9yIG5vdGlmaWNhdGlvbnMsIGFzIFJlYWN0IGRvZXNuJ3QgbGlrZSB0b28gbWFueSBzdGF0ZSBjaGFuZ2VzIGZyb20gaGVyZS5cbiAgICAgIGNvbnN0IGxhc3RTaG93biA9IHRoaXMuX2RlY2tHTEVycm9yc0VsYXBzZWRbZXJyb3JNZXNzYWdlRnVsbF07XG4gICAgICBpZiAoIWxhc3RTaG93biB8fCBsYXN0U2hvd24gPCBEYXRlLm5vdygpIC0gVEhST1RUTEVfTk9USUZJQ0FUSU9OX1RJTUUpIHtcbiAgICAgICAgdGhpcy5fZGVja0dMRXJyb3JzRWxhcHNlZFtlcnJvck1lc3NhZ2VGdWxsXSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgLy8gTWFyayBsYXllciBhcyBpbnZhbGlkXG4gICAgICAgIGxldCBleHRyYUxheWVyTWVzc2FnZSA9ICcnO1xuICAgICAgICBjb25zdCB7dmlzU3RhdGVBY3Rpb25zfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgIGxldCB0b3BNb3N0TGF5ZXIgPSBsYXllcjtcbiAgICAgICAgICB3aGlsZSAodG9wTW9zdExheWVyLnBhcmVudCkge1xuICAgICAgICAgICAgdG9wTW9zdExheWVyID0gdG9wTW9zdExheWVyLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvcE1vc3RMYXllci5wcm9wcz8uaWQpIHtcbiAgICAgICAgICAgIHZpc1N0YXRlQWN0aW9ucy5sYXllclNldElzVmFsaWQodG9wTW9zdExheWVyLCBmYWxzZSk7XG4gICAgICAgICAgICBleHRyYUxheWVyTWVzc2FnZSA9ICdUaGUgbGF5ZXIgaGFzIGJlZW4gZGlzYWJsZWQgYW5kIGhpZ2hsaWdodGVkLic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBlcnJvciBub3RpZmljYXRpb24gb3IgdXBkYXRlIGV4aXN0aW5nIG9uZSB3aXRoIHNhbWUgaWQuXG4gICAgICAgIC8vIFVwZGF0ZSBpcyByZXF1aXJlZCB0byBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2Ygbm90aWZpY2F0aW9ucyBhcyB0aGV5IHByb2JhYmx5IGFyZSBnb2luZyB0byBcImp1bXBcIiBiYXNlZCBvbiBvcmRlciBvZiBlcnJvcnMuXG4gICAgICAgIGNvbnN0IHt1aVN0YXRlQWN0aW9uc30gPSB0aGlzLnByb3BzO1xuICAgICAgICB1aVN0YXRlQWN0aW9ucy5hZGROb3RpZmljYXRpb24oXG4gICAgICAgICAgZXJyb3JOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgbWVzc2FnZTogYCR7ZXJyb3JNZXNzYWdlRnVsbH0gJHtleHRyYUxheWVyTWVzc2FnZX1gLFxuICAgICAgICAgICAgaWQ6IGVycm9yTWVzc2FnZUZ1bGwgLy8gdHJlYXQgdGhlIGVycm9yIG1lc3NhZ2UgYXMgaWRcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKiBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9ucyAqL1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuICAgIF9yZW5kZXJNYXBQb3BvdmVyKCkge1xuICAgICAgLy8gdGhpcyBjaGVjayBpcyBmb3IgbGltaXRpbmcgdGhlIGRpc3BsYXkgb2YgdGhlIGA8TWFwUG9wb3Zlcj5gIHRvIHRoZSBgPE1hcENvbnRhaW5lcj5gIHRoZSB1c2VyIGlzIGludGVyYWN0aW5nIHdpdGhcbiAgICAgIC8vIHRoZSBEZWNrR0wgb25Ib3ZlciBldmVudCBoYW5kbGVyIGFkZHMgYSBgbWFwSW5kZXhgIHByb3BlcnR5IHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgYGhvdmVySW5mb2Agb2JqZWN0IG9mIGB2aXNTdGF0ZWBcbiAgICAgIGlmICh0aGlzLnByb3BzLmluZGV4ICE9PSB0aGlzLnByb3BzLnZpc1N0YXRlLmhvdmVySW5mbz8ubWFwSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IG1vdmUgdGhpcyBpbnRvIHJlZHVjZXIgc28gaXQgY2FuIGJlIHRlc3RlZFxuICAgICAgY29uc3Qge1xuICAgICAgICBtYXBTdGF0ZSxcbiAgICAgICAgdmlzU3RhdGU6IHtcbiAgICAgICAgICBob3ZlckluZm8sXG4gICAgICAgICAgY2xpY2tlZCxcbiAgICAgICAgICBkYXRhc2V0cyxcbiAgICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgICAgICBsYXllcnMsXG4gICAgICAgICAgbW91c2VQb3M6IHttb3VzZVBvc2l0aW9uLCBjb29yZGluYXRlLCBwaW5uZWR9XG4gICAgICAgIH1cbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgbGF5ZXJzVG9SZW5kZXIgPSB0aGlzLmxheWVyc1RvUmVuZGVyU2VsZWN0b3IodGhpcy5wcm9wcyk7XG5cbiAgICAgIGlmICghbW91c2VQb3NpdGlvbiB8fCAhaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGF5ZXJIb3ZlclByb3AgPSBnZXRMYXllckhvdmVyUHJvcCh7XG4gICAgICAgIGludGVyYWN0aW9uQ29uZmlnLFxuICAgICAgICBob3ZlckluZm8sXG4gICAgICAgIGxheWVycyxcbiAgICAgICAgbGF5ZXJzVG9SZW5kZXIsXG4gICAgICAgIGRhdGFzZXRzXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY29tcGFyZU1vZGUgPSBpbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLmNvbmZpZ1xuICAgICAgICA/IGludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAuY29uZmlnLmNvbXBhcmVNb2RlXG4gICAgICAgIDogZmFsc2U7XG5cbiAgICAgIGxldCBwaW5uZWRQb3NpdGlvbiA9IHt4OiAwLCB5OiAwfTtcbiAgICAgIGxldCBsYXllclBpbm5lZFByb3A6IExheWVySG92ZXJQcm9wIHwgbnVsbCA9IG51bGw7XG4gICAgICBpZiAocGlubmVkIHx8IGNsaWNrZWQpIHtcbiAgICAgICAgLy8gcHJvamVjdCBsbmdsYXQgdG8gc2NyZWVuIHNvIHRoYXQgdG9vbHRpcCBmb2xsb3dzIHRoZSBvYmplY3Qgb24gem9vbVxuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0RnJvbU1hcFN0YXRlKG1hcFN0YXRlKTtcbiAgICAgICAgY29uc3QgbG5nTGF0ID0gY2xpY2tlZCA/IGNsaWNrZWQuY29vcmRpbmF0ZSA6IHBpbm5lZC5jb29yZGluYXRlO1xuICAgICAgICBwaW5uZWRQb3NpdGlvbiA9IHRoaXMuX2dldEhvdmVyWFkodmlld3BvcnQsIGxuZ0xhdCk7XG4gICAgICAgIGxheWVyUGlubmVkUHJvcCA9IGdldExheWVySG92ZXJQcm9wKHtcbiAgICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgICAgICBob3ZlckluZm86IGNsaWNrZWQsXG4gICAgICAgICAgbGF5ZXJzLFxuICAgICAgICAgIGxheWVyc1RvUmVuZGVyLFxuICAgICAgICAgIGRhdGFzZXRzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGF5ZXJIb3ZlclByb3AgJiYgbGF5ZXJQaW5uZWRQcm9wKSB7XG4gICAgICAgICAgbGF5ZXJIb3ZlclByb3AucHJpbWFyeURhdGEgPSBsYXllclBpbm5lZFByb3AuZGF0YTtcbiAgICAgICAgICBsYXllckhvdmVyUHJvcC5jb21wYXJlVHlwZSA9IGludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAuY29uZmlnLmNvbXBhcmVUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbW1vblByb3AgPSB7XG4gICAgICAgIG9uQ2xvc2U6IHRoaXMuX29uQ2xvc2VNYXBQb3BvdmVyLFxuICAgICAgICB6b29tOiBtYXBTdGF0ZS56b29tLFxuICAgICAgICBjb250YWluZXI6IHRoaXMuX2RlY2sgPyB0aGlzLl9kZWNrLmNhbnZhcyA6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEVycm9yQm91bmRhcnk+XG4gICAgICAgICAge2xheWVyUGlubmVkUHJvcCAmJiAoXG4gICAgICAgICAgICA8TWFwUG9wb3ZlclxuICAgICAgICAgICAgICB7Li4ucGlubmVkUG9zaXRpb259XG4gICAgICAgICAgICAgIHsuLi5jb21tb25Qcm9wfVxuICAgICAgICAgICAgICBsYXllckhvdmVyUHJvcD17bGF5ZXJQaW5uZWRQcm9wfVxuICAgICAgICAgICAgICBjb29yZGluYXRlPXtpbnRlcmFjdGlvbkNvbmZpZy5jb29yZGluYXRlLmVuYWJsZWQgJiYgKHBpbm5lZCB8fCB7fSkuY29vcmRpbmF0ZX1cbiAgICAgICAgICAgICAgZnJvemVuPXt0cnVlfVxuICAgICAgICAgICAgICBpc0Jhc2U9e2NvbXBhcmVNb2RlfVxuICAgICAgICAgICAgICBvblNldEZlYXR1cmVzPXt0aGlzLnByb3BzLnZpc1N0YXRlQWN0aW9ucy5zZXRGZWF0dXJlc31cbiAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRGZWF0dXJlPXt0aGlzLnByb3BzLnZpc1N0YXRlQWN0aW9ucy5zZXRTZWxlY3RlZEZlYXR1cmV9XG4gICAgICAgICAgICAgIGZlYXR1cmVDb2xsZWN0aW9uPXt0aGlzLmZlYXR1cmVDb2xsZWN0aW9uU2VsZWN0b3IodGhpcy5wcm9wcyl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgICAge2xheWVySG92ZXJQcm9wICYmICghbGF5ZXJQaW5uZWRQcm9wIHx8IGNvbXBhcmVNb2RlKSAmJiAoXG4gICAgICAgICAgICA8TWFwUG9wb3ZlclxuICAgICAgICAgICAgICB4PXttb3VzZVBvc2l0aW9uWzBdfVxuICAgICAgICAgICAgICB5PXttb3VzZVBvc2l0aW9uWzFdfVxuICAgICAgICAgICAgICB7Li4uY29tbW9uUHJvcH1cbiAgICAgICAgICAgICAgbGF5ZXJIb3ZlclByb3A9e2xheWVySG92ZXJQcm9wfVxuICAgICAgICAgICAgICBmcm96ZW49e2ZhbHNlfVxuICAgICAgICAgICAgICBjb29yZGluYXRlPXtpbnRlcmFjdGlvbkNvbmZpZy5jb29yZGluYXRlLmVuYWJsZWQgJiYgY29vcmRpbmF0ZX1cbiAgICAgICAgICAgICAgb25TZXRGZWF0dXJlcz17dGhpcy5wcm9wcy52aXNTdGF0ZUFjdGlvbnMuc2V0RmVhdHVyZXN9XG4gICAgICAgICAgICAgIHNldFNlbGVjdGVkRmVhdHVyZT17dGhpcy5wcm9wcy52aXNTdGF0ZUFjdGlvbnMuc2V0U2VsZWN0ZWRGZWF0dXJlfVxuICAgICAgICAgICAgICBmZWF0dXJlQ29sbGVjdGlvbj17dGhpcy5mZWF0dXJlQ29sbGVjdGlvblNlbGVjdG9yKHRoaXMucHJvcHMpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICA8L0Vycm9yQm91bmRhcnk+XG4gICAgICApO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gICAgX2dldEhvdmVyWFkodmlld3BvcnQsIGxuZ0xhdCkge1xuICAgICAgY29uc3Qgc2NyZWVuQ29vcmQgPSAhdmlld3BvcnQgfHwgIWxuZ0xhdCA/IG51bGwgOiB2aWV3cG9ydC5wcm9qZWN0KGxuZ0xhdCk7XG4gICAgICByZXR1cm4gc2NyZWVuQ29vcmQgJiYge3g6IHNjcmVlbkNvb3JkWzBdLCB5OiBzY3JlZW5Db29yZFsxXX07XG4gICAgfVxuXG4gICAgX3JlbmRlckRlY2tPdmVybGF5KFxuICAgICAgbGF5ZXJzRm9yRGVjayxcbiAgICAgIG9wdGlvbnM6IHtwcmltYXJ5TWFwOiBib29sZWFuOyBpc0ludGVyYWN0aXZlPzogYm9vbGVhbjsgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGV9ID0ge1xuICAgICAgICBwcmltYXJ5TWFwOiBmYWxzZVxuICAgICAgfVxuICAgICkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYXBTdHlsZSxcbiAgICAgICAgdmlzU3RhdGUsXG4gICAgICAgIG1hcFN0YXRlLFxuICAgICAgICB2aXNTdGF0ZUFjdGlvbnMsXG4gICAgICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgICAgICBtYXBib3hBcGlVcmwsXG4gICAgICAgIGRlY2tHbFByb3BzLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgbWFwQ29udHJvbHMsXG4gICAgICAgIGRlY2tSZW5kZXJDYWxsYmFja3MsXG4gICAgICAgIHRoZW1lLFxuICAgICAgICBnZW5lcmF0ZURlY2tHTExheWVycyxcbiAgICAgICAgb25Nb3VzZU1vdmVcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICBjb25zdCB7aG92ZXJJbmZvLCBlZGl0b3J9ID0gdmlzU3RhdGU7XG4gICAgICBjb25zdCB7cHJpbWFyeU1hcCwgaXNJbnRlcmFjdGl2ZSwgY2hpbGRyZW59ID0gb3B0aW9ucztcblxuICAgICAgLy8gZGlzYWJsZSBkb3VibGUgY2xpY2sgem9vbSB3aGVuIGVkaXRvciBpcyBpbiBhbnkgZHJhdyBtb2RlXG4gICAgICBjb25zdCB7bWFwRHJhd30gPSBtYXBDb250cm9scztcbiAgICAgIGNvbnN0IHthY3RpdmU6IGVkaXRvck1lbnVBY3RpdmUgPSBmYWxzZX0gPSBtYXBEcmF3IHx8IHt9O1xuICAgICAgY29uc3QgaXNFZGl0b3JEcmF3aW5nTW9kZSA9IEVkaXRvckxheWVyVXRpbHMuaXNEcmF3aW5nQWN0aXZlKGVkaXRvck1lbnVBY3RpdmUsIGVkaXRvci5tb2RlKTtcblxuICAgICAgY29uc3QgaW50ZXJuYWxWaWV3U3RhdGUgPSB0aGlzLmNvbnRleHQ/LmdldEludGVybmFsVmlld1N0YXRlKGluZGV4KTtcbiAgICAgIGNvbnN0IGludGVybmFsTWFwU3RhdGUgPSB7Li4ubWFwU3RhdGUsIC4uLmludGVybmFsVmlld1N0YXRlfTtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGcm9tTWFwU3RhdGUoaW50ZXJuYWxNYXBTdGF0ZSk7XG5cbiAgICAgIGNvbnN0IGVkaXRvckZlYXR1cmVTZWxlY3RlZEluZGV4ID0gdGhpcy5zZWxlY3RlZFBvbHlnb25JbmRleFNlbGVjdG9yKHRoaXMucHJvcHMpO1xuXG4gICAgICBjb25zdCB7c2V0RmVhdHVyZXMsIG9uTGF5ZXJDbGljaywgc2V0U2VsZWN0ZWRGZWF0dXJlfSA9IHZpc1N0YXRlQWN0aW9ucztcblxuICAgICAgY29uc3QgZ2VuZXJhdGVEZWNrR0xMYXllcnNNZXRob2QgPSBnZW5lcmF0ZURlY2tHTExheWVycyA/PyBjb21wdXRlRGVja0xheWVycztcbiAgICAgIGNvbnN0IGRlY2tHbExheWVycyA9IGdlbmVyYXRlRGVja0dMTGF5ZXJzTWV0aG9kKFxuICAgICAgICB7XG4gICAgICAgICAgdmlzU3RhdGUsXG4gICAgICAgICAgbWFwU3RhdGU6IGludGVybmFsTWFwU3RhdGUsXG4gICAgICAgICAgbWFwU3R5bGVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1hcEluZGV4OiBpbmRleCxcbiAgICAgICAgICBwcmltYXJ5TWFwLFxuICAgICAgICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgICAgICAgIG1hcGJveEFwaVVybCxcbiAgICAgICAgICBsYXllcnNGb3JEZWNrLFxuICAgICAgICAgIGVkaXRvckluZm86IHByaW1hcnlNYXBcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBlZGl0b3JNZW51QWN0aXZlLFxuICAgICAgICAgICAgICAgIG9uU2V0RmVhdHVyZXM6IHNldEZlYXR1cmVzLFxuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkRmVhdHVyZSxcbiAgICAgICAgICAgICAgICBmZWF0dXJlQ29sbGVjdGlvbjogdGhpcy5mZWF0dXJlQ29sbGVjdGlvblNlbGVjdG9yKHRoaXMucHJvcHMpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZUluZGV4ZXM6IHRoaXMuc2VsZWN0ZWRGZWF0dXJlSW5kZXhBcnJheVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgICAgZWRpdG9yRmVhdHVyZVNlbGVjdGVkSW5kZXhcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBvbkxheWVySG92ZXI6IHRoaXMuX29uTGF5ZXJIb3ZlcixcbiAgICAgICAgICBvblNldExheWVyRG9tYWluOiB0aGlzLl9vbkxheWVyU2V0RG9tYWluXG4gICAgICAgIH0sXG4gICAgICAgIGRlY2tHbFByb3BzXG4gICAgICApO1xuXG4gICAgICBjb25zdCBleHRyYURlY2tQYXJhbXM6IHtcbiAgICAgICAgZ2V0VG9vbHRpcD86IChpbmZvOiBhbnkpID0+IG9iamVjdCB8IG51bGw7XG4gICAgICAgIGdldEN1cnNvcj86ICh7aXNEcmFnZ2luZ306IHtpc0RyYWdnaW5nOiBib29sZWFufSkgPT4gc3RyaW5nO1xuICAgICAgfSA9IHt9O1xuICAgICAgaWYgKHByaW1hcnlNYXApIHtcbiAgICAgICAgZXh0cmFEZWNrUGFyYW1zLmdldFRvb2x0aXAgPSBpbmZvID0+XG4gICAgICAgICAgRWRpdG9yTGF5ZXJVdGlscy5nZXRUb29sdGlwKGluZm8sIHtcbiAgICAgICAgICAgIGVkaXRvck1lbnVBY3RpdmUsXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICB0aGVtZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGV4dHJhRGVja1BhcmFtcy5nZXRDdXJzb3IgPSAoe2lzRHJhZ2dpbmd9OiB7aXNEcmFnZ2luZzogYm9vbGVhbn0pID0+IHtcbiAgICAgICAgICBjb25zdCBlZGl0b3JDdXJzb3IgPSBFZGl0b3JMYXllclV0aWxzLmdldEN1cnNvcih7XG4gICAgICAgICAgICBlZGl0b3JNZW51QWN0aXZlLFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgaG92ZXJJbmZvXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVkaXRvckN1cnNvcikgcmV0dXJuIGVkaXRvckN1cnNvcjtcblxuICAgICAgICAgIGlmIChpc0RyYWdnaW5nKSByZXR1cm4gJ2dyYWJiaW5nJztcbiAgICAgICAgICBpZiAoaG92ZXJJbmZvPy5sYXllcikgcmV0dXJuICdwb2ludGVyJztcbiAgICAgICAgICByZXR1cm4gJ2dyYWInO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlZmZlY3RzID0gdGhpcy5faXNPS1RvUmVuZGVyRWZmZWN0cyhpbmRleClcbiAgICAgICAgPyBjb21wdXRlRGVja0VmZmVjdHMoe3Zpc1N0YXRlLCBtYXBTdGF0ZX0pXG4gICAgICAgIDogW107XG5cbiAgICAgIGNvbnN0IHZpZXdzID0gZGVja0dsUHJvcHM/LnZpZXdzXG4gICAgICAgID8gZGVja0dsUHJvcHM/LnZpZXdzKClcbiAgICAgICAgOiBuZXcgTWFwVmlldyh7bGVnYWN5TWV0ZXJTaXplczogdHJ1ZX0pO1xuXG4gICAgICBsZXQgYWxsRGVja0dsUHJvcHMgPSB7XG4gICAgICAgIC4uLmRlY2tHbFByb3BzLFxuICAgICAgICBwaWNraW5nUmFkaXVzOiBERUZBVUxUX1BJQ0tJTkdfUkFESVVTLFxuICAgICAgICB2aWV3cyxcbiAgICAgICAgbGF5ZXJzOiBkZWNrR2xMYXllcnMsXG4gICAgICAgIGVmZmVjdHNcbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2YgZGVja1JlbmRlckNhbGxiYWNrcz8ub25EZWNrUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFsbERlY2tHbFByb3BzID0gZGVja1JlbmRlckNhbGxiYWNrcy5vbkRlY2tSZW5kZXIoYWxsRGVja0dsUHJvcHMpO1xuICAgICAgICBpZiAoIWFsbERlY2tHbFByb3BzKSB7XG4gICAgICAgICAgLy8gaWYgb25EZWNrUmVuZGVyIHJldHVybnMgbnVsbCwgZG8gbm90IHJlbmRlciBkZWNrLmdsXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIHsuLi4oaXNJbnRlcmFjdGl2ZVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU6IHByaW1hcnlNYXBcbiAgICAgICAgICAgICAgICAgID8gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VNb3ZlPy4oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uTW91c2VNb3ZlRGVib3VuY2VkKGV2ZW50LCB2aWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge3N0eWxlOiB7cG9pbnRlckV2ZW50czogJ25vbmUnfX0pfVxuICAgICAgICA+XG4gICAgICAgICAgPERlY2tHTFxuICAgICAgICAgICAgaWQ9XCJkZWZhdWx0LWRlY2tnbC1vdmVybGF5XCJcbiAgICAgICAgICAgIG9uTG9hZD17KCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlY2tSZW5kZXJDYWxsYmFja3M/Lm9uRGVja0xvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkZWNrUmVuZGVyQ2FsbGJhY2tzLm9uRGVja0xvYWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIHsuLi5hbGxEZWNrR2xQcm9wc31cbiAgICAgICAgICAgIGNvbnRyb2xsZXI9e1xuICAgICAgICAgICAgICBpc0ludGVyYWN0aXZlXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZUNsaWNrWm9vbTogIWlzRWRpdG9yRHJhd2luZ01vZGUsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdSb3RhdGU6IHRoaXMucHJvcHMubWFwU3RhdGUuZHJhZ1JvdGF0ZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluaXRpYWxWaWV3U3RhdGU9e2ludGVybmFsVmlld1N0YXRlfVxuICAgICAgICAgICAgb25CZWZvcmVSZW5kZXI9e3RoaXMuX29uQmVmb3JlUmVuZGVyfVxuICAgICAgICAgICAgb25WaWV3U3RhdGVDaGFuZ2U9e2lzSW50ZXJhY3RpdmUgPyB0aGlzLl9vblZpZXdwb3J0Q2hhbmdlIDogdW5kZWZpbmVkfVxuICAgICAgICAgICAgey4uLmV4dHJhRGVja1BhcmFtc31cbiAgICAgICAgICAgIG9uSG92ZXI9e1xuICAgICAgICAgICAgICBpc0ludGVyYWN0aXZlXG4gICAgICAgICAgICAgICAgPyAoZGF0YSwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gRWRpdG9yTGF5ZXJVdGlscy5vbkhvdmVyKGRhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgICBlZGl0b3JNZW51QWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICBob3ZlckluZm9cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkxheWVySG92ZXJEZWJvdW5jZWQoZGF0YSwgaW5kZXgsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uQ2xpY2s9eyhkYXRhLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZUV2ZW50KGV2ZW50LnNyY0V2ZW50LCB2aWV3cG9ydCk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlcyA9IEVkaXRvckxheWVyVXRpbHMub25DbGljayhkYXRhLCBldmVudCwge1xuICAgICAgICAgICAgICAgIGVkaXRvck1lbnVBY3RpdmUsXG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIG9uTGF5ZXJDbGljayxcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZEZlYXR1cmUsXG4gICAgICAgICAgICAgICAgbWFwSW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAocmVzKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgdmlzU3RhdGVBY3Rpb25zLm9uTGF5ZXJDbGljayhkYXRhKTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBvbkVycm9yPXt0aGlzLl9vbkRlY2tFcnJvcn1cbiAgICAgICAgICAgIHJlZj17Y29tcCA9PiB7XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgaWYgKGNvbXAgJiYgY29tcC5kZWNrICYmICF0aGlzLl9kZWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuX2RlY2sgPSBjb21wLmRlY2s7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBvbldlYkdMSW5pdGlhbGl6ZWQ9e2dsID0+IHRoaXMuX29uRGVja0luaXRpYWxpemVkKGdsKX1cbiAgICAgICAgICAgIG9uQWZ0ZXJSZW5kZXI9eygpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWNrUmVuZGVyQ2FsbGJhY2tzPy5vbkRlY2tBZnRlclJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGRlY2tSZW5kZXJDYWxsYmFja3Mub25EZWNrQWZ0ZXJSZW5kZXIoYWxsRGVja0dsUHJvcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICA8L0RlY2tHTD5cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH1cblxuICAgIF91cGRhdGVNYXBib3hMYXllcnMoKSB7XG4gICAgICBjb25zdCBtYXBib3hMYXllcnMgPSB0aGlzLm1hcGJveExheWVyc1NlbGVjdG9yKHRoaXMucHJvcHMpO1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhtYXBib3hMYXllcnMpLmxlbmd0aCAmJiAhT2JqZWN0LmtleXModGhpcy5wcmV2aW91c0xheWVycykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlTWFwYm94TGF5ZXJzKHRoaXMuX21hcCwgbWFwYm94TGF5ZXJzLCB0aGlzLnByZXZpb3VzTGF5ZXJzKTtcblxuICAgICAgdGhpcy5wcmV2aW91c0xheWVycyA9IG1hcGJveExheWVycztcbiAgICB9XG5cbiAgICBfcmVuZGVyTWFwYm94T3ZlcmxheXMoKSB7XG4gICAgICBpZiAodGhpcy5fbWFwICYmIHRoaXMuX21hcC5pc1N0eWxlTG9hZGVkKCkpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlTWFwYm94TGF5ZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9vblZpZXdwb3J0Q2hhbmdlUHJvcGFnYXRlRGVib3VuY2VkID0gZGVib3VuY2UoKCkgPT4ge1xuICAgICAgY29uc3Qgdmlld1N0YXRlID0gdGhpcy5jb250ZXh0Py5nZXRJbnRlcm5hbFZpZXdTdGF0ZSh0aGlzLnByb3BzLmluZGV4KTtcbiAgICAgIG9uVmlld1BvcnRDaGFuZ2UoXG4gICAgICAgIHZpZXdTdGF0ZSxcbiAgICAgICAgdGhpcy5wcm9wcy5tYXBTdGF0ZUFjdGlvbnMudXBkYXRlTWFwLFxuICAgICAgICB0aGlzLnByb3BzLm9uVmlld1N0YXRlQ2hhbmdlLFxuICAgICAgICB0aGlzLnByb3BzLnByaW1hcnksXG4gICAgICAgIHRoaXMucHJvcHMuaW5kZXhcbiAgICAgICk7XG4gICAgfSwgREVCT1VOQ0VfVklFV1BPUlRfUFJPUEFHQVRFKTtcblxuICAgIF9vblZpZXdwb3J0Q2hhbmdlID0gdmlld3BvcnQgPT4ge1xuICAgICAgY29uc3Qge3ZpZXdTdGF0ZX0gPSB2aWV3cG9ydDtcbiAgICAgIGlmICh0aGlzLnByb3BzLmlzRXhwb3J0KSB7XG4gICAgICAgIC8vIEltYWdlIGV4cG9ydCBtYXAgc2hvdWxkbid0IGJlIGludGVyYWN0aXZlIChvdGhlcndpc2UgdGhpcyBjYWxsYmFjayBjYW5cbiAgICAgICAgLy8gbGVhZCB0byBpbmFkdmVydGVudCBjaGFuZ2VzIHRvIHRoZSBzdGF0ZSBvZiB0aGUgbWFpbiBtYXApXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtzZXRJbnRlcm5hbFZpZXdTdGF0ZX0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICBzZXRJbnRlcm5hbFZpZXdTdGF0ZSh2aWV3U3RhdGUsIHRoaXMucHJvcHMuaW5kZXgpO1xuICAgICAgdGhpcy5fb25WaWV3cG9ydENoYW5nZVByb3BhZ2F0ZURlYm91bmNlZCgpO1xuICAgIH07XG5cbiAgICBfb25MYXllckhvdmVyRGVib3VuY2VkID0gZGVib3VuY2UoKGRhdGEsIGluZGV4LCBldmVudCkgPT4ge1xuICAgICAgLy8gYWRkIGBtYXBJbmRleGAgcHJvcGVydHkgd2hpY2ggd2lsbCBlbmQgdXAgaW4gdGhlIHRoZSBgaG92ZXJJbmZvYCBvYmplY3Qgb2YgYHZpc1N0YXRlYFxuICAgICAgLy8gdGhpcyBpcyBmb3IgbGltaXRpbmcgdGhlIGRpc3BsYXkgb2YgdGhlIGA8TWFwUG9wb3Zlcj5gIHRvIHRoZSBgPE1hcENvbnRhaW5lcj5gIHRoZSB1c2VyIGlzIGludGVyYWN0aW5nIHdpdGhcbiAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgYmUgcGFydCBvZiBvbkxheWVySG92ZXIgYXJndW1lbnRzLCBpbnZlc3RpZ2F0ZVxuICAgICAgLy8gQHRzLWlnbm9yZSAoZG9lcyBub3QgZmFpbCB3aXRoIGxvY2FsIHlhcm4tdGVzdClcbiAgICAgIGRhdGEubWFwSW5kZXggPSBpbmRleDtcblxuICAgICAgdGhpcy5wcm9wcy52aXNTdGF0ZUFjdGlvbnMub25MYXllckhvdmVyKGRhdGEpO1xuICAgIH0sIERFQk9VTkNFX01PVVNFX01PVkVfUFJPUEFHQVRFKTtcblxuICAgIF9vbk1vdXNlTW92ZURlYm91bmNlZCA9IGRlYm91bmNlKChldmVudCwgdmlld3BvcnQpID0+IHtcbiAgICAgIHRoaXMucHJvcHMudmlzU3RhdGVBY3Rpb25zLm9uTW91c2VNb3ZlKG5vcm1hbGl6ZUV2ZW50KGV2ZW50LCB2aWV3cG9ydCkpO1xuICAgIH0sIERFQk9VTkNFX01PVVNFX01PVkVfUFJPUEFHQVRFKTtcblxuICAgIF90b2dnbGVNYXBDb250cm9sID0gcGFuZWxJZCA9PiB7XG4gICAgICBjb25zdCB7aW5kZXgsIHVpU3RhdGVBY3Rpb25zfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgIHVpU3RhdGVBY3Rpb25zLnRvZ2dsZU1hcENvbnRyb2wocGFuZWxJZCwgTnVtYmVyKGluZGV4KSk7XG4gICAgfTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgICBfcmVuZGVyTWFwKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB2aXNTdGF0ZSxcbiAgICAgICAgbWFwU3RhdGUsXG4gICAgICAgIG1hcFN0eWxlLFxuICAgICAgICBtYXBTdGF0ZUFjdGlvbnMsXG4gICAgICAgIE1hcENvbXBvbmVudCA9IE1hcCxcbiAgICAgICAgbWFwYm94QXBpQWNjZXNzVG9rZW4sXG4gICAgICAgIG1hcGJveEFwaVVybCxcbiAgICAgICAgbWFwQ29udHJvbHMsXG4gICAgICAgIGlzRXhwb3J0LFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIHVpU3RhdGVBY3Rpb25zLFxuICAgICAgICB2aXNTdGF0ZUFjdGlvbnMsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBwcmltYXJ5LFxuICAgICAgICBib3R0b21NYXBDb250YWluZXJQcm9wcyxcbiAgICAgICAgdG9wTWFwQ29udGFpbmVyUHJvcHMsXG4gICAgICAgIHRoZW1lLFxuICAgICAgICBkYXRhc2V0QXR0cmlidXRpb25zID0gW10sXG4gICAgICAgIGNvbnRhaW5lcklkID0gMFxuICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgIGNvbnN0IHtsYXllcnMsIGRhdGFzZXRzLCBlZGl0b3IsIGludGVyYWN0aW9uQ29uZmlnfSA9IHZpc1N0YXRlO1xuXG4gICAgICBjb25zdCBsYXllcnNUb1JlbmRlciA9IHRoaXMubGF5ZXJzVG9SZW5kZXJTZWxlY3Rvcih0aGlzLnByb3BzKTtcbiAgICAgIGNvbnN0IGxheWVyc0ZvckRlY2sgPSB0aGlzLmxheWVyc0ZvckRlY2tTZWxlY3Rvcih0aGlzLnByb3BzKTtcblxuICAgICAgLy8gQ3VycmVudCBzdHlsZSBjYW4gYmUgYSBjdXN0b20gc3R5bGUsIGZyb20gd2hpY2ggd2UgcHVsbCB0aGUgbWFwYm94IEFQSSBhY2NjZXNzIHRva2VuXG4gICAgICBjb25zdCBjdXJyZW50U3R5bGUgPSBtYXBTdHlsZS5tYXBTdHlsZXM/LlttYXBTdHlsZS5zdHlsZVR5cGVdO1xuICAgICAgY29uc3QgaW50ZXJuYWxWaWV3U3RhdGUgPSB0aGlzLmNvbnRleHQ/LmdldEludGVybmFsVmlld1N0YXRlKGluZGV4KTtcbiAgICAgIGNvbnN0IG1hcFByb3BzID0ge1xuICAgICAgICAuLi5pbnRlcm5hbFZpZXdTdGF0ZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlLFxuICAgICAgICBtYXBib3hBY2Nlc3NUb2tlbjogY3VycmVudFN0eWxlPy5hY2Nlc3NUb2tlbiB8fCBtYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgICAgICAgYmFzZUFwaVVybDogbWFwYm94QXBpVXJsLFxuICAgICAgICBtYXBMaWI6IG1hcGxpYnJlZ2wsXG4gICAgICAgIHRyYW5zZm9ybVJlcXVlc3Q6IHRoaXMucHJvcHMudHJhbnNmb3JtUmVxdWVzdCB8fCB0cmFuc2Zvcm1SZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBoYXNHZW9jb2RlckxheWVyID0gQm9vbGVhbihsYXllcnMuZmluZChsID0+IGwuaWQgPT09IEdFT0NPREVSX0xBWUVSX0lEKSk7XG4gICAgICBjb25zdCBpc1NwbGl0ID0gQm9vbGVhbihtYXBTdGF0ZS5pc1NwbGl0KTtcblxuICAgICAgY29uc3QgZGVjayA9IHRoaXMuX3JlbmRlckRlY2tPdmVybGF5KGxheWVyc0ZvckRlY2ssIHtcbiAgICAgICAgcHJpbWFyeU1hcDogdHJ1ZSxcbiAgICAgICAgaXNJbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgY2hpbGRyZW46IChcbiAgICAgICAgICA8TWFwQ29tcG9uZW50XG4gICAgICAgICAgICBrZXk9XCJib3R0b21cIlxuICAgICAgICAgICAgey4uLm1hcFByb3BzfVxuICAgICAgICAgICAgbWFwU3R5bGU9e21hcFN0eWxlLmJvdHRvbU1hcFN0eWxlID8/IEVNUFRZX01BUEJPWF9TVFlMRX1cbiAgICAgICAgICAgIHsuLi5ib3R0b21NYXBDb250YWluZXJQcm9wc31cbiAgICAgICAgICAgIHJlZj17dGhpcy5fc2V0TWFwYm94TWFwfVxuICAgICAgICAgIC8+XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgaWYgKCFkZWNrKSB7XG4gICAgICAgIC8vIGRlY2tPdmVybGF5IGNhbiBiZSBudWxsIGlmIG9uRGVja1JlbmRlciByZXR1cm5zIG51bGxcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGRvbid0IHdhbnQgdG8gcmVuZGVyIHRoZSBtYXBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgIDxNYXBDb250cm9sXG4gICAgICAgICAgICBtYXBTdGF0ZT17bWFwU3RhdGV9XG4gICAgICAgICAgICBkYXRhc2V0cz17ZGF0YXNldHN9XG4gICAgICAgICAgICBhdmFpbGFibGVMb2NhbGVzPXtMT0NBTEVfQ09ERVNfQVJSQVl9XG4gICAgICAgICAgICBkcmFnUm90YXRlPXttYXBTdGF0ZS5kcmFnUm90YXRlfVxuICAgICAgICAgICAgaXNTcGxpdD17aXNTcGxpdH1cbiAgICAgICAgICAgIHByaW1hcnk9e0Jvb2xlYW4ocHJpbWFyeSl9XG4gICAgICAgICAgICBpc0V4cG9ydD17aXNFeHBvcnR9XG4gICAgICAgICAgICBsYXllcnM9e2xheWVyc31cbiAgICAgICAgICAgIGxheWVyc1RvUmVuZGVyPXtsYXllcnNUb1JlbmRlcn1cbiAgICAgICAgICAgIG1hcEluZGV4PXtpbmRleCB8fCAwfVxuICAgICAgICAgICAgbWFwQ29udHJvbHM9e21hcENvbnRyb2xzfVxuICAgICAgICAgICAgcmVhZE9ubHk9e3RoaXMucHJvcHMucmVhZE9ubHl9XG4gICAgICAgICAgICBzY2FsZT17bWFwU3RhdGUuc2NhbGUgfHwgMX1cbiAgICAgICAgICAgIHRvcD17XG4gICAgICAgICAgICAgIGludGVyYWN0aW9uQ29uZmlnLmdlb2NvZGVyICYmIGludGVyYWN0aW9uQ29uZmlnLmdlb2NvZGVyLmVuYWJsZWRcbiAgICAgICAgICAgICAgICA/IHRoZW1lLm1hcENvbnRyb2xUb3BcbiAgICAgICAgICAgICAgICA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvcj17ZWRpdG9yfVxuICAgICAgICAgICAgbG9jYWxlPXtsb2NhbGV9XG4gICAgICAgICAgICBvblRvZ2dsZVBlcnNwZWN0aXZlPXttYXBTdGF0ZUFjdGlvbnMudG9nZ2xlUGVyc3BlY3RpdmV9XG4gICAgICAgICAgICBvblRvZ2dsZVNwbGl0TWFwPXttYXBTdGF0ZUFjdGlvbnMudG9nZ2xlU3BsaXRNYXB9XG4gICAgICAgICAgICBvbk1hcFRvZ2dsZUxheWVyPXt0aGlzLl9oYW5kbGVNYXBUb2dnbGVMYXllcn1cbiAgICAgICAgICAgIG9uVG9nZ2xlTWFwQ29udHJvbD17dGhpcy5fdG9nZ2xlTWFwQ29udHJvbH1cbiAgICAgICAgICAgIG9uVG9nZ2xlU3BsaXRNYXBWaWV3cG9ydD17bWFwU3RhdGVBY3Rpb25zLnRvZ2dsZVNwbGl0TWFwVmlld3BvcnR9XG4gICAgICAgICAgICBvblNldEVkaXRvck1vZGU9e3Zpc1N0YXRlQWN0aW9ucy5zZXRFZGl0b3JNb2RlfVxuICAgICAgICAgICAgb25TZXRMb2NhbGU9e3VpU3RhdGVBY3Rpb25zLnNldExvY2FsZX1cbiAgICAgICAgICAgIG9uVG9nZ2xlRWRpdG9yVmlzaWJpbGl0eT17dmlzU3RhdGVBY3Rpb25zLnRvZ2dsZUVkaXRvclZpc2liaWxpdHl9XG4gICAgICAgICAgICBtYXBIZWlnaHQ9e21hcFN0YXRlLmhlaWdodH1cbiAgICAgICAgICAvPlxuICAgICAgICAgIHtpc1NwbGl0U2VsZWN0b3IodGhpcy5wcm9wcykgJiYgPERyb3BwYWJsZSBjb250YWluZXJJZD17Y29udGFpbmVySWR9IC8+fVxuXG4gICAgICAgICAge2RlY2t9XG4gICAgICAgICAge3RoaXMuX3JlbmRlck1hcGJveE92ZXJsYXlzKCl9XG4gICAgICAgICAgPEVkaXRvclxuICAgICAgICAgICAgaW5kZXg9e2luZGV4IHx8IDB9XG4gICAgICAgICAgICBkYXRhc2V0cz17ZGF0YXNldHN9XG4gICAgICAgICAgICBlZGl0b3I9e2VkaXRvcn1cbiAgICAgICAgICAgIGZpbHRlcnM9e3RoaXMucG9seWdvbkZpbHRlcnNTZWxlY3Rvcih0aGlzLnByb3BzKX1cbiAgICAgICAgICAgIGxheWVycz17bGF5ZXJzfVxuICAgICAgICAgICAgb25EZWxldGVGZWF0dXJlPXt2aXNTdGF0ZUFjdGlvbnMuZGVsZXRlRmVhdHVyZX1cbiAgICAgICAgICAgIG9uU2VsZWN0PXt2aXNTdGF0ZUFjdGlvbnMuc2V0U2VsZWN0ZWRGZWF0dXJlfVxuICAgICAgICAgICAgb25Ub2dnbGVQb2x5Z29uRmlsdGVyPXt2aXNTdGF0ZUFjdGlvbnMuc2V0UG9seWdvbkZpbHRlckxheWVyfVxuICAgICAgICAgICAgb25TZXRFZGl0b3JNb2RlPXt2aXNTdGF0ZUFjdGlvbnMuc2V0RWRpdG9yTW9kZX1cbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdhbGwnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgZGlzcGxheTogZWRpdG9yLnZpc2libGUgPyAnYmxvY2snIDogJ25vbmUnXG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XG4gICAgICAgICAge21hcFN0eWxlLnRvcE1hcFN0eWxlID8gKFxuICAgICAgICAgICAgPE1hcENvbXBvbmVudFxuICAgICAgICAgICAgICBrZXk9XCJ0b3BcIlxuICAgICAgICAgICAgICB2aWV3U3RhdGU9e2ludGVybmFsVmlld1N0YXRlfVxuICAgICAgICAgICAgICBtYXBTdHlsZT17bWFwU3R5bGUudG9wTWFwU3R5bGV9XG4gICAgICAgICAgICAgIHN0eWxlPXtNQVBfU1RZTEUudG9wfVxuICAgICAgICAgICAgICBtYXBib3hBY2Nlc3NUb2tlbj17bWFwUHJvcHMubWFwYm94QWNjZXNzVG9rZW59XG4gICAgICAgICAgICAgIGJhc2VBcGlVcmw9e21hcFByb3BzLmJhc2VBcGlVcmx9XG4gICAgICAgICAgICAgIG1hcExpYj17bWFwbGlicmVnbH1cbiAgICAgICAgICAgICAgey4uLnRvcE1hcENvbnRhaW5lclByb3BzfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApIDogbnVsbH1cblxuICAgICAgICAgIHtoYXNHZW9jb2RlckxheWVyXG4gICAgICAgICAgICA/IHRoaXMuX3JlbmRlckRlY2tPdmVybGF5KFxuICAgICAgICAgICAgICAgIHtbR0VPQ09ERVJfTEFZRVJfSURdOiBoYXNHZW9jb2RlckxheWVyfSxcbiAgICAgICAgICAgICAgICB7cHJpbWFyeU1hcDogZmFsc2UsIGlzSW50ZXJhY3RpdmU6IGZhbHNlfVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IG51bGx9XG4gICAgICAgICAge3RoaXMuX3JlbmRlck1hcFBvcG92ZXIoKX1cbiAgICAgICAgICB7dGhpcy5wcm9wcy5wcmltYXJ5ID8gKFxuICAgICAgICAgICAgPEF0dHJpYnV0aW9uXG4gICAgICAgICAgICAgIHNob3dNYXBib3hMb2dvPXt0aGlzLnN0YXRlLnNob3dNYXBib3hBdHRyaWJ1dGlvbn1cbiAgICAgICAgICAgICAgc2hvd09zbUJhc2VtYXBBdHRyaWJ1dGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgZGF0YXNldEF0dHJpYnV0aW9ucz17ZGF0YXNldEF0dHJpYnV0aW9uc31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgIDwvPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7dmlzU3RhdGV9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IG1hcENvbnRlbnQgPSB0aGlzLl9yZW5kZXJNYXAoKTtcbiAgICAgIGlmICghbWFwQ29udGVudCkge1xuICAgICAgICAvLyBtYXBDb250ZW50IGNhbiBiZSBudWxsIGlmIG9uRGVja1JlbmRlciByZXR1cm5zIG51bGxcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGRvbid0IHdhbnQgdG8gcmVuZGVyIHRoZSBtYXBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8U3R5bGVkTWFwXG4gICAgICAgICAgcmVmPXt0aGlzLl9yZWZ9XG4gICAgICAgICAgc3R5bGU9e3RoaXMuc3R5bGVTZWxlY3Rvcih0aGlzLnByb3BzKX1cbiAgICAgICAgICBvbkNvbnRleHRNZW51PXtldmVudCA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpfVxuICAgICAgICAgIG1peEJsZW5kTW9kZT17dmlzU3RhdGUub3ZlcmxheUJsZW5kaW5nfVxuICAgICAgICA+XG4gICAgICAgICAge21hcENvbnRlbnR9XG4gICAgICAgIDwvU3R5bGVkTWFwPlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2l0aFRoZW1lKE1hcENvbnRhaW5lcik7XG59XG4iXX0=