import { getTableLength } from '@loaders.gl/schema';
export function* makeBatchesFromTable(table) {
  yield makeBatchFromTable(table);
}
export function makeBatchFromTable(table) {
  return {
    ...table,
    length: getTableLength(table),
    batchType: 'data'
  };
}
export async function makeTableFromBatches(batchIterator) {
  let arrayRows;
  let objectRows;
  let features;
  let shape = null;
  let schema;
  for await (const batch of batchIterator) {
    shape = shape || batch.shape;
    schema = schema || batch.schema;
    switch (batch.shape) {
      case 'array-row-table':
        arrayRows = arrayRows || [];
        for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {
          const row = batch.data[rowIndex];
          arrayRows.push(row);
        }
        break;
      case 'object-row-table':
        objectRows = objectRows || [];
        for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {
          const row = batch.data[rowIndex];
          objectRows.push(row);
        }
        break;
      case 'geojson-table':
        features = features || [];
        for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {
          const row = batch.features[rowIndex];
          features.push(row);
        }
        break;
      case 'columnar-table':
      case 'arrow-table':
      default:
        throw new Error('shape');
    }
  }
  if (!shape) {
    return null;
  }
  switch (shape) {
    case 'array-row-table':
      return {
        shape: 'array-row-table',
        data: arrayRows,
        schema
      };
    case 'object-row-table':
      return {
        shape: 'object-row-table',
        data: objectRows,
        schema
      };
    case 'geojson-table':
      return {
        shape: 'geojson-table',
        type: 'FeatureCollection',
        features: features,
        schema
      };
    default:
      return null;
  }
}
//# sourceMappingURL=make-table-from-batches.js.map