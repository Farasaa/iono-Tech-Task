"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _core = require("@deck.gl/core");

var _typed = require("@deck.gl/layers/typed");

var _constants = _interopRequireDefault(require("@luma.gl/constants"));

var _ = require("../");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function addInstanceCoverage(vs) {
  var addDecl = (0, _.editShader)(vs, 'hexagon cell vs add instance 1', 'in vec3 instancePickingColors;', "in vec3 instancePickingColors;\n     in float instanceCoverage;");
  return (0, _.editShader)(addDecl, 'hexagon cell vs add instance 2', 'float dotRadius = radius * coverage * shouldRender;', 'float dotRadius = radius * coverage * instanceCoverage * shouldRender;');
}

// TODO: export all deck.gl layers from kepler.gl
var EnhancedColumnLayer = /*#__PURE__*/function (_ColumnLayer) {
  (0, _inherits2["default"])(EnhancedColumnLayer, _ColumnLayer);

  var _super = _createSuper(EnhancedColumnLayer);

  function EnhancedColumnLayer() {
    (0, _classCallCheck2["default"])(this, EnhancedColumnLayer);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(EnhancedColumnLayer, [{
    key: "getShaders",
    value: function getShaders() {
      var shaders = (0, _get2["default"])((0, _getPrototypeOf2["default"])(EnhancedColumnLayer.prototype), "getShaders", this).call(this);
      return _objectSpread(_objectSpread({}, shaders), {}, {
        vs: addInstanceCoverage(shaders.vs)
      });
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var _this$getAttributeMan;

      (0, _get2["default"])((0, _getPrototypeOf2["default"])(EnhancedColumnLayer.prototype), "initializeState", this).call(this);
      (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.addInstanced({
        instanceCoverage: {
          size: 1,
          accessor: 'getCoverage'
        }
      });
    }
  }, {
    key: "draw",
    value: function draw(_ref) {
      var uniforms = _ref.uniforms;
      var _this$props = this.props,
          lineWidthUnits = _this$props.lineWidthUnits,
          lineWidthScale = _this$props.lineWidthScale,
          lineWidthMinPixels = _this$props.lineWidthMinPixels,
          lineWidthMaxPixels = _this$props.lineWidthMaxPixels,
          radiusUnits = _this$props.radiusUnits,
          elevationScale = _this$props.elevationScale,
          extruded = _this$props.extruded,
          filled = _this$props.filled,
          stroked = _this$props.stroked,
          strokeOpacity = _this$props.strokeOpacity,
          wireframe = _this$props.wireframe,
          offset = _this$props.offset,
          coverage = _this$props.coverage,
          radius = _this$props.radius,
          angle = _this$props.angle;
      var _this$state = this.state,
          model = _this$state.model,
          fillVertexCount = _this$state.fillVertexCount,
          wireframeVertexCount = _this$state.wireframeVertexCount,
          edgeDistance = _this$state.edgeDistance;
      model.setUniforms(uniforms).setUniforms({
        radius: radius,
        angle: angle / 180 * Math.PI,
        offset: offset,
        extruded: extruded,
        stroked: stroked,
        coverage: coverage,
        elevationScale: elevationScale,
        edgeDistance: edgeDistance,
        radiusUnits: _core.UNIT[radiusUnits],
        widthUnits: _core.UNIT[lineWidthUnits],
        widthScale: lineWidthScale,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels
      }); // When drawing 3d: draw wireframe first so it doesn't get occluded by depth test

      if (extruded && wireframe) {
        model.setProps({
          isIndexed: true
        });
        model.setVertexCount(wireframeVertexCount).setDrawMode(_constants["default"].LINES).setUniforms({
          isStroke: true
        }).draw();
      }

      if (filled) {
        model.setProps({
          isIndexed: false
        });
        model.setVertexCount(fillVertexCount).setDrawMode(_constants["default"].TRIANGLE_STRIP).setUniforms({
          isStroke: false
        }).draw();
      } // When drawing 2d: draw fill before stroke so that the outline is always on top


      if (!extruded && stroked) {
        model.setProps({
          isIndexed: false
        }); // The width of the stroke is achieved by flattening the side of the cylinder.
        // Skip the last 1/3 of the vertices which is the top.

        model.setVertexCount(fillVertexCount * 2 / 3).setDrawMode(_constants["default"].TRIANGLE_STRIP).setUniforms({
          isStroke: true,
          opacity: strokeOpacity
        }).draw();
      }
    }
  }]);
  return EnhancedColumnLayer;
}(_typed.ColumnLayer);

EnhancedColumnLayer.layerName = 'EnhancedColumnLayer';
var _default = EnhancedColumnLayer;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb2x1bW4tbGF5ZXIvZW5oYW5jZWQtY29sdW1uLWxheWVyLnRzIl0sIm5hbWVzIjpbImFkZEluc3RhbmNlQ292ZXJhZ2UiLCJ2cyIsImFkZERlY2wiLCJFbmhhbmNlZENvbHVtbkxheWVyIiwic2hhZGVycyIsImdldEF0dHJpYnV0ZU1hbmFnZXIiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZUNvdmVyYWdlIiwic2l6ZSIsImFjY2Vzc29yIiwidW5pZm9ybXMiLCJwcm9wcyIsImxpbmVXaWR0aFVuaXRzIiwibGluZVdpZHRoU2NhbGUiLCJsaW5lV2lkdGhNaW5QaXhlbHMiLCJsaW5lV2lkdGhNYXhQaXhlbHMiLCJyYWRpdXNVbml0cyIsImVsZXZhdGlvblNjYWxlIiwiZXh0cnVkZWQiLCJmaWxsZWQiLCJzdHJva2VkIiwic3Ryb2tlT3BhY2l0eSIsIndpcmVmcmFtZSIsIm9mZnNldCIsImNvdmVyYWdlIiwicmFkaXVzIiwiYW5nbGUiLCJzdGF0ZSIsIm1vZGVsIiwiZmlsbFZlcnRleENvdW50Iiwid2lyZWZyYW1lVmVydGV4Q291bnQiLCJlZGdlRGlzdGFuY2UiLCJzZXRVbmlmb3JtcyIsIk1hdGgiLCJQSSIsIlVOSVQiLCJ3aWR0aFVuaXRzIiwid2lkdGhTY2FsZSIsIndpZHRoTWluUGl4ZWxzIiwid2lkdGhNYXhQaXhlbHMiLCJzZXRQcm9wcyIsImlzSW5kZXhlZCIsInNldFZlcnRleENvdW50Iiwic2V0RHJhd01vZGUiLCJHTCIsIkxJTkVTIiwiaXNTdHJva2UiLCJkcmF3IiwiVFJJQU5HTEVfU1RSSVAiLCJvcGFjaXR5IiwiQ29sdW1uTGF5ZXIiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUFFQSxTQUFTQSxtQkFBVCxDQUE2QkMsRUFBN0IsRUFBaUM7QUFDL0IsTUFBTUMsT0FBTyxHQUFHLGtCQUNkRCxFQURjLEVBRWQsZ0NBRmMs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VUFBSTVCLE1BQUosRUFBWTtBQUNWUyxRQUFBQSxLQUFLLENBQUNZLFFBQU4sQ0FBZTtBQUFDQyxVQUFBQSxTQUFTLEVBQUU7QUFBWixTQUFmO0FBQ0FiLFFBQUFBLEtBQUssQ0FDRmMsY0FESCxDQUNrQmIsZUFEbEIsRUFFR2MsV0FGSCxDQUVlQyxzQkFBR0ksY0FGbEIsRUFHR2hCLFdBSEgsQ0FHZTtBQUFDYyxVQUFBQSxRQUFRLEVBQUU7QUFBWCxTQUhmLEVBSUdDLElBSkg7QUFLRCxPQXBEYyxDQXFEZjs7O0FBQ0EsVUFBSSxDQUFDN0IsUUFBRCxJQUFhRSxPQUFqQixFQUEwQjtBQUN4QlEsUUFBQUEsS0FBSyxDQUFDWSxRQUFOLENBQWU7QUFBQ0MsVUFBQUEsU0FBUyxFQUFFO0FBQVosU0FBZixFQUR3QixDQUV4QjtBQUNBOztBQUNBYixRQUFBQSxLQUFLLENBQ0ZjLGNBREgsQ0FDbUJiLGVBQWUsR0FBRyxDQUFuQixHQUF3QixDQUQxQyxFQUVHYyxXQUZILENBRWVDLHNCQUFHSSxjQUZsQixFQUdHaEIsV0FISCxDQUdlO0FBQUNjLFVBQUFBLFFBQVEsRUFBRSxJQUFYO0FBQWlCRyxVQUFBQSxPQUFPLEVBQUU1QjtBQUExQixTQUhmLEVBSUcwQixJQUpIO0FBS0Q7QUFDRjs7O0VBbEYrQkcsa0I7O0FBcUZsQy9DLG1CQUFtQixDQUFDZ0QsU0FBcEIsR0FBZ0MscUJBQWhDO2VBRWVoRCxtQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCB7VU5JVH0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQge0NvbHVtbkxheWVyLCBDb2x1bW5MYXllclByb3BzfSBmcm9tICdAZGVjay5nbC9sYXllcnMvdHlwZWQnO1xuaW1wb3J0IEdMIGZyb20gJ0BsdW1hLmdsL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7ZWRpdFNoYWRlcn0gZnJvbSAnLi4vJztcblxuZnVuY3Rpb24gYWRkSW5zdGFuY2VDb3ZlcmFnZSh2cykge1xuICBjb25zdCBhZGREZWNsID0gZWRpdFNoYWRlcihcbiAgICB2cyxcbiAgICAnaGV4YWdvbiBjZWxsIHZzIGFkZCBpbnN0YW5jZSAxJyxcbiAgICAnaW4gdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7JyxcbiAgICBgaW4gdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG4gICAgIGluIGZsb2F0IGluc3RhbmNlQ292ZXJhZ2U7YFxuICApO1xuXG4gIHJldHVybiBlZGl0U2hhZGVyKFxuICAgIGFkZERlY2wsXG4gICAgJ2hleGFnb24gY2VsbCB2cyBhZGQgaW5zdGFuY2UgMicsXG4gICAgJ2Zsb2F0IGRvdFJhZGl1cyA9IHJhZGl1cyAqIGNvdmVyYWdlICogc2hvdWxkUmVuZGVyOycsXG4gICAgJ2Zsb2F0IGRvdFJhZGl1cyA9IHJhZGl1cyAqIGNvdmVyYWdlICogaW5zdGFuY2VDb3ZlcmFnZSAqIHNob3VsZFJlbmRlcjsnXG4gICk7XG59XG5cbnR5cGUgRW5oYW5jZWRDb2x1bW5MYXllclByb3BzID0gQ29sdW1uTGF5ZXJQcm9wczxhbnk+ICYge1xuICBzdHJva2VPcGFjaXR5OiBhbnk7XG59O1xuXG4vLyBUT0RPOiBleHBvcnQgYWxsIGRlY2suZ2wgbGF5ZXJzIGZyb20ga2VwbGVyLmdsXG5jbGFzcyBFbmhhbmNlZENvbHVtbkxheWVyIGV4dGVuZHMgQ29sdW1uTGF5ZXI8YW55LCBFbmhhbmNlZENvbHVtbkxheWVyUHJvcHM+IHtcbiAgZ2V0U2hhZGVycygpIHtcbiAgICBjb25zdCBzaGFkZXJzID0gc3VwZXIuZ2V0U2hhZGVycygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNoYWRlcnMsXG4gICAgICB2czogYWRkSW5zdGFuY2VDb3ZlcmFnZShzaGFkZXJzLnZzKVxuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZVN0YXRlKCk7XG5cbiAgICB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKT8uYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlQ292ZXJhZ2U6IHtzaXplOiAxLCBhY2Nlc3NvcjogJ2dldENvdmVyYWdlJ31cbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVXaWR0aFVuaXRzLFxuICAgICAgbGluZVdpZHRoU2NhbGUsXG4gICAgICBsaW5lV2lkdGhNaW5QaXhlbHMsXG4gICAgICBsaW5lV2lkdGhNYXhQaXhlbHMsXG4gICAgICByYWRpdXNVbml0cyxcbiAgICAgIGVsZXZhdGlvblNjYWxlLFxuICAgICAgZXh0cnVkZWQsXG4gICAgICBmaWxsZWQsXG4gICAgICBzdHJva2VkLFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIHdpcmVmcmFtZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIGNvdmVyYWdlLFxuICAgICAgcmFkaXVzLFxuICAgICAgYW5nbGVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7bW9kZWwsIGZpbGxWZXJ0ZXhDb3VudCwgd2lyZWZyYW1lVmVydGV4Q291bnQsIGVkZ2VEaXN0YW5jZX0gPSB0aGlzLnN0YXRlO1xuXG4gICAgbW9kZWwuc2V0VW5pZm9ybXModW5pZm9ybXMpLnNldFVuaWZvcm1zKHtcbiAgICAgIHJhZGl1cyxcbiAgICAgIGFuZ2xlOiAoYW5nbGUgLyAxODApICogTWF0aC5QSSxcbiAgICAgIG9mZnNldCxcbiAgICAgIGV4dHJ1ZGVkLFxuICAgICAgc3Ryb2tlZCxcbiAgICAgIGNvdmVyYWdlLFxuICAgICAgZWxldmF0aW9uU2NhbGUsXG4gICAgICBlZGdlRGlzdGFuY2UsXG4gICAgICByYWRpdXNVbml0czogVU5JVFtyYWRpdXNVbml0c10sXG4gICAgICB3aWR0aFVuaXRzOiBVTklUW2xpbmVXaWR0aFVuaXRzXSxcbiAgICAgIHdpZHRoU2NhbGU6IGxpbmVXaWR0aFNjYWxlLFxuICAgICAgd2lkdGhNaW5QaXhlbHM6IGxpbmVXaWR0aE1pblBpeGVscyxcbiAgICAgIHdpZHRoTWF4UGl4ZWxzOiBsaW5lV2lkdGhNYXhQaXhlbHNcbiAgICB9KTtcblxuICAgIC8vIFdoZW4gZHJhd2luZyAzZDogZHJhdyB3aXJlZnJhbWUgZmlyc3Qgc28gaXQgZG9lc24ndCBnZXQgb2NjbHVkZWQgYnkgZGVwdGggdGVzdFxuICAgIGlmIChleHRydWRlZCAmJiB3aXJlZnJhbWUpIHtcbiAgICAgIG1vZGVsLnNldFByb3BzKHtpc0luZGV4ZWQ6IHRydWV9KTtcbiAgICAgIG1vZGVsXG4gICAgICAgIC5zZXRWZXJ0ZXhDb3VudCh3aXJlZnJhbWVWZXJ0ZXhDb3VudClcbiAgICAgICAgLnNldERyYXdNb2RlKEdMLkxJTkVTKVxuICAgICAgICAuc2V0VW5pZm9ybXMoe2lzU3Ryb2tlOiB0cnVlfSlcbiAgICAgICAgLmRyYXcoKTtcbiAgICB9XG4gICAgaWYgKGZpbGxlZCkge1xuICAgICAgbW9kZWwuc2V0UHJvcHMoe2lzSW5kZXhlZDogZmFsc2V9KTtcbiAgICAgIG1vZGVsXG4gICAgICAgIC5zZXRWZXJ0ZXhDb3VudChmaWxsVmVydGV4Q291bnQpXG4gICAgICAgIC5zZXREcmF3TW9kZShHTC5UUklBTkdMRV9TVFJJUClcbiAgICAgICAgLnNldFVuaWZvcm1zKHtpc1N0cm9rZTogZmFsc2V9KVxuICAgICAgICAuZHJhdygpO1xuICAgIH1cbiAgICAvLyBXaGVuIGRyYXdpbmcgMmQ6IGRyYXcgZmlsbCBiZWZvcmUgc3Ryb2tlIHNvIHRoYXQgdGhlIG91dGxpbmUgaXMgYWx3YXlzIG9uIHRvcFxuICAgIGlmICghZXh0cnVkZWQgJiYgc3Ryb2tlZCkge1xuICAgICAgbW9kZWwuc2V0UHJvcHMoe2lzSW5kZXhlZDogZmFsc2V9KTtcbiAgICAgIC8vIFRoZSB3aWR0aCBvZiB0aGUgc3Ryb2tlIGlzIGFjaGlldmVkIGJ5IGZsYXR0ZW5pbmcgdGhlIHNpZGUgb2YgdGhlIGN5bGluZGVyLlxuICAgICAgLy8gU2tpcCB0aGUgbGFzdCAxLzMgb2YgdGhlIHZlcnRpY2VzIHdoaWNoIGlzIHRoZSB0b3AuXG4gICAgICBtb2RlbFxuICAgICAgICAuc2V0VmVydGV4Q291bnQoKGZpbGxWZXJ0ZXhDb3VudCAqIDIpIC8gMylcbiAgICAgICAgLnNldERyYXdNb2RlKEdMLlRSSUFOR0xFX1NUUklQKVxuICAgICAgICAuc2V0VW5pZm9ybXMoe2lzU3Ryb2tlOiB0cnVlLCBvcGFjaXR5OiBzdHJva2VPcGFjaXR5fSlcbiAgICAgICAgLmRyYXcoKTtcbiAgICB9XG4gIH1cbn1cblxuRW5oYW5jZWRDb2x1bW5MYXllci5sYXllck5hbWUgPSAnRW5oYW5jZWRDb2x1bW5MYXllcic7XG5cbmV4cG9ydCBkZWZhdWx0IEVuaGFuY2VkQ29sdW1uTGF5ZXI7XG4iXX0=